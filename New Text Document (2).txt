/********************************************************************
* Copyright (C) 2006 Aricent Inc . All Rights Reserved
*
* $Id: erpscli.c,v 1.14 2021/09/16 07:55:28 siva Exp $
*
* Description: This file contains the ERPS CLI related routines and 
* utility functions.
*****************************************************************************/
#ifndef _ERPSCLI_C_
#define _ERPSCLI_C_

#include "erpsinc.h"
#include "fserpscli.h"
#include <time.h>
UINT4               gu4ErpsTrcLvl;
extern INT1 nmhTestv2FsErpsRingPathPort1AdminStatus(UINT4 *pu4ErrorCode , UINT4 u4FsErpsContextId , UINT4 u4FsErpsRingId , INT4 i4TestValFsErpsRingPathPort1AdminStatus);
extern INT1 nmhSetFsErpsRingPathPort1AdminStatus(UINT4 u4FsErpsContextId , UINT4 u4FsErpsRingId , INT4 i4SetValFsErpsRingPathPort1AdminStatus);
extern INT1 nmhTestv2FsErpsRingPathPort2AdminStatus(UINT4 *pu4ErrorCode , UINT4 u4FsErpsContextId , UINT4 u4FsErpsRingId , INT4 i4TestValFsErpsRingPathPort2AdminStatus);
extern INT1 nmhSetFsErpsRingPathPort2AdminStatus(UINT4 u4FsErpsContextId , UINT4 u4FsErpsRingId , INT4 i4SetValFsErpsRingPathPort2AdminStatus); 
/***************************************************************************
 * FUNCTION NAME    : cli_process_erps_cmd 
 *
 * DESCRIPTION      : This function is exported to CLI module to handle the 
 *                    ER:PS cli commands to take the corresponding action. 
 *                    Only SNMP Low level routines are called from CLI.
 *
 * INPUT            : Variable arguments
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
cli_process_erps_cmd (tCliHandle CliHandle, UINT4 u4Command, ...)
{
    UINT1              *args[ERPS_CLI_MAX_ARGS];
    UINT4               au4TCList[ERPS_TC_LIST_SIZE];
    tPortListExt       *pPort1List = NULL;
    tPortListExt       *pPort2List = NULL;
    tMacAddr            BaseMacAddr;
    va_list             ap;
    UINT4               u4ContextId = CLI_GET_CXT_ID ();
    UINT4               u4IfIndex = 0;
    UINT4               u4RingId = 0;
    UINT4               u4ErrCode = 0;
    UINT4               u4RecoveryMethod = 0;
    UINT4               u4MainRingId = 0;
    INT4                i4Inst = 0;
    INT4                i4RetStatus = CLI_FAILURE;
    INT4                i4RPLPort = 0;
    INT4                i4RplNeighbour = 0;
    INT4                i4RplNextNeighbour = 0;
    UINT4               u4DistributePort = 0;
    INT4                i4VlanGroupId = 0;
    INT4                i4GroupId = 0;
    INT4                i4MacId = 0;
    UINT1               u1ContextDelFlag = OSIX_FALSE;
    INT1                i1ArgNo = 0;
    INT4                i4RingVlan = 0;
    INT4                i4RingInnerVlan = 0;
    UINT4               u4RingMEG1 = 0;
    UINT4               u4RingMEG2 = 0;
    UINT4               u4RingME1 = 0;
    UINT4               u4RingME2 = 0;
    UINT4               u4RingMEP1 = 0;
    UINT4               u4RingMEP2 = 0;
    INT4                i4Args = 0;
    UINT4               u4RingPwId1 = 0;
    UINT4               u4RingPwId2 = 0;
#ifdef VSI_WANTED
    UINT4		        u4VsiId = 0;
#endif
    CliRegisterLock (CliHandle, ErpsApiLock, ErpsApiUnLock);

    ERPS_LOCK ();

    /* Check if the command is a switch mode command */
    if (u4ContextId == ERPS_CLI_INVALID_CONTEXT)
    {
        u4ContextId = ERPS_DEFAULT_CONTEXT_ID;
    }

    va_start (ap, u4Command);

    /* Third argument is always interface name/index */

    i4Inst = va_arg (ap, INT4);

    if (i4Inst != 0)
    {
        u4IfIndex = (UINT4) i4Inst;
    }

    /* Walk through the rest of the arguements and store in args array. 
     * Store ERPS_CLI_MAX_ARGS arguements at the max */

    MEMSET (args, 0, sizeof (args));

    while (1)
    {
        args[i1ArgNo++] = va_arg (ap, UINT1 *);

        if (i1ArgNo == ERPS_CLI_MAX_ARGS)
        {
            break;
        }
    }

    va_end (ap);
    switch (u4Command)
    {
        case CLI_ERPS_SHUTDOWN:

            u1ContextDelFlag = OSIX_TRUE;

            i4RetStatus = ErpsCliSetSystemControl (CliHandle,
                                                   u4ContextId,
                                                   ERPS_SHUTDOWN,
                                                   u1ContextDelFlag);
            break;

        case CLI_ERPS_START:

            i4RetStatus = ErpsCliSetSystemControl (CliHandle,
                                                   u4ContextId,
                                                   ERPS_START,
                                                   u1ContextDelFlag);
            break;

        case CLI_ERPS_ENABLE:

            i4RetStatus = ErpsCliSetModuleStatus (CliHandle,
                                                  u4ContextId, OSIX_ENABLED);
            break;

        case CLI_ERPS_DISABLE:

            i4RetStatus = ErpsCliSetModuleStatus (CliHandle,
                                                  u4ContextId, OSIX_DISABLED);
            break;

        case CLI_ERPS_GROUP_CREATE:

            MEMCPY (&u4RingId, args[0], sizeof (UINT4));
            i4RetStatus = ErpsCliCreateRingGroup (CliHandle,
                                                  u4ContextId, u4RingId);
            break;

        case CLI_ERPS_GROUP_DELETE:

            MEMCPY (&u4RingId, args[0], sizeof (UINT4));
            i4RetStatus = ErpsCliDeleteRingGroup (CliHandle,
                                                  u4ContextId, u4RingId);
            break;

        case CLI_ERPS_GROUP_NAME:

            MEMCPY (&u4RingId, args[1], sizeof (UINT4));
            i4RetStatus = ErpsCliConfigureRingName (CliHandle, u4ContextId,
                                                    (UINT1 *) args[0], u4RingId,
                                                    CLI_ERPS_GROUP_NAME);
            break;

        case CLI_ERPS_NOTIFY_ENABLE:

            i4RetStatus = ErpsCliSetNotification (CliHandle,
                                                  u4ContextId, ERPS_SNMP_TRUE);
            break;

        case CLI_ERPS_NOTIFY_DISABLE:

            i4RetStatus = ErpsCliSetNotification (CliHandle,
                                                  u4ContextId, ERPS_SNMP_FALSE);
            break;

        case CLI_ERPS_DEBUG:
            if (args[2] != NULL)
            {
                i4Args = CLI_PTR_TO_I4 (args[2]);
                ErpsCliSetDebugLevel (CliHandle, i4Args);
            }
            if (args[0] != NULL)
            {
                if (ErpsPortVcmIsSwitchExist (args[0], &u4ContextId)
                    != OSIX_TRUE)
                {
                    CliPrintf (CliHandle, "\r%% Switch %s Does not "
                               "exist.\r\n", args[0]);
                    i4RetStatus = CLI_FAILURE;
                    break;
                }
            }
            else
            {
                u4ContextId = ERPS_DEFAULT_CONTEXT_ID;
            }

            i4RetStatus = ErpsCliSetDebugs (CliHandle, u4ContextId,
                                            (UINT1 *) (args[1]));

            break;

        case CLI_ERPS_NO_DEBUG:

            if (args[0] != NULL)
            {
                if (ErpsPortVcmIsSwitchExist (args[0], &u4ContextId)
                    != OSIX_TRUE)
                {
                    CliPrintf (CliHandle, "\r%% Switch %s Does not "
                               "exist.\r\n", args[0]);
                    i4RetStatus = CLI_FAILURE;
                    break;
                }
            }
            else
            {
                u4ContextId = ERPS_DEFAULT_CONTEXT_ID;
            }

            i4RetStatus = ErpsCliSetDebugs (CliHandle, u4ContextId,
                                            (UINT1 *) (args[1]));

            break;

        case CLI_ERPS_RING_GROUP_NAME:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureRingName (CliHandle, u4ContextId,
                                                    (UINT1 *) args[0], u4RingId,
                                                    CLI_ERPS_RING_GROUP_NAME);
            break;

        case CLI_ERPS_RING_GROUP_ACTIVATE:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliActivateRingGroup (CliHandle, u4ContextId,
                                                    u4RingId, ACTIVE);
            break;

        case CLI_ERPS_RING_GROUP_DEACTIVATE:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliActivateRingGroup (CliHandle, u4ContextId,
                                                    u4RingId, NOT_IN_SERVICE);
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ERPS_RING_GROUP_NODEID:

             u4RingId = CLI_GET_RING_ID ();

             StrToMac ((UINT1 *) args[0], BaseMacAddr);

             i4RetStatus = ErpsCliRingGroupNodeId(CliHandle, u4ContextId,
                                                  u4RingId, BaseMacAddr);
             break;
#endif
        case CLI_ERPS_RING_GROUP_WRKG_PORTS:

            u4RingId = CLI_GET_RING_ID ();
            MEMCPY (&i4RingVlan, args[2], sizeof (INT4));
#ifdef DCSG_EXT_WANTED
            if(args[3] != 0)
            {
                MEMCPY (&i4RingInnerVlan, args[3], sizeof (INT4));
            }
            i4RetStatus = ErpsCliConfigureRingPorts (CliHandle, u4ContextId,
                                                     u4RingId,
                                                     CLI_PTR_TO_U4 (args[0]),
                                                     CLI_PTR_TO_U4 (args[1]),
                                          i4RingVlan, i4RingInnerVlan);
#else
            i4RetStatus = ErpsCliConfigureRingPorts (CliHandle, u4ContextId,
                                                     u4RingId,
                                                     CLI_PTR_TO_U4 (args[0]),
                                                     CLI_PTR_TO_U4 (args[1]),
                                                     i4RingVlan);
#endif
            break;

#ifdef VSI_WANTED
        case CLI_ERPS_RING_GROUP_WRKG_DATA_VEP:

            u4RingId = CLI_GET_RING_ID ();
            MEMCPY (&u4VsiId, args[2], sizeof (UINT4));

            i4RetStatus = ErpsCliConfigureRingDataVep (CliHandle, u4ContextId,
                                                     u4RingId,
                                                     CLI_PTR_TO_U4 (args[0]),
                                                     CLI_PTR_TO_U4 (args[1]),
                                                       u4VsiId, ERPS_SNMP_TRUE);
            break;

        case CLI_ERPS_RING_GROUP_DEL_WRKG_DATA_VEP:

            u4RingId = CLI_GET_RING_ID ();
            MEMCPY (&u4VsiId, args[2], sizeof (UINT4));

            i4RetStatus = ErpsCliConfigureRingDataVep (CliHandle, u4ContextId,
                                                     u4RingId,
                                                     CLI_PTR_TO_U4 (args[0]),
                                                     CLI_PTR_TO_U4 (args[1]),
                                                       u4VsiId, ERPS_SNMP_FALSE);
            break;
#endif
        case CLI_ERPS_RING_GROUP_PROTECT_PORTS:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureRPLPort (CliHandle, u4ContextId,
                                                   u4RingId,
                                                   CLI_PTR_TO_U4 (args[0]));
            break;

        case CLI_ERPS_RING_GROUP_UNPROTECT_PORTS:

            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliConfigureRPLPort (CliHandle, u4ContextId,
                                                   u4RingId, i4RPLPort);
            break;
        case CLI_ERPS_RING_GROUP_PORT_ENABLE:

             u4RingId = CLI_GET_RING_ID ();
             i4RetStatus = ErpsCliConfigurePortStatus (CliHandle, u4ContextId,
                                                       u4RingId,
                                                       CLI_PTR_TO_U4 (args[0]),
                                                       OSIX_ENABLED);
             break;

        case CLI_ERPS_RING_GROUP_PORT_DISABLE:

             u4RingId = CLI_GET_RING_ID ();
             i4RetStatus = ErpsCliConfigurePortStatus (CliHandle, u4ContextId,
                                                       u4RingId,
                                                       CLI_PTR_TO_U4 (args[0]),
                                                       OSIX_DISABLED);

             break;
        case CLI_ERPS_RING_VC_BLOCK:
            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfPortBlockOnVcRecovery (CliHandle,
                                                            u4ContextId,
                                                            u4RingId,
                                                            ERPS_SNMP_TRUE);
            break;

        case CLI_ERPS_RING_NO_VC_BLOCK:
            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfPortBlockOnVcRecovery (CliHandle,
                                                            u4ContextId,
                                                            u4RingId,
                                                            ERPS_SNMP_FALSE);
            break;

        case CLI_ERPS_RING_GROUP_CFM_CFG:

            u4RingId = CLI_GET_RING_ID ();
            MEMCPY (&u4RingMEG1, args[0], sizeof (UINT4));
            MEMCPY (&u4RingME1, args[1], sizeof (UINT4));
            MEMCPY (&u4RingMEP1, args[2], sizeof (UINT4));
            MEMCPY (&u4RingMEG2, args[3], sizeof (UINT4));
            MEMCPY (&u4RingME2, args[4], sizeof (UINT4));
            MEMCPY (&u4RingMEP2, args[5], sizeof (UINT4));

            i4RetStatus = ErpsCliConfigureCfmEntries (CliHandle, u4ContextId,
                                                      u4RingId, u4RingMEG1,
                                                      u4RingME1, u4RingMEP1,
                                                      u4RingMEG2, u4RingME2,
                                                      u4RingMEP2);
            break;

        case CLI_ERPS_RING_GROUP_NO_CFM_CFG:

            u4RingId = (UINT4) CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliDelCfmEntries (CliHandle, u4ContextId,
                                                u4RingId);
            break;

        case CLI_ERPS_RING_GROUP_MPLS_PW_CFG:
            u4RingId = (UINT4) CLI_GET_RING_ID ();
            MEMCPY (&u4RingPwId1, args[0], sizeof (UINT4));
            MEMCPY (&u4RingPwId2, args[1], sizeof (UINT4));
            i4RetStatus = ErpsCliConfigureMplsPwEntry (CliHandle, u4ContextId,
                                                       u4RingId, u4RingPwId1,
                                                       u4RingPwId2);
            break;

        case CLI_ERPS_RING_GROUP_NO_MPLS_PW_CFG:
            u4RingId = (UINT4) CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliDelMplsPwEntry (CliHandle, u4ContextId,
                                                 u4RingId);
            break;

        case CLI_ERPS_RING_NORMAL_TO_FS:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureSwitchCommand (CliHandle, u4ContextId,
                                                         u4RingId,
                                                         ERPS_SWITCH_COMMAND_FORCE,
                                                         u4IfIndex);
            break;
        case CLI_ERPS_RING_NORMAL_TO_MS:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureSwitchCommand (CliHandle, u4ContextId,
                                                         u4RingId,
                                                         ERPS_SWITCH_COMMAND_MANUAL,
                                                         u4IfIndex);
            break;
        case CLI_ERPS_RING_FS_TO_NORMAL:
        case CLI_ERPS_RING_MS_TO_NORMAL:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureSwitchCommand (CliHandle, u4ContextId,
                                                         u4RingId,
                                                         ERPS_SWITCH_COMMAND_NONE,
                                                         0);
            break;

        case CLI_ERPS_RING_GROUP_REVERT_WITH_WTR:
        case CLI_ERPS_RING_GROUP_REVERT:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureOperatingMode (CliHandle, u4ContextId,
                                                         u4RingId,
                                                         ERPS_RING_REVERTIVE_MODE,
                                                         CLI_PTR_TO_I4 (args
                                                                        [0]));
            break;

        case CLI_ERPS_RING_NON_REVERT:

            u4RingId = CLI_GET_RING_ID ();

            if (args[0] != NULL)
            {
                u4RecoveryMethod = ERPS_RING_MANUAL_RECOVERY;
            }
            else
            {
                u4RecoveryMethod = ERPS_RING_AUTO_RECOVERY;
            }

            i4RetStatus = ErpsCliConfigureRecoveryMethod (CliHandle,
                                                          u4ContextId,
                                                          u4RingId,
                                                          ERPS_RING_NON_REVERTIVE_MODE,
                                                          u4RecoveryMethod);
            break;

        case CLI_ERPS_RING_GROUP_TIMER_VAL:

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliConfigureRingTimers (CliHandle, u4ContextId,
                                                      u4RingId,
                                                      CLI_PTR_TO_I4 (args[0]),
                                                      CLI_PTR_TO_I4 (args[1]),
                                                      CLI_PTR_TO_I4 (args[2]));
            break;

        case CLI_ERPS_RING_PROPAGATE_TC:

            u4RingId = CLI_GET_RING_ID ();
            MEMSET (au4TCList, 0, (4 * ERPS_TC_LIST_SIZE));

            /* If ring ids are given convert them to array format 
             * and store them in au4TCList
             * au4TCList[0] contains first ring id given .. 
             * au4TCList[1] contains 2nd ring id... etc., 
             * */
            if (args[0] != NULL)
            {

                if (ConvertStrToPortArray (args[0], au4TCList,
                                           sizeof (au4TCList),
                                           ERPS_MAX_RING_ID) != OSIX_SUCCESS)
                {

                    CliPrintf (CliHandle, "\r%% Invalid ring-id \r\n", args[0]);
                    i4RetStatus = CLI_FAILURE;
                    break;
                }
            }
            i4RetStatus =
                ErpsCliPropagateTopologyChange (CliHandle, u4ContextId,
                                                u4RingId, au4TCList,
                                                (INT4) args[1]);
            break;

        case CLI_ERPS_RING_NOT_PROPAGATE_TC:

            u4RingId = CLI_GET_RING_ID ();

            MEMSET (au4TCList, 0, (4 * ERPS_TC_LIST_SIZE));

            if (args[0] != NULL)
            {
                if (ConvertStrToPortArray (args[0], au4TCList,
                                           sizeof (au4TCList),
                                           ERPS_MAX_RING_ID) != OSIX_SUCCESS)
                {

                    CliPrintf (CliHandle, "\r%% Invalid ring-id \r\n", args[0]);
                    i4RetStatus = CLI_FAILURE;
                    break;
                }
            }

            i4RetStatus =
                ErpsCliPropagateTopologyChange (CliHandle, u4ContextId,
                                                u4RingId, au4TCList,
                                                (INT4) args[1]);
            break;

        case CLI_ERPS_RING_DEL_PROPAGATE_TC:
            u4RingId = CLI_GET_RING_ID ();
            MEMSET (au4TCList, 0, (4 * ERPS_TC_LIST_SIZE));

            if (ConvertStrToPortArray (args[0], au4TCList,
                                       sizeof (au4TCList),
                                       ERPS_MAX_RING_ID) != OSIX_SUCCESS)
            {
                break;
            }
            else
            {

                i4RetStatus =
                    ErpsCliDelTopologyList (CliHandle, u4ContextId,
                                            u4RingId, au4TCList);
            }
            break;

        case CLI_ERPS_RING_DEL_ALL_PROPAGATE_TC:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliDelAllTopologyList (CliHandle, u4ContextId, u4RingId);
            break;

        case CLI_ERPS_CLEAR_STATS_ALL:

            if (args[0] != NULL)
            {
                MEMCPY (&u4RingId, args[0], sizeof (UINT4));
            }

            i4RetStatus = ErpsCliClearRingStats (CliHandle, u4ContextId,
                                                 u4RingId);
            break;

        case CLI_ERPS_SET_GROUP_MANAGER:
            i4RetStatus = ErpsCliCfgVlanGroupManager (CliHandle,
                                                      u4ContextId,
                                                      CLI_PTR_TO_U4 (args[0]));
            break;

        case CLI_ERPS_ADD_VLAN_LIST:

            if (CLI_STRLEN (args[1]) > VLAN_LIST_SIZE_EXT)
            {
                CliPrintf (CliHandle, "\r%% Vlan list exceeds the \
                           Max Length limit\r\n");
                i4RetStatus = CLI_FAILURE;
                break;

            }

            CLI_MEMSET (&gau1ErpsVlanList[0], 0, VLAN_LIST_SIZE_EXT);

            /* If vlan list is given convert them to bitmap format 
             * and store them in gau1ErpsVlanList
             * */

            if (CliStrToPortList ((UINT1 *) args[1], &gau1ErpsVlanList[0],
                                  VLAN_LIST_SIZE_EXT,
                                  CFA_L2VLAN) == CLI_FAILURE)
            {

                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }

            MEMCPY (&i4VlanGroupId, args[0], sizeof (INT4));
            i4RetStatus =
                ErpsCliAddVlanList (CliHandle, u4ContextId,
                                    i4VlanGroupId, &gau1ErpsVlanList[0]);
            break;

        case CLI_ERPS_REM_VLAN_LIST:

            if (CLI_STRLEN (args[1]) > VLAN_LIST_SIZE_EXT)
            {
                CliPrintf (CliHandle, "\r%% Vlan list exceeds the \
                           Max Length limit\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }

            CLI_MEMSET (&gau1ErpsVlanList[0], 0, VLAN_LIST_SIZE_EXT);

            /* If vlan list is given convert them to bitmap format 
             * and store them in gau1ErpsVlanList
             * */

            if (CliStrToPortList ((UINT1 *) args[1], &gau1ErpsVlanList[0],
                                  VLAN_LIST_SIZE_EXT,
                                  CFA_L2VLAN) == CLI_FAILURE)
            {

                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }

            MEMCPY (&i4VlanGroupId, args[0], sizeof (INT4));
            i4RetStatus =
                ErpsCliRemVlanList (CliHandle, u4ContextId,
                                    i4VlanGroupId, &gau1ErpsVlanList[0]);
            break;

        case CLI_ERPS_OVERWRITE_VLAN_LIST:

            if (CLI_STRLEN (args[1]) > VLAN_LIST_SIZE_EXT)
            {
                CliPrintf (CliHandle, "\r%% Vlan list exceeds the \
                           Max Length limit\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }

            CLI_MEMSET (&gau1ErpsVlanList[0], 0, VLAN_LIST_SIZE_EXT);

            /* If vlan list is given convert them to bitmap format 
             * and store them in gau1ErpsVlanList
             * */

            if (CliStrToPortList ((UINT1 *) args[1], &gau1ErpsVlanList[0],
                                  VLAN_LIST_SIZE_EXT,
                                  CFA_L2VLAN) == CLI_FAILURE)
            {

                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }

            MEMCPY (&i4VlanGroupId, args[0], sizeof (INT4));
            i4RetStatus =
                ErpsCliModVlanList (CliHandle, u4ContextId,
                                    i4VlanGroupId, &gau1ErpsVlanList[0]);
            break;

        case CLI_ERPS_REM_VLAN_GROUP:
            MEMCPY (&i4VlanGroupId, args[0], sizeof (INT4));
            i4RetStatus =
                ErpsCliRemoveVlanGroup (CliHandle, u4ContextId, i4VlanGroupId);
            break;

        case CLI_ERPS_MAP_GROUP_TO_RING:
            MEMCPY (&i4GroupId, args[0], sizeof (INT4));
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliMapVlanGroupId (CliHandle, u4ContextId,
                                       u4RingId, i4GroupId);
            break;
        case CLI_ERPS_MAP_VLANGROUP_LIST_TO_RING:
            u4RingId = CLI_GET_RING_ID ();
            if (CLI_STRLEN (args[0]) > VLAN_LIST_SIZE_EXT)
            {
                CliPrintf (CliHandle, "\r%% Vlan list exceeds the \
                           Max Length limit\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }
            CLI_MEMSET (&gau1ErpsVlanList[0], 0, ERPS_MAX_VLAN_GROUP_LIST);
            /*   If vlan group list is given convert them to bitmap format
             *  and store them in gau1ErpsVlanList */
            if (CliStrToPortList ((UINT1 *) args[0], &gau1ErpsVlanList[0],
                                  ERPS_MAX_VLAN_GROUP_LIST,
                                  CFA_L2VLAN) == CLI_FAILURE)
            {

                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                i4RetStatus = CLI_FAILURE;
                break;
            }
            i4RetStatus =
                ErpsCliMapVlanGroupList (CliHandle, u4ContextId,
                                         u4RingId, &gau1ErpsVlanList[0]);
            break;
        case CLI_ERPS_SET_PROTECTION_TYPE:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliCfgProtectionType (CliHandle, u4ContextId,
                                          u4RingId, CLI_PTR_TO_U4 (args[0]));
            break;

        case CLI_ERPS_ASSIGN_MAC_ID:
            MEMCPY (&i4MacId, args[0], sizeof (INT4));
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliMapMacId (CliHandle, u4ContextId, u4RingId, i4MacId);
            break;

        case CLI_ERPS_RING_MAIN_RING_ID:
            u4RingId = CLI_GET_RING_ID ();
            MEMCPY (&u4MainRingId, args[0], sizeof (UINT4));
            i4RetStatus =
                ErpsCliConfigureMainRingId (CliHandle, u4ContextId,
                                            u4RingId, u4MainRingId);
            break;
        case CLI_ERPS_RING_VC_PERIODIC_TIMER_VAL:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureVcPeriodicTimer (CliHandle, u4ContextId,
                                                 u4RingId,
                                                 CLI_PTR_TO_I4 (args[0]));
            break;
        case CLI_ERPS_RING_VERSION:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingversion (CliHandle, u4ContextId,
                                             u4RingId, CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_INTER_CONN_NODE:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureInterConnNode (CliHandle, u4ContextId,
                                               u4RingId,
                                               CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_MULTIPLE_FAILURE:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureMultipleFailure (CliHandle, u4ContextId,
                                                 u4RingId,
                                                 CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_RPL_NEIGHBOUR:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingRPLNeighbour (CliHandle, u4ContextId,
                                                  u4RingId,
                                                  CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_NO_RPL_NEIGHBOUR:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingRPLNeighbour (CliHandle, u4ContextId,
                                                  u4RingId, i4RplNeighbour);
            break;
        case CLI_ERPS_RING_RPL_NEXT_NEIGHBOUR:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingRPLNextNeighbour (CliHandle, u4ContextId,
                                                      u4RingId,
                                                      CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_NO_RPL_NEXT_NEIGHBOUR:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingRPLNextNeighbour (CliHandle, u4ContextId,
                                                      u4RingId,
                                                      i4RplNextNeighbour);
            break;
        case CLI_ERPS_RING_CLEAR_COMMAND:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliClearSwitchMethod (CliHandle, u4ContextId,
                                                    u4RingId,
                                                    ERPS_CLEAR_COMMAND);
            break;
        case CLI_ERPS_RING_SET_WTB:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliConfigWTBTime (CliHandle, u4ContextId,
                                                u4RingId,
                                                CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_WITHOUT_VC:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingRAPSWithoutVC (CliHandle, u4ContextId,
                                                   u4RingId,
                                                   CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_DISTRIBUTE_PORT:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureDistributePort (CliHandle, u4ContextId,
                                                u4RingId,
                                                CLI_PTR_TO_U4 (args[0]));
            break;
        case CLI_ERPS_RING_NO_DISTRIBUTE_PORT:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureDistributePort (CliHandle, u4ContextId,
                                                u4RingId, u4DistributePort);
            break;
        case CLI_ERPS_RING_PORT1_PRESENCE:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingPortPresence (CliHandle, u4ContextId,
                                                  u4RingId,
                                                  CLI_PTR_TO_U4 (args[0]),
                                                  CLI_ERPS_RING_PORT1_PRESENCE);
            break;
        case CLI_ERPS_RING_PORT2_PRESENCE:
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureRingPortPresence (CliHandle, u4ContextId,
                                                  u4RingId,
                                                  CLI_PTR_TO_U4 (args[0]),
                                                  CLI_ERPS_RING_PORT2_PRESENCE);
            break;
        case CLI_ERPS_PROP_CLEAR_FS_ENABLE:
            i4RetStatus =
                ErpsCliSetPropClearFS (CliHandle, u4ContextId, ERPS_SNMP_TRUE);
            break;
        case CLI_ERPS_PROP_CLEAR_FS_DISABLE:
            i4RetStatus =
                ErpsCliSetPropClearFS (CliHandle, u4ContextId, ERPS_SNMP_FALSE);
            break;

        case CLI_ERPS_RING_GROUP_WRKG_SUBPORTS:
            /* aps working [add] SubPortList  <ifXtype> <iface_list> 
             * SubPortList  <ifXtype> <iface_list>
             * args[0] -  Config Type.
             * args[1] -  Interface Type of PortList1/
             * args[2] -  PortList1/
             * args[3] -  Interface Type of PortList2/
             * args[4] -  PortList2
             */
            pPort1List =
                (tPortListExt *) FsUtilAllocBitList (sizeof (tPortListExt));

            if (pPort1List == NULL)
            {
                ERPS_GLOBAL_TRC
                    ("Memory allocation failed for SubPortList1\r\n");
                return CLI_FAILURE;
            }

            pPort2List =
                (tPortListExt *) FsUtilAllocBitList (sizeof (tPortListExt));

            if (pPort2List == NULL)
            {
                ERPS_GLOBAL_TRC
                    ("Memory allocation failed for SubPortList2\r\n");
                FsUtilReleaseBitList ((UINT1 *) pPort1List);
                return CLI_FAILURE;
            }

            MEMSET (pPort1List, 0, sizeof (tPortListExt));
            MEMSET (pPort2List, 0, sizeof (tPortListExt));

            u4RingId = CLI_GET_RING_ID ();
            if (OSIX_FAILURE ==
                ErpsPortCfaGetIfList ((INT1 *) args[1], (INT1 *) args[2],
                                      (UINT1 *) pPort1List,
                                      sizeof (tPortListExt)))
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }

            if (OSIX_FAILURE ==
                ErpsPortCfaGetIfList ((INT1 *) args[3], (INT1 *) args[4],
                                      (UINT1 *) pPort2List,
                                      sizeof (tPortListExt)))
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }

            i4RetStatus = ErpsCliSetRingWrkingSubPorts (CliHandle,
                                                        u4ContextId, u4RingId,
                                                        pPort1List, pPort2List,
                                                        CLI_PTR_TO_U4 (args
                                                                       [0]));
            break;

        case CLI_ERPS_RING_GROUP_DEL_WRKG_SUBPORTS:
            /* no aps working SubPortList */

            u4RingId = CLI_GET_RING_ID ();

            i4RetStatus = ErpsCliReSetRingWrkingSubPorts (CliHandle,
                                                          u4ContextId,
                                                          u4RingId);
            break;

        case CLI_ERPS_RING_GROUP_SERVICE_TYPE:
            /*  aps service [vlan | mpls-lsp | mpls-pw | mpls-lsp-pw] 
             *  $1 - Service Type 
             */
            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliSetServiceType (CliHandle, u4ContextId,
                                                 u4RingId,
                                                 CLI_PTR_TO_U4 (args[0]));
            break;

        case CLI_ERPS_MONITOR_MECH:

            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus = ErpsCliSetMonitor (CliHandle, u4ContextId,
                                             u4RingId, CLI_PTR_TO_I4 (args[0]));
            break;

        case CLI_ERPS_RING_KVALUE:

            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliConfigureKValue (CliHandle, u4ContextId,
                                        u4RingId, (UINT1 *) (args[0]));
            break;

        case CLI_ERPS_FOP_TO_ENABLE:

            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliSetFailureofProtocol (CliHandle, u4ContextId,
                                             u4RingId, OSIX_ENABLED);

            break;
        case CLI_ERPS_FOP_TO_DISABLE:

            u4RingId = CLI_GET_RING_ID ();
            i4RetStatus =
                ErpsCliSetFailureofProtocol (CliHandle, u4ContextId,
                                             u4RingId, OSIX_DISABLED);

            break;
        default:

            i4RetStatus = CLI_FAILURE;
            break;
    }

    if ((i4RetStatus == CLI_FAILURE)
        && (CLI_GET_ERR (&u4ErrCode) == CLI_SUCCESS))
    {
        if ((u4ErrCode > 0) && (u4ErrCode < CLI_ERPS_MAX_ERR))
        {
            CliPrintf (CliHandle, "\r%% %s", gaErpsCliErrString[u4ErrCode]);
        }
        CLI_SET_ERR (0);

    }
    if (NULL != pPort1List)
    {
        FsUtilReleaseBitList ((UINT1 *) pPort1List);
    }
    if (NULL != pPort2List)
    {
        FsUtilReleaseBitList ((UINT1 *) pPort2List);
    }

    CLI_SET_CMD_STATUS (i4RetStatus);

    ERPS_UNLOCK ();

    CliUnRegisterLock (CliHandle);
    UNUSED_PARAM(i4RingInnerVlan);
    UNUSED_PARAM(BaseMacAddr);
    return i4RetStatus;
}

/***************************************************************************
 * FUNCTION NAME    : cli_process_erps_sh_cmd 
 *
 * DESCRIPTION      : This function is exported to CLI module to handle the 
 *                    ERPS Cli show commands. The display is taken care in 
 *                    this function.
 *
 * INPUT            : Variable arguments
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
cli_process_erps_sh_cmd (tCliHandle CliHandle, UINT4 u4Command, ...)
{
    va_list             ap;
    UINT1               au1ContextName[VCM_ALIAS_MAX_LEN];
    UINT4               u4RingId = 0;
    UINT4               u4ContextId = ERPS_INVALID_CONTEXT_ID;
    UINT4               u4CurrContextId = 0xffffffff;
    INT4                i4GroupId = -1;
    INT4                i4RetStatus = CLI_FAILURE;
    INT4                i4Inst = 0;
    INT1                i1ArgNo = 0;
    UINT1              *args[ERPS_CLI_MAX_ARGS];
    UINT1              *pu1ContextName = NULL;

    CliRegisterLock (CliHandle, ErpsApiLock, ErpsApiUnLock);

    ERPS_LOCK ();

    va_start (ap, u4Command);

    /* Third argument is always interface name/index */

    i4Inst = va_arg (ap, INT4);
    UNUSED_PARAM (i4Inst);

    /* NOTE: For EXEC mode commands we have to pass the context-name/NULL
     * After the u4IfIndex. (ie) In all the cli commands we are passing 
     * IfIndex as the first argument in variable argument list. Like that 
     * as the second argument we have to pass context-name*/

    pu1ContextName = va_arg (ap, UINT1 *);

    MEMSET (args, 0, sizeof (args));

    while (1)
    {
        args[i1ArgNo++] = va_arg (ap, UINT1 *);
        if (i1ArgNo == ERPS_CLI_MAX_ARGS)
        {
            break;
        }
    }
    va_end (ap);

    /* Display required info for the appropriate context id (If it is 
     * given pu1ContextName by user) or display info for all contexts 
     * available (if context id is not given) */

    while (ErpsCliGetContextInfoForShowCmd (CliHandle, pu1ContextName,
                                            u4CurrContextId,
                                            &u4ContextId) == OSIX_SUCCESS)
    {
        switch (u4Command)
        {
            case CLI_ERPS_SHOW_GLB_INFO:

                i4RetStatus = ErpsCliShowGlobalInfo (CliHandle, u4ContextId);

                break;

            case CLI_ERPS_SHOW_RING_GROUP_INFO:

                if (args[0] != NULL)
                {
                    MEMCPY (&u4RingId, args[0], sizeof (UINT4));
                }

                i4RetStatus = ErpsCliShowRingInfo (CliHandle, u4ContextId,
                                                   u4RingId,
                                                   CLI_PTR_TO_I4 (args[1]));
                break;

            case CLI_ERPS_SHOW_DEBUG:

                i4RetStatus = ErpsCliShowDebugging (CliHandle, u4ContextId);

                break;

            case CLI_ERPS_SHOW_VLAN_GROUP_INFO:
                i4GroupId = CLI_PTR_TO_I4 (args[0]);

                MEMSET (au1ContextName, 0, sizeof (au1ContextName));
                ErpsPortVcmGetAliasName (u4ContextId, au1ContextName);
                CliPrintf (CliHandle, "\r\n\rSwitch %s\r\n", au1ContextName);

                if (i4GroupId != -1)
                {
                    i4RetStatus =
                        ErpsCliShowVlanGroupInfo (CliHandle, u4ContextId,
                                                  i4GroupId, FALSE);
                }
                else
                {
                    for (i4GroupId = 0; i4GroupId <= ERPS_MAX_VLAN_GROUP_ID;
                         i4GroupId++)
                    {
                        i4RetStatus = ErpsCliShowVlanGroupInfo (CliHandle,
                                                                u4ContextId,
                                                                i4GroupId,
                                                                FALSE);
                    }
                }

                break;
            case CLI_ERPS_CLEAR_STATS_ALL:

                if (args[0] == NULL)
                {
                    u4RingId = 0;
                }
                else
                {
                    u4RingId = (*(UINT4 *) (VOID *) args[0]);
                }
                i4RetStatus = ErpsCliClearRingStats (CliHandle, u4ContextId,
                                                     u4RingId);
                break;

        }

        /* If context name is given by user , break from loop as display 
         * is over */
        if (pu1ContextName != NULL)
        {
            break;
        }

        u4CurrContextId = u4ContextId;
    }

    CLI_SET_ERR (0);

    CLI_SET_CMD_STATUS (i4RetStatus);

    ERPS_UNLOCK ();

    CliUnRegisterLock (CliHandle);

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetSystemControl 
 *
 * DESCRIPTION      : This function sets the system control status of ERPS
 *                    module as configured from CLI.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    i4Status - System control status 
 *                    (ERPS_START/ERPS_SHUTDOWN)
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliSetSystemControl (tCliHandle CliHandle, UINT4 u4ContextId,
                         INT4 i4SystemControl, UINT1 u1ContextDelFlag)
{
    INT4                i4RowStatus = -1;
    UINT4               u4ErrorCode = 0;

    if (i4SystemControl == ERPS_START)
    {
        if (nmhGetFsErpsCtxtRowStatus (u4ContextId, &i4RowStatus) ==
            SNMP_FAILURE)
        {
            /* Create ERPS context, if it does not exist */

            if (nmhTestv2FsErpsCtxtRowStatus (&u4ErrorCode, u4ContextId,
                                              CREATE_AND_GO) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }

            if (nmhSetFsErpsCtxtRowStatus (u4ContextId, CREATE_AND_GO)
                == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
        }
    }

    if (nmhTestv2FsErpsCtxtSystemControl (&u4ErrorCode, u4ContextId,
                                          i4SystemControl) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsCtxtSystemControl (u4ContextId, i4SystemControl) ==
        SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    /* When System Control is shutdown , and "switch" is given 
     * delete the ERPS context table entry also */
    if (u1ContextDelFlag == OSIX_TRUE)
    {
        if (nmhTestv2FsErpsCtxtRowStatus (&u4ErrorCode, u4ContextId,
                                          DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsCtxtRowStatus (u4ContextId, DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetModuleStatus  
 *
 * DESCRIPTION      : This function sets the ERPS module status.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    i4Status - OSIX_ENABLED/OSIX_DISABLED
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliSetModuleStatus (tCliHandle CliHandle, UINT4 u4ContextId, INT4 i4Status)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsCtxtModuleStatus (&u4ErrorCode, u4ContextId,
                                         i4Status) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsCtxtModuleStatus (u4ContextId, i4Status) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if ((ErpsUtilGetMcLagStatus () == OSIX_SUCCESS)
        && (i4Status == OSIX_ENABLED))
    {
        CliPrintf (CliHandle, "MC-LAG configurations shall be done prior to "
                   "enabling ERPS in MC-LAG aware system\r\n");
    }
    return CLI_SUCCESS;
}

/****************************************************************************
* Function    :  ErpsCliSetDebugLevel
* Description :
* Input       :  CliHandle, i4CliDebugLevel
* Output      :  None
* Returns     :  CLI_SUCCESS/CLI_FAILURE
****************************************************************************/
INT4
ErpsCliSetDebugLevel (tCliHandle CliHandle, INT4 i4CliDebugLevel)
{
    gu4ErpsTrcLvl = 0;

    UNUSED_PARAM (CliHandle);

    if (i4CliDebugLevel == DEBUG_DEBUG_LEVEL)
    {
        gu4ErpsTrcLvl =
            MGMT_TRC | BUFFER_TRC | INIT_SHUT_TRC | ALL_FAILURE_TRC |
            OS_RESOURCE_TRC | CONTROL_PLANE_TRC | DATA_PATH_TRC | DUMP_TRC |
            ERPS_CRITICAL_TRC;

    }
    else if (i4CliDebugLevel == DEBUG_INFO_LEVEL)
    {
        gu4ErpsTrcLvl = CONTROL_PLANE_TRC | DATA_PATH_TRC | DUMP_TRC
            | INIT_SHUT_TRC | ALL_FAILURE_TRC | OS_RESOURCE_TRC |
            ERPS_CRITICAL_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_NOTICE_LEVEL)
    {
        gu4ErpsTrcLvl = INIT_SHUT_TRC | ALL_FAILURE_TRC | OS_RESOURCE_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_WARN_LEVEL)
    {
        gu4ErpsTrcLvl = INIT_SHUT_TRC | ALL_FAILURE_TRC | OS_RESOURCE_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_ERROR_LEVEL)
    {
        gu4ErpsTrcLvl = INIT_SHUT_TRC | ALL_FAILURE_TRC | ERPS_CRITICAL_TRC;
    }
    else if ((i4CliDebugLevel == DEBUG_CRITICAL_LEVEL)
             || (i4CliDebugLevel == DEBUG_ALERT_LEVEL)
             || (i4CliDebugLevel == DEBUG_EMERG_LEVEL))
    {
        gu4ErpsTrcLvl = INIT_SHUT_TRC | ERPS_CRITICAL_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_DEF_LVL_FLAG)
    {
        return CLI_SUCCESS;
    }
    else
    {
        return CLI_FAILURE;
    }

    CliPrintf (CliHandle, "\r ERPS_TRC_LVL : %d \n", ERPS_TRC_LVL);
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetServiceType  
 *
 * DESCRIPTION      : This function sets the ERPS service type.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier.
 *                    i4ServiceType - VLAN/MPLS_LSP/MPLS_LSP_PW/MPLS_PW
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliSetServiceType (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId,
                       INT4 i4ServiceType)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsRingServiceType (&u4ErrorCode, u4ContextId,
                                        u4RingId,
                                        i4ServiceType) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingServiceType (u4ContextId, u4RingId, i4ServiceType)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliReSetRingWrkingSubPorts  
 *
 * DESCRIPTION      : This function sets the ERPS subPortList.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId - Ring Identifier. 
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliReSetRingWrkingSubPorts (tCliHandle CliHandle, UINT4 u4ContextId,
                                UINT4 u4RingId)
{
    tSNMP_OCTET_STRING_TYPE SubPortList;
    UINT4               u4ErrorCode = 0;
    INT4                i4RingRowStatus = 0;

    MEMSET (&SubPortList, 0, sizeof (tSNMP_OCTET_STRING_TYPE));

    if ((SubPortList.pu1_OctetList =
         (UINT1 *) MemAllocMemBlk (gErpsGlobalInfo.ErpsCliMemblkBufPoolId)) ==
        NULL)
    {
        return CLI_FAILURE;
    }

    MEMSET (SubPortList.pu1_OctetList, 0, BRG_PORT_LIST_SIZE_EXT);

    if (SNMP_FAILURE == nmhTestv2FsErpsRingPort1SubPortList (&u4ErrorCode,
                                                             u4ContextId,
                                                             u4RingId,
                                                             &SubPortList))
    {
        ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
        return CLI_FAILURE;
    }
    if (SNMP_FAILURE == nmhTestv2FsErpsRingPort2SubPortList (&u4ErrorCode,
                                                             u4ContextId,
                                                             u4RingId,
                                                             &SubPortList))
    {
        ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
        return CLI_FAILURE;
    }

    /* Bring down the Row status of FsErpsRingTable to NOT_IN_SERVICE, 
     * if it is currently active.
     */
    if (SNMP_FAILURE ==
        nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RingRowStatus))
    {
        ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);

        return CLI_FAILURE;
    }

    if (i4RingRowStatus == ACTIVE)
    {
        if (SNMP_FAILURE ==
            nmhTestv2FsErpsRingRowStatus (&u4ErrorCode, u4ContextId,
                                          u4RingId, NOT_IN_SERVICE))
        {
            ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
            return CLI_FAILURE;
        }
        if (SNMP_FAILURE ==
            nmhSetFsErpsRingRowStatus (u4ContextId, u4RingId, NOT_IN_SERVICE))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
            return CLI_FAILURE;
        }
    }

    if (SNMP_FAILURE ==
        nmhSetFsErpsRingPort1SubPortList (u4ContextId, u4RingId, &SubPortList))
    {
        CLI_FATAL_ERROR (CliHandle);
        ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
        return CLI_FAILURE;
    }

    if (SNMP_FAILURE ==
        nmhSetFsErpsRingPort2SubPortList (u4ContextId, u4RingId, &SubPortList))
    {
        CLI_FATAL_ERROR (CliHandle);
        ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
        return CLI_FAILURE;
    }

    /* Make the row status back to ACTIVE state. */
    if (i4RingRowStatus == ACTIVE)
    {
        if (SNMP_FAILURE ==
            nmhTestv2FsErpsRingRowStatus (&u4ErrorCode, u4ContextId,
                                          u4RingId, ACTIVE))
        {
            ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
            return CLI_FAILURE;
        }
        if (SNMP_FAILURE ==
            nmhSetFsErpsRingRowStatus (u4ContextId, u4RingId, ACTIVE))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (SubPortList.pu1_OctetList, NULL);
            return CLI_FAILURE;
        }
    }

    MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                        (UINT1 *) SubPortList.pu1_OctetList);
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetRingWrkingSubPorts  
 *
 * DESCRIPTION      : This function sets the ERPS subPortList.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId - Ring Identifier. 
 *                    PortList2 - PortList2
 *                    PortList1 - PortList1
 *                    u4ConfigType - Configuation mode is ADD/OVERRIDE
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliSetRingWrkingSubPorts (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4RingId, tPortListExt * pPortList1,
                              tPortListExt * pPortList2, UINT4 u4ConfigType)
{
    tSNMP_OCTET_STRING_TYPE Port1OctetString;
    tSNMP_OCTET_STRING_TYPE Port2OctetString;
    UINT4               u4ErrorCode = 0;
    INT4                i4RingRowStatus = 0;

    MEMSET (&Port1OctetString, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    MEMSET (&Port2OctetString, 0, sizeof (tSNMP_OCTET_STRING_TYPE));

    Port1OctetString.pu1_OctetList =
        (UINT1 *) MemAllocMemBlk (gErpsGlobalInfo.ErpsCliMemblkBufPoolId);
    if (NULL == Port1OctetString.pu1_OctetList)
    {
        return CLI_FAILURE;
    }

    Port2OctetString.pu1_OctetList =
        (UINT1 *) MemAllocMemBlk (gErpsGlobalInfo.ErpsCliMemblkBufPoolId);
    if (NULL == Port2OctetString.pu1_OctetList)
    {
        MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                            (UINT1 *) Port1OctetString.pu1_OctetList);
        return CLI_FAILURE;
    }

    MEMSET (Port1OctetString.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);
    MEMSET (Port2OctetString.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);

    /* If the config type is ERPS_CLI_SUBPORTLIST_ADD, then 
     * the new PortList should be appended at the end of the exiting list. 
     */
    if (u4ConfigType == ERPS_CLI_SUBPORTLIST_ADD)
    {
        if (SNMP_FAILURE ==
            nmhGetFsErpsRingPort1SubPortList (u4ContextId,
                                              u4RingId, &Port1OctetString))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }
        if (SNMP_FAILURE ==
            nmhGetFsErpsRingPort2SubPortList (u4ContextId,
                                              u4RingId, &Port2OctetString))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }

    }
    else
    {
        /* If the configType is not append, then override the existing list.
         * To acheive this, the Port List is reset before proceeding with the
         * configuration of the new portlist. 
         */
        if (CLI_FAILURE ==
            ErpsCliReSetRingWrkingSubPorts (CliHandle, u4ContextId, u4RingId))
        {
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }

    }

    /* Convert the input port list to OctetSting format. */
    ErpsUtilGetOctetStrFromPortList (pPortList1, &Port1OctetString);

    ErpsUtilGetOctetStrFromPortList (pPortList2, &Port2OctetString);

    /* All the validations are done in the beginning to exhibit atomic
     * configuration of Port1 subPortList and Port2SubPortList and to avoid 
     * rollback during failure 
     */
    if (SNMP_FAILURE ==
        nmhTestv2FsErpsRingPort1SubPortList (&u4ErrorCode, u4ContextId,
                                             u4RingId, &Port1OctetString))
    {
        ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                         Port2OctetString.pu1_OctetList);
        return CLI_FAILURE;
    }
    if (SNMP_FAILURE ==
        nmhTestv2FsErpsRingPort2SubPortList (&u4ErrorCode, u4ContextId,
                                             u4RingId, &Port2OctetString))
    {
        ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                         Port2OctetString.pu1_OctetList);
        return CLI_FAILURE;
    }

    if (SNMP_FAILURE ==
        nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RingRowStatus))
    {
        CLI_FATAL_ERROR (CliHandle);
        ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                         Port2OctetString.pu1_OctetList);
        return SNMP_FAILURE;
    }

    /* Bring down the Row status of FsErpsRingTable to NOT_IN_SERVICE, 
     * if it is currently active, before modifying the postlist information. 
     */
    if (i4RingRowStatus == ACTIVE)
    {
        if (SNMP_FAILURE ==
            nmhTestv2FsErpsRingRowStatus (&u4ErrorCode, u4ContextId, u4RingId,
                                          NOT_IN_SERVICE))
        {
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }
        if (SNMP_FAILURE ==
            nmhSetFsErpsRingRowStatus (u4ContextId, u4RingId, NOT_IN_SERVICE))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }
    }

    if (SNMP_FAILURE ==
        nmhSetFsErpsRingPort1SubPortList (u4ContextId, u4RingId,
                                          &Port1OctetString))
    {
        CLI_FATAL_ERROR (CliHandle);
        ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                         Port2OctetString.pu1_OctetList);
        return CLI_FAILURE;
    }
    if (SNMP_FAILURE ==
        nmhSetFsErpsRingPort2SubPortList (u4ContextId, u4RingId,
                                          &Port2OctetString))
    {
        CLI_FATAL_ERROR (CliHandle);
        ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                         Port2OctetString.pu1_OctetList);
        return CLI_FAILURE;
    }

    /* Make the row status back to ACTIVE state. */
    if (i4RingRowStatus == ACTIVE)
    {
        if (SNMP_FAILURE ==
            nmhTestv2FsErpsRingRowStatus (&u4ErrorCode, u4ContextId, u4RingId,
                                          ACTIVE))
        {
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }
        if (SNMP_FAILURE ==
            nmhSetFsErpsRingRowStatus (u4ContextId, u4RingId, ACTIVE))
        {
            CLI_FATAL_ERROR (CliHandle);
            ErpsCliHandleFailureSubPortList (Port1OctetString.pu1_OctetList,
                                             Port2OctetString.pu1_OctetList);
            return CLI_FAILURE;
        }
    }

    MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                        (UINT1 *) Port1OctetString.pu1_OctetList);

    MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                        (UINT1 *) Port2OctetString.pu1_OctetList);
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsGetErpsCfgPrompt 
 *
 * DESCRIPTION      : This function returns the prompt to be displayed 
 *                    for Ring group. It is exported to CLI module.
 *
 * INPUT            : None
 *                    
 *
 * OUTPUT           : pi1ModeName - Mode String
 *                    pi1DispStr - Display string
 *
 * RETURNS          : OSIX_TRUE/OSIX_FALSE
 * 
 **************************************************************************/
INT1
ErpsGetErpsCfgPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4RingId = 0;
    UINT4               u4Len = STRLEN ("ring-");

    if ((!pi1DispStr) || (!pi1ModeName))
    {
        return OSIX_FALSE;
    }

    if (STRNCMP (pi1ModeName, "ring-", u4Len) != 0)
    {
        return OSIX_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;

    u4RingId = CLI_ATOI (pi1ModeName);

    /* 
     * No need to take lock here, since it is taken by
     * Cli in cli_process_erps_cmd.
     */
    CLI_SET_RING_ID (u4RingId);

    STRCPY (pi1DispStr, "(config-ring)#");

    return OSIX_TRUE;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsGetVcmErpsCfgPrompt 
 *
 * DESCRIPTION      : This function returns the prompt to be displayed 
 *                    for Ring group. It is exported to CLI module.
 *
 * INPUT            : None
 *                    
 *
 * OUTPUT           : pi1ModeName - Mode String
 *                    pi1DispStr - Display string
 *
 * RETURNS          : OSIX_TRUE/OSIX_FALSE
 * 
 **************************************************************************/
INT1
ErpsGetVcmErpsCfgPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4RingId = 0;
    UINT4               u4Len = STRLEN ("ring-");

    if ((!pi1DispStr) || (!pi1ModeName))
    {
        return OSIX_FALSE;
    }

    if (STRNCMP (pi1ModeName, "ring-", u4Len) != 0)
    {
        return OSIX_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;

    u4RingId = CLI_ATOI (pi1ModeName);

    /* 
     * No need to take lock here, since it is taken by
     * Cli in cli_process_erps_cmd.
     */
    CLI_SET_RING_ID (u4RingId);

    STRCPY (pi1DispStr, "(config-switch-ring)#");

    return OSIX_TRUE;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliCreateRingGroup  
 *
 * DESCRIPTION      : This function creates a ring entry and sets the status 
 *                    to Not Ready.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliCreateRingGroup (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId)
{
    INT4                i4RingRowStatus = -1;
    UINT1               au1Cmd[MAX_PROMPT_LEN];

    MEMSET (au1Cmd, 0, sizeof (au1Cmd));

    /* Check if the Ring Entry is already present */

    if (nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RingRowStatus)
        != SNMP_SUCCESS)
    {
        /* Create the Entry as it is not present */

        if (ErpsCliConfigRingRowStatus (CliHandle, u4ContextId, u4RingId,
                                        CREATE_AND_WAIT) == CLI_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* Change the CLI path to ring mode */
    SPRINTF ((CHR1 *) au1Cmd, "%s%u", CLI_ERPS_RING_MODE, u4RingId);

    if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)
    {
        CliPrintf (CliHandle, "\r%% Unable to enter into Ring mode\r\n");
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliDeleteRingGroup  
 *
 * DESCRIPTION      : This function deletes a ring entry,if present. 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliDeleteRingGroup (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId)
{
    INT4                i4ErpsMonitoringMech = 0;
    UINT4               u4ErpsRingPwVcId1 = 0;
    INT4                i4RingRowStatus = 0;
    UINT4               u4ErrorCode = 0;

    /*Check if, the Ring Entry is present; If not return success  */
    if (nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RingRowStatus)
        != SNMP_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Ring Entry is not present\r\n");
        return CLI_FAILURE;
    }

    /* Make the ring in-active */
    if (i4RingRowStatus == ACTIVE)
    {
        if (ErpsCliConfigRingRowStatus
            (CliHandle, u4ContextId, u4RingId, NOT_IN_SERVICE) == CLI_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* Delete the CFM entries */
    if (nmhTestv2FsErpsRingCfmRowStatus
        (&u4ErrorCode, u4ContextId, u4RingId, DESTROY) != SNMP_SUCCESS)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, DESTROY)
        != SNMP_SUCCESS)
    {
        return CLI_FAILURE;
    }

    /*Delete the MPLS PW ENTRY */
    nmhGetFsErpsRingMonitorMechanism (u4ContextId, u4RingId,
                                      &i4ErpsMonitoringMech);
    nmhGetFsErpsRingPwVcId1 (u4ContextId, u4RingId, &u4ErpsRingPwVcId1);
    if ((i4ErpsMonitoringMech != ERPS_MONITOR_MECH_CFM)
        && (u4ErpsRingPwVcId1 != 0))
    {
        if (nmhTestv2FsErpsRingMplsRowStatus
            (&u4ErrorCode, u4ContextId, u4RingId, DESTROY) != SNMP_SUCCESS)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingMplsRowStatus (u4ContextId, u4RingId, DESTROY)
            != SNMP_SUCCESS)
        {
            return CLI_FAILURE;
        }
    }

    /* Delete the ring Entry */
    if (ErpsCliConfigRingRowStatus (CliHandle, u4ContextId, u4RingId, DESTROY)
        == CLI_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingName  
 *
 * DESCRIPTION      : This function configures a ring name for the ring. 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    pu1RingName - Ring Name
 *                    i4Command   - Switch/Ring Mode
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingName (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT1 *pu1RingName, UINT4 u4RingId, INT4 i4Command)
{
    tSNMP_OCTET_STRING_TYPE RingName;
    INT4                i4RingRowStatus = -1;
    UINT4               u4ErrorCode = 0;
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT1               au1RingName[ERPS_MAX_NAME_LENGTH];

    MEMSET (au1Cmd, 0, sizeof (au1Cmd));

    if (pu1RingName == NULL)
    {
        /* Set the default ring name */
        MEMSET (au1RingName, 0, ERPS_MAX_NAME_LENGTH);
        SPRINTF ((CHR1 *) au1RingName, "Ring%u", u4RingId);
        pu1RingName = au1RingName;
    }

    /* Check if the Ring Entry is already present */

    if (nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RingRowStatus)
        != SNMP_SUCCESS)
    {
        /* Create the Entry as it is not present */
        if (ErpsCliConfigRingRowStatus (CliHandle, u4ContextId, u4RingId,
                                        CREATE_AND_WAIT) == CLI_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    RingName.pu1_OctetList = pu1RingName;
    RingName.i4_Length = STRLEN (pu1RingName);

    /* Set the Ring Name */
    if (nmhTestv2FsErpsRingName (&u4ErrorCode, u4ContextId, u4RingId,
                                 &RingName) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingName (u4ContextId, u4RingId, &RingName) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    /* Change the CLI path based on ring mode */
    if (i4Command == CLI_ERPS_GROUP_NAME)
    {
        SPRINTF ((CHR1 *) au1Cmd, "%s%u", CLI_ERPS_RING_MODE, u4RingId);

        if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Unable to enter into Ring mode\r\n");
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetNotification 
 *
 * DESCRIPTION      : This function sets the trap status. 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    i4TrapStatus - Trap Status
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliSetNotification (tCliHandle CliHandle, UINT4 u4ContextId,
                        INT4 i4TrapStatus)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsCtxtTrapStatus (&u4ErrorCode, u4ContextId, i4TrapStatus)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsCtxtTrapStatus (u4ContextId, i4TrapStatus) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliSetDebugs 
 *
 * DESCRIPTION      : This function sets and resets the Trace input for a 
 *                    context
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    pu1TraceInput - Input Trace string
 *                    
 * OUTPUT           : pi1ModeName - Mode String
 *                    pi1DispStr - Display string
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliSetDebugs (tCliHandle CliHandle, UINT4 u4ContextId, UINT1 *pu1TraceInput)
{
    tSNMP_OCTET_STRING_TYPE TraceInput;

    UINT4               u4ErrorCode = 0;
    UINT1               u1TrcType = 0;
    UINT2               u2TrcLen = 0;

    TraceInput.pu1_OctetList = pu1TraceInput;
    TraceInput.i4_Length = STRLEN (pu1TraceInput);

    /* If trace option is selected as "all" then pass all the
     * trace options as input */

    if ((STRCMP (TraceInput.pu1_OctetList, "enable all") == 0) ||
        (STRCMP (TraceInput.pu1_OctetList, "disable all") == 0))
    {
        if (STRCMP (TraceInput.pu1_OctetList, "enable all") == 0)
        {
            MEMSET (TraceInput.pu1_OctetList, 0, TraceInput.i4_Length);
            STRCAT (TraceInput.pu1_OctetList, "enable");
        }
        if (STRCMP (TraceInput.pu1_OctetList, "disable all") == 0)
        {
            MEMSET (TraceInput.pu1_OctetList, 0, TraceInput.i4_Length);
            STRCAT (TraceInput.pu1_OctetList, "disable");
        }

        for (u1TrcType = 0; u1TrcType < ERPS_MAX_TRC_TYPE; u1TrcType++)
        {
            u2TrcLen = (UINT2) STRLEN (gau1ErpsTraceTypes[u1TrcType]);
            STRCAT (TraceInput.pu1_OctetList, " ");
            STRNCAT (TraceInput.pu1_OctetList, gau1ErpsTraceTypes[u1TrcType],
                     u2TrcLen);
        }
        TraceInput.i4_Length = STRLEN (TraceInput.pu1_OctetList);
    }

    /* Set the trace status */
    if (nmhTestv2FsErpsCtxtTraceInput (&u4ErrorCode, u4ContextId,
                                       &TraceInput) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsCtxtTraceInput (u4ContextId, &TraceInput) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliActivateRingGroup 
 *
 * DESCRIPTION      : This function activates/de-activates
 *                    a ring entry 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4RowStatus - ACTIVE/ NOT_IN_SERVICE
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliActivateRingGroup (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4RingId, INT4 i4RowStatus)
{
    tErpsRingInfo *pRingInfo = NULL;
	pRingInfo = ErpsRingGetRingEntry(u4ContextId, u4RingId);

	if (ErpsCliConfigRingRowStatus (CliHandle, u4ContextId,
                                    u4RingId, (UINT1) i4RowStatus)
        == CLI_FAILURE)
    {
        return CLI_FAILURE;
    }
	if(i4RowStatus == NOT_IN_SERVICE) 
	{
		if((pRingInfo->MplsPwInfo.u4PwVcId1 != 0) || (pRingInfo->MplsPwInfo.u4PwVcId2 != 0))
		{
			CliPrintf(CliHandle, "\r Warning: Delete the PW & Create new PW so as to reset protection on the PW \r\n");
		}
	}

    return CLI_SUCCESS;
}

#ifdef DCSG_EXT_WANTED
/***************************************************************************
 * FUNCTION NAME    : ErpsCliRingGroupNodeId
 *
 * DESCRIPTION      : This function used to assign mac-addr to ring
 *                   
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    BaseMac    -Mac-Address
 *
 * OUTPUT           : None
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 **************************************************************************/
INT4
ErpsCliRingGroupNodeId(tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4RingId, tMacAddr BaseMac)
{
    UINT4            u4ErrorCode = 0;
    UNUSED_PARAM(CliHandle);

    if(nmhTestv2FsErpsRingNodeId (&u4ErrorCode , u4ContextId ,
                                  u4RingId , BaseMac)== SNMP_FAILURE)
    {
       return CLI_FAILURE;
    }

    if(nmhSetFsErpsRingNodeId(u4ContextId ,u4RingId ,
                              BaseMac)==SNMP_FAILURE)
    {
       return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

#endif
/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingPorts 
 *
 * DESCRIPTION      : This function configures the ring ports 
 *                    and R-APS Vlan.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4RingPort1 - Ring Port1
 *                    i4RingPort2 - Ring Port2
 *                    i4RingVlan  - R-APS VLAN
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
#ifdef DCSG_EXT_WANTED
INT4
ErpsCliConfigureRingPorts (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4RingId, INT4 i4RingPort1,
                           INT4 i4RingPort2, INT4 i4RingVlan, INT4 i4RingInnerVlan)
#else
INT4
ErpsCliConfigureRingPorts (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4RingId, INT4 i4RingPort1,
                           INT4 i4RingPort2, INT4 i4RingVlan)
#endif
{
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);
    /* Set the ring ports and Ring VLAN id */
#ifdef VSI_WANTED
    if ((CfaIsVepInterface(i4RingPort1) != CFA_SUCCESS) &&
            (CfaIsVepInterface(i4RingPort2) != CFA_SUCCESS))
    {
#endif
    if (nmhTestv2FsErpsRingVlanId (&u4ErrorCode, u4ContextId,
                                   u4RingId, i4RingVlan) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
#ifdef VSI_WANTED
    }
#endif
    if (nmhSetFsErpsRingVlanId (u4ContextId, u4RingId,
                                i4RingVlan) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
#ifdef VSI_WANTED
    if (i4RingInnerVlan != 0)
    {
    if(nmhTestv2FsErpsRingInnerVlanId (&u4ErrorCode, u4ContextId,
                                       u4RingId, i4RingInnerVlan) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingInnerVlanId (u4ContextId, u4RingId,
                                i4RingInnerVlan) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    }
#endif
    if (nmhTestv2FsErpsRingPort1 (&u4ErrorCode, u4ContextId,
                                  u4RingId, i4RingPort1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingPort1 (u4ContextId, u4RingId,
                               i4RingPort1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
#ifdef FM_WANTED
     ErpsNotifyRelationshipCreationToFm (u4RingId, i4RingPort1, FM_RELATIONSHIP_ADD);
#endif
    if (nmhTestv2FsErpsRingPort2 (&u4ErrorCode, u4ContextId,
                                  u4RingId, i4RingPort2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingPort2 (u4ContextId, u4RingId,
                               i4RingPort2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
#ifdef FM_WANTED
   ErpsNotifyRelationshipCreationToFm (u4RingId, i4RingPort2, FM_RELATIONSHIP_ADD);
#endif
    return CLI_SUCCESS;
}

#ifdef VSI_WANTED
/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingDataVep
 *
 * DESCRIPTION      : This function configures the ring ports 
 *                    and R-APS Vlan.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4RingPort1 - Ring Port1
 *                    i4RingPort2 - Ring Port2
 *                    i4RingVlan  - R-APS VLAN
 *                    i2ListAction - Add || Delete action to be performed
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingDataVep (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4RingId, INT4 i4RingPort1, INT4 i4RingPort2,
			     UINT4 u4RingVsiId, UINT2 i2ListAction)
{
    UINT4               u4ErrorCode = 0;
    INT4		i4RetVal = CLI_SUCCESS;

    /* Set the ring ports and Ring VLAN id */
    if (nmhTestv2FsErpsRingVsiId (&u4ErrorCode, u4ContextId,
                                   u4RingId, u4RingVsiId) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingVsiId (u4ContextId, u4RingId,
                                u4RingVsiId) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingVsiVep1Index (&u4ErrorCode, u4ContextId,
                                  u4RingId, i4RingPort1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingVsiVep1Index (u4ContextId, u4RingId,
                               i4RingPort1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingVsiVep2Index (&u4ErrorCode, u4ContextId,
                                  u4RingId, i4RingPort2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingVsiVep2Index (u4ContextId, u4RingId,
                               i4RingPort2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    /* Add or Delete the data-vep node in the ring data-vep list 
     * ERPS_SNMP_TRUE - Add
     * ERPS_SNMP_FALSE - Delete */

    if (i2ListAction == ERPS_SNMP_TRUE)
    {
 	    if (nmhSetFsErpsRingVsiRowStatus (u4ContextId, u4RingId, ACTIVE)
                                  != SNMP_SUCCESS)
	    {
	        ERPS_CONTEXT_TRC (u4ContextId, u4RingId, MGMT_TRC | ALL_FAILURE_TRC,
                "Node Addition failed for data vep into the Ring's vep list\r\n");
	        CLI_SET_ERR (CLI_ERPS_ERR_VEP_NODE_ADD);
	        i4RetVal = CLI_FAILURE;
	    }
    }
    else if (i2ListAction == ERPS_SNMP_FALSE)
    {
	    if (nmhSetFsErpsRingVsiRowStatus (u4ContextId, u4RingId, NOT_IN_SERVICE)
                                    != SNMP_SUCCESS)
	    {
	        ERPS_CONTEXT_TRC (u4ContextId, u4RingId, MGMT_TRC | ALL_FAILURE_TRC,
               "Node Deletion failed for data vep from the Ring's vep list\r\n");
  	        CLI_SET_ERR (CLI_ERPS_ERR_VEP_NODE_DEL);
	        i4RetVal = CLI_FAILURE;
 	    }
    }
    UNUSED_PARAM (CliHandle);
    return i4RetVal;
}
#endif
/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRPLPort 
 *
 * DESCRIPTION      : This function deletes a ring entry 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRPLPort (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4RingId, INT4 i4RPLPort)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsRingRplPort (&u4ErrorCode, u4ContextId,
                                    u4RingId, i4RPLPort) == SNMP_FAILURE)
    {
        return CLI_FAILURE;

    }
    if (nmhSetFsErpsRingRplPort (u4ContextId, u4RingId,
                                 i4RPLPort) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}
/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigurePortStatus
 *
 * DESCRIPTION      : This function enables/disables the port status of a ring
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 **************************************************************************/
INT4
ErpsCliConfigurePortStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4RingId, INT4 i4IfIndex, INT4 i4Status)
{
   UINT4               u4ErrorCode = 0;
   tErpsRingInfo      *pRingInfo = NULL;
   UNUSED_PARAM(CliHandle);

   pRingInfo = ErpsRingGetRingEntry (u4ContextId, u4RingId);

   if (pRingInfo == NULL)
   {
       return SNMP_FAILURE;
   }
 /*   if((pRingInfo->u4Port1IfIndex != 0)||
                (pRingInfo->u4Port2IfIndex != 0))
    {
        return SNMP_FAILURE;
    }*/

   if(pRingInfo->u4Port1IfIndex == (UINT4)i4IfIndex)
   {
       nmhTestv2FsErpsRingPathPort1AdminStatus (&u4ErrorCode ,u4ContextId ,
               u4RingId ,i4Status);

       nmhSetFsErpsRingPathPort1AdminStatus (u4ContextId, u4RingId, i4Status);

   }

   if(pRingInfo->u4Port2IfIndex == (UINT4)i4IfIndex)
   {
       nmhTestv2FsErpsRingPathPort2AdminStatus(&u4ErrorCode, u4ContextId ,
               u4RingId, i4Status);
       nmhSetFsErpsRingPathPort2AdminStatus(u4ContextId , u4RingId , i4Status);
   }

   return SNMP_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureCfmEntries 
 *
 * DESCRIPTION      : This function configures entries in the CFM table 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureCfmEntries (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4RingId, UINT4 u4RingMEG1, UINT4 u4RingME1,
                            UINT4 u4RingMEP1, UINT4 u4RingMEG2,
                            UINT4 u4RingME2, UINT4 u4RingMEP2)
{
    INT4                i4CfmStatus = -1;
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);
    /* If CFM entry does not exist create it */
    if (nmhGetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, &i4CfmStatus)
        == SNMP_FAILURE)
    {
        if (nmhTestv2FsErpsRingCfmRowStatus (&u4ErrorCode, u4ContextId,
                                             u4RingId, CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingCfmRowStatus (u4ContextId, u4RingId,
                                          CREATE_AND_WAIT) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* If Cfm entry already exists, make the entry in-active */
    if (i4CfmStatus == ACTIVE)
    {
        if (nmhTestv2FsErpsRingCfmRowStatus (&u4ErrorCode, u4ContextId,
                                             u4RingId, NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* Update MEG1, MEG2 , ME1, ME2, MEP1, MEP2 in CFM Table */

    if (nmhTestv2FsErpsRingMEG1 (&u4ErrorCode, u4ContextId,
                                 u4RingId, u4RingMEG1) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_MEG_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingMEG1 (u4ContextId, u4RingId,
                              u4RingMEG1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingMEG2 (&u4ErrorCode, u4ContextId,
                                 u4RingId, u4RingMEG2) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_MEG_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingMEG2 (u4ContextId, u4RingId,
                              u4RingMEG2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingCfmME1 (&u4ErrorCode, u4ContextId,
                                   u4RingId, u4RingME1) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_ME_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingCfmME1 (u4ContextId, u4RingId, u4RingME1)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingCfmMEP1 (&u4ErrorCode, u4ContextId,
                                    u4RingId, u4RingMEP1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingCfmMEP1 (u4ContextId, u4RingId,
                                 u4RingMEP1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingCfmME2 (&u4ErrorCode, u4ContextId,
                                   u4RingId, u4RingME2) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_ME_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingCfmME2 (u4ContextId, u4RingId, u4RingME2)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingCfmMEP2 (&u4ErrorCode, u4ContextId,
                                    u4RingId, u4RingMEP2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingCfmMEP2 (u4ContextId, u4RingId,
                                 u4RingMEP2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhTestv2FsErpsRingCfmRowStatus (&u4ErrorCode, u4ContextId,
                                         u4RingId, ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, ACTIVE)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

 /************************************************************************** 
* FUNCTION NAME    : ErpsCliDelCfmEntries 
* 
* DESCRIPTION      : This function deletes the entries in the CFM table 
* 
* INPUT            : u4ContextId - Context Identifier 
*                    u4RingId    - Ring Identifier 
* 
* OUTPUT           : None 
* 
* RETURNS          : CLI_SUCCESS/CLI_FAILURE 
* 
**************************************************************************/
INT4
ErpsCliDelCfmEntries (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId)
{
    INT4                i4CfmStatus = -1;
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    if (nmhGetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, &i4CfmStatus)
        == SNMP_FAILURE)
    {
        CliPrintf (CliHandle, "\r%% Ring Entry/CFM Entries Does not "
                   "exist.\r\n");
        return CLI_FAILURE;
    }

    /* If Cfm entry exists, delete the entries */
    if (i4CfmStatus == ACTIVE)
    {
        if (nmhTestv2FsErpsRingCfmRowStatus (&u4ErrorCode, u4ContextId,
                                             u4RingId, DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingCfmRowStatus (u4ContextId, u4RingId, DESTROY)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

/************************************************************************** 
 * * FUNCTION NAME    : ErpsCliConfigureMplsPwEntry 
 * * 
 * * DESCRIPTION      : This function associates the pw information to Ring Ports
 * * 
 * * INPUT            : u4ContextId - Context Identifier 
 * *                        u4RingId    - Ring Identifier
 * *                 u4RingPwId1 - Pw Identifier
 * *                        u4RingPwId2 -   Pw Identifier
 * * 
 * * OUTPUT           : None 
 * * 
 * * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * * 
 * **************************************************************************/
INT4
ErpsCliConfigureMplsPwEntry (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4RingId, UINT4 u4RingPwId1,
                             UINT4 u4RingPwId2)
{
    INT4                i4MplsStatus = -1;
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);
    /* If Mpls entry does not exist create it */
    if (nmhGetFsErpsRingMplsRowStatus (u4ContextId, u4RingId, &i4MplsStatus)
        == SNMP_FAILURE)
    {
        if (nmhTestv2FsErpsRingMplsRowStatus (&u4ErrorCode, u4ContextId,
                                              u4RingId, CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingMplsRowStatus (u4ContextId, u4RingId,
                                           CREATE_AND_WAIT) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* If Mpls entry already exists, make the entry in-active */
    if (i4MplsStatus == ACTIVE)
    {
        if (nmhTestv2FsErpsRingMplsRowStatus (&u4ErrorCode, u4ContextId,
                                              u4RingId, NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingMplsRowStatus
            (u4ContextId, u4RingId, NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    /* Update PWVC-ID1, PWVC-ID2 in MPLS Table */

    if (nmhTestv2FsErpsRingPwVcId1 (&u4ErrorCode, u4ContextId,
                                    u4RingId, u4RingPwId1) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_MEG_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingPwVcId1 (u4ContextId, u4RingId,
                                 u4RingPwId1) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingPwVcId2 (&u4ErrorCode, u4ContextId,
                                    u4RingId, u4RingPwId2) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ERPS_ERR_MEG_INVALID_RANGE);
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingPwVcId2 (u4ContextId, u4RingId,
                                 u4RingPwId2) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsErpsRingMplsRowStatus (&u4ErrorCode, u4ContextId,
                                          u4RingId, ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingMplsRowStatus (u4ContextId, u4RingId, ACTIVE)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/************************************************************************** 
 * * FUNCTION NAME    : ErpsCliDelMplsPwEntry 
 * * 
 * * DESCRIPTION      : This function deassociates the pw information from Ring Ports
 * * 
 * * INPUT            : u4ContextId - Context Identifier 
 * *                        u4RingId    - Ring Identifier
 * * 
 * * OUTPUT           : None 
 * * 
 * * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * * 
 * **************************************************************************/
INT4
ErpsCliDelMplsPwEntry (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId)
{
    INT4                i4MplsStatus = -1;
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    if (nmhGetFsErpsRingMplsRowStatus (u4ContextId, u4RingId, &i4MplsStatus)
        == SNMP_FAILURE)
    {
        CliPrintf (CliHandle, "\r%% Ring Entry/MPLS Entries Does not "
                   "exist.\r\n");
        return CLI_FAILURE;
    }
    /* If MPLS entry exists, delete the entries */
    if (i4MplsStatus == ACTIVE)
    {
        if (nmhTestv2FsErpsRingMplsRowStatus (&u4ErrorCode, u4ContextId,
                                              u4RingId,
                                              DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingMplsRowStatus (u4ContextId, u4RingId, DESTROY)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

 /***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureSwitchCommand 
 *
 * DESCRIPTION      : This function configures switch port 
 *                    and issues switch command.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4SwitchCmd - force/manual
 *                    i4SwitchPort- Switch port
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureSwitchCommand (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4RingId, INT4 i4SwitchCmd,
                               INT4 i4SwitchPort)
{
    UINT4               u4ErrorCode = 0;

    UNUSED_PARAM (CliHandle);

    /* Switch Port has to be configured, before issuing the switch command */
    if (i4SwitchCmd != ERPS_SWITCH_COMMAND_NONE)
    {

        if (nmhTestv2FsErpsRingConfigSwitchPort (&u4ErrorCode, u4ContextId,
                                                 u4RingId, i4SwitchPort)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingConfigSwitchPort (u4ContextId, u4RingId,
                                              i4SwitchPort) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* Configure the switch port */

    if (nmhTestv2FsErpsRingConfigSwitchCmd (&u4ErrorCode, u4ContextId, u4RingId,
                                            i4SwitchCmd) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigSwitchCmd (u4ContextId, u4RingId,
                                         i4SwitchCmd) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureOperatingMode 
 *
 * DESCRIPTION      : This function configures revertive mode of 
 *                    opertion and the WTR timer value.
 *   
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4OperatingMode - revertive/non-revertive
 *                    u4WTRTime  - Wait to Restore Timer val
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureOperatingMode (tCliHandle CliHandle,
                               UINT4 u4ContextId, UINT4 u4RingId,
                               INT4 i4OperatingMode, UINT4 u4WTRTime)
{
    UINT4               u4ErrorCode = 0;
    INT4                i4CurrOperatingMode = -1;
    UNUSED_PARAM (CliHandle);

    if (nmhGetFsErpsRingOperatingMode (u4ContextId, u4RingId,
                                       &i4CurrOperatingMode) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    /* Set the operating mode to revertive / non-revertive */

    if (i4CurrOperatingMode != i4OperatingMode)
    {
        if (nmhTestv2FsErpsRingOperatingMode (&u4ErrorCode, u4ContextId,
                                              u4RingId, i4OperatingMode)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingOperatingMode
            (u4ContextId, u4RingId, i4OperatingMode) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    /* Set the Wait-To-Restore Timer value */

    if (nmhTestv2FsErpsRingConfigWTRTime (&u4ErrorCode, u4ContextId,
                                          u4RingId, u4WTRTime) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigWTRTime (u4ContextId, u4RingId, u4WTRTime)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRecoveryMethod 
 *
 * DESCRIPTION      : This function configures non-revertive mode 
 *                    and manual recovery method.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4OperatingMode - revertive/non-revertive
 *                    u4WTRTime  - Wait to Restore Timer val
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRecoveryMethod (tCliHandle CliHandle,
                                UINT4 u4ContextId, UINT4 u4RingId,
                                INT4 i4OperatingMode, UINT4 u4RecoveryMethod)
{
    INT4                i4CurrOperatingMode = -1;
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    if (nmhGetFsErpsRingOperatingMode (u4ContextId, u4RingId,
                                       &i4CurrOperatingMode) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (i4CurrOperatingMode != i4OperatingMode)
    {
        /* Set the operating mode to non-revertive */

        if (nmhTestv2FsErpsRingOperatingMode (&u4ErrorCode, u4ContextId,
                                              u4RingId, i4OperatingMode)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsErpsRingOperatingMode (u4ContextId, u4RingId,
                                           i4OperatingMode) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    /* Set the Recovery Method */
    if (nmhTestv2FsErpsRingConfigRecoveryMethod (&u4ErrorCode, u4ContextId,
                                                 u4RingId, u4RecoveryMethod)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigRecoveryMethod (u4ContextId, u4RingId,
                                              u4RecoveryMethod) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingTimers 
 *
 * DESCRIPTION      : This function configures the values of periodic,guard,
 *                    hold-off timers
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4PeriodicTmrVal - Periodic Timer Value
 *                    u4HoldOffTmrVal - Hold-off Timer Value
 *                    u4GuardTime - Guard Timer Value
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE 
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingTimers (tCliHandle CliHandle,
                            UINT4 u4ContextId, UINT4 u4RingId,
                            UINT4 u4PeriodicTmrVal,
                            UINT4 u4HoldOffTmrVal, UINT4 u4GuardTmrVal)
{
    UINT4               u4ErrorCode = 0;

    UNUSED_PARAM (CliHandle);

    if (u4PeriodicTmrVal != ERPS_INVALID_TMR_RANGE)
    {
        /* Set the value of periodic timer */
        if (nmhTestv2FsErpsRingConfigPeriodicTime (&u4ErrorCode, u4ContextId,
                                                   u4RingId, u4PeriodicTmrVal)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingConfigPeriodicTime (u4ContextId, u4RingId,
                                                u4PeriodicTmrVal) ==
            SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    if (u4HoldOffTmrVal != ERPS_INVALID_TMR_RANGE)
    {
        /* Set the value of Hold-off timer */
        if (nmhTestv2FsErpsRingConfigHoldOffTime (&u4ErrorCode, u4ContextId,
                                                  u4RingId, u4HoldOffTmrVal)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingConfigHoldOffTime (u4ContextId, u4RingId,
                                               u4HoldOffTmrVal) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    if (u4GuardTmrVal != ERPS_INVALID_TMR_RANGE)
    {
        /* Set the value of Guard timer */
        if (nmhTestv2FsErpsRingConfigGuardTime (&u4ErrorCode, u4ContextId,
                                                u4RingId, u4GuardTmrVal)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingConfigGuardTime (u4ContextId, u4RingId,
                                             u4GuardTmrVal) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliPropagateTopologyChange 
 *
 * DESCRIPTION      : This Routine populates the TC propagation list
 *                    for the ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliPropagateTopologyChange (tCliHandle CliHandle, UINT4 u4ContextId,
                                UINT4 u4RingId, UINT4 *pu4TcProgList,
                                INT4 i4TcProgStatus)
{
    UINT4               u4ErrorCode = 0;
    UINT4               u4TcProgId = 0;
    UINT4               u4TCListIndex = 0;
    INT4                i4TCRowStatus = 0;
    INT4               i4RingTcPropStatus = 0;

    /* Configure the TC entries only if they are given as input
     * by user.
     * If no TC entries are given , just configure the TC 
     * propagation status */
    if (pu4TcProgList[0] != 0)
    {
        /* Test each and every TC list value.Only if test is success, 
         * delete the old values and configure the new values */

        for (u4TCListIndex = 0; u4TCListIndex < ERPS_TC_LIST_SIZE;
             u4TCListIndex++)
        {
            if (pu4TcProgList[u4TCListIndex] != 0)
            {
                u4TcProgId = pu4TcProgList[u4TCListIndex];

                /* This check is to ensure that invalid ring ids are not populated. 
                 * The existing TC list will be deleted only if 
                 * the new TC list is correct*/
                if (nmhTestv2FsErpsRingTcPropRowStatus
                    (&u4ErrorCode, u4ContextId, u4RingId, u4TcProgId,
                     CREATE_AND_GO) == SNMP_FAILURE)
                {
                    /* In case, the new TC list contains a TCId that is already 
                     *given by user , test routine returns error.
                     *To avoid that the following check is done.
                     */

                    if (nmhGetFsErpsRingTcPropRowStatus
                        (u4ContextId, u4RingId, u4TcProgId,
                         &i4TCRowStatus) != SNMP_SUCCESS)
                    {
                        return CLI_FAILURE;
                    }
                }
            }
        }

        /* Existing values in the RING TC propagation list are deleted */
        if (ErpsCliDelAllTopologyList (CliHandle, u4ContextId, u4RingId) ==
            CLI_FAILURE)
        {
            return CLI_FAILURE;
        }

        /* Now set the new TC propagation list values */

        for (u4TCListIndex = 0; u4TCListIndex < ERPS_TC_LIST_SIZE;
             u4TCListIndex++)
        {
            if (pu4TcProgList[u4TCListIndex] != 0)
            {
                u4TcProgId = pu4TcProgList[u4TCListIndex];

                if (nmhSetFsErpsRingTcPropRowStatus (u4ContextId, u4RingId,
                                                     u4TcProgId, CREATE_AND_GO)
                    == SNMP_FAILURE)
                {
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }
            }
        }
    }

    /* Note :- The TC list entries are configured irrespective of whether
     * the user has set the TC propagation status to enable or disable.
     * Whenever the TC propagation status is set to "enable", the TC 
     * list will be taken into account. */
    nmhGetFsErpsRingConfigPropagateTC (u4ContextId, u4RingId, &i4RingTcPropStatus);

    if ((i4TcProgStatus != 0) && (i4RingTcPropStatus != i4TcProgStatus))
    {

    /* Set the TC Propagation Status for the ring */

    if (nmhTestv2FsErpsRingConfigPropagateTC (&u4ErrorCode, u4ContextId,
                                              u4RingId, i4TcProgStatus)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigPropagateTC (u4ContextId, u4RingId,
                                           i4TcProgStatus) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliDelTopologyList 
 *
 * DESCRIPTION      : This Routine deletes the TC propagation list
 *                    for the ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliDelTopologyList (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4RingId, UINT4 *pu4TcProgList)
{
    UINT4               u4TcProgId = 0;
    UINT4               u4TCListIndex = 0;
    INT4                i4RowStatus = 0;

    for (u4TCListIndex = 0; u4TCListIndex < ERPS_TC_LIST_SIZE; u4TCListIndex++)
    {
        if (pu4TcProgList[u4TCListIndex] != 0)
        {

            u4TcProgId = pu4TcProgList[u4TCListIndex];
            if (nmhGetFsErpsRingTcPropRowStatus (u4ContextId, u4RingId,
                                                 u4TcProgId,
                                                 &i4RowStatus) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }

        }
    }

    if (ErpsCliCfgRingTopoEntry (CliHandle, u4ContextId, u4RingId,
                                 pu4TcProgList, DESTROY) == CLI_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliDelTopologyList 
 *
 * DESCRIPTION      : This Routine creates/deletes the TC propagation list
 *                    for the ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliCfgRingTopoEntry (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4RingId, UINT4 *pu4TcProgList,
                         UINT4 i4RowStatus)
{
    UINT4               u4TcProgId = 0;
    UINT4               u4ErrorCode = 0;
    UINT4               u4TCListIndex = 0;

    for (u4TCListIndex = 0; u4TCListIndex < ERPS_TC_LIST_SIZE; u4TCListIndex++)
    {
        if (pu4TcProgList[u4TCListIndex] != 0)
        {
            u4TcProgId = pu4TcProgList[u4TCListIndex];

            if (nmhTestv2FsErpsRingTcPropRowStatus (&u4ErrorCode, u4ContextId,
                                                    u4RingId, u4TcProgId,
                                                    i4RowStatus)
                == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            if (nmhSetFsErpsRingTcPropRowStatus (u4ContextId, u4RingId,
                                                 u4TcProgId, i4RowStatus)
                == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliDelAllTopologyList 
 *
 * DESCRIPTION      : This Routine deletes the entire TC propagation list
 *                    for the ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliDelAllTopologyList (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4RingId)
{
    UINT4               u4NextContextId = u4ContextId;
    UINT4               u4NextRingId = 0;
    UINT4               u4TcProgId = 0;
    UINT4               u4NextTcProgId = 0;
    UINT4               u4ErrorCode = 0;

    /* Existing values in the RING TC propagation list are deleted */
    while (nmhGetNextIndexFsErpsRingTcPropTable (u4ContextId, &u4NextContextId,
                                                 u4RingId, &u4NextRingId,
                                                 u4TcProgId, &u4NextTcProgId)
           == SNMP_SUCCESS)

    {
        if ((u4ContextId != (UINT4) u4NextContextId) ||
            (u4RingId != u4NextRingId))
        {
            break;
        }

        /* u4NextTcProgId is deleted now from the TC propagation list */

        if (nmhTestv2FsErpsRingTcPropRowStatus (&u4ErrorCode, u4ContextId,
                                                u4NextRingId, u4NextTcProgId,
                                                DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingTcPropRowStatus (u4ContextId, u4NextRingId,
                                             u4NextTcProgId, DESTROY)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        u4TcProgId = u4NextTcProgId;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliGetContextInfoForShowCmd 
 *
 * DESCRIPTION      : This Routine validates the string input for the switch
 *                    name or loop through for all the context. It also checks
 *                    if ERPS is Started or not.
 *
 * INPUT            : u4CurrContextId - Context Identifier
 *                    pu1ContextName - Entered Context Name
 *                    u4Command      - Command Identifier
 *
 * OUTPUT           : pu4ContextId - Next Context Id or
 *                                   Context Id of the entered Context name
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliGetContextInfoForShowCmd (tCliHandle CliHandle, UINT1 *pu1ContextName,
                                 UINT4 u4CurrContextId, UINT4 *pu4ContextId)
{
    /* If Switch-name is given then get the Context-Id from it */
    if (pu1ContextName != NULL)
    {
        if (ErpsPortVcmIsSwitchExist (pu1ContextName, pu4ContextId)
            != OSIX_TRUE)
        {
            CliPrintf (CliHandle, "\r%% Switch %s Does not exist.\r\n",
                       pu1ContextName);
            return OSIX_FAILURE;
        }
    }
    else
    {
        if (nmhGetNextIndexFsErpsContextTable (u4CurrContextId,
                                               pu4ContextId) != SNMP_SUCCESS)
        {
            if (ErpsUtilIsErpsStarted (*pu4ContextId) != OSIX_TRUE)
            {
                CliPrintf (CliHandle, "\r\n %%ERPS is Not Enabled\r\n");
            }
            return OSIX_FAILURE;
        }
    }

    return OSIX_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowGlobalInfo
 *
 * DESCRIPTION      : This function displays the global ring parameters
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliShowGlobalInfo (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT1               au1ContextName[VCM_ALIAS_MAX_LEN];
    INT4                i4ModuleStatus = OSIX_DISABLED;
    INT4                i4SystemControl = ERPS_SHUTDOWN;
    INT4                i4TrapEnabledStatus = ERPS_SNMP_FALSE;
    INT4                i4ProprietaryClearFS = ERPS_SNMP_FALSE;

    MEMSET (au1ContextName, 0, sizeof (au1ContextName));
    ErpsPortVcmGetAliasName (u4ContextId, au1ContextName);
    CliPrintf (CliHandle, "\r\n\r Switch %s \r\n", au1ContextName);

    if (ErpsUtilIsErpsStarted (u4ContextId) != OSIX_TRUE)
    {
        CliPrintf (CliHandle, "\r\n %%ERPS is ShutDown\r\n");
        return CLI_SUCCESS;
    }

    nmhGetFsErpsCtxtModuleStatus (u4ContextId, &i4ModuleStatus);
    nmhGetFsErpsCtxtSystemControl (u4ContextId, &i4SystemControl);
    nmhGetFsErpsCtxtTrapStatus (u4ContextId, &i4TrapEnabledStatus);
    nmhGetFsErpsCtxtProprietaryClearFS (u4ContextId, &i4ProprietaryClearFS);

    CliPrintf (CliHandle, "\r\n ERPS Global Info \r\n");

    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");
    if (i4ModuleStatus == OSIX_ENABLED)
    {
        CliPrintf (CliHandle, "%-33s: Enabled\r\n", "Module Status");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s: Disabled\r\n", "Module Status");
    }

    if (i4SystemControl == ERPS_START)
    {
        CliPrintf (CliHandle, "%-33s: Start \r\n", "System Control");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s: Shutdown \r\n", "System Control");
    }

    if (i4TrapEnabledStatus == ERPS_SNMP_TRUE)
    {
        CliPrintf (CliHandle, "%-33s: Enabled\r\n", "Trap Status");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s: Disabled\r\n", "Trap Status");
    }
    if (i4ProprietaryClearFS == ERPS_SNMP_TRUE)
    {
        CliPrintf (CliHandle, "%-33s: Enabled\r\n", "Proprietary Clear FS");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s: Disabled\r\n", "Proprietary Clear FS");
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowDebugging 
 *
 * DESCRIPTION      : This function displays the Trace options enabled
 *                    in a context.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : None 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliShowDebugging (tCliHandle CliHandle, UINT4 u4ContextId)
{
    tUtlValidTraces     UtlValidTraces;
    tSNMP_OCTET_STRING_TYPE CtxtTrace;
    UINT4               u4DbgLevel = 0;
    UINT1               au1ContextName[VCM_ALIAS_MAX_LEN];
    UINT1               au1CtxtTrace[ERPS_TRC_MAX_SIZE];
    UINT1               u1TrcStatus = 0;

    MEMSET (au1CtxtTrace, 0, sizeof (au1CtxtTrace));
    MEMSET (au1ContextName, 0, sizeof (au1ContextName));
    MEMSET (&UtlValidTraces, 0, sizeof (tUtlValidTraces));

    CtxtTrace.pu1_OctetList = au1CtxtTrace;
    CtxtTrace.i4_Length = STRLEN (au1CtxtTrace);

    /* Check if context info is present for the context id 
     * If not,return failure */

    ErpsPortVcmGetAliasName (u4ContextId, au1ContextName);

    if (ErpsUtilIsErpsStarted (u4ContextId) != OSIX_TRUE)
    {
        return CLI_SUCCESS;
    }

    if (nmhGetFsErpsCtxtTraceInput (u4ContextId, &CtxtTrace) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    UtlValidTraces.pu1TraceStrings = (UINT1 *) &gau1ErpsTraceTypes;
    UtlValidTraces.u2MaxTrcTypes = (UINT2) ERPS_MAX_TRC_TYPE;

    UtlGetTraceOptionValue (UtlValidTraces, CtxtTrace.pu1_OctetList,
                            (UINT2) CtxtTrace.i4_Length, &u4DbgLevel,
                            &u1TrcStatus);
    if (u4DbgLevel == 0)
    {
        return CLI_SUCCESS;
    }
    else
    {
        CliPrintf (CliHandle, "\r\n\r Switch %s \r\n", au1ContextName);
    }

    /* If All Debugging is ON then ,there is no need
     * to display individual debugging status */

    if ((u4DbgLevel & ERPS_ALL_TRC) == ERPS_ALL_TRC)
    {
        CliPrintf (CliHandle, "ERPS  All debugging is on\r\n");
        return CLI_SUCCESS;
    }
    if ((u4DbgLevel & INIT_SHUT_TRC) == INIT_SHUT_TRC)
    {
        CliPrintf (CliHandle, "ERPS start and shutdown debugging is on\r\n");
    }
    if ((u4DbgLevel & MGMT_TRC) == MGMT_TRC)
    {
        CliPrintf (CliHandle, "ERPS management debugging is on\r\n");
    }
    if ((u4DbgLevel & CONTROL_PLANE_TRC) == CONTROL_PLANE_TRC)
    {
        CliPrintf (CliHandle, "ERPS control plane debugging is on\r\n");
    }
    if ((u4DbgLevel & DUMP_TRC) == DUMP_TRC)
    {
        CliPrintf (CliHandle, "ERPS packet dump debugging is on\r\n");
    }
    if ((u4DbgLevel & OS_RESOURCE_TRC) == OS_RESOURCE_TRC)
    {
        CliPrintf (CliHandle, "ERPS resources debugging is on\r\n");
    }
    if ((u4DbgLevel & ALL_FAILURE_TRC) == ALL_FAILURE_TRC)
    {
        CliPrintf (CliHandle, "ERPS all failure debugging is on\r\n");
    }
    if ((u4DbgLevel & BUFFER_TRC) == BUFFER_TRC)
    {
        CliPrintf (CliHandle, "ERPS buffer debugging is on\r\n");
    }
    if ((u4DbgLevel & ERPS_CRITICAL_TRC) == ERPS_CRITICAL_TRC)
    {
        CliPrintf (CliHandle, "ERPS critical debugging is on\r\n");
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowRingConfig 
 *
 * DESCRIPTION      : This function displays the ring configurations like
 *                    ring ports, vlan etc.,
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsCliShowRingConfig (tCliHandle CliHandle, UINT4 u4ContextId, UINT4
                       u4RingId, UINT4 *pu4ShowStatus)
{
    UINT4               u4RingME1 = 0;
    UINT4               u4RingME2 = 0;
    UINT4               u4RingMEP1 = 0;
    UINT4               u4RingMEP2 = 0;
    UINT4               u4RingMEG1 = 0;
    UINT4               u4RingMEG2 = 0;
    UINT4               u4MainRingId = 0;
    UINT4               u4RingPwVcId1 = 0;
    UINT4               u4RingPwVcId2 = 0;
    INT4                i4RingVlanId = -1;
    UINT4                u4RingVsiId = -1;
    INT4                i4RingInnerVlanId = -1;
    INT4                i4RingPort1 = -1;
    INT4                i4RingPort2 = -1;
    INT4                i4RplPort = -1;
    INT4                i4RingNodeType = -1;
    INT4                i4RingOperatingMode = -1;
    INT4                i4RingRecoveryMethod = -1;
    INT4                i4SwitchPort = -1;
    INT4                i4SwitchCmd = -1;
    INT4                i4PropagateTC = -1;
    INT4                i4BlockingStatus = -1;
    INT4                i4VlanGroupId = -1;
    INT4                i4ProtectionType = -1;
    INT4                i4RingMacId = -1;
    INT4                i4FsErpsVlanGrpManager = -1;
    UINT2               u2Index = 1;
    UINT1               au1RingName[ERPS_MAX_NAME_LENGTH];
    UINT1               bResult = 0;
    UINT1               u1Counter = 0;
    UINT1              *pu1FirstLine = NULL;
    UINT1               au1FirstLine[ERPS_CLI_DISPLAY_LINE];
    UINT1               au1BlankSpace[CLI_MAX_COLS];
    UINT1               au1VlanGroupList[MAX_ERPS_VLAN_GROUP_LIST_SIZE];
    INT1                ai1IfNamePort1[CFA_MAX_PORT_NAME_LENGTH];
    INT1                ai1IfNamePort2[CFA_MAX_PORT_NAME_LENGTH];
    INT1                ai1IfNameRplPort[CFA_MAX_PORT_NAME_LENGTH];
    INT1                ai1IfNameSwitchPort[CFA_MAX_PORT_NAME_LENGTH];
    tSNMP_OCTET_STRING_TYPE RingName;
    tSNMP_OCTET_STRING_TYPE VlanGroupList;
    tSNMP_OCTET_STRING_TYPE PortSubPortList;

    MEMSET (&PortSubPortList, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    MEMSET (au1RingName, 0, sizeof (au1RingName));
    RingName.pu1_OctetList = au1RingName;
    RingName.i4_Length = STRLEN (au1RingName);

    MEMSET (au1VlanGroupList, 0, MAX_ERPS_VLAN_GROUP_LIST_SIZE);
    VlanGroupList.pu1_OctetList = au1VlanGroupList;

    nmhGetFsErpsRingName (u4ContextId, u4RingId, &RingName);
    nmhGetFsErpsRingVlanId (u4ContextId, u4RingId, &i4RingVlanId);
#ifdef VSI_WANTED
    nmhGetFsErpsRingVsiId (u4ContextId ,u4RingId , &u4RingVsiId);
#endif
    nmhGetFsErpsRingPort1 (u4ContextId, u4RingId, &i4RingPort1);
    nmhGetFsErpsRingPort2 (u4ContextId, u4RingId, &i4RingPort2);
    nmhGetFsErpsRingRplPort (u4ContextId, u4RingId, &i4RplPort);
    nmhGetFsErpsRingNodeType (u4ContextId, u4RingId, &i4RingNodeType);
    nmhGetFsErpsRingOperatingMode (u4ContextId, u4RingId, &i4RingOperatingMode);
    nmhGetFsErpsRingConfigRecoveryMethod (u4ContextId, u4RingId,
                                          &i4RingRecoveryMethod);
    nmhGetFsErpsRingCfmME1 (u4ContextId, u4RingId, &u4RingME1);
    nmhGetFsErpsRingCfmME2 (u4ContextId, u4RingId, &u4RingME2);
    nmhGetFsErpsRingCfmMEP1 (u4ContextId, u4RingId, &u4RingMEP1);
    nmhGetFsErpsRingCfmMEP2 (u4ContextId, u4RingId, &u4RingMEP2);
    nmhGetFsErpsRingMEG1 (u4ContextId, u4RingId, &u4RingMEG1);
    nmhGetFsErpsRingMEG2 (u4ContextId, u4RingId, &u4RingMEG2);
    nmhGetFsErpsRingConfigSwitchPort (u4ContextId, u4RingId, &i4SwitchPort);
    nmhGetFsErpsRingConfigSwitchCmd (u4ContextId, u4RingId, &i4SwitchCmd);
    nmhGetFsErpsRingConfigPropagateTC (u4ContextId, u4RingId, &i4PropagateTC);
    nmhGetFsErpsRingPortBlockingOnVcRecovery (u4ContextId, u4RingId,
                                              &i4BlockingStatus);
    nmhGetFsErpsRingProtectionType (u4ContextId, u4RingId, &i4ProtectionType);
    nmhGetFsErpsRingMacId (u4ContextId, u4RingId, &i4RingMacId);
    nmhGetFsErpsRingProtectedVlanGroupId (u4ContextId, u4RingId,
                                          &i4VlanGroupId);
    nmhGetFsErpsRingProtectedVlanGroupList (u4ContextId, u4RingId,
                                            &VlanGroupList);
    nmhGetFsErpsCtxtVlanGroupManager (u4ContextId, &i4FsErpsVlanGrpManager);
    nmhGetFsErpsRingConfigExtMainRingId (u4ContextId, u4RingId, &u4MainRingId);
    nmhGetFsErpsRingPwVcId1 (u4ContextId, u4RingId, &u4RingPwVcId1);
    nmhGetFsErpsRingPwVcId2 (u4ContextId, u4RingId, &u4RingPwVcId2);
    CliPrintf (CliHandle, "\r\nRing Id %u Configurations\r\n", u4RingId);

    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");
    CliPrintf (CliHandle, "%-33s : %s\r\n", "RingName", RingName.pu1_OctetList);
    CliPrintf (CliHandle, "%-33s : %d\r\n", "R-APS Vlan Id", i4RingVlanId);

    if (i4RingPort1 != 0)
    {
        CfaCliGetIfName ((UINT4) i4RingPort1, ai1IfNamePort1);
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Ring Port1", ai1IfNamePort1);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Ring Port1", "None");
    }

    if (i4RingPort2 != 0)
    {
        CfaCliGetIfName ((UINT4) i4RingPort2, ai1IfNamePort2);
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Ring Port2", ai1IfNamePort2);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Ring Port2", "None");
        if (u4MainRingId != 0)
        {
            CliPrintf (CliHandle, "%-33s : %u\r\n", "Main Ring Id ",
                       u4MainRingId);
        }
    }

    if (i4RingNodeType == ERPS_RPL_OWNER)
    {
        CliPrintf (CliHandle, "%-33s : RPL Owner\r\n", "Node Type");
    }
    if (i4RingNodeType == ERPS_NON_RPL_OWNER)
    {
        CliPrintf (CliHandle, "%-33s : Non-RPL Owner\r\n", "Node Type");
    }

    if (i4RplPort != 0)
    {
        CfaCliGetIfName ((UINT4) i4RplPort, ai1IfNameRplPort);
        CliPrintf (CliHandle, "%-33s : %s\r\n", "RPL Port", ai1IfNameRplPort);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "RPL Port", "None");
    }

    if (i4RingOperatingMode == ERPS_RING_REVERTIVE_MODE)
    {
        CliPrintf (CliHandle, "%-33s : Revertive\r\n", "Operating Mode");
    }
    if (i4RingOperatingMode == ERPS_RING_NON_REVERTIVE_MODE)
    {
        CliPrintf (CliHandle, "%-33s : Non-Revertive\r\n", "Operating Mode");
    }
    if (i4RingRecoveryMethod == ERPS_RING_MANUAL_RECOVERY)
    {
        CliPrintf (CliHandle, "%-33s : Manual\r\n", "Recovery Method");
    }
    if (i4RingRecoveryMethod == ERPS_RING_AUTO_RECOVERY)
    {
        CliPrintf (CliHandle, "%-33s : Auto\r\n", "Recovery Method");
    }
    if (i4SwitchCmd == ERPS_SWITCH_COMMAND_FORCE)
    {
        CliPrintf (CliHandle, "%-33s : Force\r\n", "Switch  Command");
    }
    if (i4SwitchCmd == ERPS_SWITCH_COMMAND_MANUAL)
    {
        CliPrintf (CliHandle, "%-33s : Manual\r\n", "Switch  Command");
    }
    if (i4SwitchCmd == ERPS_SWITCH_COMMAND_NONE)
    {
        CliPrintf (CliHandle, "%-33s : None\r\n", "Switch  Command");
    }

    if ((i4SwitchPort != 0) && (i4SwitchCmd != ERPS_SWITCH_COMMAND_NONE))
    {
        CfaCliGetIfName ((UINT4) i4SwitchPort, ai1IfNameSwitchPort);
        CliPrintf (CliHandle, "%-33s : %s\r\n", "SwitchCommand Port",
                   ai1IfNameSwitchPort);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "SwitchCommand Port", "None");
    }

    if (i4RingPort2 == 0)
    {
        if (i4BlockingStatus == ERPS_SNMP_TRUE)
        {
            CliPrintf (CliHandle, "%-33s : Allowed\r\n",
                       "Port blocking on VC recovery");
        }
        else
        {
            CliPrintf (CliHandle, "%-33s : Not-Allowed\r\n",
                       "Port blocking on VC recovery");
        }
    }

    if (i4PropagateTC == OSIX_ENABLED)
    {
        CliPrintf (CliHandle, "%-33s : Enable\r\n", "TC Propagation Status");
    }
    if (i4PropagateTC == OSIX_DISABLED)
    {
        CliPrintf (CliHandle, "%-33s : Disable\r\n", "TC Propagation Status");
    }

    if (ErpsCliShowTcListForRing (CliHandle, u4ContextId, u4RingId)
        == CLI_FAILURE)
    {
        CliPrintf (CliHandle, "%-33s : None\r\n", "TC Propagation Ring List");
    }

    if (i4ProtectionType == ERPS_PORT_BASED_PROTECTION)
    {
        CliPrintf (CliHandle, "%-33s : port-based\r\n", "Protection Type");
    }
    if (i4ProtectionType == ERPS_SERVICE_BASED_PROTECTION)
    {
        CliPrintf (CliHandle, "%-33s : service-based\r\n", "Protection Type");
        if (i4FsErpsVlanGrpManager == ERPS_VLAN_GROUP_MANAGER_MSTP)
        {
            CliPrintf (CliHandle, "%-34s: MSTP\r\n", "Group Manager");
        }
        else
        {
            CliPrintf (CliHandle, "%-34s: ERPS\r\n", "Group Manager");
        }

        CliPrintf (CliHandle, "%-33s : %d\r\n", "Vlan Group Id", i4VlanGroupId);
        CliPrintf (CliHandle, "%-33s : %d\r\n", "Mac Id", i4RingMacId);

        MEMSET (au1BlankSpace, 0, CLI_MAX_COLS);

        MEMSET (au1FirstLine, 0, ERPS_CLI_DISPLAY_LINE);

        pu1FirstLine = au1FirstLine;

        STRCPY (pu1FirstLine, "Vlan Group List                   :");

        /* Here, 0x20 refers to white space and it is used to display the
         * vlan list in new line when counter 
         * is reached to max list */

        MEMSET (au1BlankSpace, 0x20,
                MEM_MAX_BYTES (sizeof (au1BlankSpace), STRLEN (pu1FirstLine)));

        au1BlankSpace[MEM_MAX_BYTES
                      (((sizeof (au1BlankSpace)) - 1), STRLEN (pu1FirstLine))] =
            '\0';

        CliPrintf (CliHandle, "%-33s ", pu1FirstLine);

        for (; u2Index <= ERPS_MAX_VLAN_GROUP_LIST * 8; u2Index++)
        {
            /* Scanning the vlan group list bitmap to identify the vlan group id's mapped to
               the ring */
            OSIX_BITLIST_IS_BIT_SET (VlanGroupList.pu1_OctetList, u2Index,
                                     ERPS_MAX_VLAN_GROUP_LIST, bResult);
            if (bResult == OSIX_FALSE)
            {
                /* If the bit is not set, continue */
                continue;
            }
            else
            {
                if (u1Counter == ERPS_MAX_LIST_PER_LINE)
                {
                    CliPrintf (CliHandle, "\r\n");
                    STRNCPY (pu1FirstLine, au1BlankSpace,
                             sizeof (au1FirstLine));
                    pu1FirstLine[sizeof (au1FirstLine) - 1] = '\0';
                    CliPrintf (CliHandle, "%s ", pu1FirstLine);
                    u1Counter = 0;
                }

                /* If the bit is set, print the corresponding vlan group id */
                if (u1Counter == 0)
                {
                    CliPrintf (CliHandle, "%d", u2Index);
                }
                else
                {
                    CliPrintf (CliHandle, ", %d", u2Index);
                }

                u1Counter++;

            }
        }
        CliPrintf (CliHandle, "\r\n");
    }

    CliPrintf (CliHandle, "\r\n\nRing Id %u CFM Configurations\r\n", u4RingId);
    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");
    CliPrintf (CliHandle, "%-33s : %u\r\n", "MEG1", u4RingMEG1);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "ME1", u4RingME1);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "MEP1", u4RingMEP1);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "MEG2", u4RingMEG2);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "ME2", u4RingME2);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "MEP2", u4RingMEP2);

    if (u4RingPwVcId1 != 0)
    {
        CliPrintf (CliHandle, "\r\n\nRing Id %u MPLS PW Configurations\r\n",
                   u4RingId);
        CliPrintf (CliHandle,
                   "---------------------------------------------------------\r\n");
        CliPrintf (CliHandle, "%-33s : %u\r\n", "PWVC-ID1", u4RingPwVcId1);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "PWVC-ID2", u4RingPwVcId2);
    }
    PortSubPortList.pu1_OctetList =
        MemAllocMemBlk (gErpsGlobalInfo.ErpsCliMemblkBufPoolId);

    if (PortSubPortList.pu1_OctetList == NULL)
    {
        return;
    }

    MEMSET (PortSubPortList.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);

    if (SNMP_SUCCESS ==
        nmhGetFsErpsRingPort1SubPortList (u4ContextId, u4RingId,
                                          &PortSubPortList))
    {
        CliPrintf (CliHandle, "Ring Port1 SubPortList\r\n");
        CliPrintf (CliHandle, "----------------------\r\n");
        ErpsCliShowSubPortList (CliHandle, PortSubPortList.pu1_OctetList);
        CliPrintf (CliHandle, "\r\n");
    }

    MEMSET (PortSubPortList.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);
    PortSubPortList.i4_Length = 0;

    if (SNMP_SUCCESS ==
        nmhGetFsErpsRingPort2SubPortList (u4ContextId, u4RingId,
                                          &PortSubPortList))
    {
        CliPrintf (CliHandle, "Ring Port2 SubPortList\r\n");
        CliPrintf (CliHandle, "----------------------\r\n");
        ErpsCliShowSubPortList (CliHandle, PortSubPortList.pu1_OctetList);
        CliPrintf (CliHandle, "\r\n");
    }

    *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");

    MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                        (UINT1 *) PortSubPortList.pu1_OctetList);
    UNUSED_PARAM(i4RingInnerVlanId);
    UNUSED_PARAM(u4RingVsiId);
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowTcListForRing 
 *
 * DESCRIPTION      : This function displays the topology change
 *                    list for a ring 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    
 * OUTPUT           : pi1ModeName - Mode String
 *                    pi1DispStr - Display string
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliShowTcListForRing (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4RingId)
{
    UINT4               u4NextContextId = ERPS_INVALID_CONTEXT_ID;
    UINT4               u4NextRingId = 0;
    UINT4               u4TcId = 0;
    UINT4               u4NextTcProgId = 0;
    UINT1               u1Counter = 0;
    UINT1               u1MaxTCListPerLine = ERPS_MAX_LIST_PER_LINE;
    UINT1              *pu1FirstLine = NULL;
    UINT1               au1FirstLine[ERPS_CLI_DISPLAY_LINE];
    UINT1               au1BlankSpace[CLI_MAX_COLS];

    if (nmhGetNextIndexFsErpsRingTcPropTable (u4ContextId, &u4NextContextId,
                                              u4RingId, &u4NextRingId,
                                              0, &u4NextTcProgId)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    MEMSET (au1FirstLine, 0, ERPS_CLI_DISPLAY_LINE);

    MEMSET (au1BlankSpace, 0, CLI_MAX_COLS);

    pu1FirstLine = au1FirstLine;

    STRCPY (pu1FirstLine, "TC Propagation Ring List          :");

    /* Here, 0x20 refers to white space and it is used to display the
     *  vlan list in new line when counter 
     *  is reached to max list */

    MEMSET (au1BlankSpace, 0x20,
            MEM_MAX_BYTES (sizeof (au1BlankSpace), STRLEN (pu1FirstLine)));

    au1BlankSpace[MEM_MAX_BYTES
                  (((sizeof (au1BlankSpace)) - 1), STRLEN (pu1FirstLine))] =
        '\0';

    CliPrintf (CliHandle, "%-33s ", pu1FirstLine);

    do
    {
        if ((u4ContextId != (UINT4) u4NextContextId) ||
            (u4RingId != u4NextRingId))
        {
            CliPrintf (CliHandle, "None\r");
            break;
        }

        u4TcId = u4NextTcProgId;

        if (u1Counter == u1MaxTCListPerLine)
        {
            CliPrintf (CliHandle, "\r\n");
            STRNCPY (pu1FirstLine, au1BlankSpace, sizeof (au1FirstLine));
            pu1FirstLine[sizeof (au1FirstLine) - 1] = '\0';
            CliPrintf (CliHandle, "%s ", pu1FirstLine);
            u1Counter = 0;
        }
        if (u1Counter == 0)
        {
            CliPrintf (CliHandle, "%u", u4TcId);
        }
        else
        {
            CliPrintf (CliHandle, ", %u", u4TcId);
        }

        u1Counter++;
    }
    while (nmhGetNextIndexFsErpsRingTcPropTable (u4ContextId, &u4NextContextId,
                                                 u4RingId, &u4NextRingId,
                                                 u4TcId, &u4NextTcProgId)
           == SNMP_SUCCESS);

    CliPrintf (CliHandle, "\r\n");

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowRingStatistics 
 *
 * DESCRIPTION      : This function displays the ring statistics.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *
 * OUTPUT           : None 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsCliShowRingStatistics (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4RingId, UINT4 *pu4ShowStatus)
{

    time_t              ltime;
    INT4                i4RingCompatibleVersion = -1;
    UINT4               u4Prt1RapsPduSent = 0;
    UINT4               u4Prt1RapsPduRcvd = 0;
    UINT4               u4Prt1RapsPduDis = 0;
    UINT4               u4Prt1Blk = 0;
    UINT4               u4Prt1UnBlk = 0;
    UINT4               u4Prt1Failed = 0;
    UINT4               u4Prt1Recovered = 0;
    UINT4               u4Prt1VersionDiscard = 0;
    UINT4               u4Prt1RapsNRPduRx = 0;
    UINT4               u4Prt1RapsNRPduTx = 0;
    UINT4               u4Prt1RapsNRRBPduRx = 0;
    UINT4               u4Prt1RapsNRRBPduTx = 0;
    UINT4               u4Prt1RapsSFPduRx = 0;
    UINT4               u4Prt1RapsSFPduTx = 0;
    UINT4               u4Prt1RapsFSPduRx = 0;
    UINT4               u4Prt1RapsFSPduTx = 0;
    UINT4               u4Prt1RapsMSPduRx = 0;
    UINT4               u4Prt1RapsMSPduTx = 0;
    UINT4               u4Prt1RapsEventPduRx = 0;
    UINT4               u4Prt1RapsEventPduTx = 0;
    UINT4               u4Prt2RapsPduSent = 0;
    UINT4               u4Prt2RapsPduRcvd = 0;
    UINT4               u4Prt2RapsPduDis = 0;
    UINT4               u4Prt2Blk = 0;
    UINT4               u4Prt2UnBlk = 0;
    UINT4               u4Prt2Failed = 0;
    UINT4               u4Prt2Recovered = 0;
    UINT4               u4Prt2VersionDiscard = 0;
    UINT4               u4Prt2RapsNRPduRx = 0;
    UINT4               u4Prt2RapsNRPduTx = 0;
    UINT4               u4Prt2RapsNRRBPduRx = 0;
    UINT4               u4Prt2RapsNRRBPduTx = 0;
    UINT4               u4Prt2RapsSFPduRx = 0;
    UINT4               u4Prt2RapsSFPduTx = 0;
    UINT4               u4Prt2RapsFSPduRx = 0;
    UINT4               u4Prt2RapsFSPduTx = 0;
    UINT4               u4Prt2RapsMSPduRx = 0;
    UINT4               u4Prt2RapsMSPduTx = 0;
    UINT4               u4Prt2RapsEventPduRx = 0;
    UINT4               u4Prt2RapsEventPduTx = 0;
    UINT4               u4TrapsPduTx = 0;
    UINT4               u4DistributingPortRxCount = 0;
    UINT4               u4DistributingPortTxCount = 0;
    UINT4               u4Port1DefectEncTime = 0;
    UINT4               u4Port2DefectEncTime = 0;
    UINT4               u4Port1DefectClrTime = 0;
    UINT4               u4Port2DefectClrTime = 0;
    UINT4               u4RplStatusChgTime = 0;
    UINT4               u4RplNbrStatusChgTime = 0;

    /* Get the Ring Port1 Statistics */
    nmhGetFsErpsRingRAPSCompatibleVersion (u4ContextId, u4RingId,
                                           &i4RingCompatibleVersion);
    nmhGetFsErpsRingGeneratedTrapsCount (u4ContextId, u4RingId, &u4TrapsPduTx);
    nmhGetFsErpsRingPort1RapsPduSentCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsPduSent);
    nmhGetFsErpsRingPort1RapsPduRcvdCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsPduRcvd);
    nmhGetFsErpsRingPort1RapsPduDiscardCount (u4ContextId, u4RingId,
                                              &u4Prt1RapsPduDis);
    nmhGetFsErpsRingPort1BlockedCount (u4ContextId, u4RingId, &u4Prt1Blk);
    nmhGetFsErpsRingPort1UnblockedCount (u4ContextId, u4RingId, &u4Prt1UnBlk);
    nmhGetFsErpsRingPort1FailedCount (u4ContextId, u4RingId, &u4Prt1Failed);
    nmhGetFsErpsRingPort1RecoveredCount (u4ContextId, u4RingId,
                                         &u4Prt1Recovered);
    nmhGetFsErpsRingPort1VersionDiscardCount (u4ContextId, u4RingId,
                                              &u4Prt1VersionDiscard);
    nmhGetFsErpsRingPort1RapsNRPduRxCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsNRPduRx);
    nmhGetFsErpsRingPort1RapsNRPduTxCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsNRPduTx);
    nmhGetFsErpsRingPort1RapsNRRBPduRxCount (u4ContextId, u4RingId,
                                             &u4Prt1RapsNRRBPduRx);
    nmhGetFsErpsRingPort1RapsNRRBPduTxCount (u4ContextId, u4RingId,
                                             &u4Prt1RapsNRRBPduTx);
    nmhGetFsErpsRingPort1RapsSFPduRxCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsSFPduRx);
    nmhGetFsErpsRingPort1RapsSFPduTxCount (u4ContextId, u4RingId,
                                           &u4Prt1RapsSFPduTx);
    nmhGetFsErpsRingPort1DefectEncTimeSec (u4ContextId, u4RingId,
                                           &u4Port1DefectEncTime);
    nmhGetFsErpsRingPort2DefectEncTimeSec (u4ContextId, u4RingId,
                                           &u4Port2DefectEncTime);
    nmhGetFsErpsRingPort1DefectClearedTimeSec (u4ContextId, u4RingId,
                                               &u4Port1DefectClrTime);
    nmhGetFsErpsRingPort2DefectClearedTimeSec (u4ContextId, u4RingId,
                                               &u4Port2DefectClrTime);
    nmhGetFsErpsRingRplPortStatChgTimeSec (u4ContextId, u4RingId,
                                           &u4RplStatusChgTime);

    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        nmhGetFsErpsRingPort1RapsFSPduRxCount (u4ContextId, u4RingId,
                                               &u4Prt1RapsFSPduRx);
        nmhGetFsErpsRingPort1RapsFSPduTxCount (u4ContextId, u4RingId,
                                               &u4Prt1RapsFSPduTx);
        nmhGetFsErpsRingPort1RapsMSPduRxCount (u4ContextId, u4RingId,
                                               &u4Prt1RapsMSPduRx);
        nmhGetFsErpsRingPort1RapsMSPduTxCount (u4ContextId, u4RingId,
                                               &u4Prt1RapsMSPduTx);
        nmhGetFsErpsRingRplNbrPortStatChgTime (u4ContextId, u4RingId,
                                               &u4RplNbrStatusChgTime);
    }
    nmhGetFsErpsRingPort1RapsEventPduRxCount (u4ContextId, u4RingId,
                                              &u4Prt1RapsEventPduRx);
    nmhGetFsErpsRingPort1RapsEventPduTxCount (u4ContextId, u4RingId,
                                              &u4Prt1RapsEventPduTx);

    /* Get the Ring Port2 Statistics */

    nmhGetFsErpsRingPort2RapsPduSentCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsPduSent);
    nmhGetFsErpsRingPort2RapsPduRcvdCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsPduRcvd);
    nmhGetFsErpsRingPort2RapsPduDiscardCount (u4ContextId, u4RingId,
                                              &u4Prt2RapsPduDis);
    nmhGetFsErpsRingPort2BlockedCount (u4ContextId, u4RingId, &u4Prt2Blk);
    nmhGetFsErpsRingPort2UnblockedCount (u4ContextId, u4RingId, &u4Prt2UnBlk);
    nmhGetFsErpsRingPort2FailedCount (u4ContextId, u4RingId, &u4Prt2Failed);
    nmhGetFsErpsRingPort2RecoveredCount (u4ContextId, u4RingId,
                                         &u4Prt2Recovered);

    nmhGetFsErpsRingPort2VersionDiscardCount (u4ContextId, u4RingId,
                                              &u4Prt2VersionDiscard);
    nmhGetFsErpsRingPort2RapsNRPduRxCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsNRPduRx);
    nmhGetFsErpsRingPort2RapsNRPduTxCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsNRPduTx);
    nmhGetFsErpsRingPort2RapsNRRBPduRxCount (u4ContextId, u4RingId,
                                             &u4Prt2RapsNRRBPduRx);
    nmhGetFsErpsRingPort2RapsNRRBPduTxCount (u4ContextId, u4RingId,
                                             &u4Prt2RapsNRRBPduTx);
    nmhGetFsErpsRingPort2RapsSFPduRxCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsSFPduRx);
    nmhGetFsErpsRingPort2RapsSFPduTxCount (u4ContextId, u4RingId,
                                           &u4Prt2RapsSFPduTx);
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        nmhGetFsErpsRingPort2RapsFSPduRxCount (u4ContextId, u4RingId,
                                               &u4Prt2RapsFSPduRx);
        nmhGetFsErpsRingPort2RapsFSPduTxCount (u4ContextId, u4RingId,
                                               &u4Prt2RapsFSPduTx);
        nmhGetFsErpsRingPort2RapsMSPduRxCount (u4ContextId, u4RingId,
                                               &u4Prt2RapsMSPduRx);
        nmhGetFsErpsRingPort2RapsMSPduTxCount (u4ContextId, u4RingId,
                                               &u4Prt2RapsMSPduTx);
    }
    nmhGetFsErpsRingPort2RapsEventPduRxCount (u4ContextId, u4RingId,
                                              &u4Prt2RapsEventPduRx);
    nmhGetFsErpsRingPort2RapsEventPduTxCount (u4ContextId, u4RingId,
                                              &u4Prt2RapsEventPduTx);

    /* Common port statistics */
    nmhGetFsErpsRingDistPortPduRxCount (u4ContextId, u4RingId,
                                        &u4DistributingPortRxCount);
    nmhGetFsErpsRingDistPortPduTxCount (u4ContextId, u4RingId,
                                        &u4DistributingPortTxCount);

    CliPrintf (CliHandle, "\r\nRing Id %u Statistics\r\n", u4RingId);
    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");
    /* Print the Port1 Statistics */

    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS Pdu's Sent Count",
               u4Prt1RapsPduSent);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS Pdu's Received Count",
               u4Prt1RapsPduRcvd);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS Pdu's Discarded Count",
               u4Prt1RapsPduDis);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 Blocked Count", u4Prt1Blk);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 un-Blocked Count",
               u4Prt1UnBlk);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 Failed Count", u4Prt1Failed);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 recovered Count",
               u4Prt1Recovered);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 Version Discard Count",
               u4Prt1VersionDiscard);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS NR Pdu's Rx Count",
               u4Prt1RapsNRPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS NR Pdu's Tx Count",
               u4Prt1RapsNRPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS NRRB Pdu's Rx Count",
               u4Prt1RapsNRRBPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS NRRB Pdu's Tx Count",
               u4Prt1RapsNRRBPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS SF Pdu's Rx Count",
               u4Prt1RapsSFPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS SF Pdu's Tx Count",
               u4Prt1RapsSFPduTx);
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS FS Pdu's Rx Count",
                   u4Prt1RapsFSPduRx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS FS Pdu's Tx Count",
                   u4Prt1RapsFSPduTx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS MS Pdu's Rx Count",
                   u4Prt1RapsMSPduRx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS MS Pdu's Tx Count",
                   u4Prt1RapsMSPduTx);
    }
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS Event Pdu's Rx Count",
               u4Prt1RapsEventPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 R-APS Event Pdu's Tx Count",
               u4Prt1RapsEventPduTx);

    /* Print the Port2 Statistics */

    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS Pdu's Sent Count",
               u4Prt2RapsPduSent);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS Pdu's Received Count",
               u4Prt2RapsPduRcvd);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS Pdu's Discarded Count",
               u4Prt2RapsPduDis);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 Blocked Count", u4Prt2Blk);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 un-Blocked Count",
               u4Prt2UnBlk);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 Failed Count", u4Prt2Failed);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 recovered Count",
               u4Prt2Recovered);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 Version Discard Count",
               u4Prt2VersionDiscard);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS NR Pdu's Rx Count",
               u4Prt2RapsNRPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS NR Pdu's Tx Count",
               u4Prt2RapsNRPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS NRRB Pdu's Rx Count",
               u4Prt2RapsNRRBPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS NRRB Pdu's Tx Count",
               u4Prt2RapsNRRBPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS SF Pdu's Rx Count",
               u4Prt2RapsSFPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS SF Pdu's Tx Count",
               u4Prt2RapsSFPduTx);
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS FS Pdu's Rx Count",
                   u4Prt2RapsFSPduRx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS FS Pdu's Tx Count",
                   u4Prt2RapsFSPduTx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS MS Pdu's Rx Count",
                   u4Prt2RapsMSPduRx);
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS MS Pdu's Tx Count",
                   u4Prt2RapsMSPduTx);
    }
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS Event Pdu's Rx Count",
               u4Prt2RapsEventPduRx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 R-APS Event Pdu's Tx Count",
               u4Prt2RapsEventPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Traps Pdu's Tx Count",
               u4TrapsPduTx);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Distributing Port Pdu's Rx Count",
               u4DistributingPortRxCount);
    CliPrintf (CliHandle, "%-33s : %u\r\n", "Distributing Port Pdu's Tx Count",
               u4DistributingPortTxCount);

    if (u4Port1DefectEncTime != 0)
    {
        ltime = (INT4) u4Port1DefectEncTime;

        CliPrintf (CliHandle, "%-33s : %s\r\n", "Port1 Defect Encountered Time",
                   ctime (&ltime));
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n",
                   "Port1 Defect Encountered Time ", u4Port1DefectEncTime);

    }
    if (u4Port1DefectClrTime != 0)
    {

        ltime = (INT4) u4Port1DefectClrTime;

        CliPrintf (CliHandle, "%-33s : %s\r\n", "Port1 Defect Cleared Time",
                   ctime (&ltime));
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port1 Defect Cleared Time",
                   u4Port1DefectClrTime);
    }

    if (u4Port2DefectEncTime != 0)
    {
        ltime = (INT4) u4Port2DefectEncTime;
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Port2 Defect Encountered Time",
                   ctime (&ltime));
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 Defect Encountered Time",
                   u4Port2DefectEncTime);
    }

    if (u4Port2DefectClrTime != 0)
    {
        ltime = (INT4) u4Port2DefectClrTime;
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Port2 Defect Cleared Time",
                   ctime (&ltime));
    }
    else

    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Port2 Defect Cleared Time",
                   u4Port2DefectClrTime);
    }
    if (u4RplStatusChgTime != 0)
    {
        ltime = (INT4) u4RplStatusChgTime;
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Rpl Port status Change Time",
                   ctime (&ltime));
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %u\r\n", "Rpl Port status Change Time",
                   u4RplStatusChgTime);
    }
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        if (u4RplNbrStatusChgTime != 0)
        {
            ltime = (INT4) u4RplNbrStatusChgTime;
            CliPrintf (CliHandle, "%-33s : %s\r\n",
                       "Rpl Neighbour Port status Change Time", ctime (&ltime));
        }
        else
        {
            CliPrintf (CliHandle, "%-33s : %u\r\n",
                       "Rpl Neighbour Port status Change Time",
                       u4RplNbrStatusChgTime);
        }
    }
    *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowRingTimers 
 *
 * DESCRIPTION      : This function displays the Timer values
 *                    configured for the ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *
 * OUTPUT           : None 
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsCliShowRingTimers (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4RingId, UINT4 *pu4ShowStatus)
{

    UINT4               u4HoldOffTime = 0;
    UINT4               u4GuardTime = 0;
    UINT4               u4WTRTime = 0;
    UINT4               u4PeriodicTime = 0;
    UINT4               u4VcPeriodicTime = 0;
    UINT4               u4WTBTime = 0;
    INT4                i4RingCompatibleVersion = -1;

    nmhGetFsErpsRingConfigHoldOffTime (u4ContextId, u4RingId, &u4HoldOffTime);
    nmhGetFsErpsRingConfigGuardTime (u4ContextId, u4RingId, &u4GuardTime);
    nmhGetFsErpsRingConfigWTRTime (u4ContextId, u4RingId, &u4WTRTime);
    nmhGetFsErpsRingConfigPeriodicTime (u4ContextId, u4RingId, &u4PeriodicTime);
    nmhGetFsErpsRingConfigExtVCRecoveryPeriodicTime (u4ContextId, u4RingId,
                                                     &u4VcPeriodicTime);
    nmhGetFsErpsRingConfigWTBTime (u4ContextId, u4RingId, &u4WTBTime);
    nmhGetFsErpsRingRAPSCompatibleVersion (u4ContextId, u4RingId,
                                           &i4RingCompatibleVersion);

    CliPrintf (CliHandle, "\r\nRing Id %u Timers\r\n", u4RingId);
    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");
    CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
               "Periodic Timer Interval", u4PeriodicTime, "milli-seconds");
    CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
               "Hold-Off Timer Interval", u4HoldOffTime, "milli-seconds");
    CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
               "Guard Timer Interval", u4GuardTime, "milli-seconds");
    CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
               "WTR Timer Interval", u4WTRTime, "milli-seconds");

    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
                   "WTB Timer Interval", u4WTBTime, "milli-seconds");
    }
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION1)
    {
        CliPrintf (CliHandle, "%-33s : %-9lu %s\r\n",
                   "Vc Periodic Timer Interval", u4VcPeriodicTime,
                   "milli-seconds");
    }
    *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");

    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowRingInfo
 *
 * DESCRIPTION      : This function displays the configurations, status, 
 *                    statistics, timer info, of the Ring 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId - Ring identifier
 *                    i4ShowCmdType - Various options of display info
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliShowRingInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4RingId, INT4 i4ShowCmdType)
{
    static tErpsRingInfo       RingInfo;
    UINT1               au1ContextName[VCM_ALIAS_MAX_LEN];
    UINT4               u4NextContextId = ERPS_INVALID_CONTEXT_ID;
    UINT4               u4NextRingId = 0;
    UINT4               u4ShowStatus = CLI_SUCCESS;
    INT4                i4ContinueShow = CLI_SUCCESS;
    UINT1               u1IsShowAll = OSIX_TRUE;

    MEMSET (&RingInfo, 0, sizeof (tErpsRingInfo));
    MEMSET (au1ContextName, 0, sizeof (au1ContextName));
    ErpsPortVcmGetAliasName (u4ContextId, au1ContextName);
    CliPrintf (CliHandle, "\r\n\r Switch %s \r\n", au1ContextName);

    if (ErpsUtilIsErpsStarted (u4ContextId) != OSIX_TRUE)
    {
        CliPrintf (CliHandle, "\r\n %%ERPS is ShutDown\r\n");
        return CLI_SUCCESS;
    }

    /* If Ring Id is given then display information for that ring */
    if (u4RingId != 0)
    {
        RingInfo.u4ContextId = u4ContextId;
        RingInfo.u4RingId = u4RingId;

        if (ErpsRingGetNodeFromRingTable (&RingInfo) == NULL)
        {
            return CLI_FAILURE;
        }

        u1IsShowAll = OSIX_FALSE;
        u4NextRingId = u4RingId;
        u4NextContextId = u4ContextId;
    }
    else
    {
        if (nmhGetNextIndexFsErpsRingTable (u4ContextId, &u4NextContextId,
                                            u4RingId, &u4NextRingId)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    do
    {
        if (u4NextContextId != u4ContextId)
        {
            return CLI_SUCCESS;
        }

        u4RingId = u4NextRingId;

        switch (i4ShowCmdType)
        {
            case ERPS_CLI_SHOW_RING_GROUP_CONFIG:

                ErpsCliShowRingConfig (CliHandle, u4ContextId,
                                       u4NextRingId, &u4ShowStatus);
                break;

            case ERPS_CLI_SHOW_RING_GROUP_STATS:

                ErpsCliShowRingStatistics (CliHandle, u4ContextId,
                                           u4NextRingId, &u4ShowStatus);
                break;

            case ERPS_CLI_SHOW_RING_GROUP_TIMER:

                ErpsCliShowRingTimers (CliHandle, u4ContextId,
                                       u4NextRingId, &u4ShowStatus);
                break;

            case ERPS_CLI_SHOW_RING_GROUP_ALL:

                ErpsCliShowAllRingInfo (CliHandle, u4ContextId,
                                        u4NextRingId, &u4ShowStatus);
                break;

            default:
                /* Invalid show command type */
                return CLI_FAILURE;
        }

        i4ContinueShow = u4ShowStatus;

        if (u1IsShowAll == OSIX_FALSE)
        {
            break;
        }
    }
    while ((nmhGetNextIndexFsErpsRingTable (u4ContextId, &u4NextContextId,
                                            u4RingId, &u4NextRingId) ==
            SNMP_SUCCESS) && (i4ContinueShow != CLI_FAILURE));

    CliPrintf (CliHandle, "\r\n");

    return CLI_SUCCESS;
}

/******************************************************************************
 * FUNCTION NAME    :  ErpsCliClearRingStats
 *
 * DESCRIPTION      : This function clear the Stats of the 
 *                    Ring
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId - Ring identifier
 *
 * OUTPUT           : None
 * 
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 ******************************************************************************/
INT4
ErpsCliClearRingStats (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId)
{
    UINT4               u4NextContextId = u4ContextId;
    UINT4               u4NextRingId = u4RingId;
    UINT4               u4ErrorCode = 0;
    UINT1               u1IsForSingle = OSIX_FALSE;
    INT4                i4RowStatus = 0;

    UNUSED_PARAM (CliHandle);

    /* If Ring Identifier is given, then get that ring */
    if (u4RingId != 0)
    {
        if (nmhGetFsErpsRingRowStatus (u4ContextId, u4RingId, &i4RowStatus)
            == SNMP_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Ring Entry is not present\r\n");
            return CLI_FAILURE;
        }
        u1IsForSingle = OSIX_TRUE;
    }
    else
    {
        if (nmhGetNextIndexFsErpsRingTable (u4ContextId, &u4NextContextId,
                                            u4RingId, &u4NextRingId)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }

    do
    {
        if (u4NextContextId != u4ContextId)
        {
            return CLI_SUCCESS;
        }

        if (nmhTestv2FsErpsRingClearRingStats (&u4ErrorCode, u4ContextId,
                                               u4NextRingId, ERPS_SNMP_TRUE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingClearRingStats (u4ContextId, u4NextRingId,
                                            ERPS_SNMP_TRUE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        u4RingId = u4NextRingId;
    }
    while ((nmhGetNextIndexFsErpsRingTable (u4ContextId, &u4NextContextId,
                                            u4RingId, &u4NextRingId) ==
            SNMP_SUCCESS) && (u1IsForSingle == OSIX_FALSE));

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowAllRingInfo 
 *
 * DESCRIPTION      : This function displays all the information relating to 
 *                    a Ring.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4NextRingId - Ring Identifier
 *                    *pu4ShowStatus - Display status
 *
 * OUTPUT           : pu4PagingStatus - Paging Status 
 * 
 * RETURNS          : VOID
 * 
 **************************************************************************/
VOID
ErpsCliShowAllRingInfo (tCliHandle CliHandle,
                        UINT4 u4ContextId, UINT4 u4NextRingId,
                        UINT4 *pu4ShowStatus)
{
    tErpsRingInfo      *pRingInfo = NULL;
    tSNMP_OCTET_STRING_TYPE RingName;
    tMacAddr            Port1LastRcvdRapsSrcMac;
    tMacAddr            Port2LastRcvdRapsSrcMac;
    UINT1               au1RingName[ERPS_MAX_NAME_LENGTH];
    INT1                ai1IfNamePort[CFA_MAX_PORT_NAME_LENGTH];
    UINT1               au1MacStr[ERPS_CLI_MAX_MAC_STRING_SIZE];
    UINT4               u4RemainingTime = 0;
    INT4                i4RingRowStatus = -1;
    INT4                i4RingSemState = -1;
    INT4                i4RingVlanId = -1;
    UINT4                u4RingVsiId = -1;
    INT4                i4RingInnerVlanId = -1;
    INT4                i4RingPort1 = -1;
    INT4                i4RingPort2 = -1;
    INT4                i4RplPort = -1;
    INT4                i4RplNeighbourPort = -1;
    INT4                i4RplNextNeighbourPort = -1;
    INT4                i4DistributingPort = -1;
    INT4                i4RingOperatingMode = -1;
    INT4                i4RingRecoveryMethod = -1;
    INT4                i4RingMonitorMech = -1;
    INT4                i4SwitchPort = -1;
    INT4                i4SwitchCmd = -1;
    INT4                i4PropagateTC = -1;
    INT4                i4WithoutVC = -1;
    INT4                i4RingPort1Status = -1;
    INT4                i4RingPort2Status = -1;
    INT4                i4RingNodeStatus = -1;
    INT4                i4BlockingStatus = -1;
    INT4                i4RingCompatibleVersion = -1;
    INT4                i4RingConfigInterConnNode = -1;
    INT4                i4RingConfigMultipleFailure = -1;
    INT4                i4Port1LastRcvdRapsBprBitVal = 0;
    INT4                i4Port2LastRcvdRapsBprBitVal = 0;
    INT4                i4RetValFsErpsRingIsPort1Present = 0;
    INT4                i4RetValFsErpsRingIsPort2Present = 0;
    INT4                i4MonitoringMechanism = -1;
    tSNMP_OCTET_STRING_TYPE PortSubPortList;

    MEMSET (&PortSubPortList, 0, sizeof (tSNMP_OCTET_STRING_TYPE));

    MEMSET (au1RingName, 0, sizeof (au1RingName));
    MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));

    RingName.pu1_OctetList = au1RingName;
    RingName.i4_Length = STRLEN (au1RingName);

    nmhGetFsErpsRingName (u4ContextId, u4NextRingId, &RingName);
    nmhGetFsErpsRingVlanId (u4ContextId, u4NextRingId, &i4RingVlanId);
#ifdef VSI_WANTED
    nmhGetFsErpsRingVsiId (u4ContextId ,u4NextRingId , &u4RingVsiId);
#endif
    nmhGetFsErpsRingPort1 (u4ContextId, u4NextRingId, &i4RingPort1);
    nmhGetFsErpsRingPort2 (u4ContextId, u4NextRingId, &i4RingPort2);
    nmhGetFsErpsRingRplPort (u4ContextId, u4NextRingId, &i4RplPort);
    nmhGetFsErpsRingOperatingMode (u4ContextId, u4NextRingId,
                                   &i4RingOperatingMode);
    nmhGetFsErpsRingConfigRecoveryMethod (u4ContextId, u4NextRingId,
                                          &i4RingRecoveryMethod);
    nmhGetFsErpsRingSemState (u4ContextId, u4NextRingId, &i4RingSemState);
    nmhGetFsErpsRingMonitorMechanism (u4ContextId, u4NextRingId,
                                      &i4RingMonitorMech);
    nmhGetFsErpsRingConfigSwitchPort (u4ContextId, u4NextRingId, &i4SwitchPort);
    nmhGetFsErpsRingConfigSwitchCmd (u4ContextId, u4NextRingId, &i4SwitchCmd);
    nmhGetFsErpsRingConfigPropagateTC (u4ContextId, u4NextRingId,
                                       &i4PropagateTC);
    nmhGetFsErpsRingRAPSSubRingWithoutVC (u4ContextId, u4NextRingId,
                                          &i4WithoutVC);
    nmhGetFsErpsRingPort1Status (u4ContextId, u4NextRingId, &i4RingPort1Status);
    nmhGetFsErpsRingPort2Status (u4ContextId, u4NextRingId, &i4RingPort2Status);
    nmhGetFsErpsRingNodeStatus (u4ContextId, u4NextRingId, &i4RingNodeStatus);
    nmhGetFsErpsRingPortBlockingOnVcRecovery (u4ContextId, u4NextRingId,
                                              &i4BlockingStatus);
    nmhGetFsErpsRingRowStatus (u4ContextId, u4NextRingId, &i4RingRowStatus);
    nmhGetFsErpsRingRAPSCompatibleVersion (u4ContextId, u4NextRingId,
                                           &i4RingCompatibleVersion);
    nmhGetFsErpsRingConfigIsPort1Present (u4ContextId, u4NextRingId,
                                          &i4RetValFsErpsRingIsPort1Present);
    nmhGetFsErpsRingConfigIsPort2Present (u4ContextId, u4NextRingId,
                                          &i4RetValFsErpsRingIsPort2Present);
    nmhGetFsErpsRingMonitorMechanism (u4ContextId, u4NextRingId,
                                      &i4MonitoringMechanism);

    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        nmhGetFsErpsRingRplNeighbourPort (u4ContextId, u4NextRingId,
                                          &i4RplNeighbourPort);
        nmhGetFsErpsRingRplNextNeighbourPort (u4ContextId, u4NextRingId,
                                              &i4RplNextNeighbourPort);
        nmhGetFsErpsRingPort1NodeID (u4ContextId, u4NextRingId,
                                     &Port1LastRcvdRapsSrcMac);
        nmhGetFsErpsRingPort2NodeID (u4ContextId, u4NextRingId,
                                     &Port2LastRcvdRapsSrcMac);
        nmhGetFsErpsRingPort1BPRBitVal (u4ContextId, u4NextRingId,
                                        &i4Port1LastRcvdRapsBprBitVal);
        nmhGetFsErpsRingPort2BPRBitVal (u4ContextId, u4NextRingId,
                                        &i4Port2LastRcvdRapsBprBitVal);
        nmhGetFsErpsRingConfigInterConnNode (u4ContextId, u4NextRingId,
                                             &i4RingConfigInterConnNode);
        nmhGetFsErpsRingConfigMultipleFailure (u4ContextId, u4NextRingId,
                                               &i4RingConfigMultipleFailure);
    }

    nmhGetFsErpsRingConfigInfoDistributingPort (u4ContextId, u4NextRingId,
                                                &i4DistributingPort);

    CliPrintf (CliHandle, "\r\nRing Id %u \r\n", u4NextRingId);

    CliPrintf (CliHandle,
               "---------------------------------------------------------\r\n");

    CliPrintf (CliHandle, "%-33s : %s\r\n", "Ring Name",
               RingName.pu1_OctetList);
    if (i4RingVlanId != 0)
    {
        CliPrintf (CliHandle, "%-33s : %d\r\n", "RAPS Vlan Id", i4RingVlanId);
    }

    if (i4RingOperatingMode == ERPS_RING_REVERTIVE_MODE)
    {
        CliPrintf (CliHandle, "%-33s : Revertive\r\n", "Operating Mode");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : Non-Revertive\r\n", "Operating Mode");
    }

    if (i4RingRecoveryMethod == ERPS_RING_MANUAL_RECOVERY)
    {
        CliPrintf (CliHandle, "%-33s : Manual\r\n", "Recovery Method");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : Auto\r\n", "Recovery Method");
    }
    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION1)
    {
        CliPrintf (CliHandle, "%-33s : Version1\r\n",
                   "ERPS Compatible Version");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : Version2\r\n",
                   "ERPS Compatible Version");
    }

    /* Display the ring state machine info */

    switch (i4RingSemState)
    {
        case ERPS_RING_DISABLED_STATE:
            CliPrintf (CliHandle, "%-33s : Disabled \r\n", "Ring State");
            break;
        case ERPS_RING_IDLE_STATE:
            CliPrintf (CliHandle, "%-33s : Idle \r\n", "Ring State");
            break;
        case ERPS_RING_PROTECTION_STATE:
            CliPrintf (CliHandle, "%-33s : Protection \r\n", "Ring State");
            break;
        case ERPS_RING_PENDING_STATE:
            CliPrintf (CliHandle, "%-33s : Pending \r\n", "Ring State");
            break;
        case ERPS_RING_FORCED_SWITCH_STATE:
            CliPrintf (CliHandle, "%-33s : Forced Switch \r\n", "Ring State");
            break;
        case ERPS_RING_MANUAL_SWITCH_STATE:
            CliPrintf (CliHandle, "%-33s : Manual Switch \r\n", "Ring State");
            break;
    }

    /* Display the ring status */
    if (i4RingRowStatus == ACTIVE)
    {
        CliPrintf (CliHandle, "%-33s : Active \r\n", "Status");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : In-Active \r\n", "Status");
    }

    pRingInfo = ErpsRingGetRingEntry (u4ContextId, u4NextRingId);

    if (pRingInfo == NULL)
    {
        return;
    }
    if (i4RingNodeStatus & ERPS_WTR_TIMER_RUNNING)
    {
        TmrGetRemainingTime (gErpsGlobalInfo.RingTimerListId,
                             &pRingInfo->WaitToRestoreTimer.TimerNode,
                             &u4RemainingTime);
        u4RemainingTime = ERPS_CONVERT_TIME_TICKS_TO_MSEC (u4RemainingTime);

        CliPrintf (CliHandle, "%-33s : %s (Remaining Time: %u ms)\r\n",
                   "Wait-to-restore timer", "Running", u4RemainingTime);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Wait-to-restore timer",
                   "Not Running");
    }

    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        if (i4RingNodeStatus & ERPS_WTB_TIMER_RUNNING)
        {
            TmrGetRemainingTime (gErpsGlobalInfo.RingTimerListId,
                                 &pRingInfo->WaitToBlockTimer.TimerNode,
                                 &u4RemainingTime);
            u4RemainingTime = ERPS_CONVERT_TIME_TICKS_TO_MSEC (u4RemainingTime);

            CliPrintf (CliHandle, "%-33s : %s (Remaining Time: %u ms)\r\n",
                       "Wait-to-block timer", "Running", u4RemainingTime);
        }
        else
        {
            CliPrintf (CliHandle, "%-33s : %s\r\n", "Wait-to-block timer",
                       "Not Running");
        }
    }

    if (i4RingNodeStatus & ERPS_HOLDOFF_TIMER_RUNNING)
    {
        TmrGetRemainingTime (gErpsGlobalInfo.RingTimerListId,
                             &pRingInfo->HoldOffTimer.TimerNode,
                             &u4RemainingTime);
        u4RemainingTime = ERPS_CONVERT_TIME_TICKS_TO_MSEC (u4RemainingTime);

        CliPrintf (CliHandle, "%-33s : %s (Remaining Time: %u ms)\r\n",
                   "Hold timer", "Running", u4RemainingTime);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Hold timer", "Not Running");
    }

    if (i4RingNodeStatus & ERPS_GUARD_TIMER_RUNNING)
    {
        TmrGetRemainingTime (gErpsGlobalInfo.RingTimerListId,
                             &pRingInfo->GuardTimer.TimerNode,
                             &u4RemainingTime);
        u4RemainingTime = ERPS_CONVERT_TIME_TICKS_TO_MSEC (u4RemainingTime);

        CliPrintf (CliHandle, "%-33s : %s (Remaining Time: %u ms)\r\n",
                   "Guard timer", "Running", u4RemainingTime);
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : %s\r\n", "Guard timer", "Not Running");
    }

    if (i4RingPort2 == 0)
    {
        if (i4BlockingStatus == ERPS_SNMP_TRUE)
        {
            CliPrintf (CliHandle, "%-33s : Allowed\r\n",
                       "Port blocking on VC recovery");
        }
        else
        {
            CliPrintf (CliHandle, "%-33s : Not-Allowed\r\n",
                       "Port blocking on VC recovery");
        }
    }

    if (i4PropagateTC == OSIX_ENABLED)
    {
        CliPrintf (CliHandle, "%-33s : Enable\r\n", "TC Propagation Status");
    }
    else
    {
        CliPrintf (CliHandle, "%-33s : Disable\r\n", "TC Propagation Status");
    }

    if (ErpsCliShowTcListForRing (CliHandle, u4ContextId, u4NextRingId)
        == CLI_FAILURE)
    {
        CliPrintf (CliHandle, "%-33s : None\r\n", "TC Propagation Ring List");
    }

    if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        /* InterConnNode and MultipleFailure objects are displayed only when
         * they are set to either Primary or Secondary.*/
        switch (i4RingConfigInterConnNode)
        {
            case ERPS_RING_INTER_CONN_NODE_PRIMARY:
                CliPrintf (CliHandle, "%-33s : Primary\r\n",
                           "Inter Connection Node");
                break;
            case ERPS_RING_INTER_CONN_NODE_SECONDARY:
                CliPrintf (CliHandle, "%-33s : Secondary\r\n",
                           "Inter Connection Node");
                break;
            case ERPS_RING_INTER_CONN_NODE_NONE:
                CliPrintf (CliHandle, "%-33s : none\r\n",
                           "Inter Connection Node");
                break;
            default:
                break;
        }

        switch (i4RingConfigMultipleFailure)
        {
            case ERPS_RING_MULTIPLE_FAILURE_PRIMARY:
                CliPrintf (CliHandle, "%-33s : Primary\r\n",
                           "Multiple Failure");
                break;
            case ERPS_RING_MULTIPLE_FAILURE_SECONDARY:
                CliPrintf (CliHandle, "%-33s : Secondary\r\n",
                           "Multiple Failure");
                break;
            case ERPS_RING_MULTIPLE_FAILURE_DISABLED:
                CliPrintf (CliHandle, "%-33s : Disabled\r\n",
                           "Multiple Failure");
                break;
            default:
                break;
        }

        if (i4MonitoringMechanism == ERPS_MONITOR_MECH_CFM)
        {
            CliPrintf (CliHandle, "%-33s : Cfm\r\n", "Monitoring Mechanism");
        }
        else
        {
            CliPrintf (CliHandle, "%-33s : MPLS Oam\r\n",
                       "Monitoring Mechanism");
        }

        CliPrintf (CliHandle, "\r\n\r\nNode ID, BPR bit Pair \r\n%s\r\n",
                   "=====================");
        MEMSET (au1MacStr, 0, sizeof (au1MacStr));
        PrintMacAddress ((UINT1 *) &Port1LastRcvdRapsSrcMac, au1MacStr);
        CliPrintf (CliHandle, "Ring Port 1 - ");
        CliPrintf (CliHandle, "(%s, %u)\r\n",
                   au1MacStr, i4Port1LastRcvdRapsBprBitVal);

        MEMSET (au1MacStr, 0, sizeof (au1MacStr));
        PrintMacAddress ((UINT1 *) &Port2LastRcvdRapsSrcMac, au1MacStr);
        CliPrintf (CliHandle, "Ring Port 2 - ");
        CliPrintf (CliHandle, "(%s, %u)\r\n",
                   au1MacStr, i4Port2LastRcvdRapsBprBitVal);
    }

    CliPrintf (CliHandle, "\r\n\r\n");
    MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));

    if (i4RplPort != 0)
    {
        CfaCliGetIfName ((UINT4) i4RplPort, ai1IfNamePort);
        CliPrintf (CliHandle, "This node is RPL Owner. RPL Port is %s\r\n\r\n",
                   ai1IfNamePort);
    }
    else if (i4RingCompatibleVersion == ERPS_RING_COMPATIBLE_VERSION2)
    {
        if (i4RplNeighbourPort != 0)
        {
            CfaCliGetIfName ((UINT4) i4RplNeighbourPort, ai1IfNamePort);
            CliPrintf (CliHandle,
                       "This node is RPL Neighbour. RPL Neighbour port is %s\r\n\r\n",
                       ai1IfNamePort);
        }
        else if (i4RplNextNeighbourPort != 0)
        {
            CfaCliGetIfName ((UINT4) i4RplNextNeighbourPort, ai1IfNamePort);
            CliPrintf (CliHandle,
                       "This node is RPL Next Neighbour. RPL Next Neighbour port is %s\r\n\r\n",
                       ai1IfNamePort);
        }
    }

    if (i4WithoutVC == OSIX_ENABLED)
    {
        CliPrintf (CliHandle,
                   "Ring node is configured without virtual channel\r\n\r\n");
    }
    else
    {
        CliPrintf (CliHandle,
                   "Ring node is configured with virtual channel\r\n\r\n");
    }

    if ((i4RingPort1 != 0) || (i4RingPort2 != 0))
    {

        /* Display the status of ring port1 ,ring port2 , RPL Port */
        CliPrintf (CliHandle, "%-19s%-17s%-15s%-15s\r\n",
                   " Ring Port", "Link Status", "Command", "Port Status");
        *pu4ShowStatus =
            CliPrintf (CliHandle,
                       "----------------------------------"
                       "-------------------------------\r\n");
    }

    if (i4RingPort1 != 0)
    {
        MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
        CfaCliGetIfName ((UINT4) i4RingPort1, ai1IfNamePort);
        CliPrintf (CliHandle, " %-18s", ai1IfNamePort);

        if (i4RingNodeStatus & ERPS_NODE_STATUS_PORT1_LOCAL_SF)
        {
            CliPrintf (CliHandle, "%-18s", "Failed");
        }
        else if (i4RingNodeStatus & ERPS_NODE_STATUS_PORT1_RAPS_SF)
        {
            CliPrintf (CliHandle, "%-18s", "Remote Failure");
        }
        else
        {
            CliPrintf (CliHandle, "%-18s", "Not Failed");
        }

        if (i4RingPort1 == i4SwitchPort)
        {
            switch (i4SwitchCmd)
            {
                case ERPS_SWITCH_COMMAND_FORCE:
                    CliPrintf (CliHandle, "%-15s", "Force Switch");
                    break;
                case ERPS_SWITCH_COMMAND_MANUAL:
                    CliPrintf (CliHandle, "%-15s", "Manual Switch");
                    break;
                case ERPS_SWITCH_COMMAND_NONE:
                    CliPrintf (CliHandle, "%-15s", "None");
                    break;
            }
        }
        else
        {
            CliPrintf (CliHandle, "%-15s", "None");
        }

        if (i4RingPort1Status == ERPS_SNMP_PORT_BLOCK)
        {
            CliPrintf (CliHandle, "%-15s", "Blocked");
        }
        else
        {
            CliPrintf (CliHandle, "%-15s", "UnBlocked");
        }

        *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");
    }

    if ((i4RingPort2 != 0) || ((i4RingRowStatus == ACTIVE) &&
                               (i4RingPort2 == 0) &&
                               (i4WithoutVC == OSIX_DISABLED)))
    {
        if (i4RingPort2 != 0)
        {
            MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
            CfaCliGetIfName ((UINT4) i4RingPort2, ai1IfNamePort);
            CliPrintf (CliHandle, " %-18s", ai1IfNamePort);
        }
        else
        {
            CliPrintf (CliHandle, " %-18s", "Virtual Channel");
        }

        if (i4RingNodeStatus & ERPS_NODE_STATUS_PORT2_LOCAL_SF)
        {
            CliPrintf (CliHandle, "%-18s", "Failed");
        }
        else if (i4RingNodeStatus & ERPS_NODE_STATUS_PORT2_RAPS_SF)
        {
            CliPrintf (CliHandle, "%-18s", "Remote Failure");
        }
        else
        {
            CliPrintf (CliHandle, "%-18s", "Not Failed");
        }

        if ((i4RingPort2 != 0) && (i4RingPort2 == i4SwitchPort))
        {
            switch (i4SwitchCmd)
            {
                case ERPS_SWITCH_COMMAND_FORCE:
                    CliPrintf (CliHandle, "%-15s", "Force Switch");
                    break;
                case ERPS_SWITCH_COMMAND_MANUAL:
                    CliPrintf (CliHandle, "%-15s", "Manual Switch");
                    break;
                case ERPS_SWITCH_COMMAND_NONE:
                    CliPrintf (CliHandle, "%-15s", "None");
                    break;
            }
        }
        else
        {
            CliPrintf (CliHandle, "%-15s", "None");
        }

        if (i4RingPort2 != 0)
        {
            if (i4RingPort2Status == ERPS_SNMP_PORT_BLOCK)
            {
                CliPrintf (CliHandle, "%-15s", "Blocked");
            }
            else
            {
                CliPrintf (CliHandle, "%-15s", "UnBlocked");
            }
        }
        else
        {
            CliPrintf (CliHandle, "%-15s", "   -   ");
        }

        *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");

    }

    /* Display the Line card information */
    CliPrintf (CliHandle, "\r\n%-19s\r\n", "Line Card Information");
    *pu4ShowStatus = CliPrintf (CliHandle, "-----------------------\r\n");
    if (i4RingPort1 != 0)
    {
        MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
        CfaCliGetIfName ((UINT4) i4RingPort1, ai1IfNamePort);

        if (i4RetValFsErpsRingIsPort1Present == ERPS_PORT_IN_LOCAL_LINE_CARD)
        {
            CliPrintf (CliHandle, "Ring Port 1 (%s): %-15s", ai1IfNamePort,
                       "Local");
        }
        else
        {
            CliPrintf (CliHandle, "Ring Port 1 (%s): %-15s", ai1IfNamePort,
                       "Remote");
        }
        *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");
    }

    if (i4RingPort2 != 0)
    {
        MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
        CfaCliGetIfName ((UINT4) i4RingPort2, ai1IfNamePort);
        if (i4RetValFsErpsRingIsPort2Present == ERPS_PORT_IN_LOCAL_LINE_CARD)
        {
            CliPrintf (CliHandle, "Ring Port 2 (%s): %-15s\r\n", ai1IfNamePort,
                       "Local");
        }
        else
        {
            CliPrintf (CliHandle, "Ring Port 2 (%s): %-15s\r\n", ai1IfNamePort,
                       "Remote");
        }
    }
    MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
    if (i4DistributingPort != 0)
    {
        CfaCliGetIfName ((UINT4) i4DistributingPort, ai1IfNamePort);
        CliPrintf (CliHandle, "Distributing Port: %-15s\r\n", ai1IfNamePort);
    }

    *pu4ShowStatus = CliPrintf (CliHandle, "\r\n");

    PortSubPortList.pu1_OctetList =
        MemAllocMemBlk (gErpsGlobalInfo.ErpsCliMemblkBufPoolId);
    if (PortSubPortList.pu1_OctetList == NULL)
    {
        return;
    }

    MEMSET (PortSubPortList.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);
    if (SNMP_SUCCESS ==
        nmhGetFsErpsRingPort1SubPortList (u4ContextId, u4NextRingId,
                                          &PortSubPortList))
    {
        CliPrintf (CliHandle, "Ring Port1 SubPortList\r\n");
        CliPrintf (CliHandle, "----------------------\r\n");
        ErpsCliShowSubPortList (CliHandle, PortSubPortList.pu1_OctetList);
        CliPrintf (CliHandle, "\r\n");
    }

    MEMSET (PortSubPortList.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN);
    PortSubPortList.i4_Length = 0;

    if (SNMP_SUCCESS ==
        nmhGetFsErpsRingPort2SubPortList (u4ContextId, u4NextRingId,
                                          &PortSubPortList))
    {
        CliPrintf (CliHandle, "Ring Port2 SubPortList\r\n");
        CliPrintf (CliHandle, "----------------------\r\n");
        ErpsCliShowSubPortList (CliHandle, PortSubPortList.pu1_OctetList);
        CliPrintf (CliHandle, "\r\n");
    }

    MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                        (UINT1 *) PortSubPortList.pu1_OctetList);
#ifdef VSI_WANTED
    /* Display the DATA-VEP List */
    if (TMO_SLL_Count (&(pRingInfo->RingDataVepList)) != 0)
    {
	ErpsCliShowDataVepList (CliHandle, &(pRingInfo->RingDataVepList));
	CliPrintf (CliHandle, "\r\n");
    }
#endif
    UNUSED_PARAM(u4RingVsiId);
    UNUSED_PARAM(i4RingInnerVlanId);
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigRingRowStatus
 *
 * DESCRIPTION      : This function used to configure the RowStatus of a ring.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u1RowStatus - Row status of the ring
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigRingRowStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4RingId, UINT1 u1RowStatus)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingRowStatus (&u4ErrCode, u4ContextId,
                                      u4RingId, u1RowStatus) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingRowStatus (u4ContextId, u4RingId, u1RowStatus)
        == SNMP_FAILURE)
    {
        ISSCliCheckAndThrowFatalError (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfPortBlockOnVcRecovery
 *
 * DESCRIPTION      : This function used to enable blocking a interconnected  
 *                    ring port, in case of virtual channel recovery.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u1RowStatus - Row status of the ring
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfPortBlockOnVcRecovery (tCliHandle CliHandle,
                                  UINT4 u4ContextId,
                                  UINT4 u4RingId, UINT1 u1PortBlockStatus)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingPortBlockingOnVcRecovery (&u4ErrCode,
                                                     u4ContextId,
                                                     u4RingId,
                                                     u1PortBlockStatus)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingPortBlockingOnVcRecovery (u4ContextId,
                                                  u4RingId,
                                                  u1PortBlockStatus)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliCfgVlanGroupManager
 *
 * DESCRIPTION      : This function  identifies the module that manages the 
 *                    grouping of vlans in a context.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    i4VlanGroupManager - Module Name ( ERPS/ MSTP)
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliCfgVlanGroupManager (tCliHandle CliHandle, UINT4 u4ContextId,
                            INT4 i4VlanGroupManager)
{
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    if (nmhTestv2FsErpsCtxtVlanGroupManager (&u4ErrorCode,
                                             u4ContextId,
                                             i4VlanGroupManager)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsCtxtVlanGroupManager (u4ContextId,
                                          i4VlanGroupManager) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliCfgProtectionType
 *
 * DESCRIPTION      : This function type of protection being provided by the 
 *                    ring group.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                  : u4RingId         - Ring Identifier
 *                    i4ProtectionType - Type of protection(port/service)
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliCfgProtectionType (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4RingId, INT4 i4ProtectionType)
{
    UINT4               u4ErrorCode = 0;
    INT4                i4CurrProtectionType = -1;
    UNUSED_PARAM (CliHandle);

    if (nmhGetFsErpsRingProtectionType (u4ContextId, u4RingId,
                                        &i4CurrProtectionType) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    /* Set the protection type to service-based/ port-based */
    if (i4CurrProtectionType != i4ProtectionType)
    {
        if (nmhTestv2FsErpsRingProtectionType (&u4ErrorCode, u4ContextId,
                                               u4RingId, i4ProtectionType)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsErpsRingProtectionType (u4ContextId, u4RingId,
                                            i4ProtectionType) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliMapVlanGroupId
 *
 * DESCRIPTION      : This function identifies the vlan group associated with 
 *                    the ring instance.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4GroupId   - Vlan Group Id
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliMapVlanGroupId (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4RingId, INT4 i4GroupId)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingProtectedVlanGroupId (&u4ErrCode,
                                                 u4ContextId,
                                                 u4RingId,
                                                 i4GroupId) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingProtectedVlanGroupId (u4ContextId,
                                              u4RingId,
                                              i4GroupId) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliMapVlanGroupList
 *
 * DESCRIPTION      : This function identifies the list of vlan groups 
 *                      associated with the ring instance.
 *
 * INPUT            : CliHandle   - Handle to the CLI
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4GroupId   - Vlan Group Id
 *
 * OUTPUT           : None.
 *
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 *
 **************************************************************************/
INT4
ErpsCliMapVlanGroupList (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4RingId, UINT1 *pu1VlanList)
{
    tSNMP_OCTET_STRING_TYPE VlanGroupList;
    UINT4               u4ErrCode = 0;

    MEMSET (&VlanGroupList, 0, sizeof (tSNMP_OCTET_STRING_TYPE));

    VlanGroupList.pu1_OctetList = &pu1VlanList[0];
    VlanGroupList.i4_Length = ERPS_MAX_VLAN_GROUP_LIST;

    MEMCPY (VlanGroupList.pu1_OctetList, pu1VlanList, ERPS_MAX_VLAN_GROUP_LIST);

    if (nmhTestv2FsErpsRingProtectedVlanGroupList (&u4ErrCode, u4ContextId,
                                                   u4RingId, &VlanGroupList)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingProtectedVlanGroupList
        (u4ContextId, u4RingId, &VlanGroupList) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliMapMacId
 *
 * DESCRIPTION      : This function associates the mac id  with the ring.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    i4MacId   - MAC Id
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliMapMacId (tCliHandle CliHandle, UINT4 u4ContextId,
                 UINT4 u4RingId, INT4 i4MacId)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingMacId (&u4ErrCode, u4ContextId,
                                  u4RingId, i4MacId) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingMacId (u4ContextId, u4RingId, i4MacId) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliAddVlanList
 *
 * DESCRIPTION      : This function maps a list of vlans to a vlan group 
 *                    in the vlan group table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    i4VlanGroupId    - VlanGroup Id
 *                    pu1VlanList - List of protected VLAN's.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliAddVlanList (tCliHandle CliHandle, UINT4 u4ContextId,
                    INT4 i4VlanGroupId, UINT1 *pu1VlanList)
{
    UINT4               u4ErrorCode = 0;
    INT4                i4VlanGroupRowStat = 0;
    INT4                i4VlanId = 0;
    UINT2               u2ByteIndex = 0;
    UINT2               u2BitIndex = 0;
    UINT2               u2VlanFlag = 0;
    UNUSED_PARAM (CliHandle);

    /* Configure the VLAN list entries only if they are given as input
     * by user.
     * If no VLAN list is given return success */
    if (pu1VlanList != NULL)
    {

        /* Test each and every VLAN list value.Only if test is success, 
         * configure the new values */

        for (u2ByteIndex = 0; u2ByteIndex < VLAN_LIST_SIZE_EXT; u2ByteIndex++)
        {
            if (pu1VlanList[u2ByteIndex] != 0)
            {
                u2VlanFlag = pu1VlanList[u2ByteIndex];

                for (u2BitIndex = 0;
                     (u2BitIndex < BITS_PER_BYTE && u2VlanFlag != 0);
                     u2BitIndex++)
                {
                    if ((u2VlanFlag & VLAN_BIT8) != 0)
                    {
                        i4VlanId =
                            (UINT2) ((u2ByteIndex * BITS_PER_BYTE) +
                                     u2BitIndex + 1);

                        if (VLAN_IS_VLAN_ID_VALID (i4VlanId) == OSIX_FALSE)
                        {
                            u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                            continue;
                        }

                        /* This check is to ensure that invalid vlan ids are not 
                         * populated.*/
                        if (nmhTestv2FsErpsVlanGroupRowStatus
                            (&u4ErrorCode, u4ContextId, i4VlanId, i4VlanGroupId,
                             CREATE_AND_GO) == SNMP_FAILURE)
                        {
                            if ((u4ErrorCode == SNMP_ERR_NO_CREATION) ||
                                (u4ErrorCode == SNMP_ERR_INCONSISTENT_VALUE))
                            {
                                /* If any vlan which is not already created is 
                                 * tried to map to the ring group CLI error is 
                                 * thrown. Error code SNMP_ERR_NO_CREATION 
                                 * is validated to ensure the failure of the 
                                 * test routine */
                                /* If RAPS vlan is tried to associate to 
                                 * vlan group instance when ring row status is in 
                                 * Active then CLI error is thrown. Error code 
                                 * SNMP_ERR_INCONSISTENT_VALUE is validated.*/

                                return CLI_FAILURE;
                            }

                            if (u4ErrorCode == SNMP_ERR_WRONG_VALUE)
                            {
                                /*  The vlan list contains a vlan id 
                                 * (i4VlanGroupId) which exceeds the MAX or MIN 
                                 * vlan group configured for the system. In this 
                                 * case failure must be returned. To ensure that 
                                 * the test routine fails because of this
                                 * condition, the error code (SNMP_ERR_WRONG_VALUE)
                                 * is also validated.
                                 */

                                CLI_SET_ERR (CLI_ERPS_CONTEXT_NOT_PRESENT);
                                return CLI_FAILURE;
                            }
                            /* In case, the new Vlan list contains a VlanId 
                             * that is already given by user , test routine 
                             * returns error.
                             *To avoid that the following check is done.
                             */

                            if (nmhGetFsErpsVlanGroupRowStatus
                                (u4ContextId, i4VlanId, i4VlanGroupId,
                                 &i4VlanGroupRowStat) != SNMP_SUCCESS)
                            {
                                return CLI_FAILURE;
                            }
                        }
                    }
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                }
            }
        }

        i4VlanGroupRowStat = 0;
        i4VlanId = 0;
        u2VlanFlag = 0;

        /* Set the values */
        for (u2ByteIndex = 0; u2ByteIndex < VLAN_LIST_SIZE_EXT; u2ByteIndex++)
        {
            if (pu1VlanList[u2ByteIndex] != 0)
            {
                u2VlanFlag = pu1VlanList[u2ByteIndex];

                for (u2BitIndex = 0;
                     (u2BitIndex < BITS_PER_BYTE && u2VlanFlag != 0);
                     u2BitIndex++)
                {
                    if ((u2VlanFlag & VLAN_BIT8) != 0)
                    {
                        i4VlanId =
                            (UINT2) ((u2ByteIndex * BITS_PER_BYTE) +
                                     u2BitIndex + 1);

                        if (VLAN_IS_VLAN_ID_VALID (i4VlanId) == OSIX_FALSE)
                        {
                            u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                            continue;
                        }

                        if (nmhSetFsErpsVlanGroupRowStatus
                            (u4ContextId, i4VlanId, i4VlanGroupId,
                             CREATE_AND_GO) == SNMP_FAILURE)
                        {
                            return CLI_FAILURE;
                        }
                    }
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                }
            }
        }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliRemVlanList
 *
 * DESCRIPTION      : This function removes the vlan list given by user 
 *                    (that belongs to a vlan group) from the vlan group 
 *                    table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    i4VlanGroupId    - VlanGroup Id
 *                    pu1VlanList - List of protected VLAN's.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliRemVlanList (tCliHandle CliHandle, UINT4 u4ContextId,
                    INT4 i4VlanGroupId, UINT1 *pu1VlanList)
{
    UINT4               u4ErrorCode = 0;
    INT4                i4VlanId = 0;
    UINT2               u2ByteIndex = 0;
    UINT2               u2BitIndex = 0;
    UINT2               u2VlanFlag = 0;

    /* Configure the VLAN list entries only if they are given as input
     * by user.
     * If no VLAN list is given return success */
    if (pu1VlanList != NULL)
    {
        /* Test each and every VLAN list value. */

        for (u2ByteIndex = 0; u2ByteIndex < VLAN_LIST_SIZE_EXT; u2ByteIndex++)
        {
            if (pu1VlanList[u2ByteIndex] != 0)
            {
                u2VlanFlag = pu1VlanList[u2ByteIndex];

                for (u2BitIndex = 0;
                     (u2BitIndex < BITS_PER_BYTE && u2VlanFlag != 0);
                     u2BitIndex++)
                {
                    if ((u2VlanFlag & VLAN_BIT8) != 0)
                    {
                        i4VlanId =
                            (UINT2) ((u2ByteIndex * BITS_PER_BYTE) +
                                     u2BitIndex + 1);

                        if (VLAN_IS_VLAN_ID_VALID (i4VlanId) == OSIX_FALSE)
                        {
                            u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                            continue;
                        }

                        /* This check is to ensure that invalid vlan ids are not 
                         * accessed for deletion.*/
                        if (nmhTestv2FsErpsVlanGroupRowStatus
                            (&u4ErrorCode, u4ContextId, i4VlanId,
                             i4VlanGroupId, DESTROY) == SNMP_FAILURE)
                        {
                            return CLI_FAILURE;
                        }
                    }
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                }
            }
        }
        /*Only if test is success,remove the vlans */
        for (u2ByteIndex = 0; u2ByteIndex < VLAN_LIST_SIZE_EXT; u2ByteIndex++)
        {
            if (pu1VlanList[u2ByteIndex] != 0)
            {
                u2VlanFlag = pu1VlanList[u2ByteIndex];

                for (u2BitIndex = 0;
                     (u2BitIndex < BITS_PER_BYTE && u2VlanFlag != 0);
                     u2BitIndex++)
                {
                    if ((u2VlanFlag & VLAN_BIT8) != 0)
                    {
                        i4VlanId =
                            (UINT2) ((u2ByteIndex * BITS_PER_BYTE) +
                                     u2BitIndex + 1);

                        if (VLAN_IS_VLAN_ID_VALID (i4VlanId) == OSIX_FALSE)
                        {
                            u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                            continue;
                        }

                        if (nmhSetFsErpsVlanGroupRowStatus (u4ContextId,
                                                            i4VlanId,
                                                            i4VlanGroupId,
                                                            DESTROY) ==
                            SNMP_FAILURE)
                        {
                            CLI_FATAL_ERROR (CliHandle);
                            return CLI_FAILURE;
                        }
                    }
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                }
            }
        }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliModVlanList
 *
 * DESCRIPTION      : This function modifies the vlan list in the vlan
 *                    group table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    i4VlanGroupId    - VlanGroup Id
 *                    pu1VlanList - List of protected VLAN's.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliModVlanList (tCliHandle CliHandle, UINT4 u4ContextId,
                    INT4 i4VlanGroupId, UINT1 *pu1VlanList)
{
    UINT4               u4NextContextId = 0;
    UINT4               u4ErrorCode = 0;
    INT4                i4NextVlanGroupId = 0;
    INT4                i4CurrVlanGroupId = i4VlanGroupId;
    INT4                i4VlanId = 0;
    INT4                i4NextVlanId = 0;
    INT4                i4VlanCount = 0;
    BOOL1               bResult = OSIX_FALSE;

    MEMSET (&gau1ErpsVlanDelList[0], 0, VLAN_LIST_SIZE_EXT);
    /* Scan the ERPS Vlan Group Table , Get the VLAN Id, and check if the bit 
     * corresponding to the vlan id is set in pu1VlanList.
     * If bit is set in VlanList then reset the bit as this vlan is already 
     * present in the VlanGroup Table.
     * If bit is not set in VlanList, then set a bit in au1VlanDeleteList
     * and test with DESTROY option for the vlan id */

    if (pu1VlanList != NULL)
    {
        while (nmhGetNextIndexFsErpsVlanGroupTable
               (u4ContextId, &u4NextContextId, i4VlanId, &i4NextVlanId,
                i4VlanGroupId, &i4NextVlanGroupId) == SNMP_SUCCESS)

        {
            /* Break from Loop if context Id does not match, as context Id is the 
             * primary Index */

            if (u4ContextId != (UINT4) u4NextContextId)
            {
                break;
            }

            /* Continue to Loop if Group Id does not match, as many more 
             * Vlans can be mapped to the same group Id (Vlan Id is the 
             * secondary index and Group Id is the 3rd Index to vlan 
             * group table) */

            if (i4CurrVlanGroupId != i4NextVlanGroupId)
            {
                i4VlanId = i4NextVlanId;
                i4VlanGroupId = i4NextVlanGroupId;
                continue;
            }

            OSIX_BITLIST_IS_BIT_SET (pu1VlanList,
                                     i4NextVlanId, VLAN_LIST_SIZE_EXT, bResult);

            if (bResult == OSIX_TRUE)
            {
                OSIX_BITLIST_RESET_BIT (pu1VlanList, i4NextVlanId,
                                        VLAN_LIST_SIZE_EXT);
            }
            else
            {
                /* Calling the Test routine to validate the vlan group 
                 * to be deleted */
                if (nmhTestv2FsErpsVlanGroupRowStatus
                    (&u4ErrorCode, u4ContextId, i4NextVlanId, i4NextVlanGroupId,
                     DESTROY) == SNMP_FAILURE)
                {
                    return CLI_FAILURE;
                }
                OSIX_BITLIST_SET_BIT (gau1ErpsVlanDelList, i4NextVlanId,
                                      VLAN_LIST_SIZE_EXT);
            }

            i4VlanId = i4NextVlanId;
            i4VlanGroupId = i4NextVlanGroupId;
        }

        bResult = OSIX_FALSE;

        /* Test the list of all VLANS to be added in pu1VlanList 
         */
        for (i4VlanCount = 0; i4VlanCount <= VLAN_MAX_VLAN_ID_EXT;
             i4VlanCount++)
        {
            /* This check is to ensure that invalid vlan ids are not 
             * accessed for creation.*/
            OSIX_BITLIST_IS_BIT_SET (pu1VlanList,
                                     i4VlanCount, VLAN_LIST_SIZE_EXT, bResult);
            if (bResult == OSIX_TRUE)
            {
                if (nmhTestv2FsErpsVlanGroupRowStatus
                    (&u4ErrorCode, u4ContextId, i4VlanCount,
                     i4CurrVlanGroupId, CREATE_AND_GO) == SNMP_FAILURE)
                {
                    return CLI_FAILURE;
                }
            }
        }

        bResult = OSIX_FALSE;

        /* Set the list of all VLANS to be added in pu1VlanList.
         * Delete the list of all VLANS in gau1ErpsVlanDelList
         */
        for (i4VlanCount = 0; i4VlanCount <= VLAN_MAX_VLAN_ID_EXT;
             i4VlanCount++)
        {
            OSIX_BITLIST_IS_BIT_SET (pu1VlanList,
                                     i4VlanCount, VLAN_LIST_SIZE_EXT, bResult);
            if (bResult == OSIX_TRUE)
            {
                if (nmhSetFsErpsVlanGroupRowStatus (u4ContextId,
                                                    i4VlanCount,
                                                    i4CurrVlanGroupId,
                                                    CREATE_AND_GO) ==
                    SNMP_FAILURE)
                {
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }
            }
        }

        for (i4VlanCount = 0; i4VlanCount <= VLAN_MAX_VLAN_ID_EXT;
             i4VlanCount++)
        {
            bResult = OSIX_FALSE;

            OSIX_BITLIST_IS_BIT_SET (gau1ErpsVlanDelList,
                                     i4VlanCount, VLAN_LIST_SIZE_EXT, bResult);
            if (bResult == OSIX_TRUE)
            {
                if (nmhSetFsErpsVlanGroupRowStatus (u4ContextId,
                                                    i4VlanCount,
                                                    i4CurrVlanGroupId,
                                                    DESTROY) == SNMP_FAILURE)
                {
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }
            }

        }
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliRemoveVlanGroup
 *
 * DESCRIPTION      : This function removes the entire vlan list for 
 *                    a particular vlan group.
 *
 * INPUT            : CliHandle        - Handle to the CLI 
 *                  : u4ContextId      - Context Identifier
 *                    i4VlanGroupId    - VlanGroup Id
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliRemoveVlanGroup (tCliHandle CliHandle, UINT4 u4ContextId,
                        INT4 i4VlanGroupId)
{
    /* Validate the i4FsErpsVlanGroupId */
    tStpInstanceInfo    InstInfo;
    UINT4               u4NextContextId = u4ContextId;
    UINT4               u4ErrorCode = 0;
    INT4                i4NextVlanGroupId = 0;
    INT4                i4CurrVlanGroupId = i4VlanGroupId;
    INT4                i4VlanId = 0;
    INT4                i4NextVlanId = 0;

    /* Validate the vlan group before removing the vlan from
     * vlan group. */

    InstInfo.u1RequestFlag = L2IWF_REQ_INSTANCE_STATUS;
    if (L2IwfGetInstanceInfo
        (u4ContextId, (UINT2) i4VlanGroupId, &InstInfo) == L2IWF_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (InstInfo.u1InstanceStatus == OSIX_FALSE)
    {
        /* Given VlanGroup Id is not present */
        CLI_SET_ERR (CLI_ERPS_ERR_VLAN_GROUP_NOT_PRESENT);
        return CLI_FAILURE;
    }

    while (nmhGetNextIndexFsErpsVlanGroupTable (u4ContextId, &u4NextContextId,
                                                i4VlanId, &i4NextVlanId,
                                                i4VlanGroupId,
                                                &i4NextVlanGroupId) ==
           SNMP_SUCCESS)

    {
        /* Break from Loop if context Id does not match, as context Id is the 
         * primary Index */

        if (u4ContextId != (UINT4) u4NextContextId)
        {
            break;
        }

        /* Continue to Loop if Group Id does not match, as many more Vlans
         * can be mapped to the same group Id (Vlan Id is the secondary 
         * index and Group Id is the 3rd Index) */
        if (i4CurrVlanGroupId != i4NextVlanGroupId)
        {
            i4VlanId = i4NextVlanId;
            i4VlanGroupId = i4NextVlanGroupId;
            continue;
        }
        /* Calling the Test routine to validate the vlan group */
        if (nmhTestv2FsErpsVlanGroupRowStatus (&u4ErrorCode, u4ContextId,
                                               i4NextVlanId,
                                               i4NextVlanGroupId,
                                               DESTROY) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        i4VlanId = i4NextVlanId;
        i4VlanGroupId = i4NextVlanGroupId;
    }

    u4NextContextId = 0;
    i4NextVlanGroupId = 0;
    i4VlanId = 0;
    i4NextVlanId = 0;

    while (nmhGetNextIndexFsErpsVlanGroupTable (u4ContextId, &u4NextContextId,
                                                i4VlanId, &i4NextVlanId,
                                                i4VlanGroupId,
                                                &i4NextVlanGroupId) ==
           SNMP_SUCCESS)

    {
        /* Break from Loop if context Id does not match, as context Id is the 
         * primary Index */

        if (u4ContextId != (UINT4) u4NextContextId)
        {
            break;
        }

        /* Continue to Loop if Group Id does not match, as many more 
         * Vlans can be mapped to the same group Id (Vlan Id is the 
         * secondary index and Group Id is the 3rd Index) 
         * Group Id doesnot match,so move to the next group Id */
        if (i4CurrVlanGroupId != i4NextVlanGroupId)
        {
            i4VlanId = i4NextVlanId;
            i4VlanGroupId = i4NextVlanGroupId;
            continue;
        }

        /* u4VlanId is deleted */
        if (nmhSetFsErpsVlanGroupRowStatus (u4ContextId,
                                            i4NextVlanId,
                                            i4NextVlanGroupId,
                                            DESTROY) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        i4VlanId = i4NextVlanId;
        i4VlanGroupId = i4NextVlanGroupId;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliDisplayVlanList
 *
 * DESCRIPTION      : This function used to display the vlan list info
 *                    in the required format.
 *
 * INPUT            : CliHandle   -Handle to the CLI 
 *                    pu1VlanList -Vlan Bitmap that contains the list of vlans.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliDisplayVlanList (tCliHandle CliHandle, UINT1 *pu1VlanList,
                        UINT2 u2SrcFlag)
{
    UINT4               u4StartVlanId = 0;
    UINT4               u4CurrVlanId = 0;
    UINT4               u4PrevVlanId = 0;
    INT4                i4Result = OSIX_FALSE;
    BOOL1               b1Flag = OSIX_FALSE;
    UINT1               u1Counter = 0;
    UINT1              *pu1FirstLine = NULL;
    UINT1               au1FirstLine[ERPS_CLI_DISPLAY_LINE];
    UINT1               au1BlankSpace[CLI_MAX_COLS];

    MEMSET (au1FirstLine, '\0', ERPS_CLI_DISPLAY_LINE);

    MEMSET (au1BlankSpace, 0, CLI_MAX_COLS);

    /* Here, 0x20 refers to white space and it is used to display the
     * vlan list in new line,when counter
     * is reached to max list */

    pu1FirstLine = au1FirstLine;

    STRCPY (pu1FirstLine, "Vlan List                   :");

    MEMSET (au1BlankSpace, 0x20,
            MEM_MAX_BYTES (sizeof (au1BlankSpace), STRLEN (pu1FirstLine)));

    au1BlankSpace[MEM_MAX_BYTES
                  (((sizeof (au1BlankSpace)) - 1), STRLEN (pu1FirstLine))] =
        '\0';

    if (pu1VlanList != NULL)
    {
        if (u2SrcFlag == OSIX_TRUE)
        {
            CliPrintf (CliHandle, "add ");
        }
        else
        {
            CliPrintf (CliHandle, "%s ", pu1FirstLine);
        }

        /* Scan through vlans from 1-4094 and check if the Vlan is present 
         * in the input VlanList .If it is present,then print the Vlan 
         * entries in the required format.
         * */

        for (u4CurrVlanId = 1; u4CurrVlanId <= VLAN_DEV_MAX_VLAN_ID_EXT;
             u4CurrVlanId++)
        {
            OSIX_BITLIST_IS_BIT_SET (pu1VlanList, u4CurrVlanId,
                                     VLAN_LIST_SIZE_EXT, i4Result);

            if (i4Result == OSIX_FALSE)
            {
                if (u4PrevVlanId != 0)
                {
                    if (u4StartVlanId != u4PrevVlanId)
                    {
                        CliPrintf (CliHandle, "-%d", u4PrevVlanId);

                        if (u1Counter != ERPS_MAX_LIST_PER_LINE)
                        {
                            u1Counter++;
                        }
                        else
                        {
                            CliPrintf (CliHandle, "\r\n");
                            STRNCPY (pu1FirstLine, au1BlankSpace,
                                     sizeof (au1FirstLine));
                            pu1FirstLine[sizeof (au1FirstLine) - 1] = '\0';
                            CliPrintf (CliHandle, "%s ", pu1FirstLine);
                            u1Counter = 0;
                        }
                    }
                    else
                    {
                        if (u1Counter == 0)
                        {
                            CliPrintf (CliHandle, "%d", u4PrevVlanId);
                        }
                        else
                        {
                            CliPrintf (CliHandle, ",%d", u4PrevVlanId);
                        }
                        u1Counter++;
                    }
                    if (u1Counter == ERPS_MAX_LIST_PER_LINE)
                    {
                        CliPrintf (CliHandle, "\r\n");
                        STRNCPY (pu1FirstLine, au1BlankSpace,
                                 sizeof (au1FirstLine));
                        pu1FirstLine[sizeof (au1FirstLine) - 1] = '\0';
                        CliPrintf (CliHandle, "%s ", pu1FirstLine);
                        u1Counter = 0;
                    }
                    u4StartVlanId = 0;
                    u4PrevVlanId = 0;
                }
            }
            else
            {
                if ((u4StartVlanId != 0) && (b1Flag == OSIX_TRUE))
                {
                    if (u1Counter != 0)
                    {
                        CliPrintf (CliHandle, ",%d", u4StartVlanId);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%d", u4StartVlanId);
                    }
                    u1Counter++;
                    b1Flag = OSIX_FALSE;
                }

                if (u4StartVlanId == 0)
                {
                    u4StartVlanId = u4CurrVlanId;
                    b1Flag = OSIX_TRUE;
                }

                u4PrevVlanId = u4CurrVlanId;

                /* Print the last Vlan Id */
                if (u4CurrVlanId == VLAN_DEV_MAX_VLAN_ID_EXT)
                {
                    if (u4StartVlanId != u4PrevVlanId)
                    {
                        CliPrintf (CliHandle, "-%d", u4CurrVlanId);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%d", u4CurrVlanId);
                    }
                }

            }

        }
        u1Counter = 0;
    }
    if (u2SrcFlag != OSIX_TRUE)
    {
        CliPrintf (CliHandle, "\r\n\n");
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowVlanGroupInfo
 *
 * DESCRIPTION      : This function used to display the information in vlan 
 *                    group table.
 *
 * INPUT            : CliHandle     - Handle to the CLI 
 *                  : u4ContextId   - Context Identifier
 *                    i4VlanGroupId - VlanGroup Id
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliShowVlanGroupInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                          INT4 i4VlanGroupId, UINT2 u2SrcFlag)
{
    UINT4               u4NextContextId = 0;
    INT4                i4NextVlanGroupId = 0;
    INT4                i4CurrVlanGroupId = i4VlanGroupId;
    INT4                i4VlanId = 0;
    INT4                i4NextVlanId = 0;
    BOOL1               b1Flag = OSIX_FALSE;

    MEMSET (&gau1ErpsVlanList[0], 0, VLAN_LIST_SIZE_EXT);

    /*Scan the entire VLAN Group Table and get the VLAN Id's mapped to 
     * i4VlanGroupId */
    while (nmhGetNextIndexFsErpsVlanGroupTable (u4ContextId, &u4NextContextId,
                                                i4VlanId, &i4NextVlanId,
                                                i4VlanGroupId,
                                                &i4NextVlanGroupId) ==
           SNMP_SUCCESS)

    {
        if (u4ContextId != u4NextContextId)
        {
            break;
        }

        i4VlanId = i4NextVlanId;
        u4ContextId = u4NextContextId;
        i4VlanGroupId = i4NextVlanGroupId;

        if (i4CurrVlanGroupId != i4NextVlanGroupId)
        {
            continue;
        }
        /* Set the bitmap for appropriate vlan id  */
        OSIX_BITLIST_SET_BIT (gau1ErpsVlanList, i4NextVlanId,
                              VLAN_LIST_SIZE_EXT);
        /*The Flag is set to determine whether the bitlist has been set 
         * or not */
        b1Flag = OSIX_TRUE;
    }

    if (b1Flag == OSIX_TRUE)
    {
        if (u2SrcFlag == OSIX_TRUE)
        {
            if (i4CurrVlanGroupId == OSIX_FALSE)
            {
                return CLI_SUCCESS;
            }
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ring map vlan-group %d ",
                       i4CurrVlanGroupId);
        }
        else
        {
            CliPrintf (CliHandle, "Vlan Group - %d \r\n", i4CurrVlanGroupId);
        }

        ErpsCliDisplayVlanList (CliHandle, &gau1ErpsVlanList[0], u2SrcFlag);
    }

    MEMSET (&gau1ErpsVlanList[0], 0, VLAN_LIST_SIZE_EXT);

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureMainRingId
 *
 * DESCRIPTION      : This function used to configure the main-ring id of 
 *                    the sub-ring.
 *
 * INPUT            : CliHandle    - Handle to the CLI 
 *                  : u4ContextId  - Context Identifier
 *                    u4RingId     - Ring Identifier
 *                    u4MainRingId - ID of the Main Ring
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfigureMainRingId (tCliHandle CliHandle,
                            UINT4 u4ContextId,
                            UINT4 u4RingId, UINT4 u4MainRingId)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingConfigExtMainRingId (&u4ErrCode,
                                                u4ContextId,
                                                u4RingId,
                                                u4MainRingId) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigExtMainRingId (u4ContextId,
                                             u4RingId,
                                             u4MainRingId) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureVcPeriodicTimer
 *
 * DESCRIPTION      : This function used to configure the Vc periodic timer 
 *                    of the sub-ring.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u1RowStatus - Row status of the ring
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfigureVcPeriodicTimer (tCliHandle CliHandle,
                                 UINT4 u4ContextId,
                                 UINT4 u4RingId, UINT4 u4VcPeriodicTime)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingConfigExtVCRecoveryPeriodicTime (&u4ErrCode,
                                                            u4ContextId,
                                                            u4RingId,
                                                            u4VcPeriodicTime)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigExtVCRecoveryPeriodicTime (u4ContextId,
                                                         u4RingId,
                                                         u4VcPeriodicTime)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingversion
 *
 * DESCRIPTION      : This function used to configure the Version of the ring 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4Ringversion - Version number of the ring.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingversion (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4RingId, UINT4 u4Ringversion)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingRAPSCompatibleVersion (&u4ErrCode, u4ContextId,
                                                  u4RingId,
                                                  u4Ringversion) ==
        SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingRAPSCompatibleVersion (u4ContextId, u4RingId,
                                               u4Ringversion) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureInterConnNode
 *
 * DESCRIPTION      : This function used to configure the inter connection
 *                    node object value in an intermediate ring node. 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4InterConnNode - Inter connection node object value.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigureInterConnNode (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4RingId, UINT4 u4InterConnNode)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingConfigInterConnNode (&u4ErrCode, u4ContextId,
                                                u4RingId,
                                                u4InterConnNode) ==
        SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigInterConnNode (u4ContextId, u4RingId,
                                             u4InterConnNode) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureMultipleFailure
 *
 * DESCRIPTION      : This function used to configure the multiple failure 
 *                    object value in an intermediate ring node. 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4MultipleFailure - multiple failure object value.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigureMultipleFailure (tCliHandle CliHandle, UINT4 u4ContextId,
                                 UINT4 u4RingId, UINT4 u4MultipleFailure)
{
    UINT4               u4ErrCode = 0;

    if (nmhTestv2FsErpsRingConfigMultipleFailure (&u4ErrCode, u4ContextId,
                                                  u4RingId,
                                                  u4MultipleFailure) ==
        SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigMultipleFailure (u4ContextId, u4RingId,
                                               u4MultipleFailure) ==
        SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingNeighbour
 *
 * DESCRIPTION      : This function used to configure the Ring Neighbour 
 *                    port of the ring 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4Ringversion - Version number of the ring.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfigureRingRPLNeighbour (tCliHandle CliHandle, UINT4 u4ContextId,
                                  UINT4 u4RingId, UINT4 u4RplNeighbourPort)
{
    UINT4               u4ErrorCode = 0;
    if (nmhTestv2FsErpsRingRplNeighbourPort
        (&u4ErrorCode, u4ContextId, u4RingId,
         u4RplNeighbourPort) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingRplNeighbourPort
        (u4ContextId, u4RingId, u4RplNeighbourPort) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureRingNextNeighbour
 *
 * DESCRIPTION      : This function used to configure the Ring Next Neighbour 
 *                    port of the ring 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4Ringversion - Version number of the ring.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfigureRingRPLNextNeighbour (tCliHandle CliHandle, UINT4 u4ContextId,
                                      UINT4 u4RingId,
                                      UINT4 u4RplNextNeighbourPort)
{
    UINT4               u4ErrorCode = 0;
    if (nmhTestv2FsErpsRingRplNextNeighbourPort
        (&u4ErrorCode, u4ContextId, u4RingId,
         u4RplNextNeighbourPort) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingRplNextNeighbourPort
        (u4ContextId, u4RingId, u4RplNextNeighbourPort) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    :ErpsCliClearSwitchMethod 
 *
 * DESCRIPTION      : This function used to configure the clear of FS/MS/
 *                    Operating method 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4Ringversion - Version number of the ring.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliClearSwitchMethod (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4RingId, INT4 i4ConfigChangeMode)
{

    UINT4               u4ErrorCode = 0;
    if (nmhTestv2FsErpsRingConfigClear
        (&u4ErrorCode, u4ContextId, u4RingId,
         i4ConfigChangeMode) == SNMP_FAILURE)
    {

        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigClear (u4ContextId, u4RingId, i4ConfigChangeMode)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    :ErpsCliConfigswitchMethod
 *
 * DESCRIPTION      : This function used to configure the WTB timer 
 *                    
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4Ringversion - Version number of the ring.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigWTBTime (tCliHandle CliHandle, UINT4 u4ContextId,
                      UINT4 u4RingId, UINT4 u4WTBtime)
{
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    /* Set the Wait-To-Block Timer value */

    if (nmhTestv2FsErpsRingConfigWTBTime (&u4ErrorCode, u4ContextId,
                                          u4RingId, u4WTBtime) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigWTBTime (u4ContextId, u4RingId, u4WTBtime)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    :ErpsCliConfigureRingRAPSWithoutVC
 *
 * DESCRIPTION      : This function used to configure the WTB timer 
 *                    
 *
 * INPUT            : CliHandle       - Handle to the CLI 
 *                  : u4ContextId     - Context Identifier
 *                    u4RingId        - Ring Identifier
 *                    u4RAPSWithoutVC - Sub-Ring with/without VC.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingRAPSWithoutVC (tCliHandle CliHandle, UINT4 u4ContextId,
                                   UINT4 u4RingId, UINT4 u4RAPSWithoutVC)
{
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    /* Configure the sub-ring with/without virtual channel */

    if (nmhTestv2FsErpsRingRAPSSubRingWithoutVC (&u4ErrorCode, u4ContextId,
                                                 u4RingId, u4RAPSWithoutVC)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingRAPSSubRingWithoutVC
        (u4ContextId, u4RingId, u4RAPSWithoutVC) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 *  FUNCTION NAME    : ErpsCliSetPropClearFS
 *  
 *  DESCRIPTION      : This function sets the Aricent proprietary clear FS
 *                     Implementation.
 * 
 *  INPUT            : u4ContextId - Context Identifier
 *                     i4Status - ERPS_SNMP_TRUE/ERPS_SNMP_FALSE
 *  
 *  OUTPUT           : None
 * 
 *  RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 ***************************************************************************/
INT4
ErpsCliSetPropClearFS (tCliHandle CliHandle, UINT4 u4ContextId, INT4 i4Status)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsCtxtProprietaryClearFS (&u4ErrorCode, u4ContextId,
                                               i4Status) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsCtxtProprietaryClearFS (u4ContextId,
                                            i4Status) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ElpsCliSetMonitor
 *
 * DESCRIPTION      : This function sets the Monitor Mechanism for the
 *                    Protection Group.
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    u4RingId - Protection Group Identifier
 *                    i4RingMonitor - Monitor Mechanism (CFM)
 *                    CliHandle - CliHandle 
 *
 * OUTPUT           : None
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 **************************************************************************/

INT4
ErpsCliSetMonitor (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4RingId,
                   INT4 i4RingMonitor)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsRingMonitorMechanism (&u4ErrorCode, u4ContextId,
                                             u4RingId,
                                             i4RingMonitor) == SNMP_FAILURE)
    {
        CliPrintf (CliHandle,
                   "\r%% Monitoring Mechanism configuration Failed.\n");
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingMonitorMechanism (u4ContextId, u4RingId,
                                          i4RingMonitor) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureKValue
 *
 * DESCRIPTION      : This function used to configure the KValue
 *
 * INPUT            : CliHandle   - Handle to the CLI
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u1KValue - Kvalue which is to be used for running 
 *                               dfop defect raising timer.
 *
 * OUTPUT           : None.
 *
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 *
 **************************************************************************/

INT4
ErpsCliConfigureKValue (tCliHandle CliHandle,
                        UINT4 u4ContextId, UINT4 u4RingId, UINT1 *pu1KValue)
{
    UINT4               u4ErrCode = 0;
    tSNMP_OCTET_STRING_TYPE KValue;
    MEMSET (&KValue, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    KValue.pu1_OctetList = pu1KValue;
    KValue.i4_Length = STRLEN (pu1KValue);

    if (nmhTestv2FsErpsRingConfigKValue (&u4ErrCode, u4ContextId,
                                         u4RingId, &KValue) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigKValue (u4ContextId, u4RingId,
                                      &KValue) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 *  FUNCTION NAME    : ErpsCliSetFailureofProtocol
 *  
 *  DESCRIPTION      : This function sets the TFOP feature
 *                     Implementation
 * 
 *  INPUT            : u4ContextId - Context Identifier
 *                     i4Status - ERPS_SNMP_TRUE/ERPS_SNMP_FALSE
 *  
 *  OUTPUT           : None
 * 
 *  RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 ***************************************************************************/
INT4
ErpsCliSetFailureofProtocol (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4RingId, INT4 i4Status)
{
    UINT4               u4ErrorCode = 0;

    if (nmhTestv2FsErpsRingConfigFailureOfProtocol
        (&u4ErrorCode, u4ContextId, u4RingId, i4Status) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsErpsRingConfigFailureOfProtocol (u4ContextId, u4RingId,
                                                 i4Status) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    :ErpsCliConfigureRingPortPresence
 *
 * DESCRIPTION      : This function is used to configure ring port1 presence or ring port2   
                     presence as 'local' or 'remote' in the line card.    
 *                    
 *
 * INPUT            : CliHandle       - Handle to the CLI 
 *                  : u4ContextId     - Context Identifier
 *                    u4RingId        - Ring Identifier
 *                    u1IsPort1Present - Presence of ring port1.
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsCliConfigureRingPortPresence (tCliHandle CliHandle, UINT4 u4ContextId,
                                  UINT4 u4RingId, UINT1 u1IsPortPresent,
                                  UINT1 u1ConfigType)
{
    UINT4               u4ErrorCode = 0;
    UNUSED_PARAM (CliHandle);

    if (u1ConfigType == CLI_ERPS_RING_PORT1_PRESENCE)
    {
        if (nmhTestv2FsErpsRingConfigIsPort1Present
            (&u4ErrorCode, u4ContextId, u4RingId,
             u1IsPortPresent) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsErpsRingConfigIsPort1Present
            (u4ContextId, u4RingId, u1IsPortPresent) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    else if (u1ConfigType == CLI_ERPS_RING_PORT2_PRESENCE)
    {
        if (nmhTestv2FsErpsRingConfigIsPort2Present
            (&u4ErrorCode, u4ContextId, u4RingId,
             u1IsPortPresent) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsErpsRingConfigIsPort2Present
            (u4ContextId, u4RingId, u1IsPortPresent) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliConfigureDistributePort
 *
 * DESCRIPTION      : This function used to configure the Ring Neighbour 
 *                    port of the ring 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                  : u4ContextId - Context Identifier
 *                    u4RingId    - Ring Identifier
 *                    u4DistributePort - Distributing Port Index 
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/

INT4
ErpsCliConfigureDistributePort (tCliHandle CliHandle, UINT4 u4ContextId,
                                UINT4 u4RingId, UINT4 u4DistributePort)
{
    UINT4               u4ErrorCode = 0;
    if (nmhTestv2FsErpsRingConfigInfoDistributingPort
        (&u4ErrorCode, u4ContextId, u4RingId, u4DistributePort) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsErpsRingConfigInfoDistributingPort
        (u4ContextId, u4RingId, u4DistributePort) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfig
 *
 * DESCRIPTION      : This function used in show running config of erps 
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsShowRunningConfig (tCliHandle CliHandle)
{

    if (CLI_SUCCESS != ErpsShowRunningConfigCxtCmds (CliHandle))
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;

}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigCxtCmds
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    context table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsShowRunningConfigCxtCmds (tCliHandle CliHandle)
{
    UINT1               au1VcAlias[VCM_ALIAS_MAX_LEN];
    UINT4               u4FsErpsContextId = 0;
    UINT4               u4FsErpsContextIdNext = 0;
    INT4                i4FsErpsCtxtSystemControl = 0;
    INT4                i4FsErpsCtxtModuleStatus = 0;
    INT4                i4FsErpsCtxtTrapStatus = 0;
    INT4                i4FsErpsVlanGrpManager = -1;
    INT4                i4FsErpsCtxtPropClearFS = 0;
    INT4                i4GroupId = 0;

    /* Code for fsErpsContextTable Entries */

    if (nmhGetFirstIndexFsErpsContextTable (&u4FsErpsContextId) != SNMP_FAILURE)
    {

        u4FsErpsContextIdNext = u4FsErpsContextId;

        do
        {
            u4FsErpsContextId = u4FsErpsContextIdNext;
            VcmGetAliasName (u4FsErpsContextId, au1VcAlias);
            CliPrintf (CliHandle, "switch %s", au1VcAlias);

            /* Code to verify the execution of command: no shutdown aps ring   */

            nmhGetFsErpsCtxtSystemControl (u4FsErpsContextId,
                                           &i4FsErpsCtxtSystemControl);

            if (i4FsErpsCtxtSystemControl == ERPS_START)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "no shutdown aps ring");
            }

            /* Code to verify the execution of command: aps ring enable   */
            nmhGetFsErpsCtxtModuleStatus (u4FsErpsContextId,
                                          &i4FsErpsCtxtModuleStatus);

            if (i4FsErpsCtxtModuleStatus == OSIX_ENABLED)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "aps ring enable");
            }
            /* Code to verify the execution of command: aps ring notification   */
            nmhGetFsErpsCtxtTrapStatus (u4FsErpsContextId,
                                        &i4FsErpsCtxtTrapStatus);

            if (i4FsErpsCtxtTrapStatus == OSIX_DISABLED)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "no aps ring notification enable");
            }

            /*Code for the execution of aps ring vlan-group-manager */
            if (i4FsErpsCtxtSystemControl == ERPS_START)
            {
                nmhGetFsErpsCtxtVlanGroupManager (u4FsErpsContextId,
                                                  &i4FsErpsVlanGrpManager);

                if (i4FsErpsVlanGrpManager == ERPS_VLAN_GROUP_MANAGER_ERPS)
                {
                    CliPrintf (CliHandle, "\r\n");
                    CliPrintf (CliHandle, "aps ring vlan-group-manager erps");
                }
            }

            /* Code for the execution of "aps ring proprietaryClearFS enable" */
            nmhGetFsErpsCtxtProprietaryClearFS (u4FsErpsContextId,
                                                &i4FsErpsCtxtPropClearFS);

            if (i4FsErpsCtxtPropClearFS == ERPS_SNMP_TRUE)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "aps ring proprietaryClearFS enable");
            }

            for (i4GroupId = 0; i4GroupId <= ERPS_MAX_VLAN_GROUP_ID;
                 i4GroupId++)
            {
                ErpsCliShowVlanGroupInfo (CliHandle, u4FsErpsContextId,
                                          i4GroupId, OSIX_TRUE);
            }

            ErpsShowRunningConfigRingCmds (CliHandle, u4FsErpsContextId);

            CliPrintf (CliHandle, "\r\n!");
            CliPrintf (CliHandle, "\r\n");

        }
        while (nmhGetNextIndexFsErpsContextTable
               (u4FsErpsContextId, &u4FsErpsContextIdNext) != SNMP_FAILURE);

    }
    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigRingCmds
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    table, ring config table, cfm table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                    u4ContextId  - Context Identifier
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsShowRunningConfigRingCmds (tCliHandle CliHandle, UINT4 u4ContextId)
{

    tSNMP_OCTET_STRING_TYPE RingName;
    tSNMP_OCTET_STRING_TYPE VlanGroupList;
    tSNMP_OCTET_STRING_TYPE SubPortList;
    tPortListExt       *pPortList = NULL;
    tMacAddr            RingNodeId;
    tMacAddr            NullMacAddr;
    tSNMP_OCTET_STRING_TYPE KValue;
    tSNMP_OCTET_STRING_TYPE *pKValue;
    tErpsRingInfo      *pRingInfo = NULL;
    FLT4                f4KValue = 0;
    UINT4               u4FsErpsContextId = 0;
    UINT4               u4FsErpsContextIdNext = 0;
    UINT4               u4FsErpsRingId = 0;
    UINT4               u4FsErpsRingIdNext = 0;
    UINT4               u4FsErpsRingConfigWTRTime = 0;
    UINT4               u4FsErpsRingConfigWTBTime = 0;
    UINT4               u4MainRingId = 0;
    INT4                i4ServiceType = 0;
    INT4                i4FsErpsRingPort1 = -1;
    INT4                i4FsErpsRingPort2 = -1;
    INT4                i4FsErpsRingRplPort = -1;
    INT4                i4FsErpsRingRplNeighbourPort = -1;
    INT4                i4FsErpsRingConfigInfoDistributingPort = -1;
    INT4                i4FsErpsRingRplNextNeighbourPort = -1;
    INT4                i4FsErpsRingRowStatus = -1;
    INT4                i4FsErpsRingConfigSwitchPort = -1;
    INT4                i4FsErpsRingConfigSwitchCmd = -1;
    INT4                i4FsErpsRingOperatingMode = -1;
    INT4                i4FsErpsRingversion = -1;
    INT4                i4FsErpsRingConfigRecoveryMethod = -1;
    INT4                i4FsErpsRingVlanId = -1;
    INT4                i4FsErpsRingInnerVlanId = -1;
    INT4                i4FsErpsRingConfigPropagateTC = -1;
    INT4                i4RetValFsErpsRingPortBlockingOnVcRecovery = -1;
    INT4                i4RetValFsErpsRingMacId = -1;
    INT4                i4RetValFsErpsRingVlanGroupId = -1;
    INT4                i4RetValFsErpsRingProtectionType = -1;
    INT4                i4FsErpsRingRAPSSubRingWithoutVC = -1;
    INT4                i4RingConfigInterConnNode = -1;
    INT4                i4RingConfigMultipleFailure = -1;
    INT4                i4RetValFsErpsRingIsPort1Present = 0;
    INT4                i4RetValFsErpsRingIsPort2Present = 0;
    INT4                i4MonitoringMechanism = -1;
    INT4                i4RetValFsErpsRingConfigFailureOfProtocol = 0;
    UINT2               u2Index = 1;
    UINT1               au1FsErpsRingName[ERPS_MAX_NAME_LENGTH];
    UINT1               au1FsErpsDefaultRingName[ERPS_MAX_NAME_LENGTH];
    UINT1               au1MacStr[ERPS_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1VlanGroupList[MAX_ERPS_VLAN_GROUP_LIST_SIZE];
    UINT1               bResult = 0;
    INT1                ai1IfName[CFA_MAX_PORT_NAME_LENGTH];
    UINT1               u1Flag = ERPS_SNMP_TRUE;
    UINT1               au1KValue[ERPS_AVLBLTY_KVALUE_LENGTH] = { 0 };

    pRingInfo = ErpsRingGetFirstNodeFrmRingTable ();

    while (pRingInfo != NULL)
    {
        if (u4ContextId == pRingInfo->u4ContextId)
        {
            break;
        }
        pRingInfo = ErpsRingGetNextNodeFromRingTable (pRingInfo);
    }

    if (pRingInfo == NULL)
    {
        return CLI_SUCCESS;
    }

    u4FsErpsContextIdNext = pRingInfo->u4ContextId;
    u4FsErpsRingIdNext = pRingInfo->u4RingId;
    do
    {
        u4FsErpsRingId = u4FsErpsRingIdNext;
        u4FsErpsContextId = u4FsErpsContextIdNext;
        if (u4FsErpsContextId != u4ContextId)
        {
            return CLI_SUCCESS;
        }

        nmhGetFsErpsRingRowStatus (u4FsErpsContextId, u4FsErpsRingId,
                                   &i4FsErpsRingRowStatus);

        /* Code to verify the execution of command: aps group name */
        MEMSET (au1FsErpsDefaultRingName, 0, ERPS_MAX_NAME_LENGTH);
        SPRINTF ((CHR1 *) au1FsErpsDefaultRingName, "Ring%u", u4FsErpsRingId);

        MEMSET (au1FsErpsRingName, 0, ERPS_MAX_NAME_LENGTH);
        RingName.pu1_OctetList = au1FsErpsRingName;

        nmhGetFsErpsRingName (u4FsErpsContextId, u4FsErpsRingId, &RingName);

        if (STRNCMP (RingName.pu1_OctetList, au1FsErpsDefaultRingName,
                     STRLEN (RingName.pu1_OctetList)) != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps group name ");
            CliPrintf (CliHandle, "%s ", RingName.pu1_OctetList);
            CliPrintf (CliHandle, "ring group ");
            CliPrintf (CliHandle, "%u ", u4FsErpsRingId);

        }
        else
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ring group ");
            CliPrintf (CliHandle, "%u ", u4FsErpsRingId);
        }
#ifdef DCSG_EXT_WANTED
            nmhGetFsErpsRingNodeId(u4FsErpsContextId ,u4FsErpsRingId , &RingNodeId);
            
            MEMSET(NullMacAddr, 0, sizeof(NullMacAddr));
            if (MEMCMP(RingNodeId, NullMacAddr, 6) != 0)
            {
                MEMSET (au1MacStr, 0, sizeof (au1MacStr));
                PrintMacAddress ((UINT1 *) &RingNodeId, au1MacStr);
                CliPrintf (CliHandle, "\naps group nodeid ");
                CliPrintf (CliHandle, "%s\r\n", au1MacStr);
            }
#endif
        /*  Code to display aps working ringport1 ringport2 vlan */
        nmhGetFsErpsRingPort1 (u4FsErpsContextId, u4FsErpsRingId,
                               &i4FsErpsRingPort1);
        nmhGetFsErpsRingPort2 (u4FsErpsContextId, u4FsErpsRingId,
                               &i4FsErpsRingPort2);
        nmhGetFsErpsRingVlanId (u4FsErpsContextId, u4FsErpsRingId,
                                &i4FsErpsRingVlanId);
#ifdef DCSG_EXT_WANTED
            nmhGetFsErpsRingInnerVlanId (u4FsErpsContextId, u4FsErpsRingId,
                                    &i4FsErpsRingInnerVlanId);
#endif
            if ((i4FsErpsRingPort1 != 0)
        #ifdef DCSG_EXT_WANTED
            &&(i4FsErpsRingPort2 != 0)
        #endif
            )
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps working ");
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingPort1, ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
#ifdef DCSG_EXT_WANTED
                MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
                CfaCliConfGetIfName (i4FsErpsRingPort2, ai1IfName);
                CliPrintf (CliHandle, "%s ", ai1IfName);
#endif
        }
#ifdef DCSG_EXT_WANTED
	    if ((i4FsErpsRingPort1 != 0)&&(i4FsErpsRingPort2 == 0))
	    {
		CliPrintf (CliHandle, "\r\n");
		CliPrintf (CliHandle, "aps working ");
		MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
		CfaCliConfGetIfName (i4FsErpsRingPort1, ai1IfName);
		CliPrintf (CliHandle, "%s ", ai1IfName);
	    }
#endif
	    if ((i4FsErpsRingPort2 != 0)
        #ifdef DCSG_EXT_WANTED
                &&(i4FsErpsRingPort1 != 0)
        #endif
            )
        {
#ifdef DCSG_EXT_WANTED 
		CliPrintf (CliHandle, "\r\n");
		CliPrintf (CliHandle, "aps working ");
#endif
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingPort2, ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        if (i4FsErpsRingVlanId != 0)
        {
            CliPrintf (CliHandle, "vlan ");
            CliPrintf (CliHandle, "%d", i4FsErpsRingVlanId);
        }
#ifdef VSI_WANTED
	    /* To display the data-vep's configured for the ring */
	    ErpsShowRunningConfigDataVep (CliHandle, u4FsErpsContextId, u4FsErpsRingId);
#endif
        /*Code to Display Ring Version */
        nmhGetFsErpsRingRAPSCompatibleVersion (u4FsErpsContextId,
                                               u4FsErpsRingId,
                                               &i4FsErpsRingversion);

        if (i4FsErpsRingversion != ERPS_RING_COMPATIBLE_VERSION2)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps compatible version v1");
        }
        /*  Code to display aps protect */

        nmhGetFsErpsRingRplPort (u4FsErpsContextId, u4FsErpsRingId,
                                 &i4FsErpsRingRplPort);

        if (i4FsErpsRingRplPort != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps protect ");
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingRplPort, ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        if (i4FsErpsRingPort2 == 0)
        {
            nmhGetFsErpsRingConfigExtMainRingId (u4FsErpsContextId,
                                                 u4FsErpsRingId, &u4MainRingId);
            if (u4MainRingId != 0)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "aps main ring id ");
                CliPrintf (CliHandle, "%u ", u4MainRingId);
            }
        }

        /* Code to display enable/disable virtual channel */
        nmhGetFsErpsRingRAPSSubRingWithoutVC (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4FsErpsRingRAPSSubRingWithoutVC);

        if (i4FsErpsRingRAPSSubRingWithoutVC != OSIX_DISABLED)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps subring-without-virtualchannel enable");
        }

        /* Code to display aps neighbour */

        nmhGetFsErpsRingRplNeighbourPort (u4FsErpsContextId, u4FsErpsRingId,
                                          &i4FsErpsRingRplNeighbourPort);

        if (i4FsErpsRingRplNeighbourPort != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps neighbor ");
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingRplNeighbourPort, ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        nmhGetFsErpsRingRplNextNeighbourPort (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4FsErpsRingRplNextNeighbourPort);
        if (i4FsErpsRingRplNextNeighbourPort != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps next-neighbor ");
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingRplNextNeighbourPort, ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        if (i4FsErpsRingversion == ERPS_RING_COMPATIBLE_VERSION2)
        {
            nmhGetFsErpsRingConfigInterConnNode (u4FsErpsContextId,
                                                 u4FsErpsRingId,
                                                 &i4RingConfigInterConnNode);
            CliPrintf (CliHandle, "\r\n");
            switch (i4RingConfigInterConnNode)
            {
                case ERPS_RING_INTER_CONN_NODE_PRIMARY:
                    CliPrintf (CliHandle,
                               "aps interconnection-node primary\r\n");
                    break;
                case ERPS_RING_INTER_CONN_NODE_SECONDARY:
                    CliPrintf (CliHandle,
                               "aps interconnection-node secondary\r\n");
                    break;
                case ERPS_RING_INTER_CONN_NODE_NONE:
                    break;
                default:
                    break;
            }

            nmhGetFsErpsRingConfigMultipleFailure (u4FsErpsContextId,
                                                   u4FsErpsRingId,
                                                   &i4RingConfigMultipleFailure);
            CliPrintf (CliHandle, "\r\n");
            switch (i4RingConfigMultipleFailure)
            {
                case ERPS_RING_MULTIPLE_FAILURE_PRIMARY:
                    CliPrintf (CliHandle, "aps multiple-failure primary\r\n");
                    break;
                case ERPS_RING_MULTIPLE_FAILURE_SECONDARY:
                    CliPrintf (CliHandle, "aps multiple-failure secondary\r\n");
                    break;
                case ERPS_RING_MULTIPLE_FAILURE_DISABLED:
                    break;
                default:
                    break;
            }
        }

        /* Code to display aps working */

        ErpsShowRunningConfigRingCfmCmd (CliHandle, u4FsErpsContextId,
                                         u4FsErpsRingId);

        /* Code to verify the execution of command: aps manual/force  */

        nmhGetFsErpsRingConfigSwitchPort (u4FsErpsContextId, u4FsErpsRingId,
                                          &i4FsErpsRingConfigSwitchPort);

        nmhGetFsErpsRingConfigSwitchCmd (u4FsErpsContextId, u4FsErpsRingId,
                                         &i4FsErpsRingConfigSwitchCmd);

        if ((i4FsErpsRingConfigSwitchPort != 0) &&
            (i4FsErpsRingConfigSwitchCmd != ERPS_SWITCH_COMMAND_NONE))
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ");
            if (i4FsErpsRingConfigSwitchCmd == ERPS_SWITCH_COMMAND_FORCE)
            {
                CliPrintf (CliHandle, "force  ");
            }
            else
            {
                CliPrintf (CliHandle, "manual  ");
            }

            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName ((UINT4) i4FsErpsRingConfigSwitchPort,
                                 ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        /* Code to display aps wtb */

        nmhGetFsErpsRingConfigWTBTime (u4FsErpsContextId, u4FsErpsRingId,
                                       &u4FsErpsRingConfigWTBTime);

        if (u4FsErpsRingConfigWTBTime != ERPS_WTB_TMR_DEF_VAL)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps wtb ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingConfigWTBTime);
            CliPrintf (CliHandle, "milliseconds");
        }
        /* Code to verify the execution of command: aps revert  */

        nmhGetFsErpsRingOperatingMode (u4FsErpsContextId, u4FsErpsRingId,
                                       &i4FsErpsRingOperatingMode);

        nmhGetFsErpsRingConfigWTRTime (u4FsErpsContextId, u4FsErpsRingId,
                                       &u4FsErpsRingConfigWTRTime);

        /* 
         * The user might have configured revertive mode 
         * with a wtr value and then changed to non-revertive mode.
         * So only this check is added to ensure that the WTR value 
         * configured by user is also displayed.
         */
        if (u4FsErpsRingConfigWTRTime != ERPS_WTR_TMR_DEF_VAL)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps revert ");

            CliPrintf (CliHandle, "wtr ");
            CliPrintf (CliHandle, "%u ", u4FsErpsRingConfigWTRTime);
            CliPrintf (CliHandle, "milliseconds");
        }

        /* Code to verify the execution of command: aps timers */
        ErpsShowRunningConfigRingTmrCmd (CliHandle, u4FsErpsContextId,
                                         u4FsErpsRingId);

        /* Code for no aps revert */
        nmhGetFsErpsRingOperatingMode (u4FsErpsContextId, u4FsErpsRingId,
                                       &i4FsErpsRingOperatingMode);

        if (i4FsErpsRingOperatingMode == ERPS_RING_NON_REVERTIVE_MODE)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "no aps revert ");
        }

        nmhGetFsErpsRingConfigRecoveryMethod (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4FsErpsRingConfigRecoveryMethod);

        if (i4FsErpsRingConfigRecoveryMethod == ERPS_RING_MANUAL_RECOVERY)
        {
            CliPrintf (CliHandle, "manual");
        }

        /* Code to verify the execution of command: aps propagate  */

        nmhGetFsErpsRingConfigPropagateTC (u4FsErpsContextId,
                                           u4FsErpsRingId,
                                           &i4FsErpsRingConfigPropagateTC);

        if (i4FsErpsRingConfigPropagateTC == OSIX_ENABLED)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps propagate-tc ");
            CliPrintf (CliHandle, "status enable");
        }
        ErpsShowRunningConfigTcTable (CliHandle, u4FsErpsContextId,
                                      u4FsErpsRingId);

        /*Code for the execution of aps blockport-on-virtualchannel-recovery */

        nmhGetFsErpsRingPortBlockingOnVcRecovery (u4FsErpsContextId,
                                                  u4FsErpsRingId,
                                                  &i4RetValFsErpsRingPortBlockingOnVcRecovery);

        if (i4RetValFsErpsRingPortBlockingOnVcRecovery == ERPS_SNMP_TRUE)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps blockport-on-virtualchannel-recovery");
        }

        /*Code for the execution of aps map vlan-group */
        nmhGetFsErpsRingProtectedVlanGroupId (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4RetValFsErpsRingVlanGroupId);

        if (i4RetValFsErpsRingVlanGroupId != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps map vlan-group ");
            CliPrintf (CliHandle, "%d", i4RetValFsErpsRingVlanGroupId);
        }

        MEMSET (au1VlanGroupList, 0, MAX_ERPS_VLAN_GROUP_LIST_SIZE);
        /* Code for the excution of aps map vlan-group-list */
        VlanGroupList.pu1_OctetList = au1VlanGroupList;

        nmhGetFsErpsRingProtectedVlanGroupList (u4FsErpsContextId,
                                                u4FsErpsRingId, &VlanGroupList);

        /* Code to verify the execution of command: aps vlan-group-list  */
        /* Compare the vlan group list value with the default vlan group list 
           If it is not equal , then the command has been configured */
        if (VlanGroupList.i4_Length != 0)
        {
            /* Scanning the vlan group list bitmap to identify the vlan group id's mapped to 
               the ring */
            for (u2Index = 1; u2Index <= (ERPS_MAX_VLAN_GROUP_LIST * 8);
                 u2Index++)
            {
                OSIX_BITLIST_IS_BIT_SET (VlanGroupList.pu1_OctetList,
                                         u2Index, ERPS_MAX_VLAN_GROUP_LIST,
                                         bResult);
                if (bResult == OSIX_FALSE)
                {
                    /* If the bit is not set, continue */
                    continue;
                }
                else
                {
                    /* Vlan group id can be configured using two CLI commands :
                     * "aps map vlan-group <short(0-64)>" or "aps map vlan-group-list <vlan_list>" 
                     * But if Vlan Group Id is configured using CLI command "aps map vlan-group <short(0-64)>" 
                     * then SRC must not display the same in" aps map vlan-group-list <vlan_list>"CLI command 
                     * as this command was never invoked,This if check avoids the same*/

                    if (u2Index == i4RetValFsErpsRingVlanGroupId)
                    {
                        continue;
                    }
                    /*If vlan-group-list is configured and
                     *bit is set and Flag is true print the Vlan-Group-list value */
                    if (u1Flag == ERPS_SNMP_TRUE)
                    {
                        /*print the corresponding vlan group id */
                        CliPrintf (CliHandle, "\r\n");
                        CliPrintf (CliHandle, "aps map vlan-group-list ");
                        CliPrintf (CliHandle, "%d", u2Index);
                        u1Flag = ERPS_SNMP_FALSE;
                        continue;
                    }
                    else
                    {
                        /* If the bit is set and Flag is False
                         * print the corresponding vlan group id */
                        CliPrintf (CliHandle, ",%d", u2Index);
                    }
                }
            }
            /*Re initialising the flag to display the next ring group list */
            u1Flag = ERPS_SNMP_TRUE;
        }
        /*Code for the execution of aps mac-id */
        nmhGetFsErpsRingMacId (u4FsErpsContextId,
                               u4FsErpsRingId, &i4RetValFsErpsRingMacId);
        if (i4RetValFsErpsRingMacId != 1)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps mac-id ");
            CliPrintf (CliHandle, "%d", i4RetValFsErpsRingMacId);
        }

        /*Code for the execution of  aps protection-type */
        nmhGetFsErpsRingProtectionType (u4FsErpsContextId,
                                        u4FsErpsRingId,
                                        &i4RetValFsErpsRingProtectionType);

        if (i4RetValFsErpsRingProtectionType != ERPS_PORT_BASED_PROTECTION)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps protection-type service-based");
        }

        if (i4FsErpsRingRowStatus == ACTIVE)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps group active");
        }

        nmhGetFsErpsRingMonitorMechanism (u4FsErpsContextId, u4FsErpsRingId,
                                          &i4MonitoringMechanism);

        if (i4MonitoringMechanism != ERPS_MONITOR_MECH_CFM)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps monitor mplsoam");

            /*code to display Mpls Pw Configuration */
            ErpsShowRunningConfigRingMplsCmd (CliHandle, u4FsErpsContextId,
                                              u4FsErpsRingId);
        }

        nmhGetFsErpsRingConfigFailureOfProtocol (u4FsErpsContextId,
                                                 u4FsErpsRingId,
                                                 &i4RetValFsErpsRingConfigFailureOfProtocol);
        if (i4RetValFsErpsRingConfigFailureOfProtocol != OSIX_DISABLED)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ring failureOfProtocol enable");
        }

        MEMSET (&KValue, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
        KValue.pu1_OctetList = au1KValue;
        nmhGetFsErpsRingConfigKValue (u4FsErpsContextId, u4FsErpsRingId,
                                      &KValue);
        pKValue = &KValue;
        if (STRCMP (KValue.pu1_OctetList, "") != 0)
        {
            if (ERPS_OCTETSTRING_TO_FLOAT (pKValue, f4KValue) == EOF)
            {
                ERPS_GLOBAL_TRC
                    ("ERPS_OCTETSTRING_TO_FLOAT: conversion of kvalue"
                     " from octet string to float is failed.\r\n");
            }
            else if (f4KValue != ERPS_KVALUE_DEF_VAL)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "aps kvalue ");
                CliPrintf (CliHandle, "%s ", KValue.pu1_OctetList);
                CliPrintf (CliHandle, "\r\n");
            }
        }
        /*Code execution of ring port presence */
        nmhGetFsErpsRingConfigIsPort1Present (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4RetValFsErpsRingIsPort1Present);
        if (i4RetValFsErpsRingIsPort1Present == ERPS_PORT_IN_REMOTE_LINE_CARD)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ring port1 remote");
        }

        nmhGetFsErpsRingConfigIsPort2Present (u4FsErpsContextId,
                                              u4FsErpsRingId,
                                              &i4RetValFsErpsRingIsPort2Present);
        if (i4RetValFsErpsRingIsPort2Present == ERPS_PORT_IN_REMOTE_LINE_CARD)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps ring port2 remote");
        }

        nmhGetFsErpsRingConfigInfoDistributingPort (u4FsErpsContextId,
                                                    u4FsErpsRingId,
                                                    &i4FsErpsRingConfigInfoDistributingPort);
        if (i4FsErpsRingConfigInfoDistributingPort != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps distribute ");
            MEMSET (ai1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
            CfaCliConfGetIfName (i4FsErpsRingConfigInfoDistributingPort,
                                 ai1IfName);
            CliPrintf (CliHandle, "%s ", ai1IfName);
        }

        pPortList = (tPortListExt *) FsUtilAllocBitList (sizeof (tPortListExt));

        if (pPortList == NULL)
        {
            ERPS_GLOBAL_TRC
                ("ErpsShowRunningConfigRingCmds :Memory allocation failed for SubPortList\r\n");
            return CLI_FAILURE;
        }

        MEMSET (pPortList, 0, sizeof (tPortListExt));

        SubPortList.pu1_OctetList = (UINT1 *) pPortList;
        SubPortList.i4_Length = 0;

        /*This is modified w.r.t VPLS-RES SIT BUG-11374 */
        nmhGetFsErpsRingPort1SubPortList (u4FsErpsContextId, u4FsErpsRingId,
                                          &SubPortList);
        if (SubPortList.i4_Length != 0)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps working subportlist ");
            ErpsCliShowSubPortList (CliHandle, SubPortList.pu1_OctetList);
        }
        MEMSET (pPortList, 0, sizeof (tPortListExt));
        /*MEMSET (SubPortList.pu1_OctetList, 0, MAX_ERPS_CLI_BUF_LEN); */
        SubPortList.i4_Length = 0;

        nmhGetFsErpsRingPort2SubPortList (u4FsErpsContextId, u4FsErpsRingId,
                                          &SubPortList);
        if (SubPortList.i4_Length != 0)
        {
            CliPrintf (CliHandle, " subportlist ");
            ErpsCliShowSubPortList (CliHandle, SubPortList.pu1_OctetList);
            CliPrintf (CliHandle, "\r\n");
        }
        nmhGetFsErpsRingServiceType (u4FsErpsContextId, u4FsErpsRingId,
                                     &i4ServiceType);

        if (i4ServiceType == ERPS_SERVICE_MPLS_LSP_PW)
        {
            CliPrintf (CliHandle, "\b ");
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps service mpls-lsp-pw");
        }
        else if (i4ServiceType == ERPS_SERVICE_MPLS_PW)
        {
            CliPrintf (CliHandle, "\b ");
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps service mpls-pw");
        }
        else if (i4ServiceType == ERPS_SERVICE_MPLS_LSP)
        {
            CliPrintf (CliHandle, "\b ");
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps service mpls-lsp");
        }

        FsUtilReleaseBitList ((UINT1 *) pPortList);
        CliPrintf (CliHandle, "\r\n!\r\n");

    }
    while (nmhGetNextIndexFsErpsRingTable
           (u4FsErpsContextId, &u4FsErpsContextIdNext, u4FsErpsRingId,
            &u4FsErpsRingIdNext) != SNMP_FAILURE);

    UNUSED_PARAM(RingNodeId);
    UNUSED_PARAM(i4FsErpsRingInnerVlanId);
    UNUSED_PARAM(au1MacStr);
    return CLI_SUCCESS;

}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigRingCfmCmd
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    cfm table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                    u4FsErpsContextId - Context Identifier
 *                    u4FsErpsRingId    - Ring    Identifier
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsShowRunningConfigRingCfmCmd (tCliHandle CliHandle, UINT4 u4FsErpsContextId,
                                 UINT4 u4FsErpsRingId)
{
    UINT4               u4FsErpsRingMEG1 = 0;
    UINT4               u4FsErpsRingCfmMEP1 = 0;
    UINT4               u4FsErpsRingCfmME1 = 0;
    UINT4               u4FsErpsRingMEG2 = 0;
    UINT4               u4FsErpsRingCfmME2 = 0;
    UINT4               u4FsErpsRingCfmMEP2 = 0;
    INT4                i4FsErpsRingCfmRowStatus = 0;

    nmhGetFsErpsRingMEG1 (u4FsErpsContextId, u4FsErpsRingId, &u4FsErpsRingMEG1);
    nmhGetFsErpsRingCfmME1 (u4FsErpsContextId, u4FsErpsRingId,
                            &u4FsErpsRingCfmME1);
    nmhGetFsErpsRingCfmMEP1 (u4FsErpsContextId, u4FsErpsRingId,
                             &u4FsErpsRingCfmMEP1);
    nmhGetFsErpsRingMEG2 (u4FsErpsContextId, u4FsErpsRingId, &u4FsErpsRingMEG2);
    nmhGetFsErpsRingCfmME2 (u4FsErpsContextId, u4FsErpsRingId,
                            &u4FsErpsRingCfmME2);
    nmhGetFsErpsRingCfmMEP2 (u4FsErpsContextId, u4FsErpsRingId,
                             &u4FsErpsRingCfmMEP2);

    if (nmhGetFsErpsRingCfmRowStatus
        (u4FsErpsContextId, u4FsErpsRingId,
         &i4FsErpsRingCfmRowStatus) == SNMP_SUCCESS)
    {
        if ((i4FsErpsRingCfmRowStatus == ACTIVE)
            || (i4FsErpsRingCfmRowStatus == NOT_IN_SERVICE))
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps working meg ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingMEG1);

            CliPrintf (CliHandle, "me ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingCfmME1);

            CliPrintf (CliHandle, "mep ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingCfmMEP1);

            CliPrintf (CliHandle, "meg ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingMEG2);

            CliPrintf (CliHandle, "me ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingCfmME2);

            CliPrintf (CliHandle, "mep ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingCfmMEP2);

        }
    }
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigRingTmrCmd
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    timer command.
 *
 * INPUT            : CliHandle   - Handle to the CLI
 *                    u4FsErpsContextId - Context Identifier
 *                    u4FsErpsRingId    - Ring    Identifier
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsShowRunningConfigRingTmrCmd (tCliHandle CliHandle, UINT4 u4FsErpsContextId,
                                 UINT4 u4FsErpsRingId)
{
    UINT4               u4FsErpsRingConfigHoldOffTime = 0;
    UINT4               u4FsErpsRingConfigGuardTime = 0;
    UINT4               u4FsErpsRingConfigPeriodicTime = 0;
    UINT4               u4FsErpsRingConfigVcPeriodicTime = 0;

    nmhGetFsErpsRingConfigHoldOffTime (u4FsErpsContextId, u4FsErpsRingId,
                                       &u4FsErpsRingConfigHoldOffTime);

    nmhGetFsErpsRingConfigGuardTime (u4FsErpsContextId, u4FsErpsRingId,
                                     &u4FsErpsRingConfigGuardTime);

    nmhGetFsErpsRingConfigPeriodicTime (u4FsErpsContextId, u4FsErpsRingId,
                                        &u4FsErpsRingConfigPeriodicTime);

    nmhGetFsErpsRingConfigExtVCRecoveryPeriodicTime (u4FsErpsContextId,
                                                     u4FsErpsRingId,
                                                     &u4FsErpsRingConfigVcPeriodicTime);
    /*In case, all the timers have default values, then return */
    if (u4FsErpsRingConfigVcPeriodicTime != ERPS_VC_REC_PERIODIC_TMR_DEF_VAL)
    {
        CliPrintf (CliHandle, "\r\n");
        CliPrintf (CliHandle, "aps virtual channel recovery periodic time ");
        CliPrintf (CliHandle, "%u  ", u4FsErpsRingConfigVcPeriodicTime);
        CliPrintf (CliHandle, "milliseconds ");
    }

    if ((u4FsErpsRingConfigPeriodicTime == ERPS_PERIODIC_TMR_DEF_VAL)
        && (u4FsErpsRingConfigHoldOffTime == ERPS_HOLD_OFF_TMR_DEF_VAL)
        && (u4FsErpsRingConfigGuardTime == ERPS_GUARD_TMR_DEF_VAL))
    {
        return;
    }

    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "aps timers ");

    if (u4FsErpsRingConfigPeriodicTime != ERPS_PERIODIC_TMR_DEF_VAL)
    {
        CliPrintf (CliHandle, "periodic ");
        CliPrintf (CliHandle, "%u ", u4FsErpsRingConfigPeriodicTime);
        CliPrintf (CliHandle, "milliseconds ");
    }

    if (u4FsErpsRingConfigHoldOffTime != ERPS_HOLD_OFF_TMR_DEF_VAL)
    {
        CliPrintf (CliHandle, "hold-off ");
        CliPrintf (CliHandle, "%u ", u4FsErpsRingConfigHoldOffTime);
        CliPrintf (CliHandle, "milliseconds ");
    }

    if (u4FsErpsRingConfigGuardTime != ERPS_GUARD_TMR_DEF_VAL)
    {
        CliPrintf (CliHandle, "guard ");
        CliPrintf (CliHandle, "%u ", u4FsErpsRingConfigGuardTime);
        CliPrintf (CliHandle, "milliseconds ");
    }
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigTcTable 
 *
 * DESCRIPTION      : This function displays the topology change
 *                    list for a ring 
 *
 * INPUT            : u4ContextId - Context Identifier
 *                    
 * OUTPUT           : pi1ModeName - Mode String
 *                    pi1DispStr - Display string
 *
 * RETURNS          : CLI_SUCCESS/CLI_FAILURE
 * 
 **************************************************************************/
INT4
ErpsShowRunningConfigTcTable (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4RingId)
{
    UINT4               u4NextContextId = ERPS_INVALID_CONTEXT_ID;
    UINT4               u4NextRingId = 0;
    UINT4               u4TcId = 0;
    UINT4               u4NextTcProgId = 0;
    BOOL1               b1DisplayFlag = OSIX_TRUE;

    if (nmhGetNextIndexFsErpsRingTcPropTable (u4ContextId, &u4NextContextId,
                                              u4RingId, &u4NextRingId,
                                              0, &u4NextTcProgId)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    do
    {
        if ((u4ContextId != (UINT4) u4NextContextId) ||
            (u4RingId != u4NextRingId))
        {
            break;
        }

        if (b1DisplayFlag == OSIX_TRUE)
        {
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "aps propagate-tc");
            CliPrintf (CliHandle, " ring-ids ");
            b1DisplayFlag = OSIX_FALSE;
        }

        u4TcId = u4NextTcProgId;
        CliPrintf (CliHandle, "%u", u4TcId);
    }
    while (nmhGetNextIndexFsErpsRingTcPropTable (u4ContextId, &u4NextContextId,
                                                 u4RingId, &u4NextRingId,
                                                 u4TcId, &u4NextTcProgId)
           == SNMP_SUCCESS);

    return CLI_SUCCESS;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsCliShowSubPortList 
 *
 * DESCRIPTION      : This function displays the Ring Port's subPortList 
 *                    configuration. It converts the format Ifindex1, IfIndex2,
 *                    .., ifIndexn to the format Ifname 1, 2, 3, ,,n.
 *                    (e.g) Input format - 121, 122
 *                          CLI display  - pw 1, 2 since the Input CFA indices
 *                          starts from the range 121. 122.. 
 *
 * INPUT            : CliHandle - CLI Handle
 *                    pu1OctetList - Input format structure
 *                    
 * OUTPUT           : None 
 *
 * RETURNS          : None
 * 
 **************************************************************************/
VOID
ErpsCliShowSubPortList (tCliHandle CliHandle, UINT1 *pu1OctetList)
{
    tSNMP_OCTET_STRING_TYPE OctetString;
    UINT4              *pu4PortArray = NULL;
    tPortListExt       *pPortList = NULL;
    INT4                i4Index = 0;
    UINT4               u4PagingStatus = 0;

    pu4PortArray = (UINT4 *) MemAllocMemBlk (ERPS_PORT_ARRAY_POOLID ());
    if (pu4PortArray == NULL)
    {
        ERPS_GLOBAL_TRC ("Memory allocation failed for PortArray\r\n");
        return;
    }
    MEMSET (pu4PortArray, 0, sizeof (UINT4) * MAX_ERPS_SUB_PORT_LIST_SIZE);

    pPortList = (tPortListExt *) FsUtilAllocBitList (sizeof (tPortListExt));

    if (pPortList == NULL)
    {
        ERPS_GLOBAL_TRC ("Memory allocation failed for PortList\r\n");
        MemReleaseMemBlock (ERPS_PORT_ARRAY_POOLID (), (UINT1 *) pu4PortArray);
        return;
    }

    MEMSET (&OctetString, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    MEMSET (*pPortList, 0, sizeof (tPortListExt));

    OctetString.pu1_OctetList = (UINT1 *) pPortList;
    OctetString.i4_Length = BRG_PORT_LIST_SIZE_EXT;
    /* OctetString is converted to array of ports format. */
    if (OSIX_FAILURE == ConvertStrToPortArray (pu1OctetList,
                                               pu4PortArray,
                                               MAX_ERPS_SUB_PORT_LIST_SIZE,
                                               ERPS_SYS_DEF_MAX_INTERFACES))
    {
        FsUtilReleaseBitList ((UINT1 *) pPortList);
        MemReleaseMemBlock (ERPS_PORT_ARRAY_POOLID (), (UINT1 *) pu4PortArray);
        return;
    }

    for (i4Index = 0; i4Index < MAX_ERPS_SUB_PORT_LIST_SIZE; i4Index++)
    {
        if (0 == pu4PortArray[i4Index])
        {
            break;
        }
        OSIX_BITLIST_SET_BIT ((*pPortList), pu4PortArray[i4Index],
                              BRG_PORT_LIST_SIZE_EXT);
    }                            /* End of for */

    /* This CLI utility is invoked to print the interface alias names with 
     * correct indices. 
     */
    CliConfOctetToIfName (CliHandle, " ", NULL, &OctetString, &u4PagingStatus);
    FsUtilReleaseBitList ((UINT1 *) pPortList);
    MemReleaseMemBlock (ERPS_PORT_ARRAY_POOLID (), (UINT1 *) pu4PortArray);
    return;
}
#ifdef VSI_WANTED
/****************************************************************************/
/* FUNCTION NAME    : ErpsCliShowDataVepList				                */
/*									                                        */	
/* DESCRIPTION      : This function displays the Data-Vep		            */
/*                    associated with the given ring.			            */
/*									                                        */
/* INPUT            : CliHandle - CLI Handle				                */
/*                    pDataVepList - Pointer to the list holding the	    */
/*				      Data Vep's				                            */
/*									                                        */
/* OUTPUT           : None						                            */
/*									                                        */
/* RETURNS          : None						                            */	
/****************************************************************************/
VOID
ErpsCliShowDataVepList (tCliHandle CliHandle, tTMO_SLL * pList)
{
    tTMO_SLL_NODE	    *pNode = NULL;
    tErpsRingDataVep	    *pRingDataVep = NULL;
    UINT1                    u1PortStatus = 0;
    UINT2                    u2InstanceId = 0;
    INT1		     ai1IfNamePort[CFA_MAX_PORT_NAME_LENGTH];

    CliPrintf (CliHandle, "%-20s%-15s\r\n", "Data Port", "Port Status");
    CliPrintf (CliHandle, "-------------------------------\r\n");

    TMO_SLL_Scan (pList, pNode, tTMO_SLL_NODE *)
    {
	    MEMSET (ai1IfNamePort, 0, sizeof (ai1IfNamePort));
	    pRingDataVep = (tErpsRingDataVep *) pNode;
	    CfaCliGetIfName (pRingDataVep->u4DataVep1Index, ai1IfNamePort);
        u1PortStatus = ErpsPortL2IwfGetInstPortState (u2InstanceId,
                                                pRingDataVep->u4DataVep1Index);
        CliPrintf (CliHandle, "%-20s", ai1IfNamePort);
        if (u1PortStatus == ERPS_PORT_STATE_BLOCKING)
        {
            CliPrintf (CliHandle, "%-15s\r\n", "Blocked");
        }
        else
        {
            CliPrintf (CliHandle, "%-15s\r\n", "Unblocked");
        }
        if (pRingDataVep->u4DataVep2Index != 0)
        {
	        CfaCliGetIfName (pRingDataVep->u4DataVep2Index, ai1IfNamePort);
            u1PortStatus = ErpsPortL2IwfGetInstPortState (u2InstanceId,
                                                pRingDataVep->u4DataVep2Index);
            CliPrintf (CliHandle, "%-20s", ai1IfNamePort);
            if (u1PortStatus == ERPS_PORT_STATE_BLOCKING)
            {
                CliPrintf (CliHandle, "%-15s\r\n", "Blocked");
            }
            else
            {
                CliPrintf (CliHandle, "%-15s\r\n", "Unblocked");
            }
        }
    }

}
#endif
/***************************************************************************
 * FUNCTION NAME    : ErpsCliHandleFailureSubPortList
 *
 * DESCRIPTION      : This function handles the cleanup of SubPortList 
 *                    configuration. 
 *
 * INPUT            : CliHandle - CLI Handle
 *                    PortList - Memory to be freed in to the CLI pool.
 *
 * OUTPUT           : None
 *
 * RETURNS          : None
 *
 **************************************************************************/
VOID
ErpsCliHandleFailureSubPortList (UINT1 *Port1List, UINT1 *Port2List)
{
    if (NULL != Port1List)
    {
        MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                            (UINT1 *) Port1List);
    }

    if (NULL != Port2List)
    {
        MemReleaseMemBlock (gErpsGlobalInfo.ErpsCliMemblkBufPoolId,
                            (UINT1 *) Port2List);
    }
    return;
}

/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigRingMplsCmd
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    Mpls table.
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                    u4FsErpsContextId - Context Identifier
 *                    u4FsErpsRingId    - Ring    Identifier
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsShowRunningConfigRingMplsCmd (tCliHandle CliHandle, UINT4 u4FsErpsContextId,
                                  UINT4 u4FsErpsRingId)
{
    UINT4               u4FsErpsRingPwVcId1 = 0;
    UINT4               u4FsErpsRingPwVcId2 = 0;
    INT4                i4FsErpsRingMplsRowStatus = 0;

    nmhGetFsErpsRingPwVcId1 (u4FsErpsContextId, u4FsErpsRingId,
                             &u4FsErpsRingPwVcId1);
    nmhGetFsErpsRingPwVcId2 (u4FsErpsContextId, u4FsErpsRingId,
                             &u4FsErpsRingPwVcId2);

    if ((nmhGetFsErpsRingMplsRowStatus
         (u4FsErpsContextId, u4FsErpsRingId,
          &i4FsErpsRingMplsRowStatus) == SNMP_SUCCESS) &&
        (u4FsErpsRingPwVcId1 != 0) && (u4FsErpsRingPwVcId2 != 0))
    {
        if ((i4FsErpsRingMplsRowStatus == ACTIVE)
            || (i4FsErpsRingMplsRowStatus == NOT_IN_SERVICE))
        {
            CliPrintf (CliHandle, "\r\n");

            CliPrintf (CliHandle, "aps working pseudo-wire ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingPwVcId1);

            CliPrintf (CliHandle, " pseudo-wire ");

            CliPrintf (CliHandle, "%u ", u4FsErpsRingPwVcId2);

        }
    }
    return;
}
#ifdef VSI_WANTED
/***************************************************************************
 * FUNCTION NAME    : ErpsShowRunningConfigDataVep
 *
 * DESCRIPTION      : This function used in show running config of the ring 
 *                    data-vep
 *
 * INPUT            : CliHandle   - Handle to the CLI 
 *                    u4FsErpsContextId - Context Identifier
 *                    u4FsErpsRingId    - Ring    Identifier
 *
 * OUTPUT           : None.                                
 * 
 * RETURNS          : CLI_SUCCESS / CLI_FAILURE
 * 
 **************************************************************************/
VOID
ErpsShowRunningConfigDataVep (tCliHandle CliHandle, UINT4 u4FsErpsContextId,
                              UINT4 u4FsErpsRingId)
{
    tErpsRingInfo           *pRingInfo = NULL;
    tTMO_SLL_NODE           *pNode = NULL;
    tErpsRingDataVep        *pRingDataVep = NULL;
    CHR1                     ai1DataVep[40];
    INT1		             ai1IfNameVep1[CFA_MAX_PORT_NAME_LENGTH];
    INT1		             ai1IfNameVep2[CFA_MAX_PORT_NAME_LENGTH];

    pRingInfo = ErpsRingGetRingEntry (u4FsErpsContextId, u4FsErpsRingId);
    if (pRingInfo == NULL)
    {
        return;
    }
    TMO_SLL_Scan (&(pRingInfo->RingDataVepList), pNode, tTMO_SLL_NODE *)
    {
	    MEMSET (ai1IfNameVep1, 0, sizeof (ai1IfNameVep1));
	    MEMSET (ai1IfNameVep2, 0, sizeof (ai1IfNameVep2));
	    pRingDataVep = (tErpsRingDataVep *) pNode;
	    CfaCliGetIfName (pRingDataVep->u4DataVep1Index, ai1IfNameVep1);
	    CfaCliGetIfName (pRingDataVep->u4DataVep2Index, ai1IfNameVep2);
	    SNPRINTF (ai1DataVep, sizeof (ai1DataVep), "%s %s vsi %d", ai1IfNameVep1,
                                   ai1IfNameVep2, pRingDataVep->u4DataVsiId);
	    CliPrintf (CliHandle, "\r\naps map working-data-vep %s\r\n", ai1DataVep);
    }
}
#endif
#endif /* _ERPSCLI_C_ */
