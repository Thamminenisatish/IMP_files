/********************************************************************
 * Copyright (C) 2007 Aricent Inc . All Rights Reserved]
 *
 * $Id: cfmcli.c,v 1.27 2021/09/16 07:55:27 siva Exp $
 *
 * Description:  This file contains CLI SET/GET/TEST and GETNEXT
 *               routines for the MIB objects specified in fsecfm.mib
 *               and fsecfmex.mib
 *******************************************************************/

#ifndef __ECFMCLI_C
#define __ECFMCLI_C

#include "cfminc.h"
#include "fsmiy1cli.h"
#include "fscfmecli.h"
#include <time.h>

#ifdef DCSG_EXT_WANTED
#ifdef NPAPI_WANTED 
extern UINT1               gu1EcfmHwGlobalOffEnable;
#endif
#endif
PRIVATE INT4 EcfmStrToLevelList PROTO ((UINT1 *, UINT1 *, UINT4, UINT2 *));
PRIVATE VOID EcfmTstSignalHandler PROTO ((INT4));
PRIVATE VOID EcfmThSignalHandler PROTO ((INT4));
PRIVATE INT4        EcfmConfigY1731LbmParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, tEcfmLbLtTransRequest *,
        BOOL1 *));
PRIVATE INT4        EcfmConfigLbmParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, tEcfmLbLtTransRequest *,
        BOOL1 *));
PRIVATE INT4 EcfmSetCcRole PROTO ((tCliHandle, UINT4, UINT4, UINT4, INT4));
PRIVATE VOID EcfmShowErrorLog PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE VOID        EcfmDisplayFDEntries
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, UINT1 *));
PRIVATE VOID        EcfmDisplayLbrCacheBrief
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1));
PRIVATE VOID        EcfmDisplayLbrCache
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1));
PRIVATE INT4 EcfmClearGlobalStats PROTO ((tCliHandle, UINT4));
PRIVATE INT4        EcfmClearMepStats
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT1 *, UINT1 *, INT4));
PRIVATE INT4 EcfmClearCtxorPortStats PROTO ((tCliHandle, UINT4, UINT4));
PRIVATE VOID        EcfmDisplayMepInfo
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE VOID        MplsOamDisplayMepInfo
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE INT4        EcfmConfigDMParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, INT4, UINT1 *, UINT1 *,
        UINT1 *, UINT1 *, BOOL1 *, BOOL1 *, UINT1 *, UINT4 *));
PRIVATE INT4        EcfmConfigProactiveDMParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, INT4 , UINT1 *, UINT1 *,
        UINT1 *, UINT1 *, BOOL1 *, BOOL1 *, UINT1 *, UINT4 *));
PRIVATE INT4        EcfmSetMepCapability
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, UINT4));
PRIVATE INT4        EcfmConfigY1731LtmParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, UINT4, UINT1 *, UINT4, INT4,
        UINT4, BOOL1 *));
PRIVATE VOID        EcfmGetErroredLbrsCount
PROTO ((UINT4, UINT4, UINT4, UINT4, UINT4, UINT4 *, UINT4 *));
PRIVATE VOID        EcfmGetInvalidLbrsCount
PROTO ((UINT4, UINT4, UINT4, UINT4, UINT4, UINT4 *, UINT4 *));
PRIVATE INT4        EcfmSetY1731CcEnableStatus
PROTO ((tCliHandle, UINT4, UINT4, UINT4, INT4, BOOL1));
PRIVATE VOID        EcfmShowRMepY1731Defects
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, UINT4, INT1, BOOL1));
PRIVATE VOID        MplsOamShowRMepY1731Defects
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, UINT4, INT1, BOOL1));
PRIVATE UINT1 EcfmGetBit PROTO ((UINT1 *));
PRIVATE INT2 EcfmGetNumOfRMeps PROTO ((UINT4, UINT4, UINT4, UINT4));
PRIVATE INT4        EcfmConfigLMParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, UINT1 *, UINT1 *,
        UINT1 *, INT4, BOOL1 *, BOOL1 *));
PRIVATE INT4        EcfmConfigSLMOnDemandParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, UINT1 *, UINT1 *,
        INT4,INT4,INT4,INT4, INT4, BOOL1 *, BOOL1 *));

PRIVATE INT4        EcfmConfigSLMProActiveParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, BOOL1, UINT1 *, UINT1 *,
        INT4,INT4,INT4,INT4,INT4, INT4, INT4,INT4,INT4,UINT1 *,UINT4,INT4,BOOL1 *, BOOL1 *));
PRIVATE VOID        EcfmDisplayFLEntriesBrief
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE VOID        EcfmDisplayFLEntriesDetail
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE INT4        EcfmConfigTstParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, tEcfmLbLtTransRequest *,
        BOOL1 *));
PRIVATE INT4        EcfmConfigThParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4, UINT4, tEcfmLbLtThTransRequest *,
        BOOL1 *, UINT4));
PRIVATE VOID        EcfmGetSeqNumFrmErrLog
PROTO ((UINT4, UINT4, UINT4, UINT4, UINT4 *, UINT4 *));
PRIVATE INT4        EcfmGetY1731Status
PROTO ((tCliHandle, UINT4, UINT4, UINT1 *, UINT4, INT4, INT4, UINT1 *,
        UINT1 *, UINT1, UINT4 *));
PRIVATE tEcfmLbLtCliEvInfo *EcfmInitLbLtCliEventInfo PROTO ((tCliHandle));
PRIVATE VOID EcfmDeInitLbLtCliEventInfo PROTO ((tCliHandle));
PRIVATE VOID        EcfmPrintDropEnable (tCliHandle, INT4, UINT4, UINT4, UINT4);
PRIVATE VOID        EcfmPrintServicePriority (tCliHandle, INT4, UINT4, UINT4,
                                              UINT4, UINT1);
PRIVATE VOID        EcfmPrintCapability (tCliHandle, INT4, UINT4, UINT4, UINT4,
                                         UINT1);
PRIVATE VOID        EcfmPrintTimerInterval (tCliHandle, INT4, INT4, UINT4,
                                            INT4, UINT4);
PRIVATE VOID        EcfmMaMepListPrint (tCliHandle, UINT4, UINT4, UINT4, UINT1);
PRIVATE VOID        EcfmPrintTrapControl (tCliHandle, UINT4, UINT1);
PRIVATE VOID        EcfmMaListPrint (tCliHandle, UINT4, UINT4, UINT4, UINT1);
PRIVATE INT4        EcfmSearchMepIdInMA (UINT4, UINT4, UINT4);
PRIVATE INT4        EcfmCliValidateMdNameFormatForMac
PROTO ((UINT1 *pu1TestName, INT4 i4TestLength));
PRIVATE VOID        MplsOamShowXchkParams
PROTO ((tCliHandle CliHandle, UINT4 u4Type, UINT4 u4ContextId,
        UINT4 u4MdId, UINT4 u4MaId, BOOL1 b1Header));
PRIVATE VOID        MplsOamShowXchkStatus
PROTO ((tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdId, BOOL1 b1Header));
PRIVATE INT4        EcfmMpTpMepListPrint
PROTO ((tCliHandle CliHandle, UINT4, UINT4, UINT4, UINT4));
PRIVATE VOID EcfmUtilGetMaName PROTO ((UINT4, UINT4, UINT4, UINT1 *));
PRIVATE INT4        EcfmConfigAvailParams
PROTO ((tCliHandle, UINT4, UINT4, UINT4,
        UINT4, BOOL1, UINT1 *, UINT1 *, INT4,
        UINT1 *, UINT1 *, UINT1 *, UINT1 *, UINT1 *, INT4, INT4, BOOL1 *));
extern INT1
nmhGetFsPmonEthCfmAssocRowStatus ARG_LIST((tSNMP_OCTET_STRING_TYPE *,INT4 *));
extern INT4 EcfmCliShowProactiveFDBuffer (tCliHandle CliHandle, UINT4 u4ContextId,UINT4 u4PortId, UINT4 u4Command,
                                         INT4 i4DelayType, UINT4 u4TstId,UINT1 *pu1PeerMacAddr, UINT1 *pu1Arg1, UINT1 *pu1Arg2,UINT1 *pu1MdName);
extern INT4 EcfmCliInitProactiveDM (tCliHandle CliHandle,UINT4 u4ContextId, UINT4 u4Command,INT4 i4DelayType, INT4 i4Dir,
                                    UINT1 *pu1Arg1, UINT1 *pu1Arg2,UINT1 *pu1Arg3, UINT1 *pu1Arg4,UINT1 *pu1Arg5, UINT1 *pu1Arg6, UINT4 u4IfIndex,
                                    UINT1 *pu1MdName, UINT1 *patternSize, UINT4 *dataPattern);
extern INT4 EcfmCliStopProactiveDM (tCliHandle CliHandle,UINT4 u4ContextId, UINT4 u4Command,INT4 i4Dir, UINT1 *pu1Arg1,
                                    UINT1 *pu1Arg2, UINT4 u4IfIndex, UINT1 *pu1MdName,UINT1 *pu1Arg3, UINT1 *pu1Arg4);
extern VOID EcfmCliShowSummary (tCliHandle CliHandle);


UINT1
     
     
     
     
     
     
     
    gau1ModuleName[ECFM_MAX_SRC_MODULE][ECFM_SRC_MODULE_NAME_LEN] =
    { "ethernet cfm", "y1731-mplstp oam" };

BOOL1
    EcfmCliMepValidateLbmTarget PROTO ((tCliHandle CliHandle,
                                        UINT1 u1DestType,
                                        UINT4 u4ContextId,
                                        UINT4 u4MdIndex,
                                        UINT4 u4MaIndex,
                                        UINT4 u4MepId, UINT4 *pu4Target));

BOOL1
    EcfmCliMepValidateLtmTarget PROTO ((tCliHandle, UINT1,
                                        UINT4, UINT4, UINT4, UINT4, UINT4 *));

INT4 EcfmCliGetVlanIsidInfo PROTO ((UINT4 u4ContextId,
                                    UINT4 u4MdLevel,
                                    UINT2 u2LocalPortId,
                                    BOOL1 b1Direction,
                                    UINT2 u2MepIdentifier,
                                    UINT1 *pu1MaName, UINT4 *pu4VlanIsid));
UINT4               gu4EcfmTrcLvl;
/*******************************************************************************
 * 
 *  FUNCTION NAME   : cli_process_ecfm_config_cmd 
 *  
 *  DESCRIPTION     : Protocol CLI Message Handler Function to handle
 *                    configuration messages only.               
 *                                                                        
 *  INPUT           : CliHandle - CliContext ID                           
 *                    u4Command - Command identifier                      
 *                    ... - Variable command argument list                 
 *                                                                        
 *  OUTPUT          : None                                                
 *                                                                        
 *  RETURNS         : CLI_SUCCESS/CLI_FAILURE                             
 *
 ******************************************************************************/
INT4
cli_process_ecfm_config_cmd (tCliHandle CliHandle, UINT4 u4Command, ...)
{
    va_list             ap;
    UINT4              *apu4args[ECFM_CLI_MAX_ARGS];
    UINT4               u4Index = ECFM_INIT_VAL;
    UINT4               u4IfIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4VlanIsid = ECFM_INIT_VAL;
    UINT4               u4VsiId = ECFM_INIT_VAL;
    UINT4               u4OamVlanId = ECFM_INIT_VAL;
    UINT4               u4TempIsid = ECFM_INIT_VAL;
    UINT4               u4EthBnSt = 0;
    UINT4               u4EthBnTrapSt = 0;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT2               u2NoOfMdLevels = ECFM_INIT_VAL;
    UINT2               u2LocalPortId = ECFM_INIT_VAL;
    UINT1              *pu1VlanList = NULL;
    UINT1               au1MdLevelList[MDLEVEL_LIST_SIZE];
    UINT1               au1OuiVal[ECFM_OUI_LENGTH];
    UINT1               au1MdLevel[ECFM_VAL_12];
    UINT1               au1VlanId[ECFM_INDEX_FIVE] = { 0 };
    BOOL1               b1LbLtTskCmd = ECFM_FALSE;
    BOOL1               b1IsUnaware = ECFM_FALSE;
    INT1                i1argno = 0;
    tEcfmMacAddr        MacAddr;
    tSNMP_OCTET_STRING_TYPE LocalClientOui;
    MEMSET (au1OuiVal, 0, ECFM_OUI_LENGTH);
    MEMSET (&MacAddr, 0, ECFM_MAC_ADDR_LENGTH);
    MEMSET (&LocalClientOui, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    LocalClientOui.i4_Length = ECFM_OUI_LENGTH;
    LocalClientOui.pu1_OctetList = &au1OuiVal[0];
    if ((ECFM_IS_SYSTEM_INITIALISED () != ECFM_TRUE) &&
        (u4Command != CLI_ECFM_SYS_CTRL))

    {
        CliPrintf (CliHandle, "\r%% Ethernet CFM module is shutdown\r\n");
        UNUSED_PARAM(u4EthBnSt);
        UNUSED_PARAM(u4EthBnTrapSt);
        return CLI_FAILURE;
    }
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (EcfmCliSelectContextOnMode
        (CliHandle, u4Command, &u4ContextId, &u2LocalPortId, &b1LbLtTskCmd)
        == ECFM_FAILURE)

    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return CLI_FAILURE;
    }
    va_start (ap, u4Command);
    MEMSET (apu4args, 0x0, (ECFM_CLI_MAX_ARGS * sizeof (UINT4 *)));

    /* Third argument is always interface name/index */
    u4IfIndex = va_arg (ap, UINT4);
    UNUSED_PARAM (u4IfIndex);

    /* Walk through the rest of the arguements and store in args array. 
     * Store 16 arguements at the max. This is because vlan commands do not
     * take more than sixteen inputs from the command line. Another reason to
     * store is in some cases first input may be optional but user may give 
     * second input. In that case first arg will be null and second arg only 
     * has value */
    while (1)

    {
        apu4args[i1argno++] = va_arg (ap, UINT4 *);
        if (i1argno == ECFM_CLI_MAX_ARGS)

        {
            break;
        }
    }
    va_end (ap);

    pu1VlanList = UtilVlanAllocVlanListSize (sizeof (tVlanListExt));

    if (pu1VlanList == NULL)
    {
        CliPrintf (CliHandle, "\r\n Error in Allocating Memory for "
                   "Vlan List\r\n");
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return CLI_FAILURE;
    }

    CLI_MEMSET (pu1VlanList, ECFM_INIT_VAL, sizeof (tVlanListExt));

    CLI_SET_ERR (0);
    switch (u4Command)

    {

            /* ***************** Global Config mode commands************* */
            /* Module Start/Shutdown */
        case CLI_ECFM_SYS_CTRL:
            i4RetVal =
                EcfmCliSetSysCtrl (CliHandle,
                                   CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ZERO]));
            break;

            /* Module Enable/Disable */
        case CLI_ECFM_ENABLE_CFM:
            i4RetVal = EcfmCliSetModuleStatusGlobal (CliHandle, ECFM_ENABLE);
            break;
        case CLI_ECFM_DISABLE_CFM:
            i4RetVal = EcfmCliSetModuleStatusGlobal (CliHandle, ECFM_DISABLE);
            break;

            /* CCM Offload Global Module Enable/Disable */
        case CLI_ECFM_CCM_OFFLOAD_ENABLE:
            i4RetVal =
                EcfmCliSetCcmOffLoadModuleStatusGlobal (CliHandle,
                                                        ECFM_CCM_OFFLOAD_ENABLE);
            break;
        case CLI_ECFM_CCM_OFFLOAD_DISABLE:
            i4RetVal =
                EcfmCliSetCcmOffLoadModuleStatusGlobal (CliHandle,
                                                        ECFM_CCM_OFFLOAD_DISABLE);
            break;
        case CLI_ECFM_SET_CCM_OFFLOAD_MEP_ENABLE:
            i4RetVal =
                EcfmMepSetCcmOffLoadMepStatus (CliHandle,
                                               ECFM_CCM_OFFLOAD_ENABLE);
            break;
        case CLI_ECFM_SET_CCM_OFFLOAD_MEP_DISABLE:
            i4RetVal =
                EcfmMepSetCcmOffLoadMepStatus (CliHandle,
                                               ECFM_CCM_OFFLOAD_DISABLE);
            break;
        case CLI_Y1731_MPLSTPOAM_SET_AIS_OFFLOAD_MEP_ENABLE:
            i4RetVal =
                EcfmTpOamMepSetAisOffLoadMepStatus (CliHandle,
                                                    ECFM_MPLSTP_AIS_OFF_ENABLE);
            break;
        case CLI_Y1731_MPLSTPOAM_SET_AIS_OFFLOAD_MEP_DISABLE:
            i4RetVal =
                EcfmTpOamMepSetAisOffLoadMepStatus (CliHandle,
                                                    ECFM_MPLSTP_AIS_OFF_DISABLE);
            break;
            /* CC Interval and Role */
        case CLI_ECFM_DOM_SER_SET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle,
                                          CLI_ECFM_DOM_ISID_SET_CC_INT,
                                          au1MdLevelList, u2NoOfMdLevels,
                                          pu1VlanList, (UINT1 *) &u4TempIsid,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle,
                                          CLI_ECFM_DOM_UNAWARE_SET_CC_INT,
                                          au1MdLevelList, u2NoOfMdLevels,
                                          pu1VlanList, 0,
                                          CLI_PTR_TO_I4 ((UINT1 *) apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            }
            break;

        case CLI_ECFM_DOM_VLAN_SET_CC_INT:
        case CLI_ECFM_DOM_VSI_SET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      ECFM_TRUE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VLAN_SET_CC_INT:
        case CLI_ECFM_LEV_VSI_SET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      ECFM_TRUE, NULL, NULL);
            break;

        case CLI_ECFM_LEV_SER_SET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      ECFM_TRUE,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            break;
        case CLI_ECFM_DOM_ISID_SET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      ECFM_TRUE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_ISID_SET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      ECFM_TRUE, NULL, NULL);
            break;
        case CLI_ECFM_DOM_UNAWARE_SET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]),
                                      ECFM_TRUE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_SET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);

            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]),
                                      ECFM_TRUE, NULL, NULL);
            break;
        case CLI_ECFM_DOM_SER_SET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_ISID_SET_CC_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, (UINT1 *) &u4TempIsid,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                EcfmCliSetCcRole (CliHandle, u4ContextId,
                                  CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            }

            break;
        case CLI_ECFM_DOM_VLAN_SET_CC_ROLE:
        case CLI_ECFM_DOM_VSI_SET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VLAN_SET_CC_ROLE:
        case CLI_ECFM_LEV_VSI_SET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);

            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, NULL);
            break;
        case CLI_ECFM_LEV_SER_SET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);

            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            break;
        case CLI_ECFM_DOM_ISID_SET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, NULL);
            break;
        case CLI_ECFM_LEV_ISID_SET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]),
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_SET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);

            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]),
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOM_SER_SET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_ISID_SET_CC_INT_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, (UINT1 *) &u4TempIsid,
                                      CLI_PTR_TO_I4 (apu4args
                                                     [ECFM_INDEX_THREE]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle,
                                              CLI_ECFM_DOM_ISID_SET_CC_INT_ROLE,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList,
                                              (UINT1 *) &u4TempIsid,
                                              CLI_PTR_TO_I4 (apu4args
                                                             [ECFM_INDEX_TWO]),
                                              ECFM_TRUE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args
                                                     [ECFM_INDEX_THREE]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle,
                                              CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList, 0,
                                              CLI_PTR_TO_I4 (apu4args
                                                             [ECFM_INDEX_TWO]),
                                              ECFM_TRUE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args
                                                     [ECFM_INDEX_THREE]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle, u4Command,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList, 0,
                                              CLI_PTR_TO_I4 (apu4args
                                                             [ECFM_INDEX_TWO]),
                                              ECFM_TRUE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }
            break;
        case CLI_ECFM_DOM_VLAN_SET_CC_INT_ROLE:
        case CLI_ECFM_DOM_VSI_SET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_VLAN_SET_CC_INT_ROLE:
        case CLI_ECFM_LEV_VSI_SET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                  NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE, NULL, NULL);
            }
            break;
        case CLI_ECFM_LEV_SER_SET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          NULL);
            }
            break;
        case CLI_ECFM_DOM_ISID_SET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  CLI_PTR_TO_I4 (apu4args[3]),
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)
            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)
                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_ISID_SET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  CLI_PTR_TO_I4 (apu4args[3]), NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)
            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)
                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_TWO]),
                                          ECFM_TRUE, NULL, NULL);
            }
            break;
        case CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ONE]),
                                          ECFM_TRUE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_UNAWARE_SET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);

            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ONE]),
                                          ECFM_TRUE, NULL, NULL);
            }
            break;
        case CLI_MPLSTPOAM_LEV_SER_SET_CC_INT_ROLE:

            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);

            u4MdLevel = *apu4args[ECFM_INDEX_ZERO];

            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);

            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0,
                                  CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                  NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ONE]),
                                          ECFM_TRUE, NULL, NULL);
            }
            break;
        case CLI_MPLSTPOAM_LEV_SER_SET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);

            u4MdLevel = *apu4args[ECFM_INDEX_ZERO];

            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);

            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0,
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]),
                                      ECFM_TRUE, NULL, NULL);
            break;
            /* Reset to the default conf */
        case CLI_ECFM_DOM_SER_RESET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle,
                                          CLI_ECFM_DOM_ISID_RESET_CC_INT,
                                          au1MdLevelList, u2NoOfMdLevels,
                                          pu1VlanList, (UINT1 *) &u4TempIsid, 0,
                                          ECFM_FALSE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle,
                                          CLI_ECFM_DOM_UNAWARE_RESET_CC_INT,
                                          au1MdLevelList, u2NoOfMdLevels,
                                          pu1VlanList, 0, 0, ECFM_FALSE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_DOM_VSI_RESET_CC_INT:
        case CLI_ECFM_DOM_VLAN_RESET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0, 0,
                                      ECFM_FALSE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VSI_RESET_CC_INT:
        case CLI_ECFM_LEV_VLAN_RESET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0, 0,
                                      ECFM_FALSE, NULL, NULL);
            break;
        case CLI_ECFM_LEV_SER_RESET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0, 0,
                                      ECFM_FALSE,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            break;
        case CLI_ECFM_DOM_ISID_RESET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE], 0,
                                      ECFM_FALSE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_ISID_RESET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE], 0,
                                      ECFM_FALSE, NULL, NULL);
            break;
        case CLI_ECFM_DOM_UNAWARE_RESET_CC_INT:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0, 0,
                                      ECFM_FALSE, NULL, (UINT1 *)
                                      apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_RESET_CC_INT:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                      u2NoOfMdLevels, pu1VlanList, 0, 0,
                                      ECFM_FALSE, NULL, NULL);
            break;
        case CLI_ECFM_DOM_SER_RESET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_ISID_RESET_CC_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, (UINT1 *) &u4TempIsid,
                                      ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_UNAWARE_RESET_CC_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0, ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0, ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_DOM_VSI_RESET_CC_ROLE:
        case CLI_ECFM_DOM_VLAN_RESET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, ECFM_CC_ROLE_FM, NULL,
                                  (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VSI_RESET_CC_ROLE:
        case CLI_ECFM_LEV_VLAN_RESET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, ECFM_CC_ROLE_FM, NULL, NULL);
            break;
        case CLI_ECFM_LEV_SER_RESET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, ECFM_CC_ROLE_FM,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            break;
        case CLI_ECFM_DOM_ISID_RESET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  ECFM_CC_ROLE_FM, NULL, (UINT1 *)
                                  apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_ISID_RESET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  ECFM_CC_ROLE_FM, NULL, NULL);
            break;
        case CLI_ECFM_DOM_UNAWARE_RESET_CC_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, ECFM_CC_ROLE_FM, NULL, (UINT1 *)
                                  apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_RESET_CC_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels, pu1VlanList,
                                  0, ECFM_CC_ROLE_FM, NULL, NULL);
            break;
        case CLI_ECFM_DOM_SER_RESET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_ISID_RESET_CC_INT_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, (UINT1 *) &u4TempIsid,
                                      ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle,
                                              CLI_ECFM_DOM_ISID_RESET_CC_INT_ROLE,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList,
                                              (UINT1 *) &u4TempIsid, 0,
                                              ECFM_FALSE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId,
                                      CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0, ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle,
                                              CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList, 0, 0, ECFM_FALSE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                      au1MdLevelList, u2NoOfMdLevels,
                                      pu1VlanList, 0, ECFM_CC_ROLE_FM,
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                if (i4RetVal == CLI_SUCCESS)

                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }
                    i4RetVal =
                        EcfmCliSetCcInterval (CliHandle, u4Command,
                                              au1MdLevelList, u2NoOfMdLevels,
                                              pu1VlanList, 0, 0, ECFM_FALSE,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO]);
                }

            }

            break;
        case CLI_ECFM_DOM_VSI_RESET_CC_INT_ROLE:
        case CLI_ECFM_DOM_VLAN_RESET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0, ECFM_CC_ROLE_FM, NULL,
                                  (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_VSI_RESET_CC_INT_ROLE:
        case CLI_ECFM_LEV_VLAN_RESET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0, ECFM_CC_ROLE_FM, NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE, NULL, NULL);
            }
            break;
        case CLI_ECFM_LEV_SER_RESET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0, ECFM_CC_ROLE_FM,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE], NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                          NULL);
            }
            break;
        case CLI_ECFM_DOM_ISID_RESET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  ECFM_CC_ROLE_FM, NULL, (UINT1 *)
                                  apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)
            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)
                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE], 0,
                                          ECFM_FALSE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_ISID_RESET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList,
                                  (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  ECFM_CC_ROLE_FM, NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)
            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)
                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList,
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE], 0,
                                          ECFM_FALSE, NULL, NULL);
            }
            break;
        case CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0, ECFM_CC_ROLE_FM, NULL,
                                  (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE, NULL, (UINT1 *)
                                          apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_LEV_UNAWARE_RESET_CC_INT_ROLE:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetCcRole (CliHandle, u4ContextId, u4Command,
                                  au1MdLevelList, u2NoOfMdLevels,
                                  pu1VlanList, 0, ECFM_CC_ROLE_FM, NULL, NULL);
            if (i4RetVal == CLI_SUCCESS)

            {
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) == ECFM_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }
                i4RetVal =
                    EcfmCliSetCcInterval (CliHandle, u4Command, au1MdLevelList,
                                          u2NoOfMdLevels, pu1VlanList, 0, 0,
                                          ECFM_FALSE, NULL, NULL);
            }
            break;
        case CLI_MPLS_LEV_SER_CC_CONF_ENABLE_PARAM:
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            u4MdLevel = *apu4args[ECFM_INDEX_ZERO];
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            EcfmCliSetEnableY1731CcStatus (CliHandle,
                                           CLI_ECFM_LEV_UNAWARE_CC_CONF_ENABLE_PARAM,
                                           au1MdLevelList,
                                           u2NoOfMdLevels, pu1VlanList,
                                           0, ECFM_SNMP_TRUE,
                                           u4ContextId,
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                           NULL);
            break;
        case CLI_ECFM_DOM_SER_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/level list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                EcfmCliSetEnableY1731CcStatus (CliHandle,
                                               CLI_ECFM_LEV_ISID_CC_CONF_ENABLE_PARAM,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList,
                                               (INT4 *) &u4TempIsid,
                                               ECFM_SNMP_TRUE, u4ContextId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ONE],
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetEnableY1731CcStatus (CliHandle,
                                                   CLI_ECFM_LEV_UNAWARE_CC_CONF_ENABLE_PARAM,
                                                   au1MdLevelList,
                                                   u2NoOfMdLevels, pu1VlanList,
                                                   0, ECFM_SNMP_TRUE,
                                                   u4ContextId,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                                   au1MdLevelList,
                                                   u2NoOfMdLevels, pu1VlanList,
                                                   0, ECFM_SNMP_TRUE,
                                                   u4ContextId,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ZERO]);
            }
            break;

        case CLI_ECFM_DOM_VLAN_CC_CONF_ENABLE_PARAM:
        case CLI_ECFM_DOM_VSI_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_TRUE,
                                               u4ContextId, NULL, (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VLAN_CC_CONF_ENABLE_PARAM:
        case CLI_ECFM_LEV_VSI_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_TRUE,
                                               u4ContextId, NULL, NULL);
            break;
        case CLI_ECFM_DOM_ISID_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                           au1MdLevelList, u2NoOfMdLevels,
                                           pu1VlanList,
                                           ((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                           ECFM_SNMP_TRUE, u4ContextId, NULL,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_ISID_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CLI_SET_ERR (CLI_ECFM_INVALID_INPUT_ERR);
                    i4RetVal = CLI_FAILURE;
                    break;
                }
            }
            EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                           au1MdLevelList, u2NoOfMdLevels,
                                           pu1VlanList,
                                           ((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                           ECFM_SNMP_TRUE, u4ContextId, NULL,
                                           NULL);

            break;

        case CLI_ECFM_DOM_UNAWARE_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_TRUE,
                                               u4ContextId, NULL, (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_CC_CONF_ENABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_TRUE,
                                               u4ContextId, NULL, NULL);
            break;
        case CLI_ECFM_MPLS_LEV_SER_CC_CONF_DISABLE_PARAM:
            /* CCM Disable */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            u4MdLevel = *apu4args[ECFM_INDEX_ZERO];
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            EcfmCliSetEnableY1731CcStatus (CliHandle,
                                           CLI_ECFM_LEV_UNAWARE_CC_CONF_DISABLE_PARAM,
                                           au1MdLevelList,
                                           u2NoOfMdLevels, pu1VlanList,
                                           0, ECFM_SNMP_FALSE,
                                           u4ContextId,
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                           NULL);
            break;
        case CLI_ECFM_DOM_SER_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                EcfmCliSetEnableY1731CcStatus (CliHandle,
                                               CLI_ECFM_LEV_ISID_CC_CONF_DISABLE_PARAM,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList,
                                               (INT4 *) &u4TempIsid,
                                               ECFM_SNMP_FALSE, u4ContextId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ONE],
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetEnableY1731CcStatus (CliHandle,
                                                   CLI_ECFM_LEV_UNAWARE_CC_CONF_DISABLE_PARAM,
                                                   au1MdLevelList,
                                                   u2NoOfMdLevels, pu1VlanList,
                                                   0, ECFM_SNMP_FALSE,
                                                   u4ContextId,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                if (CliStrToPortList
                    (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                     CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                                   au1MdLevelList,
                                                   u2NoOfMdLevels, pu1VlanList,
                                                   0, ECFM_SNMP_FALSE,
                                                   u4ContextId,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_DOM_VSI_CC_CONF_DISABLE_PARAM :
        case CLI_ECFM_DOM_VLAN_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_FALSE,
                                               u4ContextId, NULL, (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_VSI_CC_CONF_DISABLE_PARAM:
        case CLI_ECFM_LEV_VLAN_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate Level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_FALSE,
                                               u4ContextId, NULL, NULL);
            break;
        case CLI_ECFM_DOM_ISID_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                           au1MdLevelList, u2NoOfMdLevels,
                                           pu1VlanList,
                                           (INT4 *) apu4args[ECFM_INDEX_ONE],
                                           ECFM_SNMP_FALSE, u4ContextId, NULL,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_ISID_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate Level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)
            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                           au1MdLevelList, u2NoOfMdLevels,
                                           pu1VlanList,
                                           (INT4 *) apu4args[ECFM_INDEX_ONE],
                                           ECFM_SNMP_FALSE, u4ContextId, NULL,
                                           NULL);
            break;
        case CLI_ECFM_DOM_UNAWARE_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_FALSE,
                                               u4ContextId, NULL, (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_LEV_UNAWARE_CC_CONF_DISABLE_PARAM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name/leve list */
            /* apu4args[ECFM_INDEX_ONE] : Service name/vlan list/ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate Level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetEnableY1731CcStatus (CliHandle, u4Command,
                                               au1MdLevelList, u2NoOfMdLevels,
                                               pu1VlanList, 0, ECFM_SNMP_FALSE,
                                               u4ContextId, NULL, NULL);
            break;

            /* Oui configuration */
        case CLI_ECFM_NO_OUI:
            CfaGetSysMacAddress (MacAddr);
            ECFM_MEMCPY (LocalClientOui.pu1_OctetList, &MacAddr,
                         ECFM_OUI_LENGTH);
            i4RetVal = EcfmCliConfOui (CliHandle, &LocalClientOui);
            break;
        case CLI_ECFM_OUI:

            /* apu4args[ECFM_INDEX_ZERO] contains oui value */
            CLI_CONVERT_DOT_STR_TO_ARRAY ((UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                          LocalClientOui.pu1_OctetList);
            i4RetVal = EcfmCliConfOui (CliHandle, &LocalClientOui);
            break;

            /* Trap control */
        case CLI_ECFM_ENABLE_TRAP:
        case CLI_ECFM_DISABLE_TRAP:
            i4RetVal =
                EcfmCliSetTraps (CliHandle, u4ContextId, u4Command,
                                 CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ZERO]),
                                 CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ONE]));
            break;
        case CLI_ECFM_SET_MEP_LOWEST_PRI_DEFECT:
            i4RetVal = EcfmCliSetDot1agCfmMepLowPrDef (CliHandle, u4ContextId,
                                                       CLI_PTR_TO_U4 (apu4args
                                                                      [ECFM_INDEX_ZERO]));
            break;

            /* Configuration of Vlan Table */
        case CLI_ECFM_ASSOC_VLANS_TO_PVLAN:
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliAssocVlansToPrimaryVlan (CliHandle,
                                                *((INT4 *)
                                                  apu4args[ECFM_INDEX_ZERO]),
                                                pu1VlanList);
            break;
        case CLI_ECFM_DIS_ASSOC_VLANS_TO_PVLAN:
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeAssocVlansToPrimaryVlan (CliHandle,
                                                  ((UINT1)
                                                   *apu4args[ECFM_INDEX_ZERO]),
                                                  pu1VlanList);
            break;

            /* Implicit MIP evaluation control */
        case CLI_ECFM_ENABLE_IMPLICIT_MIP_EVAL:
            i4RetVal =
                EcfmCliSetImplicitMipEvalStatus (CliHandle, ECFM_SNMP_TRUE);
            break;
        case CLI_ECFM_DISABLE_IMPLICIT_MIP_EVAL:
            i4RetVal =
                EcfmCliSetImplicitMipEvalStatus (CliHandle, ECFM_SNMP_FALSE);
            break;

            /* restrict the Implicit MIP evaluation control */
        case CLI_ECFM_RESTRICT_IMPLICIT_MIP_EVAL:
            i4RetVal =
                EcfmCliSetRestrictDynMipEvalStatus (CliHandle,
                                                    u2LocalPortId,
                                                    ((UINT2) *apu4args
                                                     [ECFM_INDEX_ZERO]),
                                                    *(apu4args
                                                      [ECFM_INDEX_ONE]));
            break;
        case CLI_ECFM_NOT_RESTRICT_IMPLICIT_MIP_EVAL:
            i4RetVal =
                EcfmCliReSetRestrictDynMipEvalStatus
                (CliHandle, u2LocalPortId, (UINT2)
                 *apu4args[ECFM_INDEX_ZERO], *((apu4args[ECFM_INDEX_ONE])));
            break;
        case CLI_ECFM_SET_XCHK_DELAY:
            i4RetVal =
                EcfmCliSetMepXChkDelay (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]));
            break;
        case CLI_ECFM_RESET_XCHK_DELAY:
            i4RetVal = EcfmCliSetMepXChkDelay (CliHandle, ECFM_INDEX_ZERO);
            break;

            /* MIP CCM Db related */
        case CLI_ECFM_MIP_CCM_DB:
            i4RetVal =
                EcfmCliMipCcmDbSetStatus (CliHandle,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ZERO]));
            break;
        case CLI_ECFM_CCM_DB_SET_HOLDTIME:
        case CLI_ECFM_CCM_DB_SET_SIZE:
        case CLI_ECFM_CCM_DB_RESET_SIZE:
        case CLI_ECFM_CCM_DB_RESET_HOLDTIME:
            i4RetVal = EcfmCliMipCcmDbSetHoldTimeOrSize
                (CliHandle, u4Command, (INT4 *) apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Default Md Table and its scalar related */
        case CLI_ECFM_DEFAULT_DOMAIN_VLAN:
            /* apu4args[0] - Vlan Id
             * apu4args[1] - MD Level
             * apu4args[2] - Mip evaluation criteria
             * apu4args[3] - Sender-id permission
             * apu4args[4] - Mask that states which variable
             *                    (level/criteia/sender-id) is set
             * */
            i4RetVal =
                EcfmCliSetMipVlanDefParams (CliHandle,
                                            *((INT4 *)
                                              apu4args[ECFM_INDEX_ZERO]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_ONE]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_TWO]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_THREE]),
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_FOUR]));
            break;
        case CLI_ECFM_NO_DEFAULT_DOMAIN_VLAN:
            /* apu4args[0] - Vlan Id
             * apu4args[1] - Mask that states which variable 
             *                    (level/criteia/sender-id) is reset 
             * */
            i4RetVal =
                EcfmCliSetMipVlanDefParams (CliHandle,
                                            *((INT4 *)
                                              apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_DEF_MD_LEVEL_DEF_VAL,
                                            ECFM_MHF_CRITERIA_DEFER,
                                            ECFM_SENDER_ID_DEFER,
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_ONE]));
            break;
        case CLI_ECFM_DEFAULT_DOMAIN_ISID:
            /* apu4args[0] - Service Instance
             * apu4args[1] - MD Level
             * apu4args[2] - Mip evaluation criteria
             * apu4args[3] - Sender-id permission
             * apu4args[4] - Mask that states which variable 
             *                    (level/criteia/sender-id) is set
             * */
            i4RetVal =
                EcfmCliSetMipIsidDefParams (CliHandle,
                                            *((INT4 *)
                                              apu4args[ECFM_INDEX_ZERO]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_ONE]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_TWO]),
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_THREE]),
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_FOUR]));
            break;
        case CLI_ECFM_NO_DEFAULT_DOMAIN_ISID:
            /* apu4args[0] - Service Instance
             * apu4args[1] - Mask that states which variable 
             *                    (level/criteia/sender-id) is reset 
             * */
            i4RetVal =
                EcfmCliSetMipIsidDefParams (CliHandle,
                                            *((INT4 *)
                                              apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_DEF_MD_LEVEL_DEF_VAL,
                                            ECFM_MHF_CRITERIA_DEFER,
                                            ECFM_SENDER_ID_DEFER,
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_ONE]));
            break;
        case CLI_ECFM_DEFAULT_DOMAIN_GLOBAL:
            /* apu4args[0] - MD Level
             * apu4args[1] - Mip evaluation criteria
             * apu4args[2] - Sender-id permission
             * apu4args[3] - Mask that states which variable 
             *                    (level/criteia/sender-id) is set
             * */
            i4RetVal =
                EcfmCliSetMipDefParams (CliHandle,
                                        CLI_PTR_TO_I4 (apu4args
                                                       [ECFM_INDEX_ZERO]),
                                        CLI_PTR_TO_I4 (apu4args
                                                       [ECFM_INDEX_ONE]),
                                        CLI_PTR_TO_I4 (apu4args
                                                       [ECFM_INDEX_TWO]),
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_THREE]));
            break;
        case CLI_ECFM_NO_DEFAULT_DOMAIN_GLOBAL:
            /* apu4args[0] - Mask that states which variable 
             *                    (level/criteia/sender-id) is reset 
             * */
            i4RetVal =
                EcfmCliSetMipDefParams (CliHandle,
                                        ECFM_MD_LEVEL_MIN,
                                        ECFM_MHF_CRITERIA_NONE,
                                        ECFM_SENDER_ID_NONE,
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_ZERO]));
            break;
            /* LBR cache related */
        case CLI_ECFM_LBR_CACHE:
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            i4RetVal =
                EcfmCliLbrCacheSetStatus (CliHandle,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ZERO]),
                                          u4ContextId);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            break;

            /* LTR cache related */
        case CLI_ECFM_LTR_CACHE:
            i4RetVal =
                EcfmCliLtrCacheSetStatus (CliHandle,
                                          CLI_PTR_TO_I4 (apu4args
                                                         [ECFM_INDEX_ZERO]));
            break;
        case CLI_ECFM_LTR_CACHE_SET_HOLDTIME:
        case CLI_ECFM_LTR_CACHE_SET_SIZE:
        case CLI_ECFM_LTR_CACHE_RESET_SIZE:
        case CLI_ECFM_LTR_CACHE_RESET_HOLDTIME:
            i4RetVal =
                EcfmCliLtrCacheSetHoldTimeOrSize (CliHandle, u4Command,
                                                  (INT4 *)
                                                  apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Domain creation and deletion */
        case CLI_ECFM_DOMAIN_CREATE:
            i4RetVal =
                EcfmCliCreateMDomain (CliHandle,
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]));
            break;

        case CLI_Y1731_MPLSTPOAM_DOMAIN_CREATE:
            i4RetVal =
                EcfmCliCreateOamMDomain (CliHandle,
                                         *(apu4args[ECFM_INDEX_ONE]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_TWO]));
            break;
        case CLI_Y1731_MPLSTPOAM_DEFDOMAIN_CREATE:
            i4RetVal =
                EcfmCliCreateOamMDomain (CliHandle,
                                         7,
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_TWO]));
            break;
        case CLI_ECFM_DOMAIN_DELETE:
            i4RetVal =
                EcfmCliDeleteMDomain (CliHandle,
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]));
            break;
        case CLI_ECFMMPLSTPOAM_DOMAIN_DELETE:
            i4RetVal =
                EcfmCliOamDeleteMDomain (CliHandle,
                                         *(apu4args[ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ONE]));
            break;
        case CLI_ECFMMPLSTPOAM_DEFDOMAIN_DELETE:
            i4RetVal =
                EcfmCliOamDeleteMDomain (CliHandle,
                                         ECFM_MPLSTP_DEF_LEVEL,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ONE]));
            break;

            /*********** Domain Mode commands**************************** */
            /* Domain MHF parameters */
        case CLI_ECFM_DOMAIN_SET_MHF_CRITERIA:
            i4RetVal =
                EcfmCliSetMDomainMhfparams (CliHandle,
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_ZERO]),
                                            0);
            break;
        case CLI_ECFM_DOMAIN_SET_SENDER_ID_PERMISSION:
            i4RetVal =
                EcfmCliSetMDomainMhfparams (CliHandle, 0,
                                            CLI_PTR_TO_I4 (apu4args
                                                           [ECFM_INDEX_ZERO]));
            break;

            /* Service or MA Creation and Deletion */
       case CLI_ECFM_ASSOC_CREATE:
           i4RetVal = EcfmCliCreateMAssociation (CliHandle,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 *(apu4args[ECFM_INDEX_ONE]),
                                                 CLI_PTR_TO_I4 (apu4args
                                                                [ECFM_INDEX_TWO]),
                                                 CLI_PTR_TO_I4 (apu4args
                                                                [ECFM_INDEX_THREE]),
                                                 NULL, NULL, u4ContextId,
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_FOUR]),
                                                 ECFM_INVALID_RANGE_VLAN_ID);
           break;
       case CLI_ECFM_UNAWARE_ASSOC_CREATE:
           i4RetVal = EcfmCliCreateMAssociation (CliHandle,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO], 0,
                                                 CLI_PTR_TO_I4 (apu4args
                                                                [ECFM_INDEX_ONE]),
                                                 CLI_PTR_TO_I4 (apu4args
                                                                [ECFM_INDEX_TWO]),
                                                 NULL, NULL, u4ContextId,
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_THREE]),
                                                 ECFM_INVALID_RANGE_VLAN_ID);
           break;
        case CLI_Y1731_MPLSTPOAM_ASSOC_CREATE_ICC_UMC:
            i4RetVal = EcfmCliCreateOamMAssociation (CliHandle,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_ZERO],
                                                     0,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_TWO]),
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_THREE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FOUR],
                                                     u4ContextId,
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_FIVE]),
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_SIX]));
            break;
        case CLI_Y1731_MPLSTPOAM_ASSOC_DELETE_ICC_UMC:
            i4RetVal = EcfmCliDeleteOamMAssociation
                (CliHandle, (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                 u4ContextId, CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ONE]));

            break;
#ifdef VSI_WANTED
        case CLI_ECFM_ASSOC_CREATE_VSIID_ICC_UMC:
            u4VsiId = *(apu4args[ECFM_INDEX_ONE]) ;
            EcfmCliCreateMAssociation (CliHandle,
                                       (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                       u4VsiId,
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                       (UINT1 *)apu4args[ECFM_INDEX_FOUR],
                                       (UINT1 *)apu4args[ECFM_INDEX_FIVE],
                                       u4ContextId,
                                       CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_SIX]),
                                       ECFM_INVALID_RANGE_VLAN_ID);
            break;
#endif
        case CLI_ECFM_ASSOC_CREATE_VSIID_OAM_VLAN_ICC_UMC:
            u4VsiId = *(apu4args[ECFM_INDEX_ONE]) ;
            u4OamVlanId = *(apu4args[ECFM_INDEX_SEVEN]) ;
            EcfmCliCreateMAssociation (CliHandle,
                                       (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                       u4VsiId,
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                       (UINT1 *)apu4args[ECFM_INDEX_FOUR],
                                       (UINT1 *)apu4args[ECFM_INDEX_FIVE],
                                       u4ContextId,
                                       CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_SIX]),
                                       u4OamVlanId);
            break;
        case CLI_ECFM_ASSOC_CREATE_VSIID_OAM_VLAN:
            u4VsiId = *(apu4args[ECFM_INDEX_ONE]) ;
            u4OamVlanId = *(apu4args[ECFM_INDEX_FIVE]) ;
            EcfmCliCreateMAssociation (CliHandle,
                                       (UINT1 *)apu4args[ECFM_INDEX_ZERO],
                                       u4VsiId,
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                       NULL, NULL, u4ContextId,
                                       CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]),
                                       u4OamVlanId);
            break;

        case CLI_ECFM_ASSOC_CREATE_VSIID:
            u4VsiId = *(apu4args[ECFM_INDEX_ONE]) ;
            EcfmCliCreateMAssociation (CliHandle,
                                       (UINT1 *)apu4args[ECFM_INDEX_ZERO],
                                       u4VsiId,
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWO]),
                                       CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_THREE]),
                                       NULL, NULL, u4ContextId,
                                       CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]),
                                       ECFM_INVALID_RANGE_VLAN_ID);
            break;

            /*** Y.1731 : Modified to add ICC and UMC ***/
      case CLI_ECFM_ASSOC_CREATE_ICC_UMC:
          i4RetVal = EcfmCliCreateMAssociation (CliHandle,
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_ZERO],
                                                *(apu4args[ECFM_INDEX_ONE]),
                                                CLI_PTR_TO_I4 (apu4args
                                                               [ECFM_INDEX_TWO]),
                                                CLI_PTR_TO_I4 (apu4args
                                                               [ECFM_INDEX_THREE]),
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_FOUR],
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_FIVE],
                                                u4ContextId,
                                                CLI_PTR_TO_U4 (apu4args
                                                               [ECFM_INDEX_SIX]),
                                                ECFM_INVALID_RANGE_VLAN_ID);
          break;
      case CLI_ECFM_UNAWARE_ASSOC_CREATE_ICC_UMC:
          i4RetVal = EcfmCliCreateMAssociation (CliHandle,
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_ZERO], 0,
                                                CLI_PTR_TO_I4 (apu4args
                                                               [ECFM_INDEX_ONE]),
                                                CLI_PTR_TO_I4 (apu4args
                                                               [ECFM_INDEX_TWO]),
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_THREE],
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_FOUR],
                                                u4ContextId,
                                                CLI_PTR_TO_U4 (apu4args
                                                               [ECFM_INDEX_FIVE]),
                                                ECFM_INVALID_RANGE_VLAN_ID);
          break;
      case CLI_ECFM_ASSOC_DELETE:
            i4RetVal = EcfmCliDeleteMAssociation (CliHandle,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ZERO],
                                                  CLI_PTR_TO_I4 (apu4args
                                                                 [ECFM_INDEX_ONE]));
            break;

            /* Service or MA Creation for ISID */
        case CLI_ECFM_ASSOC_CREATE_ISID:
            i4RetVal = EcfmCliCreateIsidMAssociation (CliHandle,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_ZERO],
                                                      *(apu4args
                                                        [ECFM_INDEX_ONE]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_TWO]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_THREE]),
                                                      NULL, NULL,
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_FOUR]),
                                                      u4ContextId);
            break;

        case CLI_ECFM_ASSOC_CREATE_ISID_ICC_UMC:
            i4RetVal = EcfmCliCreateIsidMAssociation (CliHandle,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_ZERO],
                                                      *(apu4args
                                                        [ECFM_INDEX_ONE]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_TWO]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_THREE]),
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FIVE],
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_SIX]),
                                                      u4ContextId);

            break;
            /* MaMeplist or crosscheck list configuration */
        case CLI_ECFM_CONFIG_SER_RMEP:
            u4VlanIsid = 0;
            /* apu4args[ECFM_INDEX_ZERO] : MepIdentifier */
            /* apu4args[ECFM_INDEX_ONE] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, NULL,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid,
                                             CLI_GET_MDINDEX (),
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4VlanIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliConfigIsidRemoteMep (CliHandle,
                                                       *(apu4args
                                                         [ECFM_INDEX_ZERO]),
                                                       u4VlanIsid,
                                                       (UINT1 *) apu4args
                                                       [ECFM_INDEX_ONE]);
            }
            else
            {
                i4RetVal =
                    EcfmCliConfigRemoteMep (CliHandle,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            u4VlanIsid,
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);
            }
            break;
#ifdef VSI_WANTED
        case CLI_ECFM_CONFIG_VSI_RMEP:
            u4VsiId = *(apu4args[ECFM_INDEX_ONE]) ;
            i4RetVal =
                EcfmCliConfigRemoteMep (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]),
                                        u4VsiId, NULL);
            break;
#endif            
        case CLI_ECFM_CONFIG_VLAN_RMEP:
            i4RetVal =
                EcfmCliConfigRemoteMep (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]),
                                        *(apu4args[ECFM_INDEX_ONE]), NULL);
            break;
        case CLI_ECFM_CONFIG_UNAWARE_RMEP:
            i4RetVal =
                EcfmCliConfigRemoteMep (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]), 0, NULL);
            break;
        case CLI_ECFM_CONFIG_ISID_RMEP:
            i4RetVal = EcfmCliConfigIsidRemoteMep (CliHandle,
                                                   *(apu4args[ECFM_INDEX_ZERO]),
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   NULL);
            break;

        case CLI_ECFM_DELETE_SER_RMEP:
            /* apu4args[ECFM_INDEX_ZERO] : MepIdentifier */
            /* apu4args[ECFM_INDEX_ONE] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, NULL,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid,
                                             CLI_GET_MDINDEX (),
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4VlanIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliDeleteIsidRemoteMep (CliHandle,
                                                       *(apu4args
                                                         [ECFM_INDEX_ZERO]),
                                                       u4VlanIsid,
                                                       (UINT1 *) apu4args
                                                       [ECFM_INDEX_ONE]);
            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteRemoteMep (CliHandle,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            u4VlanIsid,
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);
            }
            break;
        case CLI_ECFM_DELETE_VSI_RMEP:
        case CLI_ECFM_DELETE_VLAN_RMEP:
            i4RetVal =
                EcfmCliDeleteRemoteMep (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]),
                                        *(apu4args[ECFM_INDEX_ONE]), NULL);
            break;
        case CLI_ECFM_DELETE_UNAWARE_RMEP:
            i4RetVal =
                EcfmCliDeleteRemoteMep (CliHandle,
                                        *(apu4args[ECFM_INDEX_ZERO]), 0, NULL);
            break;
        case CLI_ECFM_DELETE_ISID_RMEP:
            i4RetVal = EcfmCliDeleteIsidRemoteMep (CliHandle,
                                                   *(apu4args[ECFM_INDEX_ZERO]),
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   NULL);
            break;

            /* MEP Archive */
        case CLI_ECFM_CC_SET_ARCHIVE_HOLDTIME:
            i4RetVal =
                EcfmCliMepArchiveSetHoldTime (CliHandle,
                                              *((INT4 *)
                                                apu4args[ECFM_INDEX_ZERO]));
            break;
        case CLI_ECFM_CC_RESET_ARCHIVE_HOLDTIME:
            i4RetVal =
                EcfmCliMepArchiveSetHoldTime (CliHandle,
                                              ECFM_MEP_ARCHIVE_DEF_HOLD_TIME);
            break;

            /***************** Interface config mode commands************** */

            /* CFM Enable/Disable on Interface */
        case CLI_ECFM_ENABLE_CFM_ON_INTF:
        case CLI_ECFM_DISABLE_CFM_ON_INTF:
            i4RetVal =
                EcfmCliSetPortModuleStatus (CliHandle, u4Command,
                                            CLI_GET_IFINDEX ());
            break;
        case CLI_ECFM_LLC_ADD:
        case CLI_ECFM_NO_LLC:
            i4RetVal = EcfmCliSetPortLLCEncapStatus (CliHandle, u4Command,
                                                     u2LocalPortId);
            break;

            /* MEP configuration and deletion */
        case CLI_ECFM_UP_DOM_SER_ACTIVE_MEP_CTRL_CONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliConfigIsidMep (CliHandle,
                                                 CLI_ECFM_UP_LEV_ISID_ACTIVE_MEP_CTRL_CONF,
                                                 u4MdLevel,
                                                 ECFM_MP_DIR_UP,
                                                 u4ContextId,
                                                 u4TempIsid,
                                                 *(apu4args[ECFM_INDEX_ONE]),
                                                 ECFM_SNMP_TRUE,
                                                 u2LocalPortId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO]);
            }
            else
            {
                i4RetVal =
                    EcfmCliConfigMep (CliHandle,
                                      u4MdLevel,
                                      ECFM_MP_DIR_UP,
                                      u4VlanIsid,
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      ECFM_SNMP_TRUE, u2LocalPortId,
                                      (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_UP_DOM_VLAN_ACTIVE_MEP_CTRL_CONF:
        case CLI_ECFM_UP_DOM_VSI_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_UP,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
#ifdef VSI_WANTED
       case CLI_ECFM_UP_LEV_VSI_ACTIVE_MEP_CTRL_CONF:
            u4VsiId = *(apu4args[ECFM_INDEX_TWO]) ;
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  u4VsiId,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
#endif
        case CLI_ECFM_UP_LEV_VLAN_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_UP_LEV_SER_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  (UINT1 *) apu4args[ECFM_INDEX_TWO], NULL);
            break;
        case CLI_ECFM_UP_DOM_UNAWARE_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_UP, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_UP_LEV_UNAWARE_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_UP_DOM_SER_MEP_CTRL_CONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliConfigIsidMep (CliHandle,
                                                 CLI_ECFM_UP_LEV_ISID_MEP_CTRL_CONF,
                                                 u4MdLevel,
                                                 ECFM_MP_DIR_UP,
                                                 u4ContextId,
                                                 u4TempIsid,
                                                 *(apu4args[ECFM_INDEX_ONE]),
                                                 ECFM_SNMP_FALSE,
                                                 u2LocalPortId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliConfigMep (CliHandle,
                                      u4MdLevel,
                                      ECFM_MP_DIR_UP,
                                      u4VlanIsid,
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      ECFM_SNMP_FALSE, u2LocalPortId,
                                      (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_UP_DOM_VLAN_MEP_CTRL_CONF:

        case CLI_ECFM_UP_DOM_VSI_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_UP,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
#ifdef VSI_WANTED
        case CLI_ECFM_UP_LEV_VSI_MEP_CTRL_CONF:
            u4VsiId = *(apu4args[ECFM_INDEX_TWO]) ;
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
#endif
        case CLI_ECFM_UP_LEV_VLAN_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_UP_LEV_SER_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP,
                                  0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  (UINT1 *) apu4args[ECFM_INDEX_TWO], NULL);
            break;
        case CLI_ECFM_UP_DOM_UNAWARE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_UP, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_UP_LEV_UNAWARE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_UP, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOWN_DOM_SER_ACTIVE_MEP_CTRL_CONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliConfigIsidMep (CliHandle,
                                                 CLI_ECFM_DOWN_LEV_ISID_ACTIVE_MEP_CTRL_CONF,
                                                 u4MdLevel,
                                                 ECFM_MP_DIR_DOWN,
                                                 u4ContextId,
                                                 u4TempIsid,
                                                 *(apu4args[ECFM_INDEX_ONE]),
                                                 ECFM_SNMP_TRUE,
                                                 u2LocalPortId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliConfigMep (CliHandle,
                                      u4MdLevel,
                                      ECFM_MP_DIR_DOWN,
                                      u4VlanIsid,
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      ECFM_SNMP_TRUE, u2LocalPortId,
                                      (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_DOWN_DOM_VLAN_ACTIVE_MEP_CTRL_CONF:
        case CLI_ECFM_DOWN_DOM_VSI_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_DOWN,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
#ifdef VSI_WANTED
        case CLI_ECFM_DOWN_LEV_VSI_ACTIVE_MEP_CTRL_CONF:
            u4VsiId = *(apu4args[ECFM_INDEX_TWO]) ;
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  u4VsiId,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
#endif
        case CLI_ECFM_DOWN_LEV_VLAN_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOWN_LEV_SER_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  (UINT1 *) apu4args[ECFM_INDEX_TWO], NULL);
            break;
        case CLI_ECFM_DOWN_DOM_UNAWARE_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_DOWN, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_DOWN_LEV_UNAWARE_ACTIVE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_TRUE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOWN_DOM_SER_MEP_CTRL_CONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal = EcfmCliConfigIsidMep (CliHandle,
                                                 CLI_ECFM_DOWN_LEV_ISID_MEP_CTRL_CONF,
                                                 u4MdLevel,
                                                 ECFM_MP_DIR_DOWN,
                                                 u4ContextId,
                                                 u4TempIsid,
                                                 *(apu4args[ECFM_INDEX_ONE]),
                                                 ECFM_SNMP_FALSE,
                                                 u2LocalPortId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliConfigMep (CliHandle,
                                      u4MdLevel,
                                      ECFM_MP_DIR_DOWN,
                                      u4VlanIsid,
                                      *(apu4args[ECFM_INDEX_ONE]),
                                      ECFM_SNMP_FALSE, u2LocalPortId,
                                      (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                      (UINT1 *) apu4args[ECFM_INDEX_ZERO]);

            }
            break;
        case CLI_ECFM_DOWN_DOM_VLAN_MEP_CTRL_CONF:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_DOM_VSI_MEP_CTRL_CONF:
#endif
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_DOWN,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_LEV_VSI_MEP_CTRL_CONF:
            u4VsiId = *(apu4args[ECFM_INDEX_TWO]) ;
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  u4VsiId,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
#endif
    
        case CLI_ECFM_DOWN_LEV_VLAN_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  *(apu4args[ECFM_INDEX_TWO]),
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_ECFM_DOWN_LEV_SER_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN,
                                  0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  (UINT1 *) apu4args[ECFM_INDEX_TWO], NULL);
            break;
        case CLI_ECFM_DOWN_DOM_UNAWARE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  u4MdLevel,
                                  ECFM_MP_DIR_DOWN, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
        case CLI_ECFM_DOWN_LEV_UNAWARE_MEP_CTRL_CONF:
            i4RetVal =
                EcfmCliConfigMep (CliHandle,
                                  *(apu4args[ECFM_INDEX_ZERO]),
                                  ECFM_MP_DIR_DOWN, 0,
                                  *(apu4args[ECFM_INDEX_ONE]),
                                  ECFM_SNMP_FALSE, u2LocalPortId,
                                  NULL, NULL);
            break;
        case CLI_Y1731_MPLSTPOAM_CONFIG_MEP:
            i4RetVal =
                EcfmCliConfigOamMep (CliHandle, u4ContextId,
                                     *(apu4args[ECFM_INDEX_ZERO]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ONE]),
                                     ECFM_INIT_VAL, ECFM_INIT_VAL,
                                     ECFM_INIT_VAL, ECFM_INIT_VAL,
                                     (UINT1 *) (apu4args[ECFM_INDEX_SIX]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_SEVEN]),
                                     (apu4args[ECFM_INDEX_EIGHT]));
            break;
        case CLI_Y1731_MPLSTPOAM_CONFIG_LSPMEP:
            i4RetVal =
                EcfmCliConfigOamMep (CliHandle, u4ContextId,
                                     *(apu4args[ECFM_INDEX_ZERO]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ONE]),
                                     *(apu4args[ECFM_INDEX_TWO]),
                                     *(apu4args[ECFM_INDEX_THREE]),
                                     *(apu4args[ECFM_INDEX_FOUR]),
                                     *(apu4args[ECFM_INDEX_FIVE]),
                                     (UINT1 *) (apu4args[ECFM_INDEX_SIX]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_SEVEN]),
                                     (apu4args[ECFM_INDEX_EIGHT]));

            break;
        case CLI_Y1731_MPLSTPOAM_CONFIG_PWMEP:
            i4RetVal =
                EcfmCliConfigOamMep (CliHandle, u4ContextId,
                                     *(apu4args[ECFM_INDEX_ZERO]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ONE]),
                                     *(apu4args[ECFM_INDEX_TWO]), ECFM_INIT_VAL,
                                     ECFM_INIT_VAL, ECFM_INIT_VAL,
                                     (UINT1 *) (apu4args[ECFM_INDEX_SIX]),
                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_SEVEN]),
                                     (apu4args[ECFM_INDEX_EIGHT]));

            break;
        case CLI_Y1731_MPLSTPOAM_DELETE_MEP:
            i4RetVal = EcfmCliDeleteOrDisableOamMep (CliHandle, u4ContextId,
                                                     *(apu4args
                                                       [ECFM_INDEX_ZERO]),
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     (UINT1
                                                      *) (apu4args
                                                          [ECFM_INDEX_SIX]),
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_SEVEN]),
                                                     (apu4args
                                                      [ECFM_INDEX_EIGHT]));
            break;
        case CLI_Y1731_MPLSTPOAM_DELETE_LSPMEP:
            i4RetVal =
                EcfmCliDeleteOrDisableOamMep (CliHandle, u4ContextId,
                                              *(apu4args[ECFM_INDEX_ZERO]),
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_ONE]),
                                              *(apu4args[ECFM_INDEX_TWO]),
                                              *(apu4args[ECFM_INDEX_THREE]),
                                              *(apu4args[ECFM_INDEX_FOUR]),
                                              *(apu4args[ECFM_INDEX_FIVE]),
                                              (UINT1
                                               *) (apu4args[ECFM_INDEX_SIX]),
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_SEVEN]),
                                              (apu4args[ECFM_INDEX_EIGHT]));
            break;
        case CLI_Y1731_MPLSTPOAM_DELETE_PWMEP:
            i4RetVal = EcfmCliDeleteOrDisableOamMep (CliHandle, u4ContextId,
                                                     *(apu4args
                                                       [ECFM_INDEX_ZERO]),
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     ECFM_INIT_VAL,
                                                     (UINT1
                                                      *) (apu4args
                                                          [ECFM_INDEX_SIX]),
                                                     CLI_PTR_TO_U4 (apu4args
                                                                    [ECFM_INDEX_SEVEN]),
                                                     (apu4args
                                                      [ECFM_INDEX_EIGHT]));

            break;
        case CLI_ECFM_UP_DOM_ISID_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             u4MdLevel,
                                             ECFM_MP_DIR_UP,
                                             u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_TRUE,
                                             u2LocalPortId, NULL);

            break;
        case CLI_ECFM_UP_LEV_ISID_ACTIVE_MEP_CTRL_CONF:
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             *(apu4args[ECFM_INDEX_ZERO]),
                                             ECFM_MP_DIR_UP, u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_TRUE,
                                             (UINT4) (u2LocalPortId), NULL);

            break;
        case CLI_ECFM_UP_DOM_ISID_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             u4MdLevel,
                                             ECFM_MP_DIR_UP,
                                             u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_FALSE,
                                             u2LocalPortId, NULL);

            break;
        case CLI_ECFM_UP_LEV_ISID_MEP_CTRL_CONF:
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             *(apu4args[ECFM_INDEX_ZERO]),
                                             ECFM_MP_DIR_UP, u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_FALSE,
                                             u2LocalPortId, NULL);

            break;
        case CLI_ECFM_DOWN_DOM_ISID_ACTIVE_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             u4MdLevel,
                                             ECFM_MP_DIR_DOWN,
                                             u4ContextId,
                                             *apu4args[ECFM_INDEX_TWO],
                                             *apu4args[ECFM_INDEX_ONE],
                                             ECFM_SNMP_TRUE,
                                             u2LocalPortId, NULL);
            break;
        case CLI_ECFM_DOWN_LEV_ISID_ACTIVE_MEP_CTRL_CONF:
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             *(apu4args[ECFM_INDEX_ZERO]),
                                             ECFM_MP_DIR_DOWN, u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_TRUE,
                                             u2LocalPortId, NULL);
            break;
        case CLI_ECFM_DOWN_DOM_ISID_MEP_CTRL_CONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             u4MdLevel,
                                             ECFM_MP_DIR_DOWN,
                                             u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_FALSE,
                                             u2LocalPortId, NULL);
            break;
        case CLI_ECFM_DOWN_LEV_ISID_MEP_CTRL_CONF:
            i4RetVal = EcfmCliConfigIsidMep (CliHandle, u4Command,
                                             *(apu4args[ECFM_INDEX_ZERO]),
                                             ECFM_MP_DIR_DOWN, u4ContextId,
                                             *(apu4args[ECFM_INDEX_TWO]),
                                             *(apu4args[ECFM_INDEX_ONE]),
                                             ECFM_SNMP_FALSE,
                                             u2LocalPortId, NULL);
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_UP_DOM_VSI_ACTIVE_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_UP_DOM_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_UP_DOM_VSI_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_UP_DOM_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_UNAWARE_MEP_CTRL_NOCONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                           u4MdLevel,
                                           apu4args[ECFM_INDEX_TWO],
                                           *(apu4args[ECFM_INDEX_ONE]),
                                           u2LocalPortId,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_DOM_VSI_ACTIVE_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_DOWN_DOM_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_UNAWARE_MEP_CTRL_NOCONF:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_DOM_VSI_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_DOWN_DOM_VLAN_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : VlanId */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                           u4MdLevel,
                                           apu4args[ECFM_INDEX_TWO],
                                           *(apu4args[ECFM_INDEX_ONE]),
                                           u2LocalPortId,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;

        case CLI_ECFM_UP_DOM_SER_ACTIVE_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_UP_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_UP_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_UP_DOM_SER_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_UP_DOM_ISID_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_UP_DOM_UNAWARE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_DOWN_DOM_SER_ACTIVE_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_DOWN_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_DOWN_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            }
            break;
        case CLI_ECFM_DOWN_DOM_SER_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_DOWN_DOM_ISID_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_DOWN_DOM_UNAWARE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_ZERO]);
            }
            break;
            /* Level & Service */
        case CLI_ECFM_UP_LEV_SER_ACTIVE_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Level */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */

            u4MdLevel = (UINT4) *apu4args[ECFM_INDEX_ZERO];
            if (EcfmCliGetVlanIsidInfo (u4ContextId,
                                        u4MdLevel,
                                        u2LocalPortId,
                                        ECFM_MP_DIR_UP,
                                        *apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        &u4VlanIsid) == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_UP_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }

            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_UP_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId, NULL);
            }
            break;
        case CLI_ECFM_UP_LEV_SER_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Level */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            u4MdLevel = (UINT4) *apu4args[ECFM_INDEX_ZERO];
            if (EcfmCliGetVlanIsidInfo (u4ContextId,
                                        u4MdLevel,
                                        u2LocalPortId,
                                        ECFM_MP_DIR_UP,
                                        *apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        &u4VlanIsid) == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_UP_DOM_ISID_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_UP_LEV_VLAN_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId, NULL);
            }
            break;
        case CLI_ECFM_DOWN_LEV_SER_ACTIVE_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Level */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            u4MdLevel = (UINT4) *apu4args[ECFM_INDEX_ZERO];
            if (EcfmCliGetVlanIsidInfo (u4ContextId,
                                        u4MdLevel,
                                        u2LocalPortId,
                                        ECFM_MP_DIR_DOWN,
                                        *apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        &u4VlanIsid) == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_DOWN_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_DOWN_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF,
                                               u4MdLevel,
                                               &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId, NULL);
            }
            break;
        case CLI_ECFM_DOWN_LEV_SER_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Level */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            u4MdLevel = (UINT4) *apu4args[ECFM_INDEX_ZERO];
            if (EcfmCliGetVlanIsidInfo (u4ContextId,
                                        u4MdLevel,
                                        u2LocalPortId,
                                        ECFM_MP_DIR_DOWN,
                                        *apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        &u4VlanIsid) == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliDeleteOrDisableIsidMep (CliHandle,
                                                   CLI_ECFM_DOWN_DOM_ISID_MEP_CTRL_NOCONF,
                                                   u4ContextId,
                                                   u4MdLevel,
                                                   &u4TempIsid,
                                                   *(apu4args[ECFM_INDEX_ONE]),
                                                   u2LocalPortId);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteOrDisableMep (CliHandle,
                                               CLI_ECFM_DOWN_LEV_VLAN_MEP_CTRL_NOCONF,
                                               u4MdLevel, &u4VlanIsid,
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId, NULL);
            }
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_UP_LEV_VSI_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_VSI_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_VSI_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_VSI_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_UP_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_UNAWARE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_UNAWARE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_VLAN_MEP_CTRL_NOCONF:
            /* apu4args[ECFM_INDEX_ZERO] : Domain level  */
            /* apu4args[ECFM_INDEX_ONE] : MepIdentifier */
            /* apu4args[ECFM_INDEX_TWO] : VlanId        */
            i4RetVal =
                EcfmCliDeleteOrDisableMep (CliHandle, u4Command,
                                           *(apu4args[ECFM_INDEX_ZERO]),
                                           apu4args[ECFM_INDEX_TWO],
                                           *(apu4args[ECFM_INDEX_ONE]),
                                           u2LocalPortId, NULL);
            break;

        case CLI_ECFM_UP_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_ISID_MEP_CTRL_NOCONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisableIsidMep (CliHandle, u4Command,
                                               u4ContextId,
                                               u4MdLevel,
                                               apu4args[ECFM_INDEX_TWO],
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId);
            break;
        case CLI_ECFM_DOWN_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_ISID_MEP_CTRL_NOCONF:
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisableIsidMep (CliHandle, u4Command,
                                               u4ContextId,
                                               u4MdLevel,
                                               apu4args[ECFM_INDEX_TWO],
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId);
            break;

        case CLI_ECFM_UP_LEV_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_ISID_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_LEV_ISID_MEP_CTRL_NOCONF:
            i4RetVal =
                EcfmCliDeleteOrDisableIsidMep (CliHandle, u4Command,
                                               u4ContextId,
                                               *(apu4args[ECFM_INDEX_ZERO]),
                                               apu4args[ECFM_INDEX_TWO],
                                               *(apu4args[ECFM_INDEX_ONE]),
                                               u2LocalPortId);
            break;
            /*PBB MODE Mep creation/deletion */
        case CLI_ECFM_UP_ACTIVE_PBB_MEP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            u4MdLevel,
                                            ECFM_MP_DIR_UP,
                                            u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_TRUE,
                                            u2LocalPortId);
            break;
        case CLI_ECFM_UP_PBB_MEP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            u4MdLevel,
                                            ECFM_MP_DIR_UP,
                                            u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_FALSE,
                                            u2LocalPortId);
            break;

        case CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            u4MdLevel,
                                            ECFM_MP_DIR_DOWN,
                                            u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_TRUE,
                                            u2LocalPortId);
            break;
        case CLI_ECFM_DOWN_PBB_MEP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            u4MdLevel,
                                            ECFM_MP_DIR_DOWN,
                                            u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_FALSE,
                                            u2LocalPortId);
            break;

        case CLI_ECFM_UP_ACTIVE_PBB_MEP_CTRL_CONF_LEV:
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_MP_DIR_UP, u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_TRUE,
                                            u2LocalPortId);
            break;
        case CLI_ECFM_UP_PBB_MEP_CTRL_CONF_LEV:
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_MP_DIR_UP, u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_FALSE,
                                            u2LocalPortId);
            break;

        case CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_CONF_LEV:
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_MP_DIR_DOWN, u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_TRUE,
                                            u2LocalPortId);
            break;
        case CLI_ECFM_DOWN_PBB_MEP_CTRL_CONF_LEV:
            i4RetVal = EcfmCliConfigPbbMep (CliHandle, u4Command,
                                            *(apu4args[ECFM_INDEX_ZERO]),
                                            ECFM_MP_DIR_DOWN, u4ContextId,
                                            *(apu4args[ECFM_INDEX_ONE]),
                                            ECFM_SNMP_FALSE,
                                            u2LocalPortId);
            break;
        case CLI_ECFM_UP_ACTIVE_PBB_MEP_CTRL_NOCONF_DOM:
        case CLI_ECFM_UP_PBB_MEP_CTRL_NOCONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_UP, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliDeleteOrDisablePbbMep (CliHandle, u4Command,
                                                     u4MdLevel,
                                                     *(apu4args
                                                       [ECFM_INDEX_ONE]),
                                                     u2LocalPortId);
            break;
        case CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_NOCONF_DOM:
        case CLI_ECFM_DOWN_PBB_MEP_CTRL_NOCONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_MP_DIR_DOWN, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliDeleteOrDisablePbbMep (CliHandle, u4Command,
                                                     u4MdLevel,
                                                     *(apu4args
                                                       [ECFM_INDEX_ONE]),
                                                     u2LocalPortId);
            break;

        case CLI_ECFM_UP_ACTIVE_PBB_MEP_CTRL_NOCONF_LEV:
        case CLI_ECFM_UP_PBB_MEP_CTRL_NOCONF_LEV:
        case CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_NOCONF_LEV:
        case CLI_ECFM_DOWN_PBB_MEP_CTRL_NOCONF_LEV:
            i4RetVal = EcfmCliDeleteOrDisablePbbMep (CliHandle, u4Command,
                                                     *(apu4args
                                                       [ECFM_INDEX_ZERO]),
                                                     *(apu4args
                                                       [ECFM_INDEX_ONE]),
                                                     u2LocalPortId);
            break;

            /* MIP configuration/deletion in PBB mode */
        case CLI_ECFM_PBB_MIP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigPbbMip (CliHandle, CLI_ECFM_CONFIG_MIP_LEV_VLAN,
                                     u4ContextId, u4MdLevel,
                                     u2LocalPortId);
            break;

        case CLI_ECFM_ACTIVE_PBB_MIP_CTRL_CONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigPbbMip (CliHandle, CLI_ECFM_ACTIVE_MIP_LEV_ISID,
                                     u4ContextId, u4MdLevel,
                                     u2LocalPortId);
            break;

        case CLI_ECFM_PBB_MIP_CTRL_NOCONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisablePbbMip (CliHandle,
                                              CLI_ECFM_DELETE_MIP_LEV_ISID,
                                              u4MdLevel,
                                              u2LocalPortId);
            break;

        case CLI_ECFM_ACTIVE_PBB_MIP_CTRL_NOCONF_DOM:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteOrDisablePbbMip (CliHandle,
                                              CLI_ECFM_DEACTIVE_MIP_LEV_VLAN,
                                              u4MdLevel,
                                              u2LocalPortId);
            break;
        case CLI_ECFM_PBB_MIP_CTRL_CONF_LEV:
            i4RetVal =
                EcfmCliConfigPbbMip (CliHandle, CLI_ECFM_CONFIG_MIP_LEV_VLAN,
                                     u4ContextId,
                                     *((INT4 *) apu4args[ECFM_INDEX_ZERO]),
                                     u2LocalPortId);
            break;

        case CLI_ECFM_ACTIVE_PBB_MIP_CTRL_CONF_LEV:
            i4RetVal =
                EcfmCliConfigPbbMip (CliHandle, CLI_ECFM_ACTIVE_MIP_LEV_ISID,
                                     u4ContextId,
                                     *((INT4 *) apu4args[ECFM_INDEX_ZERO]),
                                     u2LocalPortId);
            break;

        case CLI_ECFM_PBB_MIP_CTRL_NOCONF_LEV:
            i4RetVal =
                EcfmCliDeleteOrDisablePbbMip (CliHandle,
                                              CLI_ECFM_DELETE_MIP_LEV_ISID,
                                              *((INT4 *)
                                                apu4args[ECFM_INDEX_ZERO]),
                                              u2LocalPortId);
            break;

        case CLI_ECFM_ACTIVE_PBB_MIP_CTRL_NOCONF_LEV:
            i4RetVal =
                EcfmCliDeleteOrDisablePbbMip (CliHandle,
                                              CLI_ECFM_DEACTIVE_MIP_LEV_ISID,
                                              *((INT4 *)
                                                apu4args[ECFM_INDEX_ZERO]),
                                              u2LocalPortId);
            break;

            /* MIP configuration/deletion in ECFM mode */
        case CLI_ECFM_CONFIG_MIP_DOM_SER:
        case CLI_ECFM_ACTIVE_MIP_DOM_SER:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                i4RetVal = EcfmCliConfigIsidMip (CliHandle, u4Command,
                                                 u4ContextId,
                                                 u4MdLevel,
                                                 u4VlanIsid,
                                                 u2LocalPortId);

            }
            else
            {
                i4RetVal =
                    EcfmCliConfigMip (CliHandle, u4Command,
                                      u4MdLevel,
                                      u4VlanIsid, u2LocalPortId);
            }
            break;
        case CLI_ECFM_DEACTIVE_MIP_DOM_SER:
        case CLI_ECFM_DELETE_MIP_DOM_SER:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            /* apu4args[ECFM_INDEX_ONE] : Service name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                i4RetVal = EcfmCliDeleteIsidMip (CliHandle, u4Command,
                                                 u4ContextId,
                                                 u4MdLevel,
                                                 u4VlanIsid,
                                                 u2LocalPortId);

            }
            else
            {
                i4RetVal =
                    EcfmCliDeleteMip (CliHandle, u4Command,
                                      u4MdLevel,
                                      u4VlanIsid, u2LocalPortId);
            }
            break;
        case CLI_ECFM_CONFIG_MIP_DOM_VLAN:
        case CLI_ECFM_ACTIVE_MIP_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_CONFIG_MIP_DOM_VSI:
        case CLI_ECFM_ACTIVE_MIP_DOM_VSI:
#endif
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliConfigMip (CliHandle, u4Command,
                                  u4MdLevel,
                                  *((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                  u2LocalPortId);
            break;
        case CLI_ECFM_DEACTIVE_MIP_DOM_VLAN:
        case CLI_ECFM_DELETE_MIP_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DEACTIVE_MIP_DOM_VSI:
        case CLI_ECFM_DELETE_MIP_DOM_VSI:
#endif         
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliDeleteMip (CliHandle, u4Command,
                                  u4MdLevel,
                                  *((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                  u2LocalPortId);
            break;
        case CLI_ECFM_CONFIG_MIP_LEV_VLAN:
        case CLI_ECFM_ACTIVE_MIP_LEV_VLAN:
            i4RetVal =
                EcfmCliConfigMip (CliHandle, u4Command,
                                  *((INT4 *) apu4args[ECFM_INDEX_ZERO]),
                                  *((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                  u2LocalPortId);
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_CONFIG_MIP_LEV_VSI:
        case CLI_ECFM_ACTIVE_MIP_LEV_VSI:
            u4IfIndex = CLI_GET_IFINDEX ();
            VcmGetContextInfoFromIfIndex (u4IfIndex,
                                          &u4ContextId, &u2LocalPortId);
            u4IfIndex = (UINT4) u2LocalPortId;

            i4RetVal =
                EcfmCliConfigMip (CliHandle, u4Command,
                                  *((INT4 *) apu4args[ECFM_INDEX_ZERO]),
                                  *((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                  u4IfIndex);
            break;
#endif            
        case CLI_ECFM_DEACTIVE_MIP_LEV_VLAN:
        case CLI_ECFM_DELETE_MIP_LEV_VLAN:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DEACTIVE_MIP_LEV_VSI:
        case CLI_ECFM_DELETE_MIP_LEV_VSI:
#endif
            i4RetVal =
                EcfmCliDeleteMip (CliHandle, u4Command,
                                  *((INT4 *) apu4args[ECFM_INDEX_ZERO]),
                                  *((INT4 *) apu4args[ECFM_INDEX_ONE]),
                                  u2LocalPortId);
            break;
        case CLI_ECFM_CONFIG_MIP_DOM_ISID:
        case CLI_ECFM_ACTIVE_MIP_DOM_ISID:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliConfigIsidMip (CliHandle, u4Command,
                                             u4ContextId,
                                             u4MdLevel,
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ONE]),
                                             u2LocalPortId);
            break;

        case CLI_ECFM_DEACTIVE_MIP_DOM_ISID:
        case CLI_ECFM_DELETE_MIP_DOM_ISID:
            /* apu4args[ECFM_INDEX_ZERO] : Domain name */
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO], NULL,
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_DELETE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            i4RetVal = EcfmCliDeleteIsidMip (CliHandle, u4Command,
                                             u4ContextId,
                                             u4MdLevel,
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ONE]),
                                             u2LocalPortId);
            break;
        case CLI_ECFM_CONFIG_MIP_LEV_ISID:
        case CLI_ECFM_ACTIVE_MIP_LEV_ISID:
            i4RetVal = EcfmCliConfigIsidMip (CliHandle, u4Command,
                                             u4ContextId,
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ZERO]),
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ONE]),
                                             u2LocalPortId);
            break;

        case CLI_ECFM_DEACTIVE_MIP_LEV_ISID:
        case CLI_ECFM_DELETE_MIP_LEV_ISID:
            i4RetVal = EcfmCliDeleteIsidMip (CliHandle, u4Command,
                                             u4ContextId,
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ZERO]),
                                             *((INT4 *)
                                               apu4args[ECFM_INDEX_ONE]),
                                             u2LocalPortId);
            break;

            /************************* Y.1731 Commands ***********************/
            /* Enables or disables Y.1731 globally */
        case CLI_ECFM_ENABLE_Y1731:
        case CLI_ECFM_DISABLE_Y1731:
            i4RetVal =
                EcfmCliSetY1731Status (CliHandle, u4ContextId, u4Command);
            break;

            /* Sets or Resets Frame Delay Buffer size */
        case CLI_ECFM_SET_FD_BUFFER_SIZE:
        case CLI_ECFM_RESET_FD_BUFFER_SIZE:
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            i4RetVal =
                EcfmCliSetFDBufferSize (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            break;

            /* Sets or Resets Loopback cache size and holdtime */
        case CLI_ECFM_SET_LBRCACHE_SIZE_HOLDTIME:
        case CLI_ECFM_SET_LBRCACHE_SIZE:
        case CLI_ECFM_SET_LBRCACHE_HOLDTIME:
        case CLI_ECFM_RESET_LBRCACHE_SIZE_HOLDTIME:
        case CLI_ECFM_RESET_LBRCACHE_SIZE:
        case CLI_ECFM_RESET_LBRCACHE_HOLDTIME:
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            i4RetVal =
                EcfmCliSetLbrCacheParams (CliHandle, u4ContextId, u4Command,
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                          (UINT1 *) apu4args[ECFM_INDEX_ONE]);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            break;

            /* Sets or Resets Error-log size and status */
        case CLI_ECFM_SET_ERR_LOG_SIZE:
        case CLI_ECFM_ENABLE_ERR_LOG:
        case CLI_ECFM_DISABLE_ERR_LOG:
        case CLI_ECFM_DISABLE_ERR_LOG_SET_SIZE:
            i4RetVal =
                EcfmCliSetErrLogParams (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;

            /*************** Start of MEP MODE Related Commands**************/
            /* Sets the Frame Delay Threshold value */
        case CLI_ECFM_SET_FD_THRESHOLD:
            i4RetVal =
                EcfmCliSetFDThreshold (CliHandle, u4ContextId,
                                       *(apu4args[ECFM_INDEX_ZERO]));
            break;

            /* Sets the unicast/multicast mac address for CCM PDU */
        case CLI_ECFM_SET_CCM_MULTICAST_MAC:
        case CLI_ECFM_SET_CCM_UNICAST_MAC:
            i4RetVal =
                EcfmCliSetCcmMac (CliHandle, u4ContextId, u4Command,
                                  (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Sets or Resets MEP capability */
        case CLI_ECFM_SET_MEP_CAPABILITY:
            i4RetVal =
                EcfmCliSetMepCapability (CliHandle, u4ContextId,
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ZERO]));
            break;

            /* Sets or Resets RDI Capability and period */
        case CLI_ECFM_DISABLE_RDI_CAP:
        case CLI_ECFM_ENABLE_RDI_CAP:
        case CLI_ECFM_RDI_PERIOD:
            i4RetVal =
                EcfmCliSetMepRdiCapability (CliHandle, u4ContextId, u4Command,
                                            (UINT1 *)
                                            apu4args[ECFM_INDEX_ZERO]);
            break;
            /* Sets or Resets CSF Capability */
        case CLI_ECFM_DISABLE_CSF_CAP:
        case CLI_ECFM_ENABLE_CSF_CAP:
            i4RetVal = 
                EcfmCliSetMepCsfCapability (CliHandle, u4ContextId, u4Command);
                break; 

            /* Set AIS Capability on MEP , Ais period and interval */
        case CLI_ECFM_ENABLE_AIS_CAP:
        case CLI_ECFM_DISABLE_AIS_CAP:
        case CLI_ECFM_CONF_AIS_PARAMS:
            i4RetVal =
                EcfmCliSetMepAisCapability (CliHandle, u4ContextId, u4Command,
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_ONE]),
                                            (UINT1 *)
                                            apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Sets or Resets Frame Loss Buffer size */
        case CLI_ECFM_SET_FL_BUFFER_SIZE:
        case CLI_ECFM_RESET_FL_BUFFER_SIZE:
            i4RetVal =
                EcfmCliSetFLBufferSize (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Sets the Client Layer MEP's MD Level */
        case CLI_ECFM_SET_CLNT_LAYER_LEVEL:
        case CLI_ECFM_RESET_CLNT_LAYER_LEVEL:
            i4RetVal =
                EcfmCliSetClntLayerLevel (CliHandle, u4ContextId, u4Command,
                                          (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
            break;

            /* Sets the Ais and Lck Client mac address */
        case CLI_ECFM_SET_AIS_CLNT_MAC:
        case CLI_ECFM_SET_LCK_CLNT_MAC:
        case CLI_ECFM_SET_AIS_LCK_CLNT_MAC:
            i4RetVal =
                EcfmCliSetClntMacAddr (CliHandle, u4ContextId, u4Command,
                                       (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                       (UINT1 *) apu4args[ECFM_INDEX_ONE]);
            break;

            /* Sets the Near-end and Far-end Loss Threshold value */
        case CLI_ECFM_SET_LOSS_THRESHOLD:
            i4RetVal =
                EcfmCliSetFLThreshold (CliHandle, u4ContextId,
                                       (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                       (UINT1 *) apu4args[ECFM_INDEX_ONE]);
            break;

            /* Set MEP for out-of-serivce operations */
        case CLI_ECFM_SET_OUT_OF_SERVICE:
        case CLI_ECFM_RESET_OUT_OF_SERVICE:
        case CLI_ECFM_CONF_LCK_PARAMS:
            i4RetVal =
                EcfmCliSetOutOfServiceParams (CliHandle, u4ContextId,
                                              u4Command,
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_TWO]),
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ZERO],
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_ONE]);
            break;

            /* Sets Vlan priority and Drop eligibility parameters */
        case CLI_ECFM_VLAN_PARAM_PRIORITY_DOM:
        case CLI_ECFM_VLAN_PARAM_DOM:
        case CLI_ECFM_VLAN_PARAM_PRIORITY_LEV:
        case CLI_ECFM_VLAN_PARAM_LEVEL:
        case CLI_ECFM_VLAN_PARAM_PRIORITY:
        case CLI_ECFM_VLAN_PARAM:
            i4RetVal =
                EcfmCliSetVlanParams (CliHandle, u4ContextId, u4Command,
                                      CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ZERO]),
                                      (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                      (UINT1 *) apu4args[ECFM_INDEX_TWO]);
            break;
        case CLI_ECFM_SET_DROP_ELIGIBILITY:
            i4RetVal =
                EcfmCliSetDropEligibility (CliHandle, u4ContextId,
                                           CLI_PTR_TO_U4 (apu4args
                                                          [ECFM_INDEX_ZERO]),
                                           CLI_PTR_TO_U4 (apu4args
                                                          [ECFM_INDEX_ONE]));
            break;
        case CLI_ECFM_SET_VLAN_PRIORITY:
            i4RetVal =
                EcfmCliSetVlanPriority (CliHandle, u4ContextId,
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_ZERO]),
                                        (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                        (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                        (UINT1 *) apu4args[ECFM_INDEX_FIVE],
                                        (UINT1 *) apu4args[ECFM_INDEX_SIX],
                                        (UINT1 *) apu4args[ECFM_INDEX_SEVEN],
                                        (UINT1 *) apu4args[ECFM_INDEX_EIGHT],
                                        (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TEN],
                                        (UINT1 *) apu4args[ECFM_INDEX_ELEVEN]);
            break;

            /* Set 1DM Transaction interval */
        case CLI_ECFM_SET_DM_TRANS_INTERVAL:
            i4RetVal =
                EcfmCliSet1DMTransInterval (CliHandle, u4ContextId,
                                            *((INT4 *)
                                              apu4args[ECFM_INDEX_ZERO]));
            break;

            /*Set Fault Alarm Time */
        case CLI_ECFM_FNG_SET_ALARMTIME:
            i4RetVal =
                EcfmCliConfigureFaultAlarmTime (CliHandle, u4ContextId,
                                                *((INT4 *)
                                                  apu4args[ECFM_INDEX_ZERO]),
                                                CLI_ECFM_FNG_SET_ALARMTIME);
            break;

            /*Set Fault Reset Time */
        case CLI_ECFM_FNG_SET_RESETTIME:
            i4RetVal =
                EcfmCliConfigureFaultAlarmTime (CliHandle, u4ContextId,
                                                *((INT4 *)
                                                  apu4args[ECFM_INDEX_ZERO]),
                                                CLI_ECFM_FNG_SET_RESETTIME);
            break;

            /*************** End of MEP MODE Related Commands**************/
            /* Set MEP's capability for MEPs at same level and vlan */
        case CLI_ECFM_SET_DOM_UNAWARE_MEP_CAPABILITY_IN_MA:
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain level name */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             NULL, &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_ZERO]),
                                                  NULL,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ONE]);
            break;
        case CLI_ECFM_SET_LEV_UNAWARE_MEP_CAPABILITY_IN_MA:
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain level list */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_ZERO]),
                                                  (UINT1 *) (apu4args
                                                             [ECFM_INDEX_TWO]),
                                                  NULL);
            break;
        case CLI_ECFM_SET_MEP_CAPABILITY_IN_DOM_ISID_MA:
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain name */
            /* apu4args[ECFM_INDEX_TWO] : ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             NULL, &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetMultipleMepsIsidCapability (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      NULL);
            break;
        case CLI_ECFM_SET_MEP_CAPABILITY_IN_LEV_ISID_MA:
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain level list */
            /* apu4args[ECFM_INDEX_TWO] : ISID */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            i4RetVal =
                EcfmCliSetMultipleMepsIsidCapability (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      NULL);
            break;
        case CLI_ECFM_SET_MEP_CAPABILITY_IN_DOM_VLAN_MA:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_SET_MEP_CAPABILITY_IN_DOM_VSI_MA:
#endif
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain name */
            /* apu4args[ECFM_INDEX_TWO] : Vlan list */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             NULL, &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_TWO], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_ZERO]),
                                                  NULL,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ONE]);
            break;

        case CLI_ECFM_SET_MEP_CAPABILITY_IN_DOM_SER_MA:
            /* apu4args[ECFM_INDEX_ZERO] : Capability to be set */
            /* apu4args[ECFM_INDEX_ONE] : Domain name */
            /* apu4args[ECFM_INDEX_TWO] : Service name */
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
            if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                             &u4MdLevel, &u4VlanIsid, 0,
                                             &b1IsUnaware, u2LocalPortId,
                                             ECFM_INIT_VAL, ECFM_CREATE)
                == CLI_FAILURE)
            {
                EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                return CLI_FAILURE;
            }
            SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
            if (EcfmStrToLevelList
                (au1MdLevel, au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
            if (CliStrToPortList
                (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                 CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
            {
                u4TempIsid = ECFM_ISID_INTERNAL_TO_ISID (u4VlanIsid);
                i4RetVal =
                    EcfmCliSetMultipleMepsIsidCapability (CliHandle,
                                                          u4ContextId,
                                                          CLI_ECFM_SET_MEP_CAPABILITY_IN_LEV_ISID_MA,
                                                          au1MdLevelList,
                                                          u2NoOfMdLevels,
                                                          (UINT1 *) &u4TempIsid,
                                                          CLI_PTR_TO_U4
                                                          (apu4args
                                                           [ECFM_INDEX_ZERO]),
                                                          NULL);

            }
            else if (b1IsUnaware == ECFM_TRUE)
            {
                i4RetVal =
                    EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                      CLI_ECFM_SET_LEV_UNAWARE_MEP_CAPABILITY_IN_MA,
                                                      au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      pu1VlanList,
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      NULL,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_ONE]);
            }
            else
            {
                i4RetVal =
                    EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      pu1VlanList,
                                                      CLI_PTR_TO_U4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_ONE]);
            }
            break;

        case CLI_ECFM_SET_MEP_CAPABILITY_IN_LEV_VLAN_MA:
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_SET_MEP_CAPABILITY_IN_LEV_VSI_MA:
#endif            
            CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
            if (EcfmStrToLevelList
                ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1MdLevelList,
                 MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Validate level list */
            for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels; u4Index++)

            {
                if ((UINT2) au1MdLevelList[u4Index] > ECFM_MD_LEVEL_MAX)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (CliStrToPortList
                ((UINT1 *) apu4args[ECFM_INDEX_TWO], pu1VlanList,
                 ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

            {
                CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }
            i4RetVal =
                EcfmCliSetMultipleMepsCapability (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_ZERO]),
                                                  NULL, NULL);
            break;

            /* Enabling Y1731 on a port */
        case CLI_ECFM_ENABLE_Y1731_ON_INTF:
        case CLI_ECFM_DISABLE_Y1731_ON_INTF:
            i4RetVal =
                EcfmCliSetPortY1731OperStatus (CliHandle, u4ContextId,
                                               u4Command, CLI_GET_IFINDEX ());
            break;
		case CLI_ECFM_SET_ETH_BN_TR_STATUS:

            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

			i4RetVal = EcfmCliSetEthbnTrStatus (CliHandle, CLI_GET_IFINDEX (), CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ZERO]),
					CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_ONE]));

            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
			break;

            /* Sets Port/MEP loopback status */
        case CLI_ECFM_MEP_LOOPBACK_STATUS:
            i4RetVal =
                EcfmCliSetMepLoopbackStatus (CliHandle, u4ContextId,
                                             CLI_PTR_TO_I4(apu4args[ECFM_INDEX_ZERO]));
            break;

            /* Sets the source mac address for the CFM Messages */
        case CLI_ECFM_SET_MEP_SRC_MAC:
            if (apu4args[0] != NULL)
            {
                StrToMac ((UINT1 *) apu4args[0], MacAddr);
            }
            i4RetVal = EcfmCliSetMepSrcMacAddress (CliHandle, u4ContextId, MacAddr);
            break;

        case CLI_ECFM_SET_MCLAG_MEP_SHUTDOWN:
            i4RetVal = EcfmCliSetMcLagMepShutdown
                        (CliHandle, CLI_PTR_TO_I4(apu4args[ECFM_INDEX_ZERO]));
            break;

        case CLI_ECFM_SET_MCLAG_MEP_FAULT_HOLDTIME:
            i4RetVal = EcfmCliSetMcLagMepFaultHoldTime
                        (CliHandle,CLI_PTR_TO_U4(apu4args[ECFM_INDEX_ZERO]));
            break;

        default:

            /* Given command does not match with any SET command. */
            /* It may be a SHOW command */
            break;
    }

    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
    /* For configuration commands we have to release the context */
    if (b1LbLtTskCmd != ECFM_TRUE)

    {
        ECFM_CC_RELEASE_CONTEXT ();
    }

    else

    {
        ECFM_LBLT_RELEASE_CONTEXT ();
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    if ((i4RetVal == CLI_FAILURE) && (CLI_GET_ERR (&u4ErrCode) == CLI_SUCCESS))

    {
        if ((u4ErrCode >= CLI_ERR_START_ID_ECFM) &&
            (u4ErrCode < CLI_ECFM_MAX_ERR))

        {
            CliPrintf (CliHandle, "\r%% %s",
                       gaEcfmCliErrString[CLI_ERR_OFFSET_ECFM (u4ErrCode)]);
        }
        CLI_SET_ERR (0);
    }
    CLI_SET_CMD_STATUS (i4RetVal);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return i4RetVal;
}

/*******************************************************************************
 * 
 *  FUNCTION NAME   : cli_process_ecfm_user_exec_cmd 
 *  
 *  DESCRIPTION     : Protocol CLI Message Handler Function for the user exec
 *                     mode commands.
 *
 *                                                                        
 *  INPUT           : CliHandle - CliContext ID                           
 *                    u4Command - Command identifier                      
 *                    ... - Variable command argument list                 
 *                                                                        
 *  OUTPUT          : None                                                
 *                                                                        
 *  RETURNS         : CLI_SUCCESS/CLI_FAILURE                             
 *
 ******************************************************************************/
INT4
cli_process_ecfm_user_exec_cmd (tCliHandle CliHandle, UINT4 u4Command, ...)
{
    va_list             ap;
    static UINT4              *apu4args[ECFM_CLI_MAX_ARGS];
    UINT4              *pu4target = NULL;
    UINT1              *pu1ContextName = NULL;
    UINT4               u4Index = ECFM_INIT_VAL;
    UINT4               u4IfIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4TempContextId = ECFM_CLI_INVALID_CONTEXT;
    UINT4               u4Ttl = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4VlanIsid = ECFM_INIT_VAL;
    UINT4               u4NextVlanIsid = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT2               u2NoOfMdLevels = ECFM_INIT_VAL;
    UINT2               u2LocalPortId = ECFM_INIT_VAL;
    static UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE] = "\0";
    UINT1              *pu1MaName = NULL;
    UINT1              *pu1VlanList = NULL;
    static UINT1               au1VlanId[ECFM_INDEX_FIVE] = { 0 };
    static UINT1               au1MdLevelList[MDLEVEL_LIST_SIZE];
    static UINT1               au1MdLevel[ECFM_VAL_12];
    INT1                i1argno = ECFM_INIT_VAL;
    BOOL1               b1SingleContxtCmd = ECFM_FALSE;
    BOOL1               b1IsUnaware = ECFM_FALSE;
    UINT1               u1PortOperStatus = ECFM_DISABLE;
    UINT1               u1LbDestType = ECFM_INIT_VAL;
    static tEcfmMacAddr        MacAddr;
    static tEcfmMacAddr        au1InMacAddr;
    static tEcfmLbLtTransRequest LbRequest;
    static  tEcfmLbLtTransRequest TstRequest;
    static tEcfmLbLtThTransRequest ThRequest;
    /* MPLS-TP OAM related variables */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
#ifdef TRACE_WANTED
    INT4                i4Args = ECFM_INIT_VAL;
#endif

    MEMSET (&MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    MEMSET (&LbRequest, ECFM_INIT_VAL, sizeof (tEcfmLbLtTransRequest));
    MEMSET (&TstRequest, ECFM_INIT_VAL, sizeof (tEcfmLbLtTransRequest));
    MEMSET (&ThRequest, ECFM_INIT_VAL, sizeof (tEcfmLbLtThTransRequest));
    MEMSET (apu4args, ECFM_INIT_VAL, ECFM_CLI_MAX_ARGS * ECFM_VAL_4);
    MEMSET (&au1InMacAddr,0, sizeof (tEcfmMacAddr));
    MEMSET (&au1VlanId,0,sizeof (au1VlanId));
    MEMSET (&au1MdLevelList, 0, sizeof (au1MdLevelList));
    MEMSET (&au1MdLevel,0, sizeof (au1MdLevel));
    MEMSET (&au1MdName, 0, sizeof (au1MdName));
    MEMSET (&apu4args, 0, sizeof (apu4args));

    ECFM_REGISTER_CLI_CC_LOCK ();

    va_start (ap, u4Command);

    /* For MPLS-TP OAM, the domain name parameter is not supported,
     * whereas in Ethernet OAM, domain name is allowed.
     * Hence domain name string is initialied to NULL string so that and
     * passed as argument to a generic function which can be used for both
     * Ethernet and MPLS-TP OAM
     */
    au1MdName[ZERO] = '\0';

    /* Third argument is always interface name/index */
    u4IfIndex = va_arg (ap, UINT4);

    /* NOTE: For EXEC mode commands we have to pass the context-name/NULL
     *       After the u4IfIndex. (ie) In all the cli commands we 
     *       are passing IfIndex as the first argument in 
     *       variable argument list. Like that as the second argument
     *       we have to pass context-name*/
    pu1ContextName = va_arg (ap, UINT1 *);

    /* Walk through the rest of the arguements and store in args array. 
     * Store 16 arguements at the max. This is because vlan commands do not
     * take more than sixteen inputs from the command line. Another reason to
     * store is in some cases first input may be optional but user may give 
     * second input. In that case first arg will be null and second arg only 
     * has value */
    while (1)

    {
        apu4args[i1argno++] = va_arg (ap, UINT4 *);
        if (i1argno == ECFM_CLI_MAX_ARGS)

        {
            break;
        }
    }
    va_end (ap);

    /* Display the global information which is not specfic to any context */
    /* Display OUI */
    if (ECFM_IS_SYSTEM_INITIALISED () != ECFM_TRUE)

    {
        CliPrintf (CliHandle, "\r\n ECFM is not initialised\r\n");
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return CLI_FAILURE;
    }

    switch (u4Command)
    {
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_SHOW_SUMMARY:
            ECFM_UNREGISTER_CLI_CC_LOCK (); /*Unlock it here as inside definition, 
                                             *Lock is taken again */
             EcfmCliShowSummary (CliHandle);
            return i4RetVal;
#endif
        case CLI_ECFM_SHOW_GLOBAL_INFO:

        {
            UINT1               au1OuiVal[ECFM_OUI_LENGTH];
            UINT1               au1OuiStrVal[ECFM_CLI_OUI_STR_LEN];
            tSNMP_OCTET_STRING_TYPE LocalClientOui;

            /* Display OUI for the ECFM  */
            MEMSET (au1OuiVal, 0, ECFM_OUI_LENGTH);
            MEMSET (&LocalClientOui, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
            LocalClientOui.i4_Length = ECFM_OUI_LENGTH;
            LocalClientOui.pu1_OctetList = au1OuiVal;
            nmhGetFsMIEcfmOui (&LocalClientOui);
            ECFM_MEMSET (au1OuiStrVal, 0, ECFM_CLI_OUI_STR_LEN);
            CliOctetToStr (LocalClientOui.pu1_OctetList,
                           LocalClientOui.i4_Length, au1OuiStrVal,
                           ECFM_CLI_OUI_STR_LEN);
            CliPrintf (CliHandle, "\r\nConfigured OUI : %s\r\n", au1OuiStrVal);
            break;
        }

#ifdef TRACE_WANTED
        case CLI_ECFM_GBL_DEBUG:
        case CLI_ECFM_NO_GBL_DEBUG:
            i4RetVal = EcfmCliSetGlobalDebug (CliHandle, u4Command);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            return i4RetVal;
#else /*  */
        case CLI_ECFM_GBL_DEBUG:

            /* fall through */
        case CLI_ECFM_NO_GBL_DEBUG:
            CliPrintf (CliHandle, "\r%% Debug not supported \r\n");
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            return CLI_FAILURE;

#endif /*  */
        default:
            break;
    }

    pu1VlanList = UtilVlanAllocVlanListSize (sizeof (tVlanListExt));

    if (pu1VlanList == NULL)
    {
        CliPrintf (CliHandle, "\r\n Error in Allocating Memory for "
                   "Vlan List\r\n");
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return CLI_FAILURE;
    }

    CLI_MEMSET (pu1VlanList, ECFM_INIT_VAL, sizeof (tVlanListExt));
    /* For Executive mode commands */
    while (EcfmCliGetContextForShowCmd
           (CliHandle, u4Command, pu1ContextName, u4IfIndex,
            u4TempContextId, &u4ContextId, &u2LocalPortId) == ECFM_SUCCESS)

    {
        switch (u4Command)

        {

                /* Show commands */
                /* Domain */
            case CLI_ECFM_SHOW_DOMAIN_BRIEF:
            case CLI_ECFM_SHOW_DOMAIN:
            case CLI_ECFM_SHOW_DOMAIN_LEV_BRIEF:
            case CLI_ECFM_SHOW_DOMAIN_LEV:
                i4RetVal =
                    EcfmCliShowDomains (CliHandle, u4ContextId,
                                        u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;
            case CLI_Y1731_MPLSTPOAM_SHOW_DOM_BRIEF:
            case CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV_BRIEF:
            case CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV:
            case CLI_Y1731_MPLSTPOAM_SHOW_DOM:
                i4RetVal =
                    MplsOamShowDomains (CliHandle, u4ContextId,
                                        u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;
                /* Association/Service */
            case CLI_ECFM_SHOW_SERVICE_BRIEF:
            case CLI_ECFM_SHOW_SERVICE:
            case CLI_ECFM_SHOW_SERVICE_DOMAIN:
            case CLI_ECFM_SHOW_SERVICE_LEVEL:
            case CLI_ECFM_SHOW_SERVICE_DOM_BRIEF:
            case CLI_ECFM_SHOW_SERVICE_LEV_BRIEF:
                i4RetVal =
                    EcfmCliShowServices (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                break;

            case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV_BRIEF:
            case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_BRIEF:
            case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV:
            case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE:
                i4RetVal =
                    MplsOamCliShowServices (CliHandle, u4ContextId, u4Command,
                                            (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                break;
                /* Local Maintenance Point */
            case CLI_ECFM_SHOW_MEP_AT_INTF:
            case CLI_ECFM_SHOW_MEP_AT_DOMAIN:
            case CLI_ECFM_SHOW_MEP_AT_LEVEL:
            case CLI_ECFM_SHOW_MEP_ALL:
            case CLI_ECFM_SHOW_MIP_AT_INTF:
            case CLI_ECFM_SHOW_MIP_AT_DOMAIN:
            case CLI_ECFM_SHOW_MIP_AT_LEVEL:
            case CLI_ECFM_SHOW_MIP_ALL:
            case CLI_ECFM_SHOW_MP_AT_INTF:
            case CLI_ECFM_SHOW_MP_AT_DOMAIN:
            case CLI_ECFM_SHOW_MP_AT_LEVEL:
            case CLI_ECFM_SHOW_MP_ALL:
                i4RetVal =
                    EcfmCliShowLocalMp (CliHandle, u4ContextId, u4Command,
                                        (INT1 *) apu4args[ECFM_INDEX_ZERO],
                                        u4IfIndex,
                                        (INT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;
            case CLI_Y1731_MPLSTPOAM_SHOW_MEP_ALL:
            case CLI_Y1731_MPLSTPOAM_SHOW_MEP_AT_LEVEL:
                i4RetVal =
                    MplsOamCliShowLocalMp (CliHandle, u4ContextId, u4Command,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;
                /* Crosscheck/MaMepList */
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_ISID:
                if (apu4args[ECFM_INDEX_TWO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }
                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ZERO]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ONE]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_TWO]));
                if (apu4args[ECFM_INDEX_TWO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }

                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_ISID:
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ZERO]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ONE]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_TWO]));
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_ISID:
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ZERO]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ONE]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_TWO]));

                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_SER:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_SER:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_SER:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MEP indentifier/Mac address */
                /* apu4args[ECFM_INDEX_ONE] : Domain name / Level */
                /* apu4args[ECFM_INDEX_TWO] : Service name */
                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1 *) (apu4args
                                                          [ECFM_INDEX_ZERO]),
                                               (UINT1 *) (apu4args
                                                          [ECFM_INDEX_ONE]),
                                               (UINT1 *) (apu4args
                                                          [ECFM_INDEX_TWO]));
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_SER:
            case CLI_ECFM_SHOW_RMEP_XCHK_SER:
                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1 *) (apu4args
                                                          [ECFM_INDEX_ZERO]),
                                               (UINT1 *) &u4VlanIsid,
                                               (UINT1 *) (apu4args
                                                          [ECFM_INDEX_ONE]));

                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID:
            case CLI_ECFM_SHOW_RMEP_XCHK_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VSI:
#ifdef DCSG_EXT_WANTED            
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VSI:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VSI:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VSI: 
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VSI:
            case CLI_ECFM_SHOW_RMEP_XCHK_VSI:            
            case CLI_ECFM_SHOW_RMEP_XCHK_VLAN_UNAWARE:
#endif            
            case CLI_ECFM_SHOW_RMEP_XCHK:
                i4RetVal =
                    EcfmCliShowRMepInXChkList (CliHandle, u4ContextId,
                                               u4Command,
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ZERO]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_ONE]),
                                               (UINT1
                                                *) (apu4args[ECFM_INDEX_TWO]));
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_LEV:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_SER:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_LEV:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_SER:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_LEV_SER:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_LEV_SER:
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK:
                i4RetVal =
                    MplsOamCliShowRMepInXChkList (CliHandle, u4ContextId,
                                                  u4Command,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ZERO],
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ONE],
                                                  (UINT1
                                                   *) (apu4args
                                                       [ECFM_INDEX_TWO]));
                break;

                /* Remote MEP in CC Database */
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_SER:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_SER:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_SER:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MEP indentifier/Mac address */
                /* apu4args[ECFM_INDEX_ONE] : Domain name / Level  */
                /* apu4args[ECFM_INDEX_TWO] : Service name */
                i4RetVal =
                    EcfmCliShowRMep (CliHandle, u4ContextId,
                                     u4Command,
                                     (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                     (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                     (UINT1 *) apu4args[ECFM_INDEX_TWO]);

                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_SER:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MEP indentifier/Mac address */
                /* apu4args[ECFM_INDEX_ONE] : Service name */
                i4RetVal =
                    EcfmCliShowRMep (CliHandle, u4ContextId,
                                     u4Command,
                                     (UINT1 *)
                                     apu4args[ECFM_INDEX_ZERO],
                                     (UINT1 *) &u4NextVlanIsid,
                                     (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_ISID:
                if (apu4args[ECFM_INDEX_TWO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }
                i4RetVal =
                    EcfmCliShowRMep (CliHandle, u4ContextId, u4Command,
                                     (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                     (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                     (UINT1 *) apu4args[ECFM_INDEX_TWO]);
                if (apu4args[ECFM_INDEX_TWO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }

                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_ISID:
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliShowRMep (CliHandle, u4ContextId, u4Command,
                                     (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                     (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                     (UINT1 *) apu4args[ECFM_INDEX_TWO]);

                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MPID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VSI:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VSI: 
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VSI: 
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VSI:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VSI:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VSI:
#endif
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VLAN_UNAWARE:
            case CLI_ECFM_SHOW_RMEP_CC_MAC:
            case CLI_ECFM_SHOW_RMEP_DOMAIN:
            case CLI_ECFM_SHOW_RMEP_LEVEL:
            case CLI_ECFM_SHOW_RMEP_ALL:
                i4RetVal =
                    EcfmCliShowRMep (CliHandle, u4ContextId, u4Command,
                                     (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                     (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                     (UINT1 *) apu4args[ECFM_INDEX_TWO]);
                break;

            case CLI_MPLSTPOAM_SHOW_RMEP_ALL:
            case CLI_MPLSTPOAM_SHOW_RMEP_LEVEL:
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV:
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_SER:
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID:
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV_SER:
                /* apu4args[ECFM_INDEX_ZERO]: MepId */
                /* apu4args[ECFM_INDEX_ONE] : MdLevel */
                /* apu4args[ECFM_INDEX_TWO] : Service Name */
                i4RetVal =
                    MplsOamCliShowRMep (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                        (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO]);
                break;

                /* MIP CCM Database */
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                /* apu4args[ECFM_INDEX_ONE] : Mac address */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId, NULL,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 &u4MdLevel, &u4NextVlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                do
                {
                    u4VlanIsid = u4NextVlanIsid;
                    i4RetVal =
                        EcfmCliShowMipCcmDb (CliHandle, u4ContextId, u4Command,
                                             (UINT1 *) &u4VlanIsid,
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             u4IfIndex);
                }
                while (EcfmCliGetNextVlanIsidInfo (CliHandle, u4ContextId,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   u4VlanIsid, &u4NextVlanIsid,
                                                   &b1IsUnaware) ==
                       CLI_SUCCESS);
                break;

            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC_INTF:            
#endif
            case CLI_ECFM_SHOW_MIP_CCM_DB_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB:
                i4RetVal =
                    EcfmCliShowMipCcmDb (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         u4IfIndex);
                break;

                /* Traceroute/LTR Cache */
            case CLI_ECFM_SHOW_TRACEROUTE_CACHE:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal = EcfmCliShowLtCache (CliHandle, u4ContextId);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

                /* Global Information */
            case CLI_ECFM_SHOW_GLOBAL_INFO:
                i4RetVal = EcfmCliShowGlobalInfo (CliHandle, u4ContextId);
                break;

            case CLI_Y1731_MPLSTPOAM_SHOW_GLOBAL_INFO:
                i4RetVal = MplsOamCliShowGlobalInfo (CliHandle, u4ContextId);
                break;
                /*  Errors through Crosschecking */
            case CLI_ECFM_SHOW_ERR_DOM:
            case CLI_ECFM_SHOW_ERR_LEV:
            case CLI_ECFM_SHOW_ERR_ALL:
                i4RetVal =
                    EcfmCliShowErrors (CliHandle, u4ContextId, u4Command,
                                       (INT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;
            case CLI_MPLSTPOAM_SHOW_ERR_LEV:
            case CLI_MPLSTPOAM_SHOW_ERR_ALL:
                i4RetVal =
                    MplsOamCliShowErrors (CliHandle, u4ContextId, u4Command,
                                          (INT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;

                /* Statistics */
            case CLI_ECFM_SHOW_STATS_INTF_DOM_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : Domain name */
                /* apu4args[ECFM_INDEX_ONE] : ISID */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliShowStatistics (CliHandle, u4ContextId, u4Command,
                                           u4IfIndex,
                                           (UINT1 *) &u4MdLevel,
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_LEV_ISID:
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliShowStatistics (CliHandle, u4ContextId, u4Command,
                                           u4IfIndex,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;

            case CLI_ECFM_SHOW_STATS_INTF_ISID:
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }
                i4RetVal =
                    EcfmCliShowStatistics (CliHandle, u4ContextId, u4Command,
                                           u4IfIndex,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                break;
            case CLI_ECFM_SHOW_STATS_INTF_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                i4RetVal =
                    EcfmCliShowStatistics (CliHandle, u4ContextId,
                                           u4Command, u4IfIndex,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                           (UINT1 *) &u4VlanIsid);
                break;

            case CLI_ECFM_SHOW_STATS:
            case CLI_ECFM_SHOW_STATS_INTF_LEV_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_STATS_INTF_LEV_VSI:
            case CLI_ECFM_SHOW_STATS_INTF_DOM_VSI:
            case CLI_ECFM_SHOW_STATS_INTF_VSI:
#endif
            case CLI_ECFM_SHOW_STATS_INTF_LEV_SER:
            case CLI_ECFM_SHOW_STATS_INTF_LEV:
            case CLI_ECFM_SHOW_STATS_INTF_VLAN:
            case CLI_ECFM_SHOW_STATS_INTF:
            case CLI_ECFM_SHOW_STATS_LEV_SER:
            case CLI_ECFM_SHOW_STATS_INTF_DOM_VLAN:
            case CLI_ECFM_SHOW_STATS_INTF_DOM:
            case CLI_ECFM_SHOW_STATS_INTF_DOM_SER:
            case CLI_ECFM_MPLS_SHOW_STATS_LEV:
            case CLI_ECFM_MPLS_SHOW_STATS:
            case CLI_ECFM_SHOW_MPLS_STATS_DOM_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Domain name/ Level */
                /* apu4args[ECFM_INDEX_ONE] : Service name/ VLAN ID */
                i4RetVal =
                    EcfmCliShowStatistics (CliHandle, u4ContextId, u4Command,
                                           u4IfIndex,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                           (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                break;

                /* Port Information */
            case CLI_ECFM_SHOW_PORT:
            case CLI_ECFM_SHOW_PORT_ALL:
                i4RetVal =
                    EcfmShowPortInfo (CliHandle, u4ContextId, u4Command,
                                      u4IfIndex);
                break;

                /* Configuration Errors */
            case CLI_ECFM_SHOW_CONFIG_ERROR_SER_INTF:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                i4RetVal =
                    EcfmCliShowConfigErrors (CliHandle, u4ContextId,
                                             CLI_ECFM_SHOW_CONFIG_ERROR_SER_INTF,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             u4IfIndex);
                break;
            case CLI_ECFM_SHOW_CONFIG_ERROR_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                i4RetVal =
                    EcfmCliShowConfigErrors (CliHandle, u4ContextId,
                                             CLI_ECFM_SHOW_CONFIG_ERROR_SER,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             u4IfIndex);
                break;
            case CLI_ECFM_SHOW_MIP_PREVENT_TBL:
                i4RetVal = EcfmCliShowMipPreventTbl (CliHandle);
                break;
            case CLI_ECFM_SHOW_CONFIG_ERROR_VLAN_INTF:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_CONFIG_ERROR_VSI_INTF:
#endif          
            case CLI_ECFM_SHOW_CONFIG_ERROR_VLAN:
#ifdef DCSG_EXT_WANTED      
            case CLI_ECFM_SHOW_CONFIG_ERROR_VSI:
#endif            
            case CLI_ECFM_SHOW_CONFIG_ERROR_ISID_INTF:
            case CLI_ECFM_SHOW_CONFIG_ERROR_ISID:
            case CLI_ECFM_SHOW_CONFIG_ERROR_INTF:
            case CLI_ECFM_SHOW_CONFIG_ERROR:
                /* apu4args[ECFM_INDEX_ZERO] : VLAN/ISID */
                i4RetVal =
                    EcfmCliShowConfigErrors (CliHandle, u4ContextId,
                                             u4Command,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             u4IfIndex);
                break;

                /* Default-domain */
            case CLI_ECFM_SHOW_DEFAULT_DOMAIN:
                i4RetVal = EcfmShowDefaultDomain (CliHandle, u4ContextId);
                break;

                /******Clear commands***********************************/
                /* Traceroute or LTR cache */
            case CLI_ECFM_CLR_TRACEROUTE_CACHE:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal = EcfmCliClearLtrCache (CliHandle, u4ContextId);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

                /* MIP CCM DB */
            case CLI_ECFM_CLR_MIP_CCM_DB:
                i4RetVal = EcfmCliClearMipCcmDb (CliHandle, u4ContextId);
                break;

                /* Remote MEP Database */
            case CLI_ECFM_CLR_RMEP_DB_DOM:
            case CLI_ECFM_CLR_RMEP_DB_LEV:
            case CLI_ECFM_CLR_RMEP_DB_ALL:
                i4RetVal =
                    EcfmCliClearRemoteMep (CliHandle, u4ContextId, u4Command,
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                           (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;

                /* Errors through Crosschecking */
            case CLI_ECFM_CLR_ERR_DOM:
            case CLI_ECFM_CLR_ERR_LEV:
            case CLI_ECFM_CLR_ERR_ALL:
                i4RetVal =
                    EcfmCliClearErrors (CliHandle, u4ContextId, u4Command,
                                        (INT1 *) apu4args[ECFM_INDEX_ZERO]);
                break;

                /* Clearing Error Log */
            case CLI_ECFM_CLR_ERR_LOG:
                i4RetVal = EcfmCliClearErrorLog (CliHandle, u4ContextId);
                break;

            case CLI_ECFM_CLR_ETH_BN_COUNT:

                if(u4IfIndex != 0)
                {
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();

                        i4RetVal =  EcfmCliClearEthBnCount(CliHandle, u4IfIndex);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                       
                }
                else
                {
                /* Locks are handled inside the function */
                        i4RetVal = EcfmCliClearAllEthBnCount (CliHandle, u4IfIndex);
                }
                break;
                
                /* LBM or ping Initiation */
            case CLI_ECFM_LB_DOM_SER:
                /* apu4args[ECFM_INDEX_TWO] : MD name */
                /* apu4args[3] : Service name */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *) apu4args[3],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                pu1MaName = ((UINT1 *) apu4args[ECFM_INDEX_THREE]);

            case CLI_ECFM_LB_DOM_ISID:
            case CLI_ECFM_LB_LEV_ISID:
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : ISID */
                if (u4Command == CLI_ECFM_LB_LEV_ISID ||
                    u4Command == CLI_ECFM_LB_DOM_ISID)
                {
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }
            case CLI_ECFM_LB_LEV_SER:
                u4MdLevel = *((UINT4 *) apu4args[ECFM_INDEX_TWO]);
                pu1MaName = ((UINT1 *) apu4args[ECFM_INDEX_THREE]);
                /*fallthrough */
            case CLI_ECFM_LB_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_LB_DOM_VSI: 
            case CLI_ECFM_LB_LEV_VSI:
#endif         
            case CLI_ECFM_LB_DOM:
            case CLI_ECFM_LB_LEV_VLAN:
            case CLI_ECFM_LB_LEV:
            case CLI_ECFM_MPTP_LB_LEV_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Mep Identifier */
                /* apu4args[ECFM_INDEX_ONE] : Mac address */
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : Vlan Id / VSI id / ISID */
                /* apu4args[4] : Data pattern */
                /* apu4args[5] : Tlv */
                /* apu4args[6] : PDU size */
                /* apu4args[7] : Variable-bytes */
                /* apu4args[8] : Interval */
                /* apu4args[9] : No of PDUs */
                /* apu4args[10] : Deadline Interval  */
                /* apu4args[11] : Direction */
                /* apu4args[12] : Command type */
                /* apu4args[13] : LBM mode */
                /* ---- MPLS-TP related arguments follows --- */
                /* apu4args[14] : MPLS-TP Target ICC name */
                /* apu4args[15] : MPLS-TP Local Mep */
                /* apu4args[16] : MPLS-TP Target NodeId */
                /* apu4args[17] : MPLS-TP Target If-Num */
                /* apu4args[18] : MPLS-TP TTL */
                /* apu4args[19] : u4IntervalType */

                if (ECFM_LBLT_CLI_EVENT_INFO (CliHandle) != NULL)
                {
                    CLI_SET_ERR (CLI_ECFM_PING_RUNNING_ERR);
                    i4RetVal = CLI_FAILURE;
                    if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                        ((u4Command == CLI_ECFM_LB_DOM_ISID) ||
                         (u4Command == CLI_ECFM_LB_LEV_ISID)))
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                    break;
                }
                if ((pu1MaName == NULL) && (apu4args[ECFM_INDEX_THREE] != NULL))
                {
                    u4VlanIsid = *((UINT4 *) apu4args[ECFM_INDEX_THREE]);
                }

                /* First find the module (i.e. Y1731 or ECFM) 
                 * running on the MEP initiated the LBM */
                if (u4Command != CLI_ECFM_MPTP_LB_LEV_SER)
                {
                    if (apu4args[ECFM_INDEX_ZERO] != NULL)
                    {
                        u1LbDestType = ECFM_TX_DEST_TYPE_MEPID;
                        pu4target = apu4args[ECFM_INDEX_ZERO];
                    }
                    else if (apu4args[ECFM_INDEX_ONE] != NULL)
                    {
                        u1LbDestType = ECFM_TX_DEST_TYPE_UNICAST;
                        pu4target = apu4args[ECFM_INDEX_ONE];
                    }
                    else
                    {
                        u1LbDestType = ECFM_TX_DEST_TYPE_MULTICAST;
                        pu4target = NULL;
                    }
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        i4RetVal =
                            EcfmGetY1731Status (CliHandle, u4ContextId,
                                                u4Command,
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_TWO],
                                                u4VlanIsid,
                                                (INT4) (u4IfIndex),
                                                CLI_PTR_TO_U4 (apu4args
                                                               [ECFM_INDEX_ELEVEN]),
                                                &u1PortOperStatus, pu1MaName,
                                                u1LbDestType, pu4target);
                    }
                    else
                    {
                        i4RetVal =
                            EcfmGetY1731Status (CliHandle, u4ContextId,
                                                u4Command,
                                                (UINT1 *)
                                                apu4args[ECFM_INDEX_TWO], 0,
                                                (INT4) (u4IfIndex),
                                                CLI_PTR_TO_U4 (apu4args
                                                               [ECFM_INDEX_ELEVEN]),
                                                &u1PortOperStatus, pu1MaName,
                                                u1LbDestType, pu4target);
                    }

                    if (i4RetVal == CLI_FAILURE)
                    {
                        if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                            ((u4Command == CLI_ECFM_LB_DOM_ISID) ||
                             (u4Command == CLI_ECFM_LB_LEV_ISID)))
                        {
                            *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                                ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                            apu4args
                                                            [ECFM_INDEX_THREE]);
                        }
                        break;
                    }
                }
                else
                {
                    /* For Y.1731 based MPLS-TP OAM, always Y.1731 port oper status 
                     * is enabled
                     */
                    u1PortOperStatus = ECFM_ENABLE;

                    if (EcfmCliGetMdMaSnmpIndex (CliHandle, u4ContextId,
                                                 au1MdName,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_THREE],
                                                 &u4MdIndex,
                                                 &u4MaIndex) != CLI_SUCCESS)
                    {
                        i4RetVal = CLI_FAILURE;
                        break;
                    }

                    LbRequest.u4LocalMepId =
                        ((apu4args[ECFM_INDEX_FIFTEEN] != NULL) ?
                         *(apu4args[ECFM_INDEX_FIFTEEN]) : ZERO);

                    LbRequest.u4Cmd = u4Command;
                    LbRequest.u4MdIndex = u4MdIndex;
                    LbRequest.u4MaIndex = u4MaIndex;
                }

                /* Register to handle CTRL C event */
                i4RetVal =
                    CliEcfmRegisterSignalHandler (ECFM_SIGINT,
                                                  EcfmLbSignalHandler);

                /* Y1731 LBM */
                if (u1PortOperStatus == ECFM_ENABLE)
                {
                    /* Setting the destination type */
                    if (apu4args[ECFM_INDEX_ZERO] != NULL)
                    {
                        /* This condition is for both Ethernet and MPLS-TP OAM */
                        LbRequest.u4TargetMepId = *(apu4args[ECFM_INDEX_ZERO]);
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MEPID;

                        if (u4Command == CLI_ECFM_MPTP_LB_LEV_SER)
                        {
                            LbRequest.u1LbmTtl =
                                (UINT1) (apu4args[ECFM_INDEX_EIGHTEEN] ?
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_EIGHTEEN]) :
                                         ECFM_LBM_TTL_DEF);
                        }
                    }
                    else if (apu4args[ECFM_INDEX_ONE] != NULL)
                    {
                        StrToMac ((UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  au1InMacAddr);
                        ECFM_MEMCPY (LbRequest.LbTargetMacAddr, au1InMacAddr,
                                     ECFM_MAC_ADDR_LENGTH);
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_UNICAST;
                    }
                    else if ((apu4args[ECFM_INDEX_ZERO] == NULL) &&
                             (u4Command == CLI_ECFM_MPTP_LB_LEV_SER))
                    {
                        /* For MPLS-TP MIP Parameters */
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MIPID;
                        LbRequest.pu1TgtIccCode = (UINT1 *) apu4args
                            [ECFM_INDEX_FOURTEEN];

                        LbRequest.u4TgtNodeId = (((UINT4 *)
                                                  apu4args[ECFM_INDEX_SIXTEEN]
                                                  !=
                                                  NULL) ? *((UINT4 *)
                                                            apu4args
                                                            [ECFM_INDEX_SIXTEEN])
                                                 : ZERO);

                        LbRequest.u4TgtIfNum = (((UINT1 *)
                                                 apu4args[ECFM_INDEX_SEVENTEEN]
                                                 !=
                                                 NULL) ? *((UINT4 *)
                                                           apu4args
                                                           [ECFM_INDEX_SEVENTEEN])
                                                : ZERO);
                        LbRequest.u1LbmTtl =
                            (UINT1) (((UINT1 *) apu4args[ECFM_INDEX_EIGHTEEN] !=
                                      NULL) ? (UINT1)
                                     *apu4args[ECFM_INDEX_EIGHTEEN] :
                                     ECFM_LBM_TTL_DEF);
                    }
                    else
                    {
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MULTICAST;
                    }

                    /* Setting data, test Tlv or none */
                    if (apu4args[ECFM_INDEX_FOUR] != NULL)
                    {
                        LbRequest.u1LbTlvOrNone = ECFM_LBLT_LBM_WITH_DATA_TLV;
                        LbRequest.pu1LbDataPattern =
                            (UINT1 *) apu4args[ECFM_INDEX_FOUR];
                    }
                    else if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FIVE]) != -1)
                    {
                        LbRequest.u1LbTlvOrNone = ECFM_LBLT_LBM_WITH_TEST_TLV;
                        LbRequest.u4LbTstPatternType =
                            CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FIVE]);
                    }
                    else
                    {
                        LbRequest.u1LbTlvOrNone = ECFM_LBLT_LBM_WITHOUT_TLV;
                    }

                    /* Setting the PDU size */
                    if (apu4args[ECFM_INDEX_SIX] != NULL)
                    {
                        LbRequest.u4LbPduSize =
                            *((UINT4 *) apu4args[ECFM_INDEX_SIX]);
                        if (LbRequest.u1LbTlvOrNone ==
                            ECFM_LBLT_LBM_WITH_DATA_TLV)
                        {
                            LbRequest.u4LbPatternSize =
                                *(UINT4 *) (apu4args[ECFM_INDEX_SIX]) -
                                ECFM_VAL_30;
                        }
                        else if (LbRequest.u1LbTlvOrNone ==
                                 ECFM_LBLT_LBM_WITH_TEST_TLV)
                        {
                            LbRequest.u4LbPatternSize =
                                *(UINT4 *) (apu4args[ECFM_INDEX_SIX]) -
                                ECFM_VAL_31;
                        }
                        else
                        {
                            LbRequest.u1LbTlvOrNone =
                                ECFM_LBLT_LBM_WITH_DATA_TLV;
                            LbRequest.u4LbPatternSize =
                                *(UINT4 *) (apu4args[ECFM_INDEX_SIX]) -
                                ECFM_VAL_30;
                        }

                    }
                    else if (apu4args[ECFM_INDEX_SEVEN] != NULL)
                    {
                        LbRequest.b1LbVariableBytes = ECFM_TRUE;
                    }
                    else
                    {
                        if (LbRequest.u1LbTlvOrNone ==
                            ECFM_LBLT_LBM_WITH_TEST_TLV)
                        {
                            LbRequest.u4LbPatternSize = ECFM_VAL_33;
                            LbRequest.u4LbPduSize = ECFM_VAL_64;
                        }
                        else if (LbRequest.u1LbTlvOrNone ==
                                 ECFM_LBLT_LBM_WITH_DATA_TLV)
                        {
                            LbRequest.u4LbPatternSize = ECFM_VAL_34;
                            LbRequest.u4LbPduSize = ECFM_VAL_64;
                        }

                        else

                        {
                            LbRequest.u1LbTlvOrNone = ECFM_LBLT_LBM_WITHOUT_TLV;
                            LbRequest.u4LbPatternSize = 0;
                            LbRequest.u4LbPduSize = ECFM_VAL_27;
                        }
                    }

                    /* Setting no. of PDUs to send */
                    if (apu4args[ECFM_INDEX_NINE] != NULL)

                    {
                        LbRequest.u4LbMessages =
                            *((UINT4 *) apu4args[ECFM_INDEX_NINE]);
                    }

                    else

                    {
                        LbRequest.u4LbMessages = Y1731_LB_MESG_DEF_VAL;
                    }

                    /* Setting interval */
                    if (apu4args[ECFM_INDEX_EIGHT] != NULL)

                    {
                        if (((UINT2) *apu4args[ECFM_INDEX_EIGHT]) >
                            ECFM_LB_INTERVAL_IN_USEC_MAX)
                        {
                            LbRequest.u2LbInterval =
                                (((UINT2) *apu4args[ECFM_INDEX_EIGHT]) /
                                 ECFM_NUM_OF_USEC_IN_A_MSEC);
                            LbRequest.u1LbIntervalType =
                                ECFM_LBLT_LB_INTERVAL_MSEC;
                        }

                        else

                        {
                            LbRequest.u2LbInterval =
                                (UINT2) *apu4args[ECFM_INDEX_EIGHT];
                            if (apu4args[ECFM_INDEX_NINETEEN] != NULL)
                            {
                                LbRequest.u1LbIntervalType =
                                    CLI_PTR_TO_U4 (apu4args
                                                   [ECFM_INDEX_NINETEEN]);
                            }
                            else
                            {
                                LbRequest.u1LbIntervalType =
                                    ECFM_LBLT_LB_INTERVAL_SEC;
                            }
                        }
                    }

                    else

                    {
                        LbRequest.u2LbInterval = Y1731_LB_INTERVAL_DEF_VAL;
                        LbRequest.u1LbIntervalType = ECFM_LBLT_LB_INTERVAL_SEC;
                    }

                    /* Setting deadline interval */
                    if (apu4args[ECFM_INDEX_TEN] != NULL)

                    {
                        LbRequest.u4LbDeadline =
                            *((UINT4 *) apu4args[ECFM_INDEX_TEN]);
                    }

                    else

                    {
                        LbRequest.u4LbDeadline = Y1731_LB_DEADLINE_DEF_VAL;
                    }
                    /* Setting Lbm Mode */
                    if (apu4args[ECFM_INDEX_THIRTEEN] != NULL)
                    {
                        LbRequest.u1LbMode =
                            CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THIRTEEN]);
                    }
                    else
                    {
                        LbRequest.u1LbMode = ECFM_LBLT_LB_REQ_RES_TYPE;
                    }
                    /* Setting Lbr Timeout */
                    if (apu4args[ECFM_INDEX_FOURTEEN] != NULL)
                    {
                        LbRequest.u4LbrTimeout =
                            CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOURTEEN]);
                    }
                    else
                    {
                        LbRequest.u4LbrTimeout = ECFM_LTR_TIMEOUT_DEF_VAL;
                    }

                    /*If we are not able to register the interrupt handler for
                     * ctrl+c then we need to stop the transaction in 10 seconds
                     * */
                    if ((i4RetVal == CLI_FAILURE) &&
                        (LbRequest.u4LbDeadline == 0) &&
                        (LbRequest.u4LbMessages == 0))

                    {
                        LbRequest.u4LbDeadline = ECFM_LB_INTERVAL_DEF_VAL;
                    }
                    i4RetVal = CLI_SUCCESS;
                    if (apu4args[ECFM_INDEX_THREE] != NULL)

                    {
                        i4RetVal =
                            EcfmCliXmitY1731Lbm (CliHandle, u4ContextId,
                                                 u4Command,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 u4VlanIsid, (INT4) (u4IfIndex),
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_ELEVEN]),
                                                 LbRequest,
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_TWELVE]),
                                                 pu1MaName, pu4target);
                    }

                    else

                    {
                        i4RetVal =
                            EcfmCliXmitY1731Lbm (CliHandle, u4ContextId,
                                                 u4Command,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO], 0,
                                                 (INT4) (u4IfIndex),
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_ELEVEN]),
                                                 LbRequest,
                                                 CLI_PTR_TO_U4 (apu4args
                                                                [ECFM_INDEX_TWELVE]),
                                                 pu1MaName, pu4target);
                    }
                }
                /* ECFM LBM */
                else

                {

                    /* Setting the destination type */
                    if (apu4args[ECFM_INDEX_ZERO] != NULL)

                    {
                        LbRequest.u4TargetMepId = *(apu4args[ECFM_INDEX_ZERO]);
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MEPID;
                    }
                    if (apu4args[ECFM_INDEX_ONE] != NULL)

                    {
                        StrToMac ((UINT1 *) apu4args[ECFM_INDEX_ONE],
                                  au1InMacAddr);
                        ECFM_MEMCPY (LbRequest.LbTargetMacAddr, au1InMacAddr,
                                     ECFM_MAC_ADDR_LENGTH);
                        LbRequest.u1LbDestType = ECFM_TX_DEST_TYPE_UNICAST;
                    }
                    if ((apu4args[ECFM_INDEX_ZERO] == NULL) &&
                        (apu4args[ECFM_INDEX_ONE] == NULL))
                    {
                        CLI_SET_ERR (CLI_ECFM_MISSING_MEP_MAC_IN_8021AG_ERR);
                        i4RetVal = CLI_FAILURE;
                        break;
                    }

                    if ((CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FIVE]) != -1) ||
                        (apu4args[ECFM_INDEX_SIX] != NULL) ||
                        (apu4args[ECFM_INDEX_SEVEN] != NULL) ||
                        (apu4args[ECFM_INDEX_EIGHT] != NULL) ||
                        (apu4args[ECFM_INDEX_TEN] != NULL))
                    {
                        CLI_SET_ERR (CLI_ECFM_INVALID_ECFM_OPTIONS_ERR);
                        i4RetVal = CLI_FAILURE;
                        break;
                    }

                    /* Setting data Tlv */
                    if (apu4args[ECFM_INDEX_FOUR] != NULL)

                    {
                        LbRequest.pu1LbDataPattern =
                            (UINT1 *) apu4args[ECFM_INDEX_FOUR];
                        LbRequest.u1LbTlvOrNone = ECFM_LBLT_LBM_WITH_DATA_TLV;
                    }

                    /* Setting no. of PDUs to send */
                    if (apu4args[ECFM_INDEX_NINE] != NULL)

                    {
                        LbRequest.u4LbMessages =
                            *((UINT4 *) apu4args[ECFM_INDEX_NINE]);
                    }
                    if (apu4args[ECFM_INDEX_THREE] != NULL)

                    {
                        i4RetVal =
                            EcfmCliXmitLbm (CliHandle, u4ContextId, u4Command,
                                            (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                            u4VlanIsid, (INT4) (u4IfIndex),
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_ELEVEN]),
                                            LbRequest,
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_TWELVE]),
                                            pu1MaName, pu4target);
                    }

                    else

                    {
                        i4RetVal =
                            EcfmCliXmitLbm (CliHandle, u4ContextId, u4Command,
                                            (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                            0, (INT4) (u4IfIndex),
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_ELEVEN]),
                                            LbRequest,
                                            CLI_PTR_TO_U4 (apu4args
                                                           [ECFM_INDEX_TWELVE]),
                                            pu1MaName, pu4target);

                    }
                }
                b1SingleContxtCmd = ECFM_TRUE;
                if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                    ((u4Command == CLI_ECFM_LB_DOM_ISID) ||
                     (u4Command == CLI_ECFM_LB_LEV_ISID)))
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }

                /* Unregister Ctrl C */
                CliEcfmUnRegisterSignalHandler (ECFM_SIGINT);
                break;
                /* Traceroute or LTM Initiation */
            case CLI_ECFM_LT_DOMAIN_SER:
                /* apu4args[ECFM_INDEX_TWO] : MD name */
                /* apu4args[3] : Service name */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_THREE],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL,
                                                 ECFM_INIT_VAL) == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                pu1MaName = (UINT1 *) apu4args[ECFM_INDEX_THREE];
                apu4args[ECFM_INDEX_THREE] = (UINT4 *) &u4VlanIsid;

            case CLI_ECFM_LT_LEVEL_SER:
                if (u4Command == CLI_ECFM_LT_LEVEL_SER)
                {
                    u4MdLevel = *(UINT4 *) apu4args[ECFM_INDEX_TWO];
                    pu1MaName = (UINT1 *) apu4args[ECFM_INDEX_THREE];
                }
            case CLI_ECFM_LT_DOMAIN_ISID:
            case CLI_ECFM_LT_LEVEL_ISID:
                if (u4Command == CLI_ECFM_LT_DOMAIN_ISID
                    || u4Command == CLI_ECFM_LT_LEVEL_ISID)
                {
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }
                /*fallthrough */
                /* Traceroute or LTM Initiation */
            case CLI_ECFM_LT_DOMAIN:
            case CLI_ECFM_LT_DOMAIN_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_LT_DOMAIN_VSI:
            
            case CLI_ECFM_LT_LEVEL_VSI:
#endif            
            case CLI_ECFM_LT_LEVEL:
            case CLI_ECFM_LT_LEVEL_VLAN:
                /* apu4args[ECFM_INDEX_ZERO] : Mep Identifier */
                /* apu4args[ECFM_INDEX_ONE] : Mac address */
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : Vlan Id */
                /* apu4args[4] : Time to live, to be included in LTR */
                /* apu4args[5] : Time for all the replies (LTR) of a TM 
                   to be received by the MEP */
                /* apu4args[6] : To use MIP CCM DB or not for forwarding */
                /* apu4args[7] : Direction */

                /* If user has provided TTL value */
                if (apu4args[ECFM_INDEX_FOUR] != NULL)

                {
                    u4Ttl = *((UINT4 *) apu4args[ECFM_INDEX_FOUR]);
                }

                else

                {
                    u4Ttl = ECFM_LTM_TTL_DEF_VAL;
                }

                /* Register to handle CTRL C event */
                i4RetVal =
                    CliEcfmRegisterSignalHandler (ECFM_SIGINT,
                                                  EcfmLtSignalHandler);
                /* If user has provided target mepid */
                if (apu4args[ECFM_INDEX_ZERO] != NULL)

                {
                    i4RetVal =
                        EcfmCliXmitLtmForMpId (CliHandle, u4ContextId,
                                               u4Command,
                                               *((UINT4 *)
                                                 apu4args[ECFM_INDEX_ZERO]),
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_TWO],
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_THREE],
                                               u4Ttl,
                                               (UINT1 *)
                                               apu4args[ECFM_INDEX_FIVE],
                                               CLI_PTR_TO_U4 (apu4args
                                                              [ECFM_INDEX_SIX]),
                                               CLI_PTR_TO_U4 (apu4args
                                                              [ECFM_INDEX_SEVEN]),
                                               (INT4) (u4IfIndex), pu1MaName);
                }

                /* If user has provided target Mac Address */
                else if (apu4args[ECFM_INDEX_ONE] != NULL)

                {
                    StrToMac ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1InMacAddr);
                    i4RetVal =
                        EcfmCliXmitLtmForMacAddr (CliHandle, u4ContextId,
                                                  u4Command, au1InMacAddr,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_TWO],
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_THREE],
                                                  u4Ttl,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_FIVE],
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_SIX]),
                                                  CLI_PTR_TO_U4 (apu4args
                                                                 [ECFM_INDEX_SEVEN]),
                                                  u2LocalPortId, pu1MaName);
                }
                b1SingleContxtCmd = ECFM_TRUE;
                if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                    ((u4Command == CLI_ECFM_LT_DOMAIN_ISID) ||
                     (u4Command == CLI_ECFM_LT_LEVEL_ISID)))
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }
                /* Unregister Ctrl C */
                CliEcfmUnRegisterSignalHandler (ECFM_SIGINT);
                break;

                /* Enabling or Disabling of Crosschecking */
            case CLI_ECFM_ENABLE_DOM_SER_XCHKING:
            case CLI_ECFM_DISABLE_DOM_SER_XCHKING:
                /* apu4args[ECFM_INDEX_ZERO] : Domain name */
                /* apu4args[ECFM_INDEX_ONE] : Service name */
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (u4MdLevel <= ECFM_MD_LEVEL_MAX)
                {
                    SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
                }
                else
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                if (EcfmStrToLevelList
                    (au1MdLevel, au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }

                if (ECFM_IS_MEP_ISID_AWARE ((INT4) u4VlanIsid))
                {
                    i4RetVal =
                        EcfmCliSetXcheckIsidEnableStatus (CliHandle,
                                                          u4ContextId,
                                                          u4Command,
                                                          au1MdLevelList,
                                                          u2NoOfMdLevels,
                                                          (UINT1 *)
                                                          &u4VlanIsid, (UINT1 *)
                                                          apu4args
                                                          [ECFM_INDEX_ZERO]);

                }
                else
                {
                    SPRINTF ((CHR1 *) au1VlanId, "%u", u4VlanIsid);
                    if (CliStrToPortList
                        (au1VlanId, pu1VlanList, ECFM_VLAN_LIST_SIZE,
                         CFA_L2VLAN) == CLI_FAILURE)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                    i4RetVal =
                        EcfmCliSetXcheckEnableStatus (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      pu1VlanList, (UINT1 *)
                                                      apu4args
                                                      [ECFM_INDEX_ZERO]);
                }
                break;
            case CLI_ECFM_ENABLE_DOM_VLAN_XCHKING:
            case CLI_ECFM_DISABLE_DOM_VLAN_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0, &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }

                if (u4MdLevel <= ECFM_MD_LEVEL_MAX)
                {
                    SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
                }
                else
                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                if (EcfmStrToLevelList
                    (au1MdLevel, au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                if (CliStrToPortList
                    ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                     ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetXcheckEnableStatus (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ZERO]);

                break;
            case CLI_ECFM_ENABLE_LEV_VLAN_XCHKING:
            case CLI_ECFM_DISABLE_LEV_VLAN_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                if (EcfmStrToLevelList
                    ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                if (CliStrToPortList
                    ((UINT1 *) apu4args[ECFM_INDEX_ONE], pu1VlanList,
                     ECFM_VLAN_LIST_SIZE, CFA_L2VLAN) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Vlan List\r\n");
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliSetXcheckEnableStatus (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  NULL);
                break;
            case CLI_ECFM_ENABLE_DOM_ISID_XCHKING:
            case CLI_ECFM_DISABLE_DOM_ISID_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0, &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
                if (EcfmStrToLevelList
                    (au1MdLevel, au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                i4RetVal =
                    EcfmCliSetXcheckIsidEnableStatus (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)
                                                      apu4args
                                                      [ECFM_INDEX_ZERO]);
                break;
            case CLI_ECFM_ENABLE_LEV_ISID_XCHKING:
            case CLI_ECFM_DISABLE_LEV_ISID_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                if (EcfmStrToLevelList
                    ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                i4RetVal =
                    EcfmCliSetXcheckIsidEnableStatus (CliHandle, u4ContextId,
                                                      u4Command, au1MdLevelList,
                                                      u2NoOfMdLevels,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      NULL);
                break;
            case CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING:
            case CLI_ECFM_DOM_UNAWARE_DISABLE_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                CLI_MEMSET (au1MdLevel, ECFM_VAL_0, ECFM_VAL_12);
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0, &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                SPRINTF ((CHR1 *) au1MdLevel, "%u", u4MdLevel);
                if (EcfmStrToLevelList
                    (au1MdLevel, au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                i4RetVal =
                    EcfmCliSetXcheckEnableStatus (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_ZERO]);
                break;
            case CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING:
            case CLI_ECFM_LEV_UNAWARE_DISABLE_XCHKING:
                CLI_MEMSET (au1MdLevelList, '\t', MDLEVEL_LIST_SIZE);
                if (EcfmStrToLevelList
                    ((UINT1 *) apu4args[ECFM_INDEX_ZERO], au1MdLevelList,
                     MDLEVEL_LIST_SIZE, &u2NoOfMdLevels) == CLI_FAILURE)

                {
                    CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Validate level list */
                for (u4Index = ECFM_INIT_VAL; u4Index < u2NoOfMdLevels;
                     u4Index++)

                {
                    if ((UINT2) (au1MdLevelList[u4Index]) > ECFM_MD_LEVEL_MAX)

                    {
                        CliPrintf (CliHandle, "\r%% Invalid Level List\r\n");
                        UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                        ECFM_UNREGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                }
                i4RetVal =
                    EcfmCliSetXcheckEnableStatus (CliHandle, u4ContextId,
                                                  u4Command, au1MdLevelList,
                                                  u2NoOfMdLevels, pu1VlanList,
                                                  NULL);
                break;

#ifdef TRACE_WANTED
                /* Traces */

            case CLI_ECFM_DEBUG_LEVEL:
                i4Args = CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ZERO]);
                EcfmCliSetDebugLevel (CliHandle, i4Args);
                break;

            case CLI_ECFM_DEBUG:
            case CLI_ECFM_NO_DEBUG:
                i4RetVal =
                    EcfmCliSetDebug (CliHandle, u4ContextId, u4Command,
                                     CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_ZERO]));

                /* Since Debug is for the only a context either for a default if
                 * no input is provided or for a particular context, we are not 
                 * suppose to continue the loop */
                b1SingleContxtCmd = ECFM_TRUE;
                break;

#else /*  */
            case CLI_ECFM_DEBUG:
            case CLI_ECFM_NO_DEBUG:

#endif /* TRACE_WANTED */
                /* Clearing global, per port and per MEP statistics */
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : MD name */
                /* apu4args[ECFM_INDEX_ONE] : ISID */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0, &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId, u4Command,
                                            u4IfIndex,
                                            (UINT1 *) &u4MdLevel,
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);

                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                break;

            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : MD level */
                /* apu4args[ECFM_INDEX_ONE] : ISID */
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId, u4Command,
                                            u4IfIndex,
                                            (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);

                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;

            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_ISID:
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId, u4Command,
                                            u4IfIndex,
                                            (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);

                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                break;
            case CLI_ECFM_CLR_ALL_STATS:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId,
                                            CLI_ECFM_CLR_ALL_STATS,
                                            ECFM_INIT_VAL, NULL, NULL);
                break;

            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId,
                                            CLI_ECFM_CLR_MEP_STATS_ON_INTF_SER,
                                            u4IfIndex,
                                            (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                            NULL);
                break;

            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_DOM_SER:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_SER:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VSI: 
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VSI:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VSI:
#endif            
            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV_SER:
            case CLI_ECFM_CLR_GLOBAL_STATS:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VLAN:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_SER:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VLAN:
            case CLI_ECFM_CLR_INTF_STATS:
            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV:
                /* apu4args[ECFM_INDEX_ZERO] : Domain / Level */
                /* apu4args[ECFM_INDEX_ONE]  : Service / Vlan Id  */
                i4RetVal =
                    EcfmCliClearStatistics (CliHandle, u4ContextId, u4Command,
                                            u4IfIndex,
                                            (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                            (UINT1 *) apu4args[ECFM_INDEX_ONE]);
                break;

                /* Clearing Frame delay buffer contents */
            case CLI_ECFM_CLR_FD_BUFFER:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal = EcfmCliClearFDBuffer (CliHandle, u4ContextId);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;
#ifdef DCSG_EXT_WANTED
                /* Clearing Proactive Frame delay buffer contents */
            case CLI_ECFM_CLR_PRO_FD_BUFFER:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal = EcfmCliClearProFDBuffer (CliHandle, u4ContextId);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;
#endif
                /* Clearing Loopback cache contents */
            case CLI_ECFM_CLR_LBR_CACHE:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal = EcfmCliClearLbrCache (CliHandle, u4ContextId);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

                /* Clearing Frame loss buffer contents */
            case CLI_ECFM_CLR_FL_BUFFER:
                i4RetVal = EcfmCliClearFLBuffer (CliHandle, u4ContextId);
                break;

                /* Display details of local MEP */
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_SER:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_SER:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_SER:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MEP indentifier/ Mac address */
                /* apu4args[ECFM_INDEX_ONE] : Domain name/ Level  */
                /* apu4args[ECFM_INDEX_TWO] : Service name */
                i4RetVal =
                    EcfmCliShowLocalMepInfo (CliHandle, u4ContextId,
                                             u4Command,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_TWO]);
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MEP indentifier */
                /* apu4args[ECFM_INDEX_ONE] : Service name */
                i4RetVal =
                    EcfmCliShowLocalMepInfo (CliHandle, u4ContextId,
                                             CLI_ECFM_SHOW_MEP_MPID_ON_SER,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) &u4VlanIsid,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ONE]);
                break;
            case CLI_ECFM_SHOW_MEP_MAC_ON_SER:
                /* apu4args[ECFM_INDEX_ZERO] : MAC address */
                /* apu4args[ECFM_INDEX_ONE] : Service name */
                i4RetVal =
                    EcfmCliShowLocalMepInfo (CliHandle, u4ContextId,
                                             CLI_ECFM_SHOW_MEP_MAC_ON_SER,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) &u4VlanIsid,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ONE]);
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM:
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_VSI:
            case CLI_ECFM_SHOW_MEP_MPID_ON_VSI:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_VSI:
            case CLI_ECFM_SHOW_MEP_MAC_ON_VSI:
	        case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_VSI:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_VSI:
#endif        
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_ISID:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_ISID:
            case CLI_ECFM_SHOW_MEP_MPID_ON_VLAN:
            case CLI_ECFM_SHOW_MEP_MPID_ON_ISID:
            case CLI_ECFM_SHOW_MEP_MPID_ON_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MPID:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_ISID:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_ISID:
            case CLI_ECFM_SHOW_MEP_MAC_ON_ISID:
            case CLI_ECFM_SHOW_MEP_MAC_ON_UNAWARE:
            case CLI_ECFM_SHOW_MEP_MAC:
                i4RetVal =
                    EcfmCliShowLocalMepInfo (CliHandle, u4ContextId,
                                             u4Command,
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_ZERO],
                                             (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                             (UINT1 *)
                                             apu4args[ECFM_INDEX_TWO]);
                break;

            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_LEV_SER:
            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_SER:
            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_LEV:
            case CLI_MPLSTPOAM_SHOW_MEP_MPID:
                /* apu4args[0]   - MepId
                 * apu4args[1]   - MdLevel
                 * apu4args[2]   - Service Name
                 */
                if (apu4args[ECFM_INDEX_ONE] == NULL)
                {
                    i4RetVal =
                        MplsOamCliShowLocalMepInfo (CliHandle, u4ContextId,
                                                    u4Command,
                                                    (UINT1)
                                                    *apu4args[ECFM_INDEX_ZERO],
                                                    (UINT1)
                                                    ECFM_INDEX_ONE,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }
                else
                {
                    i4RetVal =
                        MplsOamCliShowLocalMepInfo (CliHandle, u4ContextId,
                                                    u4Command,
                                                    (UINT1)
                                                    *(apu4args
                                                      [ECFM_INDEX_ZERO]),
                                                    (UINT1)
                                                    *(apu4args[ECFM_INDEX_ONE]),
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }

                break;
                /* Display details of loopback cache */
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_ISID:
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0, &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowLbrCache (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                break;

            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_ISID:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_ISID:
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowLbrCache (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_ISID:
            case CLI_ECFM_SHOW_LBRCACHE_ON_ISID:
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowLbrCache (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                break;

            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM:
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_VSI:
#endif           
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_SER:
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Domain name */
                /* apu4args[ECFM_INDEX_ONE] : Service name / Vlan Id */
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowLbrCache (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO]);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

            case CLI_ECFM_SHOW_LBRCACHE_ON_SER:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Service name */
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_ON_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_VSI:
#endif           
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_ON_UNAWARE:
            case CLI_ECFM_SHOW_LBRCACHE_ON_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_SER:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_SER:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowLbrCache (CliHandle, u4ContextId, u4Command,
                                         (UINT1 *) apu4args[ECFM_INDEX_ZERO],
                                         (UINT1 *) apu4args[ECFM_INDEX_ONE],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

                /* Display details of Frame delay buffer */
            case CLI_ECFM_SHOW_FD_DOM_INTF_ISID:
            case CLI_ECFM_SHOW_FD_DOM_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : Measurement Type of Frame Delay or detailed */
                /* apu4args[ECFM_INDEX_ONE] : Whether user wants brief info */
                /* apu4args[ECFM_INDEX_TWO] : Mac Address of the MEP with which
                   Frame Loss is calculated */
                /* apu4args[3] : Domain name */
                /* apu4args[4] : ISID */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *) apu4args[3], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE]);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }

            case CLI_ECFM_SHOW_FD_LEV_INTF_ISID:
            case CLI_ECFM_SHOW_FD_LEV_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : Measurement Type of Frame Delay or detailed */
                /* apu4args[ECFM_INDEX_ONE] : Whether user wants brief info */
                /* apu4args[ECFM_INDEX_TWO] : Mac Address of the MEP with which
                   Frame Loss is calculated */
                /* apu4args[3] : Domain level */
                /* apu4args[4] : ISID */
                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }

                break;

            case CLI_ECFM_SHOW_FD_INTF_ISID:
            case CLI_ECFM_SHOW_FD_ISID:
                /* apu4args[ECFM_INDEX_ZERO] : Measurement Type of Frame Delay or detailed */
                /* apu4args[ECFM_INDEX_ONE] : Whether user wants brief info */
                /* apu4args[ECFM_INDEX_TWO] : Mac Address of the MEP with which
                   Frame Loss is calculated */
                /* apu4args[3] : ISID */
                if (apu4args[ECFM_INDEX_THREE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }

                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                if (apu4args[ECFM_INDEX_THREE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }

                break;

            case CLI_ECFM_SHOW_FD_DOM_INTF_SER:
            case CLI_ECFM_SHOW_FD_DOM_SER:
            case CLI_ECFM_SHOW_FD_DOM_INTF:
            case CLI_ECFM_SHOW_FD_DOM_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FD_DOM_INTF_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_FD_DOM_INTF_VSI:
            case CLI_ECFM_SHOW_FD_DOM_VSI:
#endif            
            case CLI_ECFM_SHOW_FD_DOM:
            case CLI_ECFM_SHOW_FD_DOM_UNAWARE:
            case CLI_ECFM_SHOW_FD_DOM_VLAN:
                /* apu4args[ECFM_INDEX_ZERO]: Measurement Type of 
                 *                             Frame Delay or detailed */
                /* apu4args[ECFM_INDEX_ONE]: Whether user wants brief info */
                /* apu4args[ECFM_INDEX_TWO]: Mac Address of the MEP with which
                   Frame Loss is calculated */
                /* apu4args[ECFM_INDEX_THREE]: Domain name */
                /* apu4args[ECFM_INDEX_FOUR]: Service name / Vlan Id */
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE]);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

            case CLI_ECFM_SHOW_FD_INTF_SER:
            case CLI_ECFM_SHOW_FD_SER:
            case CLI_ECFM_SHOW_FD_INTF:
            case CLI_ECFM_SHOW_FD_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FD_INTF_VLAN:
#ifdef DCSG_EXT_WANTED
            case CLI_ECFM_SHOW_FD_INTF_VSI:
            case CLI_ECFM_SHOW_FD_VSI:
            case CLI_ECFM_SHOW_FD_LEV_INTF_VSI:
            case CLI_ECFM_SHOW_FD_LEV_VSI:
#endif            
            case CLI_ECFM_SHOW_FD:
            case CLI_ECFM_SHOW_FD_UNAWARE:
            case CLI_ECFM_SHOW_FD_LEV_INTF:
            case CLI_ECFM_SHOW_FD_LEV_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FD_LEV_INTF_VLAN:
            case CLI_ECFM_SHOW_FD_LEV:
            case CLI_ECFM_SHOW_FD_LEV_UNAWARE:
            case CLI_ECFM_SHOW_FD_VLAN:
            case CLI_ECFM_SHOW_FD_LEV_VLAN:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;
            case CLI_ECFM_SHOW_PRO_FD_DOM:
            case CLI_ECFM_SHOW_PRO_FD_DOM_SER:
                /* apu4args[ECFM_INDEX_ZERO]: Measurement Type of
                 *                             Frame Delay or detailed */
                /* apu4args[ECFM_INDEX_ONE]: Whether user wants brief info */
                /* apu4args[ECFM_INDEX_TWO]: Mac Address of the MEP with which
                   Frame Loss is calculated */
                /* apu4args[ECFM_INDEX_THREE]: Domain name */
                /* apu4args[ECFM_INDEX_FOUR]: Service name / Vlan Id */
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowProactiveFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE]);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

            case CLI_ECFM_SHOW_PRO_FD_LEV:
            case CLI_ECFM_SHOW_PRO_FD:
            case CLI_ECFM_SHOW_PRO_FD_SER:
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                i4RetVal =
                    EcfmCliShowProactiveFDBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                break;

                /* Display details of error log */
            case CLI_ECFM_SHOW_ERR_LOG_DOM_ISID:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_ISID:
                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                i4RetVal =
                    EcfmCliShowErrLog (CliHandle, u4ContextId, u4Command,
                                       (INT1 *) apu4args[ECFM_INDEX_ZERO],
                                       (INT1 *) apu4args[ECFM_INDEX_ONE]);

                if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ONE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ONE]);
                }

                break;

            case CLI_ECFM_SHOW_ERR_LOG_ISID:
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                i4RetVal =
                    EcfmCliShowErrLog (CliHandle, u4ContextId, u4Command,
                                       (INT1 *) apu4args[ECFM_INDEX_ZERO],
                                       (INT1 *) apu4args[ECFM_INDEX_ONE]);

                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_ZERO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_ZERO]);
                }

                break;
            case CLI_ECFM_SHOW_ERR_LOG_DOM_SER:
            case CLI_ECFM_SHOW_ERR_LOG_SER:
                /* apu4args[ECFM_INDEX_ZERO] : Domain name */
                /* apu4args[ECFM_INDEX_ONE] : Service name */
            case CLI_ECFM_SHOW_ERR_LOG:
            case CLI_ECFM_SHOW_ERR_LOG_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_VSI:
            case CLI_ECFM_SHOW_ERR_LOG_UNAWARE:
            case CLI_ECFM_SHOW_ERR_LOG_LEV:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_VSI:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_UNAWARE:
            case CLI_ECFM_SHOW_ERR_LOG_DOM:
            case CLI_ECFM_SHOW_ERR_LOG_DOM_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_DOM_VSI:
            case CLI_ECFM_SHOW_ERR_LOG_DOM_UNAWARE:
                i4RetVal =
                    EcfmCliShowErrLog (CliHandle, u4ContextId, u4Command,
                                       (INT1 *) apu4args[ECFM_INDEX_ZERO],
                                       (INT1 *) apu4args[ECFM_INDEX_ONE]);
                break;

                /* Display details of Frame Loss buffer */
            case CLI_ECFM_SHOW_FL_INTF_ISID:
            case CLI_ECFM_SHOW_FL_ISID:
                if (apu4args[ECFM_INDEX_THREE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }
                i4RetVal =
                    EcfmCliShowFLBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);

                if (apu4args[ECFM_INDEX_THREE] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }

                break;

            case CLI_ECFM_SHOW_FL_DOM_INTF_ISID:
            case CLI_ECFM_SHOW_FL_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_THREE],
                                                 NULL, &u4MdLevel, &u4VlanIsid,
                                                 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }

                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }
                i4RetVal =
                    EcfmCliShowFLBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE]);

                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }

                break;

            case CLI_ECFM_SHOW_FL_LEV_INTF_ISID:
            case CLI_ECFM_SHOW_FL_LEV_ISID:
                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }
                i4RetVal =
                    EcfmCliShowFLBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);

                if (apu4args[ECFM_INDEX_FOUR] != NULL)
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_FOUR] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_FOUR]);
                }

                break;

            case CLI_ECFM_SHOW_FL_DOM_SER:
            case CLI_ECFM_SHOW_FL_DOM_INTF_SER:
            case CLI_ECFM_SHOW_FL_SER:
            case CLI_ECFM_SHOW_FL_INTF_SER:
            case CLI_ECFM_SHOW_FL_DOM_INTF:
            case CLI_ECFM_SHOW_FL_DOM_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FL_DOM_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_DOM_INTF_VSI:
            case CLI_ECFM_SHOW_FL_DOM:
            case CLI_ECFM_SHOW_FL_DOM_UNAWARE:
            case CLI_ECFM_SHOW_FL_DOM_VLAN:
            case CLI_ECFM_SHOW_FL_DOM_VSI:
                i4RetVal =
                    EcfmCliShowFLBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) &u4MdLevel,
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE]);
                break;

            case CLI_ECFM_SHOW_FL_INTF:
            case CLI_ECFM_SHOW_FL_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FL_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_INTF_VSI:
            case CLI_ECFM_SHOW_FL:
            case CLI_ECFM_SHOW_FL_UNAWARE:
            case CLI_ECFM_SHOW_FL_LEV_INTF:
            case CLI_ECFM_SHOW_FL_LEV_INTF_UNAWARE:
            case CLI_ECFM_SHOW_FL_LEV_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_LEV_INTF_VSI:
            case CLI_ECFM_SHOW_FL_LEV:
            case CLI_ECFM_SHOW_FL_LEV_UNAWARE:
            case CLI_ECFM_SHOW_FL_VLAN:
            case CLI_ECFM_SHOW_FL_VSI:
            case CLI_ECFM_SHOW_FL_LEV_VLAN:
            case CLI_ECFM_SHOW_FL_LEV_VSI:
                i4RetVal =
                    EcfmCliShowFLBuffer (CliHandle, u4ContextId,
                                         u4IfIndex, u4Command,
                                         CLI_PTR_TO_I4 (apu4args
                                                        [ECFM_INDEX_ZERO]),
                                         CLI_PTR_TO_U4 (apu4args
                                                        [ECFM_INDEX_ONE]),
                                         (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                         (UINT1 *) apu4args[ECFM_INDEX_THREE],
                                         (UINT1 *) apu4args[ECFM_INDEX_FOUR],
                                         NULL);
                break;

            case CLI_ECFM_SHOW_FL_SLM_ONDEMAND:
                i4RetVal =
                    EcfmCliShowFLSlmOnDemandBuffer (CliHandle, u4ContextId,
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                    CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]));

                break;

            case CLI_ECFM_SHOW_FL_SLM_PROACTIVE:
                i4RetVal =
                    EcfmCliShowFLSlmProActiveBuffer (CliHandle, u4ContextId,
                                                     (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                     (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                     CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FIVE]));

                break;

            case CLI_ECFM_DEL_FL_SLM_PROACTIVE:
                i4RetVal =
                    EcfmCliDelFLSlmProActiveConfig (CliHandle, u4ContextId,
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]));

                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_SER:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }

                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *)&u4MdLevel,(UINT1 *)&u4VlanIsid,(UINT1 *) apu4args[ECFM_INDEX_TWO],
                             (UINT1 *)apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),(UINT1 *) apu4args[ECFM_INDEX_ONE],
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_NINE]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_TEN]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_ELEVEN]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_TWELVE]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_THIRTEEN]),
                             (UINT1 *) apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) &u4VlanIsid,
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO],CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_THIRTEEN]),CLI_PTR_TO_U4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VSI:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VSI:

                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }


                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {

                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                            u4Command,(UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),(UINT1 *) 
                            apu4args[ECFM_INDEX_ONE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_ELEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TWELVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),(UINT1 *) 
                            apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) apu4args[ECFM_INDEX_TWO],
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_THIRTEEN]),
                             CLI_PTR_TO_U4 ( (UINT1 *) apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VSI:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VSI:

                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                            u4Command,(UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ONE],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),NULL,CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_ELEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TWELVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),(UINT1 *) 
                            apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =

                        EcfmCliStopSlmProActiveLossMeasurement(CliHandle, u4ContextId,
                            u4Command,(UINT1 *) apu4args[ECFM_INDEX_ONE] ,
                            (UINT1 *) apu4args[ECFM_INDEX_ZERO] ,NULL,(UINT1 *) 
                            apu4args[ECFM_INDEX_TWO],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
                /* Initiate SLM Loss Measurement */
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_SER:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *)&u4MdLevel,(UINT1 *)&u4VlanIsid,(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO],(UINT1 *) apu4args[ECFM_INDEX_THREE],
                             CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_NINE]),(UINT1 *) 
                             apu4args[ECFM_INDEX_ONE]);
                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel, (UINT1 *) &u4VlanIsid, 
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VSI:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VSI:

                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                 /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {

                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                            u4Command,(UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 
                            (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                            (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),(UINT1 *) 
                            apu4args[ECFM_INDEX_ONE]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =       
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                            u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                            apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VSI:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VSI:

                /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ONE],
                             (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                             apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_NINE]), NULL);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_ZERO],NULL,(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
                /* Initiate Loss Measurement */
            case CLI_ECFM_FL_MEP_MPID_DOM_SER:
            case CLI_ECFM_FL_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_SEVEN]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *)
                                                    &u4MdLevel,
                                                    (UINT1 *)
                                                    &u4VlanIsid,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FOUR],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FIVE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_SIX],
                                                    u4IfIndex, (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *) &u4MdLevel,
                                                    (UINT1 *) &u4VlanIsid,
                                                    u4IfIndex,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_FL_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MPID_DOM_VSI:
            case CLI_ECFM_FL_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MAC_DOM_VSI:
            case CLI_ECFM_FL_MEP_MPID_DOM:
            case CLI_ECFM_FL_MEP_MAC_DOM:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_SEVEN]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *)
                                                    &u4MdLevel,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FOUR],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FIVE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_SIX],
                                                    u4IfIndex, (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *)
                                                    &u4MdLevel,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO],
                                                    u4IfIndex, (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
            case CLI_ECFM_FL_MEP_MPID_DOM_ISID:
            case CLI_ECFM_FL_MEP_MAC_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if ((u4Command == CLI_ECFM_FL_MEP_MPID_DOM_ISID) ||
                    (u4Command == CLI_ECFM_FL_MEP_MAC_DOM_ISID))
                {
                    apu4args[ECFM_INDEX_ONE] = &u4MdLevel;
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }
            case CLI_ECFM_FL_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FL_MEP_MAC_LEV_ISID:
                if ((u4Command == CLI_ECFM_FL_MEP_MPID_LEV_ISID) ||
                    (u4Command == CLI_ECFM_FL_MEP_MAC_LEV_ISID))
                {
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }

            case CLI_ECFM_FL_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MPID_LEV_VSI:
            case CLI_ECFM_FL_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MAC_LEV_VSI:
            case CLI_ECFM_FL_MEP_MPID_LEV:
            case CLI_ECFM_FL_MEP_MAC_LEV:
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_SEVEN]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FOUR],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_FIVE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_SIX],
                                                    u4IfIndex, NULL);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                        ((u4Command == CLI_ECFM_FL_MEP_MPID_LEV_ISID) ||
                         (u4Command == CLI_ECFM_FL_MEP_MAC_LEV_ISID)))
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopLossMeasurement (CliHandle, u4ContextId,
                                                    u4Command,
                                                    CLI_PTR_TO_I4 (apu4args
                                                                   [ECFM_INDEX_ZERO]),
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_ONE],
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_TWO],
                                                    u4IfIndex, NULL,
                                                    (UINT1 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                        ((u4Command == CLI_ECFM_FL_MEP_MPID_LEV_ISID) ||
                         (u4Command == CLI_ECFM_FL_MEP_MPID_DOM_ISID)))
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

                /* Initiate/Stop Delay Measurement */
            case CLI_ECFM_FD_MEP_MPID_DOM_SER:
            case CLI_ECFM_FD_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *) apu4args[3],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_EIGHT]) ==
                    CLI_ECFM_FD_START)
                {
                    i4RetVal =
                        EcfmCliInitDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ZERO]),
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     &u4MdLevel,
                                                     (UINT1 *)
                                                     &u4VlanIsid,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FOUR],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FIVE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SIX],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SEVEN],
                                                     u4IfIndex,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO],
                                                     (UINT1 *) apu4args[ECFM_INDEX_NINE], 
                                                     apu4args[ECFM_INDEX_TEN]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     &u4MdLevel,
                                                     (UINT1 *)
                                                     &u4VlanIsid, u4IfIndex,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO]);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                        ((u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID) ||
                         (u4Command == CLI_ECFM_FD_MEP_MAC_DOM_ISID)))

                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_FD_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MPID_DOM_VSI:
            case CLI_ECFM_FD_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MAC_DOM_VSI:
            case CLI_ECFM_FD_MEP_MPID_DOM:
            case CLI_ECFM_FD_MEP_MAC_DOM:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_EIGHT]) ==
                    CLI_ECFM_FD_START)
                {
                    i4RetVal =
                        EcfmCliInitDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ZERO]),
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     &u4MdLevel,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_THREE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FOUR],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FIVE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SIX],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SEVEN],
                                                     u4IfIndex, (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO],
                                                     (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                                     apu4args[ECFM_INDEX_TEN]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     &u4MdLevel,
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_THREE],
                                                     u4IfIndex, (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO]);
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_FD_MEP_MPID_DOM_ISID:
            case CLI_ECFM_FD_MEP_MAC_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }

                if ((u4Command == CLI_ECFM_FD_MEP_MPID_DOM_ISID) ||
                    (u4Command == CLI_ECFM_FD_MEP_MAC_DOM_ISID))
                {
                    /* Make Argument two as MdLevel */
                    apu4args[ECFM_INDEX_TWO] = &u4MdLevel;

                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }

            case CLI_ECFM_FD_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FD_MEP_MAC_LEV_ISID:
                if ((u4Command == CLI_ECFM_FD_MEP_MPID_LEV_ISID) ||
                    (u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID))
                {
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }
            case CLI_ECFM_FD_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FD_MEP_MPID_LEV_VSI:
            case CLI_ECFM_FD_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_FD_MEP_MAC_LEV_VSI:
            case CLI_ECFM_FD_MEP_MPID_LEV:
            case CLI_ECFM_FD_MEP_MAC_LEV:
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_EIGHT]) ==
                    CLI_ECFM_FD_START)
                {
                    i4RetVal =
                        EcfmCliInitDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ZERO]),
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_THREE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FOUR],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_FIVE],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SIX],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_SEVEN],
                                                     u4IfIndex, NULL,
                                                     (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                                     apu4args[ECFM_INDEX_TEN]);
                    if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                        ((u4Command == CLI_ECFM_FD_MEP_MPID_LEV_ISID) ||
                         (u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID)))

                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopDelayMeasurement (CliHandle, u4ContextId,
                                                     u4Command,
                                                     CLI_PTR_TO_I4 (apu4args
                                                                    [ECFM_INDEX_ONE]),
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_TWO],
                                                     (UINT1 *)
                                                     apu4args[ECFM_INDEX_THREE],
                                                     u4IfIndex, NULL);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                        ((u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID) ||
                         (u4Command == CLI_ECFM_FD_MEP_MAC_DOM_ISID)))

                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

                 /* Initiate/Stop Proactive Delay Measurement */
             case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM_SER:
             case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM_SER:
                 if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_TWO],
                                                  (UINT1 *) apu4args[3],
                                                  &u4MdLevel, &u4VlanIsid, 0,
                                                  &b1IsUnaware, u2LocalPortId,
                                                  ECFM_INIT_VAL, ECFM_INIT_VAL)
                     == CLI_FAILURE)
                 {
                     EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                     return CLI_FAILURE;
                 }
                 if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_SIX]) ==
                     CLI_ECFM_FD_PROACTIVE_START)
                 {
                     i4RetVal =
                         EcfmCliInitProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      &u4MdLevel,
                                                      (UINT1 *)
                                                      &u4VlanIsid,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FIVE],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SIX],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SEVEN],
                                                      u4IfIndex,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                                      apu4args[ECFM_INDEX_TEN]);
                                                      

                     b1SingleContxtCmd = ECFM_TRUE;
                 }
                 else
                 {
                     i4RetVal =
                         EcfmCliStopProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      &u4MdLevel,
                                                      (UINT1 *)
                                                      &u4VlanIsid, u4IfIndex,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)apu4args[ECFM_INDEX_FIVE]);
                     if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                         ((u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID) ||
                          (u4Command == CLI_ECFM_FD_MEP_MAC_DOM_ISID)))

                     {
                         *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                             ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                         apu4args
                                                         [ECFM_INDEX_THREE]);
                     }

                     b1SingleContxtCmd = ECFM_TRUE;

                 }
                 break;


             case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM:
             case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM:
                 if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                  (UINT1 *)
                                                  apu4args[ECFM_INDEX_TWO], NULL,
                                                  &u4MdLevel, &u4VlanIsid, 0,
                                                  &b1IsUnaware, u2LocalPortId,
                                                  ECFM_INIT_VAL, ECFM_INIT_VAL)
                     == CLI_FAILURE)
                 {
                     EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                     return CLI_FAILURE;
                 }
                 if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_EIGHT]) ==
                     CLI_ECFM_FD_PROACTIVE_START)
                 {
                     i4RetVal =
                         EcfmCliInitProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      &u4MdLevel,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_THREE],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FIVE],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SIX],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SEVEN],
                                                      u4IfIndex, (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                                      apu4args[ECFM_INDEX_TEN]);

                     b1SingleContxtCmd = ECFM_TRUE;
                 }
                 else
                 {
                     i4RetVal =
                         EcfmCliStopProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      &u4MdLevel,
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_THREE],
                                                      u4IfIndex, (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)apu4args[ECFM_INDEX_FIVE]);

                     b1SingleContxtCmd = ECFM_TRUE;

                 }
                 break;


             case CLI_ECFM_PROACTIVE_FD_MEP_MPID_LEV:
             case CLI_ECFM_PROACTIVE_FD_MEP_MAC_LEV:
                 if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_EIGHT]) ==
                     CLI_ECFM_FD_PROACTIVE_START)
                 {
                     i4RetVal =
                             EcfmCliInitProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ZERO]),
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_THREE],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_FIVE],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SIX],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_SEVEN],
                                                      u4IfIndex, NULL,
                                                      (UINT1 *) apu4args[ECFM_INDEX_NINE],
                                                      apu4args[ECFM_INDEX_TEN]);
                     if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                         ((u4Command == CLI_ECFM_FD_MEP_MPID_LEV_ISID) ||
                          (u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID)))

                     {
                         *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                             ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                         apu4args
                                                         [ECFM_INDEX_THREE]);
                     }

                     b1SingleContxtCmd = ECFM_TRUE;
                 }
                 else
                 {
                     i4RetVal =
                         EcfmCliStopProactiveDM (CliHandle, u4ContextId,
                                                      u4Command,
                                                      CLI_PTR_TO_I4 (apu4args
                                                                     [ECFM_INDEX_ONE]),
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_TWO],
                                                      (UINT1 *)
                                                      apu4args[ECFM_INDEX_THREE],
                                                      u4IfIndex, NULL,
                                                      (UINT1 *)apu4args[ECFM_INDEX_FOUR],
                                                      (UINT1 *)apu4args[ECFM_INDEX_FIVE]);
;
                     if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                         ((u4Command == CLI_ECFM_FD_MEP_MAC_LEV_ISID) ||
                          (u4Command == CLI_ECFM_FD_MEP_MAC_DOM_ISID)))

                     {
                         *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                             ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                         apu4args
                                                         [ECFM_INDEX_THREE]);
                     }

                     b1SingleContxtCmd = ECFM_TRUE;

                 }
                 break;

                /* TST Initiation */
            case CLI_ECFM_TST_DOM_SER:
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : service name */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *) apu4args[3],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                apu4args[ECFM_INDEX_THREE] = &u4VlanIsid;

            case CLI_ECFM_TST_DOM_ISID:
            case CLI_ECFM_TST_LEV_ISID:
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : ISID */
                if (u4Command == CLI_ECFM_TST_LEV_ISID ||
                    u4Command == CLI_ECFM_TST_DOM_ISID)
                {
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }
            case CLI_ECFM_TST_DOM_VLAN:
            case CLI_ECFM_TST_DOM:
            case CLI_ECFM_TST_LEV_VLAN:
            case CLI_ECFM_TST_LEV:
                /* apu4args[ECFM_INDEX_ZERO] : Mep Identifier */
                /* apu4args[ECFM_INDEX_ONE] : Mac address */
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : Vlan Id */
                /* apu4args[4] : Test pattern */
                /* apu4args[5] : Tlv */
                /* apu4args[6] : PDU size */
                /* apu4args[7] : Variable-bytes */
                /* apu4args[8] : Interval */
                /* apu4args[9] : No of PDUs */
                /* apu4args[10] : Deadline Interval  */
                /* apu4args[11] : Direction */
                if (ECFM_LBLT_CLI_EVENT_INFO (CliHandle) != NULL)

                {
                    CLI_SET_ERR (CLI_ECFM_PING_RUNNING_ERR);
                    i4RetVal = CLI_FAILURE;
                    if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                        ((u4Command == CLI_ECFM_TST_LEV_ISID) ||
                         (u4Command == CLI_ECFM_TST_DOM_ISID)))

                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                    break;
                }

                /* Register to handle CTRL C event */
                i4RetVal =
                    CliEcfmRegisterSignalHandler (ECFM_SIGINT,
                                                  EcfmTstSignalHandler);

                /* Setting the destination type */
                if (apu4args[ECFM_INDEX_ZERO] != NULL)

                {
                    TstRequest.u4TargetMepId = *(apu4args[ECFM_INDEX_ZERO]);
                    TstRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MEPID;
                }

                else if (apu4args[ECFM_INDEX_ONE] != NULL)

                {
                    StrToMac ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1InMacAddr);
                    ECFM_MEMCPY (TstRequest.LbTargetMacAddr, au1InMacAddr,
                                 ECFM_MAC_ADDR_LENGTH);
                    TstRequest.u1LbDestType = ECFM_TX_DEST_TYPE_UNICAST;
                }

                else

                {
                    TstRequest.u1LbDestType = ECFM_TX_DEST_TYPE_MULTICAST;
                }

                /* Setting Test Tlv type */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) != -1)

                {
                    TstRequest.u4LbTstPatternType =
                        CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]);
                }

                else

                {
                    TstRequest.u4LbTstPatternType =
                        ECFM_LBLT_TEST_TLV_PRBS_WITHOUT_CRC;
                }

                /* Setting the PDU size */
                if (apu4args[ECFM_INDEX_FIVE] != NULL)

                {
                    TstRequest.u4LbPduSize =
                        *((UINT4 *) apu4args[ECFM_INDEX_FIVE]);
                    TstRequest.u4LbPatternSize =
                        *(UINT4 *) (apu4args[ECFM_INDEX_FIVE]) - ECFM_VAL_31;
                }

                else if (apu4args[ECFM_INDEX_SIX] != NULL)

                {
                    TstRequest.b1LbVariableBytes = ECFM_SNMP_TRUE;
                }

                else

                {
                    TstRequest.u4LbPduSize = ECFM_VAL_64;
                    TstRequest.u4LbPatternSize = ECFM_VAL_33;
                }

                if (apu4args[ECFM_INDEX_THREE] == NULL)

                {
                    TstRequest.u4LbPatternSize = TstRequest.u4LbPatternSize +
                        ECFM_VAL_4;
                }

                /* Setting no. of PDUs to send */
                if (apu4args[ECFM_INDEX_EIGHT] != NULL)

                {
                    TstRequest.u4LbMessages =
                        *((UINT4 *) apu4args[ECFM_INDEX_EIGHT]);
                }

                else

                {
                    TstRequest.u4LbMessages = ECFM_TST_MESG_DEF_VAL;
                }

                /* Setting interval */
                if (apu4args[ECFM_INDEX_SEVEN] != NULL)

                {
                    if (((UINT2) *apu4args[ECFM_INDEX_SEVEN]) >
                        ECFM_LB_INTERVAL_IN_USEC_MAX)

                    {
                        TstRequest.u2LbInterval =
                            (((UINT2) *apu4args[ECFM_INDEX_SEVEN]) /
                             ECFM_NUM_OF_USEC_IN_A_MSEC);
                        TstRequest.u1LbIntervalType = ECFM_LBLT_LB_INTERVAL_SEC;
                    }

                    else

                    {
                        TstRequest.u2LbInterval =
                            ((UINT2) *apu4args[ECFM_INDEX_SEVEN]);
                        TstRequest.u1LbIntervalType =
                            ECFM_LBLT_LB_INTERVAL_MSEC;
                    }
                }
                else

                {
                    TstRequest.u2LbInterval = ECFM_TST_INTERVAL_DEF_VAL;
                    TstRequest.u1LbIntervalType = ECFM_LBLT_LB_INTERVAL_SEC;
                }

                /* Setting deadline interval */
                if (apu4args[ECFM_INDEX_NINE] != NULL)

                {
                    TstRequest.u4LbDeadline =
                        *((UINT4 *) apu4args[ECFM_INDEX_NINE]);
                }

                else

                {
                    TstRequest.u4LbDeadline = ECFM_TST_DEADLINE_DEF_VAL;
                }

                /* If we are not able to register the interrupt handler for
                 * ctrl+c then we need to stop the transaction in 10 seconds
                 * */
                if ((i4RetVal == CLI_FAILURE) &&
                    (TstRequest.u4LbDeadline == 0) &&
                    (TstRequest.u4LbMessages == 0))

                {
                    TstRequest.u4LbDeadline = ECFM_LB_INTERVAL_DEF_VAL;
                }
                i4RetVal = CLI_SUCCESS;
                if (apu4args[ECFM_INDEX_THREE] != NULL)

                {
                    i4RetVal =
                        EcfmCliXmitTst (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO],
                                        *((UINT4 *) apu4args[ECFM_INDEX_THREE]),
                                        (INT4) (u4IfIndex),
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_TEN]),
                                        TstRequest,
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_ELEVEN]));
                }

                else

                {
                    i4RetVal =
                        EcfmCliXmitTst (CliHandle, u4ContextId, u4Command,
                                        (UINT1 *) apu4args[ECFM_INDEX_TWO], 0,
                                        (INT4) (u4IfIndex),
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_TEN]),
                                        TstRequest,
                                        CLI_PTR_TO_U4 (apu4args
                                                       [ECFM_INDEX_ELEVEN]));
                } b1SingleContxtCmd = ECFM_TRUE;

                /* Unregister Ctrl C */
                CliEcfmUnRegisterSignalHandler (ECFM_SIGINT);
                if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                    ((u4Command == CLI_ECFM_TST_LEV_ISID) ||
                     (u4Command == CLI_ECFM_TST_DOM_ISID)))

                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }

                break;
                /* TH Initiation */
            case CLI_ECFM_TH_DOM_SER:
                /* apu4args[ECFM_INDEX_TWO] : MD name */
                /* apu4args[3] : Service name */
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 (UINT1 *) apu4args[3],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                apu4args[ECFM_INDEX_TWO] = &u4MdLevel;
                apu4args[3] = &u4VlanIsid;

            case CLI_ECFM_TH_DOM_ISID:
            case CLI_ECFM_TH_LEV_ISID:
                /* apu4args[ECFM_INDEX_TWO] : MD name */
                /* apu4args[3] : ISID */
                if ((u4Command == CLI_ECFM_TH_DOM_ISID) ||
                    (u4Command == CLI_ECFM_TH_LEV_ISID))
                {
                    if (apu4args[ECFM_INDEX_THREE] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }
                }
            case CLI_ECFM_TH_DOM_VLAN:
            case CLI_ECFM_TH_DOM_VSI:
            case CLI_ECFM_TH_DOM:
            case CLI_ECFM_TH_LEV_VLAN:
            case CLI_ECFM_TH_LEV_VSI:
            case CLI_ECFM_TH_LEV:
                /* apu4args[ECFM_INDEX_ZERO] : Mep Identifier */
                /* apu4args[ECFM_INDEX_ONE] : Mac address */
                /* apu4args[ECFM_INDEX_TWO] : MD name/level */
                /* apu4args[3] : Vlan Id */
                /* apu4args[4] : Tlv type */
                /* apu4args[5] : PDU size */
                /* apu4args[6] : Interval */
                /* apu4args[7] : No of PDUs */
                /* apu4args[8] : Deadline Interval  */
                /* apu4args[9] : No of PDUs to be sent in burst */
                /* apu4args[10] : Deadline Interval in burst */
                /* apu4args[11] : Direction */
                /* apu4args[12] : Command type */
                if (ECFM_LBLT_CLI_EVENT_INFO (CliHandle) != NULL)
                {
                    CLI_SET_ERR (CLI_ECFM_TH_RUNNING_ERR);
                    i4RetVal = CLI_FAILURE;
                    if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                        ((u4Command == CLI_ECFM_TH_DOM_ISID) ||
                         (u4Command == CLI_ECFM_TH_LEV_ISID)))

                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_THREE]);
                    }

                    break;
                }
                /* Register to handle CTRL C event */
                i4RetVal =
                    CliEcfmRegisterSignalHandler (ECFM_SIGINT,
                                                  EcfmThSignalHandler);
                /* Setting the destination type */
                if (apu4args[ECFM_INDEX_ZERO] != NULL)
                {
                    ThRequest.u4TargetMepId = *(apu4args[ECFM_INDEX_ZERO]);
                    ThRequest.u1DestIsMepId = ECFM_TRUE;
                }
                else if (apu4args[ECFM_INDEX_ONE] != NULL)
                {
                    StrToMac ((UINT1 *) apu4args[ECFM_INDEX_ONE], au1InMacAddr);
                    ECFM_MEMCPY (ThRequest.TargetMacAddr, au1InMacAddr,
                                 ECFM_MAC_ADDR_LENGTH);
                    ThRequest.u1DestIsMepId = ECFM_FALSE;
                }
                /* Setting Test Tlv type */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) != -1)
                {
                    ThRequest.u1TstPatternType =
                        CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]);
                }
                else
                {
                    ThRequest.u1TstPatternType =
                        CLI_ECFM_TEST_TLV_NULL_WITHOUT_CRC;
                }
                /* Setting the PDU size */
                if (apu4args[ECFM_INDEX_FIVE] != NULL)
                {
                    ThRequest.u4ThFrameSize =
                        *((UINT4 *) apu4args[ECFM_INDEX_FIVE]);
                }
                else
                {
                    ThRequest.u4ThFrameSize = ECFM_LBLT_TH_PKT_DEF_SIZE;
                }
                /* Setting no. of PDUs to send */
                if (apu4args[ECFM_INDEX_SEVEN] != NULL)
                {
                    ThRequest.u4ThMessages =
                        *((UINT4 *) apu4args[ECFM_INDEX_SEVEN]);
                }
                else
                {
                    ThRequest.u4ThMessages = ECFM_TH_MESG_DEF_VAL;
                }
                /* Setting interval */
                if (apu4args[ECFM_INDEX_SIX] != NULL)
                {
                    ThRequest.u4ThPps = *((UINT4 *) apu4args[ECFM_INDEX_SIX]);
                }
                else
                {
                    ThRequest.u4ThPps = ECFM_TH_PPS_DEF_VAL;
                }
                /* Setting deadline interval */
                if (apu4args[ECFM_INDEX_EIGHT] != NULL)
                {
                    ThRequest.u4ThDeadline =
                        *((UINT4 *) apu4args[ECFM_INDEX_EIGHT]);
                }
                else
                {
                    ThRequest.u4ThDeadline = ECFM_TH_DEADLINE_DEF_VAL;
                }

                /* Setting no. of PDUs to send in a burst */
                if (apu4args[ECFM_INDEX_NINE] != NULL)
                {
                    ThRequest.u4ThBurstMessages =
                        *((UINT4 *) apu4args[ECFM_INDEX_NINE]);
                    ThRequest.u1ThBurstType = ECFM_LBLT_TH_BURST_TYPE_MSGS;
                }
                /* Setting deadline interval in a burst */
                if (apu4args[ECFM_INDEX_TEN] != NULL)
                {
                    ThRequest.u4ThBurstDeadline =
                        *((UINT4 *) apu4args[ECFM_INDEX_TEN]);
                    ThRequest.u1ThBurstType = ECFM_LBLT_TH_BURST_TYPE_DL;
                }
                if ((apu4args[ECFM_INDEX_NINE] == NULL)
                    && (apu4args[ECFM_INDEX_TEN] == NULL))
                {
                    ThRequest.u4ThBurstMessages =
                        ECFM_LBLT_TH_BURST_MESSAGES_DEF_VAL;
                    ThRequest.u4ThBurstDeadline =
                        ECFM_LBLT_TH_BURST_DEADLINE_DEF_VAL;
                    ThRequest.u1ThBurstType = ECFM_LBLT_TH_BURST_TYPE_MSGS;
                }

                if (apu4args[ECFM_INDEX_THIRTEEN] != NULL)
                {
                    ThRequest.u1ThType =
                        CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THIRTEEN]);
                }
                else
                {
                    ThRequest.u1ThType = ECFM_LBLT_TH_TYPE_2TH;
                }

                i4RetVal = CLI_SUCCESS;
                if (apu4args[ECFM_INDEX_THREE] != NULL)
                {
                    i4RetVal = EcfmCliXmitTh (CliHandle,
                                              u4ContextId, u4Command,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_TWO],
                                              *((UINT4 *)
                                                apu4args[ECFM_INDEX_THREE]),
                                              (INT4) (u4IfIndex),
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_ELEVEN]),
                                              ThRequest,
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_TWELVE]));
                }
                else
                {
                    i4RetVal = EcfmCliXmitTh (CliHandle,
                                              u4ContextId, u4Command,
                                              (UINT1 *)
                                              apu4args[ECFM_INDEX_TWO], 0,
                                              (INT4) (u4IfIndex),
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_ELEVEN]),
                                              ThRequest,
                                              CLI_PTR_TO_U4 (apu4args
                                                             [ECFM_INDEX_TWELVE]));
                }
                b1SingleContxtCmd = ECFM_TRUE;
                /* Unregister Ctrl C */
                CliEcfmUnRegisterSignalHandler (ECFM_SIGINT);
                if ((apu4args[ECFM_INDEX_THREE] != NULL) &&
                    ((u4Command == CLI_ECFM_TH_DOM_ISID)
                     || (u4Command == CLI_ECFM_TH_LEV_ISID)))
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_THREE] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_THREE]);
                }
                break;

                /* Initiate Avilability Measurement */
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_SER:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWELVE]) ==
                    CLI_ECFM_AVLBLTY_START)
                {
                    i4RetVal =
                        EcfmCliInitAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       &u4MdLevel,
                                                       (UINT1 *)
                                                       &u4VlanIsid,
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_THREE],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FOUR],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FIVE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_SIX],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_SEVEN],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_EIGHT],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_NINE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TEN],
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ELEVEN]),
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_THIRTEEN]),
                                                       u4IfIndex);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       &u4MdLevel,
                                                       (UINT1 *)
                                                       &u4VlanIsid, u4IfIndex);
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWELVE]) ==
                    CLI_ECFM_AVLBLTY_START)
                {
                    i4RetVal =
                        EcfmCliInitAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       &u4MdLevel,
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TWO],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_THREE],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FOUR],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FIVE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_SIX],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_SEVEN],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_EIGHT],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_NINE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TEN],
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ELEVEN]),
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_THIRTEEN]),
                                                       u4IfIndex);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       &u4MdLevel,
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TWO],
                                                       u4IfIndex);
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID) ||
                    (u4Command == CLI_ECFM_AVLBLTY_MEP_MAC_DOM_ISID))
                {
                    apu4args[ECFM_INDEX_ONE] = &u4MdLevel;
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID:
                if ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID) ||
                    (u4Command == CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID))
                {
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }

            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV:
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV:
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_TWELVE]) ==
                    CLI_ECFM_AVLBLTY_START)
                {
                    i4RetVal =
                        EcfmCliInitAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_ONE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TWO],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_THREE],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FOUR],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_FIVE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_SIX],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_SEVEN],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_EIGHT],
                                                       (UINT1 *)
                                                       apu4args
                                                       [ECFM_INDEX_NINE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TEN],
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ELEVEN]),
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_THIRTEEN]),
                                                       u4IfIndex);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL)
                        && ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID)
                            || (u4Command ==
                                CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID)))
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopAvlbltyMeasurement (CliHandle, u4ContextId,
                                                       u4Command,
                                                       CLI_PTR_TO_I4 (apu4args
                                                                      [ECFM_INDEX_ZERO]),
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_ONE],
                                                       (UINT1 *)
                                                       apu4args[ECFM_INDEX_TWO],
                                                       u4IfIndex);
                    if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                        ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID) ||
                         (u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID)))
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

                /* Display Avilability Percentage */
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_SER:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_TWO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliShowAvlbltyMeasurement (CliHandle, u4ContextId,
                                                   u4Command,
                                                   CLI_PTR_TO_I4 (apu4args
                                                                  [ECFM_INDEX_ZERO]),
                                                   (UINT1 *)
                                                   &u4MdLevel,
                                                   (UINT1 *)
                                                   &u4VlanIsid, u4IfIndex);
                b1SingleContxtCmd = ECFM_TRUE;

                break;

            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF:
            case CLI_ECFM_SHOW_AVLBLTY_DOM:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                i4RetVal =
                    EcfmCliShowAvlbltyMeasurement (CliHandle, u4ContextId,
                                                   u4Command,
                                                   CLI_PTR_TO_I4 (apu4args
                                                                  [ECFM_INDEX_ZERO]),
                                                   (UINT1 *)
                                                   &u4MdLevel,
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_TWO],
                                                   u4IfIndex);
                b1SingleContxtCmd = ECFM_TRUE;

                break;
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_ISID:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE], NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                    ECFM_UNREGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID) ||
                    (u4Command == CLI_ECFM_AVLBLTY_MEP_MAC_DOM_ISID))
                {
                    apu4args[ECFM_INDEX_ONE] = &u4MdLevel;
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }
            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_ISID:
                if ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID) ||
                    (u4Command == CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID))
                {
                    if (apu4args[ECFM_INDEX_TWO] != NULL)
                    {
                        *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                            ECFM_ISID_TO_ISID_INTERNAL (*(UINT4 *)
                                                        apu4args
                                                        [ECFM_INDEX_TWO]);
                    }
                }
            case CLI_ECFM_SHOW_MEP_LOOPBACK_STATUS:
                i4RetVal = EcfmCliShowLoopbackStatus (CliHandle, u4ContextId);
                break;
            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF:
            case CLI_ECFM_SHOW_AVLBLTY_LEV:
                i4RetVal =
                    EcfmCliShowAvlbltyMeasurement (CliHandle, u4ContextId,
                                                   u4Command,
                                                   CLI_PTR_TO_I4 (apu4args
                                                                  [ECFM_INDEX_ZERO]),
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_ONE],
                                                   (UINT1 *)
                                                   apu4args[ECFM_INDEX_TWO],
                                                   u4IfIndex);
                if ((apu4args[ECFM_INDEX_TWO] != NULL) &&
                    ((u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID) ||
                     (u4Command == CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID)))
                {
                    *(UINT4 *) apu4args[ECFM_INDEX_TWO] =
                        ECFM_ISID_INTERNAL_TO_ISID (*(UINT4 *)
                                                    apu4args[ECFM_INDEX_TWO]);
                }
                b1SingleContxtCmd = ECFM_TRUE;

                break;
            case CLI_ECFM_SHOW_AVLBLTY:
                i4RetVal =
                    EcfmCliShowAvlbltyMeasurement (CliHandle, u4ContextId,
                                                   u4Command,
                                                   0, NULL, NULL, u4IfIndex);
                break;

             case CLI_ECFM_ETH_BN_INFO:
                 if(u4IfIndex != 0)
                 {
                     ECFM_UNREGISTER_CLI_CC_LOCK ();
                     ECFM_REGISTER_CLI_LBLT_LOCK ();

                     i4RetVal =  EcfmCliEthBnInfo(CliHandle, u4IfIndex);
                     ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                     ECFM_REGISTER_CLI_CC_LOCK ();
                 }
                 else
                 {
                     /* Locks are handled inside the function */
                     i4RetVal = EcfmCliEthBnShowAllInfo (CliHandle, u4IfIndex);
                 }
                 break;

             case CLI_ECFM_ETH_BN_STAT:
                 if(u4IfIndex != 0)
                 {
                     ECFM_UNREGISTER_CLI_CC_LOCK ();
                     ECFM_REGISTER_CLI_LBLT_LOCK ();

                     i4RetVal =  EcfmCliEthBnStat(CliHandle, u4IfIndex);
                     ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                     ECFM_REGISTER_CLI_CC_LOCK ();

                 }
                 else
                 {
                     /* Locks are handled inside the function */
                     i4RetVal = EcfmCliEthBnShowAllStat (CliHandle, u4IfIndex);

                 }
                 break;

#if 0





            case CLI_ECFM_SHOW_FL_SLM_ONDEMAND:
                i4RetVal =
                    EcfmCliShowFLSlmOnDemandBuffer (CliHandle, u4ContextId,
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                    CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]));

                break;

            case CLI_ECFM_SHOW_FL_SLM_PROACTIVE:
                i4RetVal =
                    EcfmCliShowFLSlmProActiveBuffer (CliHandle, u4ContextId,
                                                     (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                     (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                     CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]),
                                                     CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FIVE]));

                break;

            case CLI_ECFM_DEL_FL_SLM_PROACTIVE:
                i4RetVal =
                    EcfmCliDelFLSlmProActiveConfig (CliHandle, u4ContextId,
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ZERO]),
                                                    (UINT1 *) (apu4args[ECFM_INDEX_ONE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_TWO]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_THREE]),
                                                    CLI_PTR_TO_U4 (apu4args[ECFM_INDEX_FOUR]));

                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_SER:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }

                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command, (UINT1 *)&u4MdLevel, (UINT1 *)&u4VlanIsid,(UINT1 *) apu4args[ECFM_INDEX_TWO],
                             (UINT1 *)apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),(UINT1 *) apu4args[ECFM_INDEX_ONE],
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_NINE]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_TEN]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_ELEVEN]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_TWELVE]),
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_THIRTEEN]),
                             (UINT1 *) apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) &u4VlanIsid,
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO],CLI_PTR_TO_I4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_THIRTEEN]),CLI_PTR_TO_U4 ( (UINT1 *) 
                             apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VSI:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VSI:

                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }


                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {

                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                            u4Command, (UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),(UINT1 *) 
                            apu4args[ECFM_INDEX_ONE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_ELEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TWELVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),(UINT1 *) 
                            apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) apu4args[ECFM_INDEX_TWO],
                             CLI_PTR_TO_I4 ( (UINT1 *) apu4args[ECFM_INDEX_THIRTEEN]),
                             CLI_PTR_TO_U4 ( (UINT1 *) apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VSI:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VSI:

                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmProActiveLossMeasurement (CliHandle, u4ContextId,
                            u4Command, (UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ONE],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),NULL,CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_ELEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_TWELVE]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),(UINT1 *) 
                            apu4args[ECFM_INDEX_FOURTEEN],CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SIXTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                else
                {
                    i4RetVal =

                        EcfmCliStopSlmProActiveLossMeasurement(CliHandle, u4ContextId,
                            u4Command,(UINT1 *) apu4args[ECFM_INDEX_ONE] ,
                            (UINT1 *) apu4args[ECFM_INDEX_ZERO] ,NULL,(UINT1 *) 
                            apu4args[ECFM_INDEX_TWO],CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_THIRTEEN]),CLI_PTR_TO_U4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_FIFTEEN]));

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
                /* Initiate SLM Loss Measurement */
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_SER:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_SER:
                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ZERO],
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command, (UINT1 *)&u4MdLevel, (UINT1 *)&u4VlanIsid,(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO],(UINT1 *) apu4args[ECFM_INDEX_THREE],
                             CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_NINE]),(UINT1 *) 
                             apu4args[ECFM_INDEX_ONE]);
                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) &u4MdLevel, (UINT1 *) &u4VlanIsid, 
                             (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;

            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VSI:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VSI:

                if (EcfmCliGetLevelVlanIsidInfo (CliHandle, u4ContextId,
                                                 (UINT1 *)
                                                 apu4args[ECFM_INDEX_ONE],
                                                 NULL,
                                                 &u4MdLevel, &u4VlanIsid, 0,
                                                 &b1IsUnaware, u2LocalPortId,
                                                 ECFM_INIT_VAL, ECFM_INIT_VAL)
                    == CLI_FAILURE)
                {
                    EcfmCliErrorDisplay (CliHandle, u4ErrCode, pu1VlanList);
                    return CLI_FAILURE;
                }
                 /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {

                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                            u4Command, (UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                            apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 
                            (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                            (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ( (UINT1 *) 
                            apu4args[ECFM_INDEX_NINE]),(UINT1 *) 
                            apu4args[ECFM_INDEX_ONE]);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =       
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                            u4Command,(UINT1 *) &u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ZERO],
                            (UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                            apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VSI:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VSI:

                /* Start SLM OnDemand transaction */
                if (CLI_PTR_TO_I4 (apu4args[ECFM_INDEX_FOUR]) ==
                    CLI_ECFM_FL_START)
                {
                    i4RetVal =
                        EcfmCliInitSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command, (UINT1 *)&u4MdLevel,(UINT1 *) apu4args[ECFM_INDEX_ONE],
                             (UINT1 *) apu4args[ECFM_INDEX_TWO],(UINT1 *) 
                             apu4args[ECFM_INDEX_THREE],CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_FIVE]),CLI_PTR_TO_I4 
                             (apu4args[ECFM_INDEX_SIX]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_SEVEN]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_EIGHT]),CLI_PTR_TO_I4 ((UINT1 *) 
                             apu4args[ECFM_INDEX_NINE]), NULL);

                    b1SingleContxtCmd = ECFM_TRUE;
                }
                /* Stop SLM OnDemand transaction */
                else
                {
                    i4RetVal =
                        EcfmCliStopSlmOnDemandLossMeasurement (CliHandle, u4ContextId,
                             u4Command,(UINT1 *) apu4args[ECFM_INDEX_ONE],(UINT1 *) 
                             apu4args[ECFM_INDEX_ZERO],NULL,(UINT1 *) 
                             apu4args[ECFM_INDEX_TWO]);

                    b1SingleContxtCmd = ECFM_TRUE;

                }
                break;


#endif
            default:

                /* Given command does not match with any of the SET or SHOW
                 * commands */
                CliPrintf (CliHandle, "\r%% Unknown command \r\n");
                UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
        }

        /* If SwitchName or Interface is given as input for show command 
         * then we have to come out of the Loop */
        if ((pu1ContextName != NULL) || (u4IfIndex != 0))

        {
            break;
        }

        /* If command is for a single context either default or given context */
        if (b1SingleContxtCmd == ECFM_TRUE)

        {
            break;
        }
        u4TempContextId = u4ContextId;
    }
    if ((i4RetVal == CLI_FAILURE) && (CLI_GET_ERR (&u4ErrCode) == CLI_SUCCESS))

    {
        if ((u4ErrCode >= CLI_ERR_START_ID_ECFM) &&
            (u4ErrCode < CLI_ECFM_MAX_ERR))

        {
            CliPrintf (CliHandle, "\r%% %s",
                       gaEcfmCliErrString[CLI_ERR_OFFSET_ECFM (u4ErrCode)]);
        }
        CLI_SET_ERR (0);
    }
    CLI_SET_CMD_STATUS (i4RetVal);
    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return i4RetVal;
}

/****************************************************************************
* Function    :  EcfmCliSetDebugLevel 
* Description :
* Input       :  CliHandle, i4CliDebugLevel
* Output      :  None
* Returns     :  CLI_SUCCESS/CLI_FAILURE
****************************************************************************/
INT4
EcfmCliSetDebugLevel (tCliHandle CliHandle, INT4 i4CliDebugLevel)
{
    gu4EcfmTrcLvl = 0;

    UNUSED_PARAM (CliHandle);
    if (i4CliDebugLevel == DEBUG_DEBUG_LEVEL)
    {
        gu4EcfmTrcLvl = ECFM_FN_ENTRY_TRC |
            ECFM_FN_EXIT_TRC |
            ECFM_CRITICAL_TRC |
            ECFM_INIT_SHUT_TRC |
            ECFM_MGMT_TRC |
            ECFM_DATA_PATH_TRC |
            ECFM_CONTROL_PLANE_TRC |
            ECFM_DUMP_TRC |
            ECFM_OS_RESOURCE_TRC | ECFM_ALL_FAILURE_TRC | ECFM_BUFFER_TRC;

    }
    else if (i4CliDebugLevel == DEBUG_INFO_LEVEL)
    {
        gu4EcfmTrcLvl =
            ECFM_CONTROL_PLANE_TRC | ECFM_DATA_PATH_TRC | ECFM_DUMP_TRC |
            ECFM_INIT_SHUT_TRC | ECFM_ALL_FAILURE_TRC | ECFM_OS_RESOURCE_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_NOTICE_LEVEL)
    {
        gu4EcfmTrcLvl =
            ECFM_INIT_SHUT_TRC | ECFM_ALL_FAILURE_TRC | ECFM_OS_RESOURCE_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_WARN_LEVEL)
    {
        gu4EcfmTrcLvl =
            ECFM_INIT_SHUT_TRC | ECFM_ALL_FAILURE_TRC | ECFM_OS_RESOURCE_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_ERROR_LEVEL)
    {
        gu4EcfmTrcLvl = ECFM_INIT_SHUT_TRC | ECFM_ALL_FAILURE_TRC;
    }
    else if ((i4CliDebugLevel == DEBUG_CRITICAL_LEVEL)
             || (i4CliDebugLevel == DEBUG_ALERT_LEVEL)
             || (i4CliDebugLevel == DEBUG_EMERG_LEVEL))
    {
        gu4EcfmTrcLvl = ECFM_INIT_SHUT_TRC;
    }
    else if (i4CliDebugLevel == DEBUG_DEF_LVL_FLAG)
    {
        return CLI_SUCCESS;
    }
    else
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmGetDomainConfigPrompt 
 *                                                                           
 *     DESCRIPTION      : This function Checks for domain validity and          
 *                        returns the prompt to be displayed.                
 *                                                                           
 *     INPUT            : pi1ModeName - Mode to be configured.               
 *                                                                           
 *     OUTPUT           : pi1DispStr  - Prompt to be displayed.              
 *                                                                           
 *     RETURNS          : ECFM_TRUE or ECFM_FALSE                                      
 *                                                                           
 *******************************************************************************/
INT1
EcfmGetDomainConfigPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4Index;
    UINT4               u4Len = STRLEN (CLI_DOMAIN_MODE);
    INT4                i4Dot1qCfmMdRowStatus;
    if ((!pi1DispStr) || (!pi1ModeName))

    {
        return ECFM_FALSE;
    }
    if (STRNCMP (pi1ModeName, CLI_DOMAIN_MODE, u4Len) != 0)

    {
        return ECFM_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;
    u4Index = CLI_ATOI (pi1ModeName);

    /* 
     * No need to take lock here, since it is taken by
     * Cli in cli_process_ecfm_config_cmd.
     */
    if ((nmhGetDot1agCfmMdRowStatus (u4Index, &i4Dot1qCfmMdRowStatus)) !=
        SNMP_SUCCESS)

    {
        return ECFM_FALSE;
    }
    CLI_SET_MDINDEX (u4Index);
    STRCPY (pi1DispStr, "(config-ether-ecfm)#");
    return ECFM_TRUE;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmTpOamGetDomainConfigPrompt
 *
 *     DESCRIPTION      : This function Checks for domain validity and
 *                        returns the prompt to be displayed.
 *
 *     INPUT            : pi1ModeName - Mode to be configured.
 *
 *     OUTPUT           : pi1DispStr  - Prompt to be displayed.
 *
 *     RETURNS          : ECFM_TRUE or ECFM_FALSE
 *
 *******************************************************************************/
INT1
EcfmTpOamGetDomainConfigPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4Index;
    UINT4               u4Len = STRLEN (CLI_MPLS_DOMAIN_MODE);
    INT4                i4Dot1qCfmMdRowStatus;
    if ((!pi1DispStr) || (!pi1ModeName))

    {
        return ECFM_FALSE;
    }
    if (STRNCMP (pi1ModeName, CLI_MPLS_DOMAIN_MODE, u4Len) != 0)

    {
        return ECFM_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;
    u4Index = CLI_ATOI (pi1ModeName);

    /*
     * No need to take lock here, since it is taken by
     * Cli in cli_process_ecfm_config_cmd.
     */
    if ((nmhGetDot1agCfmMdRowStatus (u4Index, &i4Dot1qCfmMdRowStatus)) !=
        SNMP_SUCCESS)

    {
        return ECFM_FALSE;
    }
    CLI_SET_MDINDEX (u4Index);
    STRCPY (pi1DispStr, "(config-mpls-ecfm)#");
    return ECFM_TRUE;

}

/****************************************************************************
 *                                                                          
 *    FUNCTION NAME    : EcfmGetNoOfMasInMd 
 *                                                                          
 *    DESCRIPTION      : This function returns number of Mas in a MD. indexed
 *                       by u4MdIndex. 
 *
 *    INPUT            : u4ContextId - Context Id
 *                       u4MdId - Index of Md Table, 
 *                                                                          
 *    OUTPUT           : None.
 *                                                                          
 *    RETURNS          : Number of Mas in a MD. 
 *    
 *                                                                          
 ****************************************************************************/
PRIVATE UINT4
EcfmGetNoOfMasInMd (UINT4 u4ContextId, UINT4 u4MdId)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4Count = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)

    {
        return 0;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return 0;
    }

    /* MaTable not empty, now scan its each row */
    while (i4RetVal == SNMP_SUCCESS)

    {
        i4RetMaRowStatus = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        if ((u4MdIndex == u4MdId)
            && (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE))

        {
            u4Count = u4Count + ECFM_INCR_VAL;
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                return u4Count;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    return u4Count;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmRemoteMep 
 *                                                                          
 *     DESCRIPTION      : This function will check if MEP is remotely configured
 *                        in a MA.
 *                        
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type -  Command
 *                        u4ContextId - Context Identifier                                                
 *                        u4MdId - MD Index 
 *                        u4MaId - MA Index
 *                        u4MaMepListId - MEP Identifier
 *     OUTPUT           : pu4LocalMepId - Local MEP Identifier
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE             BOOL1
EcfmRemoteMep (UINT4 u4ContextId, UINT4 u4MdId, UINT4 u4MaId,
               UINT4 u4MaMepListId, UINT4 *pu4LocalMepId)
{

    /* Variables to scan remote MEP table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check if there is any Remote MEP at this context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId, 0,
                                                   &u4MdIndex, 0,
                                                   &u4MaIndex, 0,
                                                   &u4MepIdentifier, 0,
                                                   &u4RMepIdentifier) ==
        SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }

    /* Scan Remote Mep Table to find remote MEP with Id u4MaMepListId in same
     * MA depend upon the input */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        if ((u4ContextId == (UINT4) (i4CurrentContextId)) &&
            (u4MdIndex == u4MdId) &&
            (u4MaIndex == u4MaId) && (u4RMepIdentifier == u4MaMepListId))

        {

            /* MEP with u4MaMepListId is a remote to MEP with u4MepIdentifier */
            *pu4LocalMepId = u4MepIdentifier;
            return ECFM_TRUE;
        }

        /* move to next remote MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex,
                                                       u4MepIdentifier,
                                                       &u4NextMepIdentifier,
                                                       u4RMepIdentifier,
                                                       &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    return ECFM_FALSE;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowXchkParams
 *                                                                          
 *     DESCRIPTION      : This function will show the crosscheck list 
 *                        information for a particualar MD or MA
 *                        
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type -  Command
 *                        u4ContextId - Context Identifier                                                
 *                        u4MdId - MD Index 
 *                        u4MaId - MA Index
 *                        b1Header - True, indicates that header to be printed.
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmShowXchkParams (tCliHandle CliHandle, UINT4 u4Type, UINT4 u4ContextId,
                    UINT4 u4MdId, UINT4 u4MaId, BOOL1 b1Header)
{
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4MepPrimaryVid = ECFM_INIT_VAL;
    INT4                i4MaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4MepActive = ECFM_INIT_VAL;
    INT4                i4RMepState = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4LocalMepId = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    tEcfmMacAddr        MacAddr;
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        TempMacAddr;
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId, 0,
                                                      &u4MdIndex, 0,
                                                      &u4MaIndex, 0,
                                                      &u4MaMepListIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        if (((u4Type == CLI_ECFM_SHOW_SERVICE) &&
             (u4MdIndex == u4MdId) &&
             (u4MaIndex == u4MaId)) ||
            ((u4Type == CLI_ECFM_SHOW_DOMAIN) && (u4MdIndex == u4MdId)))

        {
            i4RetMepRowStatus = ECFM_INIT_VAL;
            i4MaPrimaryVid = ECFM_INIT_VAL;
            i4MepPrimaryVid = ECFM_INIT_VAL;
            i4MepActive = ECFM_INIT_VAL;
            u4LocalMepId = ECFM_INIT_VAL;
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                           u4MaIndex, &i4MaPrimaryVid);

            nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex,
                                         u4MaIndex, u4MaMepListIndex,
                                         (UINT4 *) &i4MepPrimaryVid);
#ifdef VSI_WANTED
            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "Crosscheck:");

                if (i4MepPrimaryVid != 0)
                {
                    if (EcfmUtilCfaIsVsiId (i4MepPrimaryVid) == ECFM_SUCCESS)
                    {
                CliPrintf (CliHandle,
                                   "\r\n%-5s%-9s%-10s%-15s%-7s", "MPID",
                                   "VSI ID", "ISID", "Type", "Mep-Up");
                    }
                }

                if (u4Type == CLI_ECFM_SHOW_SERVICE)
                {
                    CliPrintf (CliHandle, "%-18s", "Mac Address");
                }
                CliPrintf (CliHandle, "\r\n");
                b1Header = ECFM_FALSE;
            }
#endif
#ifndef VSI_WANTED
            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "Crosscheck:");
                        CliPrintf (CliHandle,
                                   "\r\n%-5s%-5s%-10s%-15s%-7s", "MPID",
                           "VLAN", "ISID", "Type", "Mep-Up");

                if (u4Type == CLI_ECFM_SHOW_SERVICE)
                {
                    CliPrintf (CliHandle, "%-18s", "Mac Address");
                }
                CliPrintf (CliHandle, "\r\n");
                b1Header = ECFM_FALSE;

            } 
#endif
            /* If MEP is locally configured or not */
            if ((nmhGetFsMIEcfmMepRowStatus
                 (i4CurrContextId, u4MdIndex, u4MaIndex, u4MaMepListIndex,
                  &i4RetMepRowStatus) == SNMP_SUCCESS)
                && (i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE))

            {
                nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex,
                                             u4MaIndex, u4MaMepListIndex,
                                             (UINT4 *) &i4MepPrimaryVid);
                nmhGetFsMIEcfmMepActive (i4CurrContextId, u4MdIndex, u4MaIndex,
                                         u4MaMepListIndex, &i4MepActive);

                /* MepId */
                CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);

                /* VlanId */
                if (i4MepPrimaryVid != 0)
                {
                    if (ECFM_IS_MEP_ISID_AWARE (i4MepPrimaryVid))
                    {
                        CliPrintf (CliHandle, "%-5s", "-");
                        CliPrintf (CliHandle, "%-10u",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4MepPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-5u", i4MepPrimaryVid);
                        CliPrintf (CliHandle, "%-10s", "-");
                    }
                }
                else

                {
                    if (i4MaPrimaryVid != 0)

                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4MaPrimaryVid))
                        {
                            CliPrintf (CliHandle, "%-5s", "-");
                            CliPrintf (CliHandle, "%-10u",
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4MaPrimaryVid));
                        }
                        else
                        {
                            CliPrintf (CliHandle, "%-5u", i4MaPrimaryVid);
                            CliPrintf (CliHandle, "%-10s", "-");
                        }
                    }

                    else
                    {
                        CliPrintf (CliHandle, "%-5s", "-");
                        CliPrintf (CliHandle, "%-10s", "-");
                    }
                }

                /* Type */
                CliPrintf (CliHandle, "%-15s", "Local");

                /* Status */
                if (i4MepActive == ECFM_SNMP_TRUE)

                {
                    CliPrintf (CliHandle, "%-7s", "Yes");
                }

                else

                {
                    CliPrintf (CliHandle, "%-7s", "No");
                }
                if (u4Type == CLI_ECFM_SHOW_DOMAIN)

                {
                    CliPrintf (CliHandle, "\r\n");
                }

                else

                {
                    ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL,
                                 ECFM_MAC_ADDR_LENGTH);
                    nmhGetFsMIEcfmMepMacAddress (i4CurrContextId, u4MdIndex,
                                                 u4MaIndex, u4MaMepListIndex,
                                                 &RetMacAddr);
                    PrintMacAddress (RetMacAddr, au1String);
                    CliPrintf (CliHandle, "%-18s\r\n", au1String);
                }
            }

            else

            {
                if (EcfmRemoteMep
                    (i4CurrContextId, u4MdIndex, u4MaIndex, u4MaMepListIndex,
                     &u4LocalMepId) == ECFM_TRUE)

                {

                    /* Remote */
                    nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex,
                                                 u4MaIndex, u4LocalMepId,
                                                 (UINT4 *) &i4MepPrimaryVid);
                    nmhGetFsMIEcfmMepDbRMepState (i4CurrContextId, u4MdIndex,
                                                  u4MaIndex, u4LocalMepId,
                                                  u4MaMepListIndex,
                                                  &i4RMepState);

                    /* MepId */
                    CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);

                    /* VlanId */
                    if (i4MepPrimaryVid != 0)
                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4MepPrimaryVid))
                        {
                            CliPrintf (CliHandle, "%-5s", "-");
                            CliPrintf (CliHandle, "%-10u",
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4MepPrimaryVid));
                        }
                        else
                        {
                            CliPrintf (CliHandle, "%-5u", i4MepPrimaryVid);
                            CliPrintf (CliHandle, "%-10s", "-");
                        }
                    }
                    else
                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4MaPrimaryVid))
                        {
                            CliPrintf (CliHandle, "%-5s", "-");
                            CliPrintf (CliHandle, "%-10u",
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4MaPrimaryVid));
                        }
                        else
                        {
                            CliPrintf (CliHandle, "%-5u", i4MaPrimaryVid);
                            CliPrintf (CliHandle, "%-10s", "-");
                        }
                    }
                    /* Type */
                    CliPrintf (CliHandle, "%-15s", "Remote");

                    /* Status */
                    if (i4RMepState == ECFM_RMEP_OK)

                    {
                        CliPrintf (CliHandle, "%-7s", "Yes");
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-7s", "No");
                    }
                    if (u4Type == CLI_ECFM_SHOW_DOMAIN)

                    {
                        CliPrintf (CliHandle, "\r\n");
                    }

                    else

                    {
                        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL,
                                     ECFM_MAC_ADDR_LENGTH);
                        ECFM_MEMSET (TempMacAddr, ECFM_DEF_MAC_ADDR,
                                     ECFM_MAC_ADDR_LENGTH);
                        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL,
                                     ECFM_MAC_ADDR_LENGTH);
                        nmhGetFsMIEcfmMepDbMacAddress (i4CurrContextId,
                                                       u4MdIndex, u4MaIndex,
                                                       u4LocalMepId,
                                                       u4MaMepListIndex,
                                                       &RetMacAddr);
                        if ((ECFM_MEMCMP
                             (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                            ||
                            (ECFM_MEMCMP
                             (RetMacAddr, TempMacAddr,
                              ECFM_MAC_ADDR_LENGTH) == 0))

                        {
                            CliPrintf (CliHandle, "%-18s\r\n", "Not learned");
                        }

                        else

                        {
                            ECFM_MEMSET (au1String, ECFM_INIT_VAL,
                                         ECFM_CLI_MAX_MAC_STRING_SIZE);
                            PrintMacAddress (RetMacAddr, au1String);
                            CliPrintf (CliHandle, "%-18s\r\n", au1String);
                        }
                    }
                }

                else

                {

                    /* Not configured */
                    /* MepId */
                    CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);
                    /* VlanId */
                    if (ECFM_IS_MEP_ISID_AWARE (i4MaPrimaryVid))
                    {
                        CliPrintf (CliHandle, "%-5s", "-");
                        CliPrintf (CliHandle, "%-10u",
                                   ECFM_ISID_INTERNAL_TO_ISID (i4MaPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-5u", i4MaPrimaryVid);
                        CliPrintf (CliHandle, "%-10s", "-");
                    }
                    /* Type */
                    CliPrintf (CliHandle, "%-15s", "Not configured");

                    /* Status */
                    CliPrintf (CliHandle, "%-7s", "No");
                    if (u4Type == CLI_ECFM_SHOW_DOMAIN)

                    {
                        CliPrintf (CliHandle, "\r\n");
                    }

                    else

                    {
                        CliPrintf (CliHandle, "-\r\n");
                    }
                }
            }
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                          (UINT4 *)
                                                          &i4NextContextId,
                                                          u4MdIndex,
                                                          &u4NextMdIndex,
                                                          u4MaIndex,
                                                          &u4NextMaIndex,
                                                          u4MaMepListIndex,
                                                          &u4NextMaMepListIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MaMepListIndex = u4NextMaMepListIndex;

            /* Check for the same context */
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowXchkStatus  
 *                                                                          
 *     DESCRIPTION      : This function will show crosscheck status of a
 *                        Maintenance Domain
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier                                                 
 *                        u4MdIndex -  MD identifier
 *                        b1Header - True, indicates that header to be printed.
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmShowXchkStatus (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdId,
                    BOOL1 b1Header)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4XchkStatus = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;

    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)

    {
        return;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return;
    }

    /* MaTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext))

    {
        i4RetMaRowStatus = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        if ((u4MdId == u4MdIndex)
            && (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE))

        {
            i4RetPriVlanId = ECFM_INIT_VAL;
            i4XchkStatus = ECFM_INIT_VAL;
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
            nmhGetFsMIEcfmMaCrosscheckStatus (i4CurrentContextId, u4MdIndex,
                                              u4MaIndex, &i4XchkStatus);
            nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);
#ifndef VSI_WANTED
             if (b1Header == ECFM_TRUE)
             {
                 if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                 {
                     CliPrintf (CliHandle, "\r\n");
                     CliPrintf (CliHandle, "%-10s%-11s%-22s", "ISID",
                                "Crosscheck", "ServiceID");
                     CliPrintf (CliHandle, "\r\n");
                 }
                 else
                 {
                     CliPrintf (CliHandle, "\r\n");
                     CliPrintf (CliHandle, "%-5s%-11s%-22s", "Vlan",
                                "Crosscheck", "ServiceID");
                     CliPrintf (CliHandle, "\r\n");
                 }
                 b1Header = ECFM_FALSE;
             }
#endif
#ifdef VSI_WANTED
            if (b1Header == ECFM_TRUE)
            {
                    CliPrintf (CliHandle, "\r\n");
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "%-5s%-11s%-22s", "Vsi",
                                   "Crosscheck", "ServiceID");
                    }
                    else
                    {
                    CliPrintf (CliHandle, "%-5s%-11s%-22s", "Vlan",
                               "Crosscheck", "ServiceID");
                    }
                    CliPrintf (CliHandle, "\r\n");
                b1Header = ECFM_FALSE;
            }
#endif
            if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
            {
                CliPrintf (CliHandle, "%-10u",
                           ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
            }
            else
            {
                CliPrintf (CliHandle, "%-5d", i4RetPriVlanId);
            }
            if (i4XchkStatus == ECFM_ENABLE)

            {
                CliPrintf (CliHandle, "%-11s", "Enabled");
            }

            else

            {
                CliPrintf (CliHandle, "%-11s", "Disabled");
            }
            CliPrintf (CliHandle, "%-22s\r\n", au1StrMaName);
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowDomains                                       
 *                                                                          
 *     DESCRIPTION      : This function will show the configured domain
 *                        information 
 *                                                                          
 *     INPUT            : CliHandle      - CliContext ID
 *                        u4ContextId    - Context Identifier                                                 
 *                        u4Type         - Command
 *                        pu1Arg         - Domain Name or Level
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowDomains (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                    UINT1 *pu1Arg)
{
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMdRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMepArchiveHoldTime = ECFM_INIT_VAL;
    INT4                i4RetMhfCreation = ECFM_INIT_VAL;
    INT4                i4RetIdPermission = ECFM_INIT_VAL;
    INT4                i4RetMegVlanPriority = ECFM_INIT_VAL;
    INT4                i4RetMegDropEnable = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT4               u4MdLevel = 0;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4Count = ECFM_INIT_VAL;    /* No. of associations 
                                                       associated 
                                                       with a MD */
    UINT4               u4PagingStatus = CLI_SUCCESS;
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Flag = ECFM_FALSE;
    BOOL1               b1IsHeaderPrinted = ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMdTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0,
         &u4MdIndex) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    /* Its for required context, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))
    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        i4RetMepArchiveHoldTime = ECFM_INIT_VAL;

        /* first check its row status */
        nmhGetFsMIEcfmMdRowStatus (i4CurrentContextId, u4MdIndex,
                                   &i4RetMdRowStatus);
        if (i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE)
        {

            /* Get u4MdIndex's name level, no. of associations in this MD */
            nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
            nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex,
                                    &i4RetMdFormat);
            nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);

            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);

            u4Count = EcfmGetNoOfMasInMd (i4CurrentContextId, u4MdIndex);

            switch (u4Type)
            {
                case CLI_ECFM_SHOW_DOMAIN_BRIEF:
                case CLI_ECFM_SHOW_DOMAIN:
                    /* Compare MdName if passed through CLI */
                    if ((pu1Arg != NULL) &&
                        (STRCMP (au1StrMdName, pu1Arg) == 0))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                    break;

                case CLI_ECFM_SHOW_DOMAIN_LEV_BRIEF:
                case CLI_ECFM_SHOW_DOMAIN_LEV:
                    /* Compare MdLevel if passed through CLI */
                    if (pu1Arg != NULL)
                        MEMCPY (&u4MdLevel, pu1Arg, sizeof (UINT4));

                    if (u4RetMdLevel == u4MdLevel)
                    {
                        b1Entry = ECFM_TRUE;
                    }
                    break;

                default:
                    break;
            }

            /* Show all the errors corresponding to MEP and its associated
             * remote MEPs
             */
            if ((pu1Arg == NULL) || (b1Entry == ECFM_TRUE))
            {

                b1Flag = ECFM_TRUE;

                /* Print header for first time alone */
                if ((b1IsHeaderPrinted == ECFM_FALSE) &&
                    ((u4Type == CLI_ECFM_SHOW_DOMAIN_BRIEF) ||
                     (u4Type == CLI_ECFM_SHOW_DOMAIN_LEV_BRIEF)))
                {
                    CliPrintf (CliHandle, "\r\n%-21s%-10s%-10s%-10s%-20s\r\n",
                               "Domain Name", "Index", "Level", "Services",
                               "Archive(min)");

                    b1IsHeaderPrinted = ECFM_TRUE;
                }

                if (u4Type == CLI_ECFM_SHOW_DOMAIN_BRIEF ||
                    u4Type == CLI_ECFM_SHOW_DOMAIN_LEV_BRIEF)
                {
                    nmhGetFsMIEcfmMepArchiveHoldTime (i4CurrentContextId,
                                                      u4MdIndex,
                                                      &i4RetMepArchiveHoldTime);
                    CliPrintf (CliHandle, "%-21s", au1StrMdName);
                    CliPrintf (CliHandle, "%-10u", u4MdIndex);
                    CliPrintf (CliHandle, "%-10u", u4RetMdLevel);
                    CliPrintf (CliHandle, "%-10u", u4Count);
                    CliPrintf (CliHandle, "%-20u", i4RetMepArchiveHoldTime);
                    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                }
                else
                {
                    /* Domain detail */
                    i4RetMhfCreation = ECFM_INIT_VAL;
                    i4RetIdPermission = ECFM_INIT_VAL;
                    i4RetMegVlanPriority = ECFM_INIT_VAL;
                    i4RetMegDropEnable = ECFM_INIT_VAL;
                    nmhGetFsMIEcfmMdMhfCreation (i4CurrentContextId, u4MdIndex,
                                                 &i4RetMhfCreation);
                    nmhGetFsMIEcfmMdMhfIdPermission (i4CurrentContextId,
                                                     u4MdIndex,
                                                     &i4RetIdPermission);
                    nmhGetFsMIY1731MegVlanPriority (i4CurrentContextId,
                                                    u4MdIndex,
                                                    (INT4 *)
                                                    &i4RetMegVlanPriority);
                    nmhGetFsMIY1731MegDropEnable (i4CurrentContextId, u4MdIndex,
                                                  (INT4 *) &i4RetMegDropEnable);
                    CliPrintf (CliHandle, "\r\nDomain Name : %s", au1StrMdName);

                    if (i4RetMdFormat == ECFM_DOMAIN_NAME_TYPE_DNS_LIKE_NAME)
                    {
                        CliPrintf (CliHandle,
                                   "\r\nDomain Format : dns-like-name");
                    }
                    if (i4RetMdFormat == ECFM_DOMAIN_NAME_TYPE_NONE)
                    {
                        CliPrintf (CliHandle, "\r\nDomain Format : none");
                    }
                    if (i4RetMdFormat ==
                        ECFM_DOMAIN_NAME_TYPE_MAC_ADDR_AND_UINT)
                    {
                        CliPrintf (CliHandle, "\r\nDomain Format : mac-addr");
                    }
                    if (i4RetMdFormat == ECFM_DOMAIN_NAME_TYPE_CHAR_STRING)
                    {
                        CliPrintf (CliHandle,
                                   "\r\nDomain Format : char-string");
                    }

                    CliPrintf (CliHandle, "\r\nIndex : %u", u4MdIndex);
                    CliPrintf (CliHandle, "\r\nLevel : %u", u4RetMdLevel);
                    CliPrintf (CliHandle, "\r\nVlan Priority : %u",
                               i4RetMegVlanPriority);

                    if (i4RetMegDropEnable == 1)
                    {
                        CliPrintf (CliHandle, "\r\nDrop Eligibility : Enabled");
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r\nDrop Eligibility : Disabled");
                    }

                    switch (i4RetMhfCreation)
                    {
                        case ECFM_MHF_CRITERIA_NONE:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : none");
                            break;
                        case ECFM_MHF_CRITERIA_DEFAULT:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : default");
                            break;
                        case ECFM_MHF_CRITERIA_EXPLICIT:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : explicit");
                            break;
                        default:
                            break;
                    }

                    switch (i4RetIdPermission)
                    {
                        case ECFM_SENDER_ID_NONE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission : none");
                            break;
                        case ECFM_SENDER_ID_CHASSIS:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission : Chassis-Id");
                            break;
                        case ECFM_SENDER_ID_MANAGE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission : Mgt-Address");
                            break;
                        case ECFM_SENDER_ID_CHASSID_MANAGE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission : Chassis-Id and Mgt-Address ");
                            break;
                        default:
                            break;
                    }
                    CliPrintf (CliHandle, "\r\nTotal Services : %u\r\n",
                               u4Count);

                    /* Crosscheck status to be added */
                    EcfmShowXchkStatus (CliHandle, i4CurrentContextId,
                                        u4MdIndex, ECFM_TRUE);

                    /* Crosscheck parameters */
                    EcfmShowXchkParams (CliHandle, CLI_ECFM_SHOW_DOMAIN,
                                        i4CurrentContextId, u4MdIndex, 0,
                                        ECFM_TRUE);
                    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                }
            }

            if (b1Entry == ECFM_TRUE)    /* If the required entry found, break */
                b1Entry = ECFM_FALSE;
        }
        i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrentContextId,
                                                   (UINT4 *) &i4NextContextId,
                                                   u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1IsShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {

            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }
    CliPrintf (CliHandle, "\n");

    if (b1Flag == ECFM_FALSE)
    {
        CliPrintf (CliHandle, "%% Given Level/Domain not present\r\n");
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetModuleStatusGlobal                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable Ecfm module for
 *                        all Meps.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status   - Ecfm Module status                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetModuleStatusGlobal (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if this can be set */
    if (nmhTestv2FsEcfmModuleStatus (&u4ErrorCode, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the status */
    if (nmhSetFsEcfmModuleStatus (i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetCcmOffLoadModuleStatusGlobal                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable Ecfm CCMOffload 
 *                        module status globally.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status   - CCMOffload status                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetCcmOffLoadModuleStatusGlobal (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if this can be set */
    if (nmhTestv2FsEcfmGlobalCcmOffload (&u4ErrorCode, i4Status) ==
        SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the status */
    nmhSetFsEcfmGlobalCcmOffload (i4Status);
    CliPrintf (CliHandle, " ");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmMepSetCcmOffLoadMepStatus  
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable Ecfm CCMOffload 
 *                        module status for the MEP.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status   - CCMOffload status                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmMepSetCcmOffLoadMepStatus (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDirection = ECFM_INIT_VAL;

    /* Check if ECFM module is started or not */
    if (ECFM_IS_SYSTEM_SHUTDOWN (ECFM_CC_CURR_CONTEXT_ID ()))

    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC, "OFFLOAD :"
                     "ECFM Module is SHUTDOWN\r\n");
        return CLI_FAILURE;
    }
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    u4CurrentContextId = ECFM_CC_CURR_CONTEXT_ID ();
    nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (u4CurrentContextId, u4MdIndex,
                                                  u4MaIndex, &u4RetPrimaryVid);

    if (ECFM_IS_MEP_ISID_AWARE (u4RetPrimaryVid))
    {
        if (nmhTestv2FsMIEcfmExtMepRowStatus
            (&u4ErrorCode, u4CurrentContextId, u4MdIndex, u4MaIndex,
             u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepRowStatus
            (u4CurrentContextId, u4MdIndex, u4MaIndex,
             u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmExtMepCcmOffload (&u4ErrorCode,
                                               u4CurrentContextId,
                                               u4MdIndex, u4MaIndex, u4MepId,
                                               i4Status) == SNMP_FAILURE)
        {
            if (nmhGetDot1agCfmMepDirection (u4MdIndex, u4MaIndex, u4MepId,
                                             &i4RetDirection) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            if ((i4RetDirection == ECFM_MP_DIR_UP) &&
                (i4Status == ECFM_CCM_OFFLOAD_ENABLE))
            {
                CliPrintf (CliHandle,
                           "\r%%Offload should be disabled for Up Mep\r\n ");
            }
            CliPrintf (CliHandle,
                       "\r%% Error: Offloading Cannot be Enabled\r\n ");
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepCcmOffload (u4CurrentContextId,
                                            u4MdIndex, u4MaIndex, u4MepId,
                                            i4Status) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmExtMepRowStatus
            (&u4ErrorCode, u4CurrentContextId, u4MdIndex, u4MaIndex, u4MepId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepRowStatus
            (u4CurrentContextId, u4MdIndex, u4MaIndex, u4MepId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

    }
    else
    {

        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) != SNMP_SUCCESS)

        {
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4MdIndex, u4MaIndex, u4MepId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) != SNMP_SUCCESS)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Test if this can be set */
        if (nmhTestv2FsEcfmMepCcmOffload
            (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepId,
             i4Status) == SNMP_FAILURE)

        {
            if (nmhGetDot1agCfmMepDirection (u4MdIndex, u4MaIndex, u4MepId,
                                             &i4RetDirection) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            if ((i4RetDirection == ECFM_MP_DIR_UP) &&
                (i4Status == ECFM_CCM_OFFLOAD_ENABLE))
            {
                CliPrintf (CliHandle,
                           "\r%%Offload should be disabled for Up Mep\r\n ");
                return CLI_FAILURE;
            }
            nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex, u4MepId,
                                         ECFM_ROW_STATUS_ACTIVE);
            CliPrintf (CliHandle,
                       "\r%% Error: Offloading Cannot be Enabled\r\n ");
            return CLI_FAILURE;
        }

        /* Then Set the status */
        if (nmhSetFsEcfmMepCcmOffload (u4MdIndex, u4MaIndex, u4MepId, i4Status)
            == SNMP_FAILURE)

        {
            nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex, u4MepId,
                                         ECFM_ROW_STATUS_ACTIVE);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4MdIndex, u4MaIndex, u4MepId,
             ECFM_ROW_STATUS_ACTIVE) != SNMP_SUCCESS)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    ECFM_CC_TRC_FN_EXIT ();
    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : EcfmTpOamMepSetAisOffLoadMepStatus
 *
 *     DESCRIPTION      : This function will enable/disable Ecfm AISOffload
 *                        module status for the MEP.
 *
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status   - CCMOffload status
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *****************************************************************************/
INT4
EcfmTpOamMepSetAisOffLoadMepStatus (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;

    /* Check if ECFM module is started or not */
    if (ECFM_IS_SYSTEM_SHUTDOWN (ECFM_CC_CURR_CONTEXT_ID ()))

    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC, "OFFLOAD :"
                     "ECFM Module is SHUTDOWN\r\n");
        return CLI_FAILURE;
    }
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    u4CurrentContextId = ECFM_CC_CURR_CONTEXT_ID ();
    if (nmhTestv2FsMIEcfmExtMepRowStatus
        (&u4ErrorCode, u4CurrentContextId, u4MdIndex, u4MaIndex,
         u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return SNMP_FAILURE;
    }
    if (nmhSetFsMIEcfmExtMepRowStatus
        (u4CurrentContextId, u4MdIndex, u4MaIndex,
         u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return SNMP_FAILURE;
    }

    /* Test if this can be set */
    if (nmhTestv2FsMIY1731MepAisOffload
        (&u4ErrorCode, u4CurrentContextId, u4MdIndex, u4MaIndex, u4MepId,
         i4Status) == SNMP_FAILURE)

    {
        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex, u4MepId,
                                     ECFM_ROW_STATUS_ACTIVE);
        CliPrintf (CliHandle, "\r\n Error Offloading Can Not Enabled  ");
        return CLI_FAILURE;
    }

    /* Then Set the status */
    if (nmhSetFsMIY1731MepAisOffload (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepId, i4Status)
        == SNMP_FAILURE)

    {
        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex, u4MepId,
                                     ECFM_ROW_STATUS_ACTIVE);
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (nmhSetFsMIEcfmExtMepRowStatus
        (u4CurrentContextId, u4MdIndex, u4MaIndex,
         u4MepId, ECFM_ROW_STATUS_ACTIVE) != SNMP_SUCCESS)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    ECFM_CC_TRC_FN_EXIT ();
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliConfOui                                       
 *                                                                          
 *     DESCRIPTION      : This function will set the OUI     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        pLocalClientOui - OUI                
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliConfOui (tCliHandle CliHandle, tSNMP_OCTET_STRING_TYPE * pLocalClientOui)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /*Test if OUI value can be set */
    if (nmhTestv2FsEcfmOui (&u4ErrorCode, pLocalClientOui) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set ECFM oui */
    nmhSetFsEcfmOui (pLocalClientOui);
    CliPrintf (CliHandle, " ");
    return CLI_SUCCESS;
}

/*****************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliCreateMDomain                               
 *                                                                           
 *     DESCRIPTION      : This function will enter into Domain database      
 *                        config                                             
 *                        mode. New MD will be created when that MD name is  
 *                        not present at that level in the database.         
 *                                                                           
 *     INPUT            : Pu1MdName   - Pointer to Md Name                   
 *                        u1MdLevel   - Level at which it is to be created
 *                        u4MdNameType- Type of the Md Name to be set
 *                                                                                                   
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 *****************************************************************************/
INT4
EcfmCliCreateMDomain (tCliHandle CliHandle, UINT1 *pu1MdName, UINT1 u1MdLevel,
                      UINT4 u4MdNameType)
{
    tSNMP_OCTET_STRING_TYPE MdName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MdMac[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT2               u2MaUint = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4MdNamelen = STRLEN (pu1MdName);
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;

    MEMSET (au1Cmd, 0, MAX_PROMPT_LEN);
    MEMSET (au1MdName, 0, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (au1RetMdName, 0, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (au1MdMac, 0, ECFM_MD_NAME_ARRAY_SIZE);

    MdName.pu1_OctetList = au1MdName;
    MdName.i4_Length = ECFM_INIT_VAL;

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    /* Check the given input for the MAC+2 Oct sring format is correct or not */
    if (u4MdNameType == ECFM_DOMAIN_NAME_TYPE_MAC_ADDR_AND_UINT)
    {
        if (EcfmCliValidateMdNameFormatForMac (pu1MdName, i4MdNamelen)
            == ECFM_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MD_NAME_FORMAT_ERR);
            ECFM_CC_TRC (ECFM_MGMT_TRC | ECFM_ALL_FAILURE_TRC,
                         "\tCLI:Invalid MD Name Format \n");
            return CLI_FAILURE;
        }

        MEMCPY (au1MdMac, pu1MdName, ECFM_MAC_ADD_STRING_LENGTH);
        StrToMac (au1MdMac, MdName.pu1_OctetList);
        SSCANF ((CHR1 *) (pu1MdName + ECFM_MAC_ADD_STRING_LENGTH + ECFM_VAL_1),
                "%hu", &u2MaUint);
        MEMCPY ((MdName.pu1_OctetList + MAC_ADDR_LEN), &u2MaUint,
                sizeof (UINT2));
        MdName.i4_Length = (MAC_ADDR_LEN + sizeof (UINT2));
    }
    else if ((u4MdNameType == ECFM_DOMAIN_NAME_TYPE_DNS_LIKE_NAME) ||
             (u4MdNameType == ECFM_DOMAIN_NAME_TYPE_CHAR_STRING) ||
             (u4MdNameType == ECFM_DOMAIN_NAME_TYPE_NONE))
    {
        MEMCPY (MdName.pu1_OctetList, pu1MdName, i4MdNamelen);
        MdName.i4_Length = i4MdNamelen;
    }

    /* Check for the existence of the domain */
    i4RetVal = nmhGetFirstIndexDot1agCfmMdTable (&u4MdIndex);
    while (i4RetVal == SNMP_SUCCESS)

    {
        MEMSET (au1RetMdName, 0, ECFM_MD_NAME_ARRAY_SIZE);

        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);

        if ((RetMdName.i4_Length == MdName.i4_Length) &&
            (MEMCMP (RetMdName.pu1_OctetList, MdName.pu1_OctetList,
                     RetMdName.i4_Length) == 0))
        {
            nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
            if (u4RetMdLevel == (UINT4) (u1MdLevel))

            {
                nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);

                if (i4RetMdFormat == (INT4) u4MdNameType)
                {
                    b1EntryFound = ECFM_TRUE;
                    break;
                }
                else
                {
                    CLI_SET_ERR (CLI_ECFM_DOM_LEVEL_CONF_ERR);
                    return CLI_FAILURE;

                }

            }

            else

            {
                CLI_SET_ERR (CLI_ECFM_DOM_LEVEL_CONF_ERR);
                return CLI_FAILURE;
            }
        }
        i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
        }
    }

    /* Check if entry found */
    if (b1EntryFound != ECFM_TRUE)
    {
        u4MdIndex = ECFM_INIT_VAL;

        /* Get unused index */
        if (nmhGetDot1agCfmMdTableNextIndex (&u4MdIndex) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_DOM_OWERFLOW_ERR);
            return CLI_FAILURE;
        }

        /* Check whether domain can be created */
        if (nmhTestv2Dot1agCfmMdRowStatus (&u4ErrCode, u4MdIndex,
                                           ECFM_ROW_STATUS_CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        /* Create Maintenance Domain */
        if (nmhSetDot1agCfmMdRowStatus
            (u4MdIndex, ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set Mdname and MdLevel */
        if (nmhTestv2Dot1agCfmMdFormat
            (&u4ErrCode, u4MdIndex, u4MdNameType) == SNMP_FAILURE)

        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdFormat (u4MdIndex, u4MdNameType) == SNMP_FAILURE)

        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2Dot1agCfmMdName (&u4ErrCode, u4MdIndex, &MdName)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhTestv2Dot1agCfmMdMdLevel (&u4ErrCode, u4MdIndex, u1MdLevel)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdName (u4MdIndex, &MdName) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdMdLevel (u4MdIndex, u1MdLevel) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Now make this row status to active */
        if (nmhTestv2Dot1agCfmMdRowStatus
            (&u4ErrCode, u4MdIndex, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_ACTIVE)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* ENTER Domain Config Mode */
    SPRINTF ((CHR1 *) au1Cmd, "%s%u", CLI_DOMAIN_MODE, u4MdIndex);
    if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_CHMOD_ERR);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*****************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliCreateOamMDomain
 *
 *     DESCRIPTION      : This function will enter into Domain database
 *                        config
 *                        mode. New MD will be created when that MD name is
 *                        not present at that level in the database.
 *
 *     INPUT            : Pu1MdName   - Pointer to Md Name
 *                        u1MdLevel   - Level at which it is to be created
 *                        u4MdNameType- Type of the Md Name to be set
 *
 *     OUTPUT           : CliHandle - Contains error messages
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *****************************************************************************/
INT4
EcfmCliCreateOamMDomain (tCliHandle CliHandle, UINT1 u1MdLevel,
                         UINT4 u4MdNameType)
{
    tSNMP_OCTET_STRING_TYPE MdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MdMac[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT1               au1DefMdName[6];
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4MdNamelen = strlen ("NONE");
    BOOL1               b1EntryFound = ECFM_FALSE;

    MEMSET (au1Cmd, 0, MAX_PROMPT_LEN);
    MEMSET (au1MdName, 0, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (au1MdMac, 0, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (au1DefMdName, 0, strlen ("NONE"));

    MdName.pu1_OctetList = au1MdName;
    MdName.i4_Length = ECFM_INIT_VAL;

    /* For MPLSTPOAM Default MD Domain Name "NONE" will be used */

    MEMCPY (au1DefMdName, "NONE", strlen ("NONE"));
    /* Check the given input for the MAC+2 Oct sring format is correct or not */
    if ((u4MdNameType == ECFM_DOMAIN_NAME_TYPE_DNS_LIKE_NAME) ||
        (u4MdNameType == ECFM_DOMAIN_NAME_TYPE_CHAR_STRING))
    {
        MEMCPY (MdName.pu1_OctetList, au1DefMdName, i4MdNamelen);
        MdName.i4_Length = i4MdNamelen;
    }

    /* Check for the existence of the domain */
    i4RetVal = nmhGetFirstIndexDot1agCfmMdTable (&u4MdIndex);
    while (i4RetVal == SNMP_SUCCESS)

    {
        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
        if (u4RetMdLevel == (UINT4) (u1MdLevel))
        {
            b1EntryFound = ECFM_TRUE;
            break;
        }
        /* MPLSTPOAM : In case of MPLTP OAM we can allow the creation
         * of Domains in different level with No domain name("").
         */

        i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
        }
    }

    /* Check if entry found */
    if (b1EntryFound != ECFM_TRUE)
    {
        u4MdIndex = ECFM_INIT_VAL;

        /* Get unused index */
        if (nmhGetDot1agCfmMdTableNextIndex (&u4MdIndex) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_DOM_OWERFLOW_ERR);
            return CLI_FAILURE;
        }

        /* Check whether domain can be created */
        if (nmhTestv2Dot1agCfmMdRowStatus (&u4ErrCode, u4MdIndex,
                                           ECFM_ROW_STATUS_CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        /* Create Maintenance Domain */
        if (nmhSetDot1agCfmMdRowStatus
            (u4MdIndex, ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set Mdname and MdLevel */
        if (nmhTestv2Dot1agCfmMdFormat
            (&u4ErrCode, u4MdIndex, u4MdNameType) == SNMP_FAILURE)

        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdFormat (u4MdIndex, u4MdNameType) == SNMP_FAILURE)

        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2Dot1agCfmMdName (&u4ErrCode, u4MdIndex, &MdName)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhTestv2Dot1agCfmMdMdLevel (&u4ErrCode, u4MdIndex, u1MdLevel)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdName (u4MdIndex, &MdName) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdMdLevel (u4MdIndex, u1MdLevel) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Now make this row status to active */
        if (nmhTestv2Dot1agCfmMdRowStatus
            (&u4ErrCode, u4MdIndex, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_ACTIVE)
            == SNMP_FAILURE)
        {
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    /* ENTER Domain Config Mode */
    SPRINTF ((CHR1 *) au1Cmd, "%s%u", CLI_MPLS_DOMAIN_MODE, u4MdIndex);
    if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_CHMOD_ERR);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliSetMDomainMhfparams 
 *                                                                          
 *     DESCRIPTION      : This function will set Mhf creation criteria and/or 
 *                        Sender Id permission of particular Maintenance Domain
 *                                                                           
 *     INPUT            : i4MhfCriteria -  MHF creation criteria 
 *                        i4SenderIdPermission - Sender Id permission
 *                        
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliSetMDomainMhfparams (tCliHandle CliHandle, INT4 i4MhfCriteria,
                            INT4 i4SenderIdPermission)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    BOOL1               b1ParamSet = ECFM_FALSE;
    BOOL1               b1CriteriaSet = ECFM_TRUE;
    tEcfmCcMdInfo      *pMdNode = NULL;
    tEcfmCcMaInfo      *pMaNode = NULL;
    tEcfmCcMipInfo     *pMipNode = NULL;

    /* Get this value from config prompt */
    u4MdIndex = CLI_GET_MDINDEX ();
    if (nmhTestv2Dot1agCfmMdRowStatus
        (&u4ErrCode, u4MdIndex, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_NOT_IN_SERVICE)
        == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    /* Set Mhf criteria and/or SenderId permission */
    if (i4MhfCriteria != 0)

    {
        pMipNode = (tEcfmCcMipInfo *) RBTreeGetFirst (ECFM_CC_GLOBAL_MIP_TABLE);
        pMdNode = EcfmSnmpLwGetMdEntry (u4MdIndex);
        while ((pMipNode != NULL) && (pMdNode != NULL))
        {
            pMaNode = (tEcfmCcMaInfo *) RBTreeGetFirst (pMdNode->MaTable);
            do
            {

                if ((pMipNode->u4MdIndex == pMdNode->u4MdIndex)
                    && (pMipNode->u4MaIndex == pMaNode->u4MaIndex))
                {
                    if ((pMaNode->u1MhfCreation == ECFM_MHF_CRITERIA_DEFER)
                        && ((UINT1) i4MhfCriteria != pMdNode->u1MhfCreation))
                    {
                        b1CriteriaSet = ECFM_FALSE;
                        CliPrintf (CliHandle,
                                   "\r%% Unable to Set Criteria when MIP is active\r\n");
                    }

                }
            }
            while ((pMaNode = (tEcfmCcMaInfo *) RBTreeGetNext (pMdNode->MaTable,
                                                               pMaNode,
                                                               NULL)) != NULL);

            pMipNode = RBTreeGetNext (ECFM_CC_GLOBAL_MIP_TABLE,
                                      (tRBElem *) pMipNode, NULL);
        }

        if (nmhTestv2Dot1agCfmMdMhfCreation
            (&u4ErrCode, u4MdIndex, i4MhfCriteria) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (b1CriteriaSet != ECFM_FALSE)
        {
            if (nmhSetDot1agCfmMdMhfCreation (u4MdIndex, i4MhfCriteria)
                == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
        }
        b1ParamSet = ECFM_TRUE;
    }
    if (i4SenderIdPermission != 0)

    {
        if (nmhTestv2Dot1agCfmMdMhfIdPermission
            (&u4ErrCode, u4MdIndex, i4SenderIdPermission) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMdMhfIdPermission (u4MdIndex, i4SenderIdPermission)
            == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        b1ParamSet = ECFM_TRUE;
    }

    /* Now make this row status to active */
    if (nmhTestv2Dot1agCfmMdRowStatus
        (&u4ErrCode, u4MdIndex, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_ACTIVE)
        == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (b1ParamSet == ECFM_TRUE)

    {
        return CLI_SUCCESS;
    }
    return CLI_FAILURE;
}

/*****************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteMDomain                               
 *                                                                           
 *     DESCRIPTION      : This function deletes existing MD  configuration   
 *                                                                           
 *     INPUT            : Pu1MdName   - Pointer to Md Name                   
 *                        u1MdLevel   - level                                
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ***************************************************************************/
INT4
EcfmCliDeleteMDomain (tCliHandle CliHandle, UINT1 *pu1MdName, UINT1 u1MdLevel,
                      INT4 i4MdFormat)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE MdName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT2               u2MaUint = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MdMac[ECFM_MD_NAME_ARRAY_SIZE];

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);

    /*Get first index */
    i4RetVal = nmhGetFirstIndexDot1agCfmMdTable (&u4MdIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    MdName.pu1_OctetList = au1MdName;
    MdName.i4_Length = ECFM_INIT_VAL;

    while (i4RetVal == SNMP_SUCCESS)
    {
        MEMSET (RetMdName.pu1_OctetList, 0, ECFM_MD_NAME_ARRAY_SIZE);
        RetMdName.i4_Length = ECFM_INIT_VAL;

        MEMSET (MdName.pu1_OctetList, 0, ECFM_MD_NAME_ARRAY_SIZE);
        MdName.i4_Length = ECFM_INIT_VAL;

        /* Get u4MdIndex's name and level */
        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
        nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);

        if (i4RetMdFormat != i4MdFormat)
        {
            i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex,
                                                        &u4NextMdIndex);
            u4MdIndex = u4NextMdIndex;
            continue;
        }

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        if (i4MdFormat == ECFM_DOMAIN_NAME_TYPE_MAC_ADDR_AND_UINT)
        {
            if (EcfmCliValidateMdNameFormatForMac
                (pu1MdName, STRLEN (pu1MdName)) != ECFM_FAILURE)
            {
                MEMCPY (au1MdMac, pu1MdName, ECFM_MAC_ADD_STRING_LENGTH);
                StrToMac (au1MdMac, MdName.pu1_OctetList);
                SSCANF ((CHR1 *) (pu1MdName + ECFM_MAC_ADD_STRING_LENGTH +
                                  ECFM_VAL_1), "%hu", &u2MaUint);
                MEMCPY ((MdName.pu1_OctetList + MAC_ADDR_LEN), &u2MaUint,
                        sizeof (UINT2));
                MdName.i4_Length = (MAC_ADDR_LEN + sizeof (UINT2));
            }
        }

        /* Check if this is the domain to delete */
        if ((((STRCMP (au1StrMdName, pu1MdName) == 0) ||
              ((MdName.i4_Length == RetMdName.i4_Length) &&
               (MEMCMP (RetMdName.pu1_OctetList, MdName.pu1_OctetList,
                        RetMdName.i4_Length) == 0))) &&
             (u1MdLevel == (UINT1) u4RetMdLevel)))
        {
            /* Now make this row status to DESTROY */
            if (nmhTestv2Dot1agCfmMdRowStatus
                (&u4ErrCode, u4MdIndex,
                 ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);

            /* Done successfully */
            return CLI_SUCCESS;
        }

        /* Get next valid index */
        i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex, &u4NextMdIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
    CliPrintf (CliHandle, " ");
    return CLI_FAILURE;
}

/*****************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliOamDeleteMDomain
 *
 *     DESCRIPTION      : This function deletes existing MD  configuration
 *
 *     INPUT            : i4MdFormat  - Pointer to Md Name
 *                        u1MdLevel   - level
 *
 *     OUTPUT           : CliHandle - Contains error messages
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ***************************************************************************/
INT4
EcfmCliOamDeleteMDomain (tCliHandle CliHandle, UINT1 u1MdLevel, INT4 i4MdFormat)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE MdName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1DefMdName[ECFM_MD_NAME_ARRAY_SIZE];

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1DefMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);

    MEMCPY (au1DefMdName, "NONE", strlen ("NONE"));

    /*Get first index */
    i4RetVal = nmhGetFirstIndexDot1agCfmMdTable (&u4MdIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    MdName.pu1_OctetList = au1MdName;
    MdName.i4_Length = ECFM_INIT_VAL;

    while (i4RetVal == SNMP_SUCCESS)
    {
        MEMSET (RetMdName.pu1_OctetList, 0, ECFM_MD_NAME_ARRAY_SIZE);
        RetMdName.i4_Length = ECFM_INIT_VAL;

        MEMSET (MdName.pu1_OctetList, 0, ECFM_MD_NAME_ARRAY_SIZE);
        MdName.i4_Length = ECFM_INIT_VAL;

        /* Get u4MdIndex's name and level */
        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
        nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);

        if (i4RetMdFormat != i4MdFormat)
        {
            i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex,
                                                        &u4NextMdIndex);
            u4MdIndex = u4NextMdIndex;
            continue;
        }

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Check if this is the domain to delete */
        if ((((STRCMP (au1StrMdName, au1DefMdName) == 0) ||
              ((MdName.i4_Length == RetMdName.i4_Length) &&
               (MEMCMP (RetMdName.pu1_OctetList, MdName.pu1_OctetList,
                        RetMdName.i4_Length) == 0))) &&
             (u1MdLevel == (UINT1) u4RetMdLevel)))
        {
            /* Now make this row status to DESTROY */
            if (nmhTestv2Dot1agCfmMdRowStatus
                (&u4ErrCode, u4MdIndex,
                 ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }
            nmhSetDot1agCfmMdRowStatus (u4MdIndex, ECFM_ROW_STATUS_DESTROY);

            /* Done successfully */
            return CLI_SUCCESS;
        }

        /* Get next valid index */
        i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex, &u4NextMdIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
    CliPrintf (CliHandle, " ");
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliCreateMAssociation                          
 *                                                                          
 *     DESCRIPTION      : This function will create a new maintenance        
 *                        association in a maintenace domain config
 *                                                                           
 *     INPUT            : Pu1MaName   - Pointer to Ma Name                   
 *                        u4PrimaryVlanId  - vlanId which needs to associated 
 *                        with this Ma.  
 *                        i4MhfCriteria - Value indicating if MHF can be created 
 *                        for this MA       
 *                        pu1Icc - Pointer to the ICC code
 *                        pu1Umc - Pointer to the UMC code     
 *                        u4ContextId  - Current Context Id
 *                        u4MaNameType - MA Name Type
 *                        
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliCreateMAssociation (tCliHandle CliHandle, UINT1 *pu1MaName,
                           UINT4 u4PrimaryVlanId,
                           INT4 i4MhfCriteria,
                           INT4 i4SenderIdPermission, UINT1 *pu1Icc,
                           UINT1 *pu1Umc, UINT4 u4ContextId, UINT4 u4MaNameType,
                           UINT4 u4VlanRangeId)
{
    tSNMP_OCTET_STRING_TYPE MaName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE IccCode;
    tSNMP_OCTET_STRING_TYPE UmcCode;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaUnusedIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4VpnOuiVal = ECFM_INIT_VAL;
    UINT4               u4VpnIndVal = ECFM_INIT_VAL;
    UINT4               u4Counter = ECFM_INIT_VAL;
    UINT4               u4MaStrLen = ECFM_INIT_VAL;
    UINT4               u4RetVlanId = ECFM_INIT_VAL;
    UINT2               u2MaVal = ECFM_INIT_VAL;
    UINT2               u2Count = ECFM_INIT_VAL;
    UINT2               u2Index = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1VpnOui[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1VpnIndex[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               u1DotCount = ECFM_INIT_VAL;
    BOOL1               b1CriteriaSet = ECFM_TRUE;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4RetStatus = CLI_SUCCESS;

    tEcfmCcMipInfo     *pMipNode = NULL;
    tEcfmCcMaInfo      *pMaNode = NULL;

    /* Get this value from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    MEMSET (&MaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    MaName.pu1_OctetList = au1MaName;
    MEMSET (au1MaName, 0, ECFM_MA_NAME_ARRAY_SIZE);
    MEMSET (au1VpnIndex, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    MEMSET (au1VpnOui, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);

    MaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

    if (EcfmValidateMaNameStrFormat (pu1MaName, u4MaNameType) == ECFM_FAILURE)
    {
        CliPrintf (CliHandle, "%% Invalid input for specified format or Values "
                   "are not with in the range\r\n");
        return CLI_FAILURE;
    }

    /* Check for MA name whether it is UNSIGNED_INT_16 format or not */
    if (u4MaNameType == ECFM_ASSOC_NAME_PRIMARY_VID)
    {
        if (pu1MaName == NULL)
        {
            u2MaVal = u4PrimaryVlanId;
        }
        else
        {
            u2MaVal = ATOI (pu1MaName);
        }

        u2MaVal = ECFM_HTONS (u2MaVal);
        MaName.i4_Length = sizeof (u2MaVal);
        MEMCPY (MaName.pu1_OctetList, &u2MaVal, MaName.i4_Length);
    }
    else if (u4MaNameType == ECFM_ASSOC_NAME_UNSIGNED_INT_16)
    {
        u2MaVal = ATOI (pu1MaName);
        u2MaVal = ECFM_HTONS (u2MaVal);
        MaName.i4_Length = sizeof (u2MaVal); 
        MEMCPY (MaName.pu1_OctetList, &u2MaVal, MaName.i4_Length); 
    }
    /* Check for MA name for RFC2865_VPN_ID */
    else if (u4MaNameType == ECFM_ASSOC_NAME_RFC2865_VPN_ID)
    {
        u4MaStrLen = STRLEN (pu1MaName);
        u4Counter = u4MaStrLen;
        for (u4Counter = 0; u4Counter < u4MaStrLen; u4Counter++)
        {
            if (pu1MaName[u4Counter] == ':')
            {
                u1DotCount++;
                continue;
            }
            /* check the colon count shoud be one */
            if (u1DotCount != ECFM_VAL_1)
            {
                if (u2Count < ECFM_MA_NAME_ARRAY_SIZE)
                {
                    au1VpnOui[u2Count] = pu1MaName[u4Counter];
                }
                u2Count++;
            }
            else
            {
                if (u2Index < ECFM_MA_NAME_ARRAY_SIZE)
                {
                    au1VpnIndex[u2Index] = pu1MaName[u4Counter];
                }
                u2Index++;
            }
        }

        SSCANF ((CHR1 *) au1VpnOui, "%x", &u4VpnOuiVal);
        SSCANF ((CHR1 *) au1VpnIndex, "%x", &u4VpnIndVal);
        /* Copy the VPN OUI 3 bytes as specified in the MIB */
        MaName.pu1_OctetList[0] = (u4VpnOuiVal >> 16) & ECFM_MASK_WITH_VAL_255;
        MaName.pu1_OctetList[1] = (u4VpnOuiVal >> 8) & ECFM_MASK_WITH_VAL_255;
        MaName.pu1_OctetList[2] = (u4VpnOuiVal) & ECFM_MASK_WITH_VAL_255;
        u4VpnIndVal = ECFM_HTONL (u4VpnIndVal);

        /* Copy the VPN indeex 4 bytes as specified in the MIB after the 
         * VPN OUT (3 bytes) */
        MEMCPY ((MaName.pu1_OctetList + ECFM_VAL_3), &u4VpnIndVal,
                sizeof (u4VpnIndVal));
        MaName.i4_Length = ECFM_VAL_7;
    }
    else
    {
        MaName.i4_Length = STRLEN (pu1MaName);
        MEMCPY (MaName.pu1_OctetList, pu1MaName, MaName.i4_Length);
        MaName.pu1_OctetList = pu1MaName;
    }

    /* Check for the existence of the already created Association */
    i4RetVal = nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex);
    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetVlanId);

        if ((u4MdIndex == u4PromptMdIndex) &&
            (MaName.i4_Length == RetMaName.i4_Length) &&
            (MEMCMP (RetMaName.pu1_OctetList, MaName.pu1_OctetList,
                     MaName.i4_Length) == 0))
        {

            if (u4RetVlanId != u4PrimaryVlanId)
            {
                CLI_SET_ERR (CLI_ECFM_MA_EXIST_ERR);
                return CLI_FAILURE;
            }
            /* Set Mhf criteria, SenderId permission, ICC or UMC code */
            if ((i4MhfCriteria == -1) && (i4SenderIdPermission == -1) &&
                (pu1Icc == NULL) && (pu1Umc == NULL))
            {
                CLI_SET_ERR (CLI_ECFM_MA_EXIST_ERR);
                return CLI_FAILURE;
            }

            if (nmhTestv2Dot1agCfmMaNetRowStatus
                (&u4ErrCode, u4PromptMdIndex, u4MaIndex,
                 ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }

            if (nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                           u4MaIndex,
                                           ECFM_ROW_STATUS_NOT_IN_SERVICE) ==
                SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }

            u4SavedMaIndex = u4MaIndex;
            break;
        }
        /*If Primary VLAN Id is already configured in that domain, 
         *MA should not be allowed to create*/
        if ((u4MdIndex == u4PromptMdIndex) && (u4RetVlanId == u4PrimaryVlanId))
        {
            CLI_SET_ERR (CLI_ECFM_MA_CONFIG_ERR);
            return CLI_FAILURE;
        }
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    if (u4SavedMaIndex == 0)
    {

        /* Create MA */
        /* Get Unused index */
        if (nmhGetDot1agCfmMdMaNextIndex
            (u4PromptMdIndex, &u4MaUnusedIndex) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_OWERFLOW_ERR);
            return CLI_FAILURE;
        }

        /* Check whether Association can be created */
        if (nmhTestv2Dot1agCfmMaNetRowStatus
            (&u4ErrCode, u4PromptMdIndex, u4MaUnusedIndex,
             ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        /* Create Maintenance Association */
        if (nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set the MA Format */
        if (nmhTestv2Dot1agCfmMaNetFormat
            (&u4ErrCode, u4PromptMdIndex, u4MaUnusedIndex,
             u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMaNetFormat
            (u4PromptMdIndex, u4MaUnusedIndex, u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2Ieee8021CfmMaCompPrimarySelectorType
            (&u4ErrCode, 0, u4PromptMdIndex, u4MaUnusedIndex,
             ECFM_SERVICE_SELECTION_VLAN) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }
        if (nmhSetIeee8021CfmMaCompPrimarySelectorType
            (0, u4PromptMdIndex, u4MaUnusedIndex,
             ECFM_SERVICE_SELECTION_VLAN) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;

        }

        /* Set Primary VlanId */
        if (nmhTestv2Ieee8021CfmMaCompPrimarySelectorOrNone
            (&u4ErrCode, ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
             u4MaUnusedIndex, u4PrimaryVlanId) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetIeee8021CfmMaCompPrimarySelectorOrNone
            (ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
             u4MaUnusedIndex, u4PrimaryVlanId) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

#ifdef DCSG_EXT_WANTED
        if (u4VlanRangeId != ECFM_INVALID_RANGE_VLAN_ID)
        {
            if (nmhTestv2FsMIEcfmMaOamVlanId
                (&u4ErrCode, ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
                 u4MaUnusedIndex, (INT4) u4VlanRangeId) == SNMP_FAILURE)
            {
                nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                           u4MaUnusedIndex,
                                           ECFM_ROW_STATUS_DESTROY);
                CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
                return CLI_FAILURE;
            }

            if (nmhSetFsMIEcfmMaOamVlanId
                (ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
                 u4MaUnusedIndex, (INT4) u4VlanRangeId) == SNMP_FAILURE)
            {
                nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                           u4MaUnusedIndex,
                                           ECFM_ROW_STATUS_DESTROY);
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
#endif

        if (nmhTestv2Dot1agCfmMaNetName
            (&u4ErrCode, u4PromptMdIndex, u4MaUnusedIndex,
             &MaName) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMaNetName
            (u4PromptMdIndex, u4MaUnusedIndex, &MaName) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmMaRowStatus (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        u4SavedMaIndex = u4MaUnusedIndex;
    }

    /* Set Mhf criteria */
    if (i4MhfCriteria != -1)
    {
        pMipNode = (tEcfmCcMipInfo *) RBTreeGetFirst (ECFM_CC_GLOBAL_MIP_TABLE);
        pMaNode = EcfmSnmpLwGetMaEntry (u4PromptMdIndex, u4SavedMaIndex);
        while ((pMipNode != NULL) && (pMaNode != NULL))
        {
            if ((pMipNode->u4MaIndex == pMaNode->u4MaIndex)
                && (pMipNode->u4MdIndex == pMaNode->u4MdIndex))
            {
                if ((UINT1) i4MhfCriteria != pMaNode->u1MhfCreation)
                {
                    b1CriteriaSet = ECFM_FALSE;
                    CliPrintf (CliHandle,
                               "\r%% Unable to Set Criteria when MIP is active\r\n");
                }
            }
            pMipNode = RBTreeGetNext (ECFM_CC_GLOBAL_MIP_TABLE,
                                      (tRBElem *) pMipNode, NULL);
        }
        if (nmhTestv2Ieee8021CfmMaCompMhfCreation
            (&u4ErrCode, ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
             u4SavedMaIndex, i4MhfCriteria) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_MHF_CRITERIA_CONF_ERR);
            return CLI_FAILURE;
        }
        if (b1CriteriaSet != ECFM_FALSE)
        {
            if (nmhSetIeee8021CfmMaCompMhfCreation
                (ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
                 u4SavedMaIndex, i4MhfCriteria) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
    }

    /* Set sender id permission */
    if (i4SenderIdPermission != -1)
    {
        if (nmhTestv2Ieee8021CfmMaCompIdPermission
            (&u4ErrCode, ECFM_CC_CURR_CONTEXT_ID (),
             u4PromptMdIndex, u4SavedMaIndex,
             i4SenderIdPermission) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_SENDER_ID_CONF_ERR);
            return CLI_FAILURE;
        }

        if (nmhSetIeee8021CfmMaCompIdPermission
            (ECFM_CC_CURR_CONTEXT_ID (), u4PromptMdIndex,
             u4SavedMaIndex, i4SenderIdPermission) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* Setting ICC and UMC code */
    if ((pu1Icc != NULL) && (pu1Umc != NULL))
    {
        do
        {
            ECFM_MEMSET (&IccCode, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            IccCode.pu1_OctetList = pu1Icc;
            IccCode.i4_Length = ECFM_STRLEN (pu1Icc);
            if (nmhTestv2FsMIY1731MeMegIdIcc
                (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
                 &IccCode) == SNMP_FAILURE)
            {
                CLI_SET_ERR (CLI_ECFM_MA_ICC_CONF_ERR);
                i4RetStatus = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731MeMegIdIcc
                (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
                 &IccCode) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            ECFM_MEMSET (&UmcCode, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            UmcCode.pu1_OctetList = pu1Umc;
            UmcCode.i4_Length = ECFM_STRLEN (pu1Umc);
            if (nmhTestv2FsMIY1731MeMegIdUmc
                (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
                 &UmcCode) == SNMP_FAILURE)
            {
                CLI_SET_ERR (CLI_ECFM_MA_UMC_CONF_ERR);
                i4RetStatus = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731MeMegIdUmc
                (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
                 &UmcCode) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        while (0);
    }
    /* Make the row status to Active */
    if (nmhTestv2FsMIY1731MeRowStatus
        (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeRowStatus
        (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    UNUSED_PARAM (u4VlanRangeId);
    return i4RetStatus;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliCreateOamMAssociation
 *
 *     DESCRIPTION      : This function will create a new maintenance
 *                        association in a maintenace domain config for MPLS
 *                        this will also assing the service type for the MA as either
 *                        LSP or PW
 *
 *     INPUT            : Pu1MaName   - Pointer to Ma Name
 *                        u4PrimaryVlanId  - vlanId which needs to associated
 *                        with this Ma.
 *                        i4MhfCriteria - Value indicating if MHF can be created
 *                        for this MA
 *                        pu1Icc - Pointer to the ICC code
 *                        pu1Umc - Pointer to the UMC code
 *                        u4ContextId  - Current Context Id
 *                        u4MaNameType - MA Name Type
 *                        u4MaServiceType - MA Service Type (LSP/PW)
 *
 *     OUTPUT           : CliHandle - Contains error messages
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/

INT4
EcfmCliCreateOamMAssociation (tCliHandle CliHandle, UINT1 *pu1MaName,
                              UINT4 u4PrimaryVlanId, INT4 i4MhfCriteria,
                              INT4 i4SenderIdPermission, UINT1 *pu1Icc,
                              UINT1 *pu1Umc, UINT4 u4ContextId,
                              UINT4 u4MaNameType, UINT4 u4MaServiceType)
{
    tSNMP_OCTET_STRING_TYPE MaName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE IccCode;
    tSNMP_OCTET_STRING_TYPE UmcCode;

    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaUnusedIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4RetStatus = CLI_SUCCESS;

    UNUSED_PARAM (u4PrimaryVlanId);
    UNUSED_PARAM (i4MhfCriteria);
    UNUSED_PARAM (i4SenderIdPermission);

    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "%% Unable to select the context\r\rn");
        return CLI_FAILURE;
    }

    /* Get this value from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    MEMSET (&MaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    MaName.pu1_OctetList = au1MaName;
    MEMSET (au1MaName, 0, ECFM_MA_NAME_ARRAY_SIZE);
    MaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

    /* Check for the existence of the already created Association */
    i4RetVal = nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex);
    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;

        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);

        if ((u4MdIndex == u4PromptMdIndex) && ((pu1MaName != NULL) &&
                                               (ECFM_STRCMP
                                                (MaName.pu1_OctetList,
                                                 pu1MaName) == 0)))
        {
            if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode,
                                                 u4ContextId,
                                                 u4PromptMdIndex,
                                                 u4MaIndex,
                                                 u4MaServiceType,
                                                 0,
                                                 ECFM_ROW_STATUS_NOT_IN_SERVICE)
                == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                              u4PromptMdIndex,
                                              u4MaIndex,
                                              u4MaServiceType,
                                              0,
                                              ECFM_ROW_STATUS_NOT_IN_SERVICE)
                == SNMP_FAILURE)
            {
                CliPrintf (CliHandle, "\r%% Unable to deactivate the Service "
                           "temporarily for re-configuration\r\n ");
                return CLI_FAILURE;
            }
            if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                return CLI_FAILURE;
            }
            u4SavedMaIndex = u4MaIndex;
            break;
        }
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    if (u4SavedMaIndex == 0)
    {

        /* Create MA */
        /* Get Unused index */
        if (nmhGetDot1agCfmMdMaNextIndex
            (u4PromptMdIndex, &u4MaUnusedIndex) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_OWERFLOW_ERR);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode,
                                             u4ContextId,
                                             u4PromptMdIndex,
                                             u4MaUnusedIndex,
                                             u4MaServiceType,
                                             0,
                                             ECFM_ROW_STATUS_CREATE_AND_WAIT) ==
            SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          u4MaServiceType,
                                          0,
                                          ECFM_ROW_STATUS_CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmExtMaFormat (&u4ErrCode,
                                          u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          u4MaServiceType,
                                          0, u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          u4MaServiceType,
                                          0, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaFormat (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       u4MaServiceType,
                                       0, u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          u4MaServiceType,
                                          0, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        ECFM_MEMSET (&MaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

        if (pu1MaName != NULL)
        {
            MaName.pu1_OctetList = pu1MaName;
            MaName.i4_Length = ECFM_STRLEN (pu1MaName);
            if (nmhTestv2FsMIEcfmExtMaName (&u4ErrCode, u4ContextId,
                                            u4PromptMdIndex,
                                            u4MaUnusedIndex,
                                            u4MaServiceType,
                                            0, &MaName) == SNMP_FAILURE)
            {
                nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                              u4PromptMdIndex,
                                              u4MaUnusedIndex,
                                              u4MaServiceType,
                                              0, ECFM_ROW_STATUS_DESTROY);
                return CLI_FAILURE;
            }

            if (nmhSetFsMIEcfmExtMaName (u4ContextId,
                                         u4PromptMdIndex,
                                         u4MaUnusedIndex,
                                         u4MaServiceType,
                                         0, &MaName) == SNMP_FAILURE)
            {
                nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                              u4PromptMdIndex,
                                              u4MaUnusedIndex,
                                              u4MaServiceType,
                                              0, ECFM_ROW_STATUS_DESTROY);
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
        u4SavedMaIndex = u4MaUnusedIndex;
    }

    /* Y.1731 : Setting ICC and UMC code */
    ECFM_MEMSET (&IccCode, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    IccCode.pu1_OctetList = pu1Icc;
    IccCode.i4_Length = ECFM_STRLEN (pu1Icc);
    if (nmhTestv2FsMIY1731MeMegIdIcc (&u4ErrCode, u4ContextId,
                                      u4PromptMdIndex,
                                      u4SavedMaIndex, &IccCode) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MA_ICC_CONF_ERR);
        return CLI_FAILURE;
    }
    ECFM_MEMSET (&UmcCode, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    UmcCode.pu1_OctetList = pu1Umc;
    UmcCode.i4_Length = ECFM_STRLEN (pu1Umc);
    if (nmhTestv2FsMIY1731MeMegIdUmc (&u4ErrCode, u4ContextId,
                                      u4PromptMdIndex,
                                      u4SavedMaIndex, &UmcCode) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MA_UMC_CONF_ERR);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeMegIdIcc
        (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         &IccCode) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeMegIdUmc
        (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         &UmcCode) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    /* Make the row status to Active */
    if (nmhTestv2FsMIY1731MeRowStatus
        (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeRowStatus
        (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliDeleteOamMAssociation
 *
 *     DESCRIPTION      : This function deletes existing MA  configuration
 *
 *     INPUT            : CliHandle - Contains error messages
 *                      : Pu1MaName - Pointer to MaName
 *                        u4ContextId  - Current Context Id
 *                      : u4MaNameFormat - MaName format.
 *                                                                          
 *     OUTPUT           : None.                                                  
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                         
 ******************************************************************************/
INT4
EcfmCliDeleteOamMAssociation (tCliHandle CliHandle, UINT1 *pu1MaName,
                              UINT4 u4ContextId, UINT4 u4MaNameFormat)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE InMaName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT1               au1InMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    INT4                i4SelectorType = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;

    u4CurrentContextId = u4ContextId;
    /*Get Md Index out of prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();
    u4MdIndex = u4PromptMdIndex;

    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "%% Unable to select the context\r\rn");
        return CLI_FAILURE;
    }

    i4RetVal = nmhGetNextIndexFsMIEcfmExtMaTable
        (u4CurrentContextId, &u4NextContextId, u4MdIndex,
         &u4NextMdIndex, u4MaIndex, &u4NextMaIndex,
         i4SelectorType, &i4NextSelectorType, 0, &u4NextSelectorOrNone);

    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1MaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&InMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));

        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

        InMaName.pu1_OctetList = au1InMaName;
        InMaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

        if (ECFM_CC_SELECT_CONTEXT (u4CurrentContextId) != ECFM_SUCCESS)
        {
            CliPrintf (CliHandle, "%% Unable to select the context for "
                       "MA to delete an entry from the table.\r\n");
            return CLI_FAILURE;
        }
        /* Get u4MaIndex's name */
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);

        if (i4RetMaFormat != (INT4) u4MaNameFormat)
        {
            i4RetVal = nmhGetNextIndexFsMIEcfmExtMaTable
                (u4CurrentContextId, &u4NextContextId,
                 u4MdIndex, &u4NextMdIndex, u4MaIndex,
                 &u4NextMaIndex, i4SelectorType,
                 &i4NextSelectorType, 0, &u4NextSelectorOrNone);
            if (i4RetVal == SNMP_SUCCESS)
            {
                if ((u4CurrentContextId != u4NextContextId) ||
                    (u4MdIndex != u4NextMdIndex))
                {
                    CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
                    return CLI_FAILURE;
                }

                u4MaIndex = u4NextMaIndex;
                i4SelectorType = i4NextSelectorType;
            }
            continue;
        }

        if (EcfmValidateMaNameStrFormat (pu1MaName, u4MaNameFormat)
            != ECFM_SUCCESS)
        {
            CliPrintf (CliHandle, "%% Invalid input for specified format "
                       "or Values are not with in the range\r\n");
            return CLI_FAILURE;
        }

        /* Currently it is assumed as Char String format */
        MEMCPY (au1MaName, RetMaName.pu1_OctetList, RetMaName.i4_Length);
        if (STRCMP (au1MaName, pu1MaName) == 0)
        {
            if ((i4SelectorType == ECFM_SERVICE_SELECTION_LSP) ||
                (i4SelectorType == ECFM_SERVICE_SELECTION_PW))
            {
                if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode,
                                                     u4CurrentContextId,
                                                     u4PromptMdIndex,
                                                     u4MaIndex, i4SelectorType,
                                                     0, ECFM_ROW_STATUS_DESTROY)
                    != SNMP_SUCCESS)
                {
                    CliPrintf (CliHandle, "%% Cannot delete the service "
                               "entry\r\n");
                    return CLI_FAILURE;
                }

                /* Delete Maintenance Association */
                if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId, u4PromptMdIndex,
                                                  u4MaIndex, i4SelectorType, 0,
                                                  ECFM_ROW_STATUS_DESTROY)
                    != SNMP_SUCCESS)
                {
                    CliPrintf (CliHandle, "%% Unable to set the rowstatus for "
                               "deleting an MA.\r\n");
                    ECFM_CC_RELEASE_CONTEXT ();
                    return CLI_FAILURE;
                }
                return CLI_SUCCESS;
            }
            CliPrintf (CliHandle, "%% Not a MPLS-TP Service\r\n");
            return CLI_FAILURE;
        }

        i4RetVal = nmhGetNextIndexFsMIEcfmExtMaTable
            (u4CurrentContextId, &u4NextContextId, u4MdIndex, &u4NextMdIndex,
             u4MaIndex, &u4NextMaIndex, i4SelectorType, &i4NextSelectorType,
             0, &u4NextSelectorOrNone);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if ((u4CurrentContextId != u4NextContextId) ||
                (u4MdIndex != u4NextMdIndex))
            {
                CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
                return CLI_FAILURE;
            }

            u4MaIndex = u4NextMaIndex;
            i4SelectorType = i4NextSelectorType;
        }
    }
    /* Return error if the MA is not configured already */
    CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
    CliPrintf (CliHandle, " ");
    return CLI_FAILURE;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliDeleteMAssociation
 *
 *     DESCRIPTION      : This function deletes existing MA  configuration
 *
 *     INPUT            : CliHandle - Contains error messages
 *                      : Pu1MaName - Pointer to MaName
 *                      : i4MaFormat - MaName format.
 *                                                                          
 *     OUTPUT           : None.                                                  
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                         
 ******************************************************************************/
INT4
EcfmCliDeleteMAssociation (tCliHandle CliHandle, UINT1 *pu1MaName,
                           INT4 i4MaFormat)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE InMaName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT4               u4RetVidIsid = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4VpnIndex = ECFM_INIT_VAL;
    UINT4               u4VpnOui = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    UINT2               u2MaVal = ECFM_INIT_VAL;
    UINT1               au1InMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];

    /*Get first index */
    i4RetVal = nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /*Get Md Index out of prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();
    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1MaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1InMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&InMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));

        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

        InMaName.pu1_OctetList = au1InMaName;
        InMaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

        /* Get u4MaIndex's name */
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetVidIsid);
        if (i4RetMaFormat != i4MaFormat)
        {
            i4RetVal = nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex,
                                                           &u4NextMdIndex,
                                                           u4MaIndex,
                                                           &u4NextMaIndex);
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            continue;
        }

        if ((i4RetMaFormat == ECFM_ASSOC_NAME_PRIMARY_VID) ||
            (i4RetMaFormat == ECFM_ASSOC_NAME_UNSIGNED_INT_16))
        {
            MEMCPY (&u2MaVal, RetMaName.pu1_OctetList, RetMaName.i4_Length);
            u2MaVal = ECFM_HTONS (u2MaVal);
            SPRINTF ((CHR1 *) au1MaName, "%d", u2MaVal);
        }
        else if (i4RetMaFormat == ECFM_ASSOC_NAME_RFC2865_VPN_ID)
        {
            u4VpnOui = 0;
            u4VpnIndex = 0;

            u4VpnOui = RetMaName.pu1_OctetList[2] | u4VpnOui;
            u4VpnOui = (RetMaName.pu1_OctetList[1] << 8) | u4VpnOui;
            u4VpnOui = (RetMaName.pu1_OctetList[0] << 16) | u4VpnOui;

            MEMCPY (&u4VpnIndex, (RetMaName.pu1_OctetList + ECFM_VAL_3),
                    ECFM_VAL_4);
            u4VpnIndex = ECFM_HTONL (u4VpnIndex);

            SPRINTF ((CHR1 *) au1MaName, "%06x:%08x", u4VpnOui, u4VpnIndex);
        }
        else if ((i4RetMaFormat == ECFM_ASSOC_NAME_CHAR_STRING) ||
                 (i4RetMaFormat == ECFM_ASSOC_NAME_ICC))
        {
            MEMCPY (au1MaName, RetMaName.pu1_OctetList, RetMaName.i4_Length);
        }

        if (EcfmValidateMaNameStrFormat (pu1MaName, i4MaFormat) != ECFM_FAILURE)
        {
            if ((i4MaFormat == ECFM_ASSOC_NAME_PRIMARY_VID) ||
                (i4MaFormat == ECFM_ASSOC_NAME_UNSIGNED_INT_16))
            {
                u2MaVal = ATOI (pu1MaName);
                u2MaVal = ECFM_HTONS (u2MaVal);
                InMaName.i4_Length = sizeof (u2MaVal);
                MEMCPY (InMaName.pu1_OctetList, &u2MaVal, InMaName.i4_Length);
            }
        }

        if ((u4MdIndex == u4PromptMdIndex) &&
            ((STRCMP (au1MaName, pu1MaName) == 0) ||
             ((InMaName.i4_Length == RetMaName.i4_Length) &&
              MEMCMP (InMaName.pu1_OctetList, RetMaName.pu1_OctetList,
                      RetMaName.i4_Length) == 0)))
        {

            if (!(ECFM_IS_MEP_ISID_AWARE (u4RetVidIsid)))
            {
                /*That particular entry found */
                /* Now make this row status to DESTROY */
                if (nmhTestv2Dot1agCfmMaNetRowStatus
                    (&u4ErrCode, u4MdIndex, u4MaIndex,
                     ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
                {
                    CliPrintf (CliHandle,
                               "\r%% MA cannot be deleted,when MIP/MEP/MAMEPlist exist in this MA\n");
                    return CLI_FAILURE;
                }
                /* MSR notification for service creation is handled in MaComp
                 * RowStatus Set functaion. But service deletion indication is 
                 * not handled properly ,when incremental save is enabled. So MaCompRowStatus
                 * Function is called to handle this issue*/

                u4CurrentContextId = ECFM_CC_CURR_CONTEXT_ID ();
                nmhSetIeee8021CfmMaCompRowStatus (u4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  ECFM_ROW_STATUS_DESTROY);
                nmhSetDot1agCfmMaNetRowStatus (u4MdIndex, u4MaIndex,
                                               ECFM_ROW_STATUS_DESTROY);

                /* Done successfully */
                return CLI_SUCCESS;
            }
            else
            {
                u4Isid = ECFM_ISID_INTERNAL_TO_ISID (u4RetVidIsid);
                u4CurrentContextId = ECFM_CC_CURR_CONTEXT_ID ();
                if (nmhTestv2FsMIEcfmExtMaRowStatus
                    (&u4ErrCode, u4CurrentContextId, u4MdIndex,
                     u4MaIndex, ECFM_SERVICE_SELECTION_ISID, u4Isid,
                     ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

                {
                    return CLI_FAILURE;
                }

                nmhSetFsMIEcfmExtMaRowStatus (u4CurrentContextId, u4MdIndex,
                                              u4MaIndex,
                                              ECFM_SERVICE_SELECTION_ISID,
                                              u4Isid, ECFM_ROW_STATUS_DESTROY);
                return CLI_SUCCESS;
            }
        }

        /* Get next index */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
    CliPrintf (CliHandle, " ");
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmSameMepExists                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database config 
 *                        mode checks whether MEP(not active)with same 
 *                        configuration exists .
 *                                                                           
 *     INPUT            : u4MdIndex       - Index of Domain in which MEP is
 *                                          configured
 *                        u4MaIndex       - Index of MA with which MEP is
 *                                          associated.                            
 *                        u4MepIdentifier - MEP Identifier                        
 *                        u4IfIndex       - Interface Index at which MEP is
 *                                          configured                          
 *                        u1MdLevel       - MdLevel at which MEP is configured
 *                        u4VlanId -        VlanId with which MEP is associated 
 *                        i1MepDirection - Direction of MEP
 *                        u4MaPrimaryVid - PrimaryVid of MA with which MEP is
 *                                         associated
 *     OUTPUT           : pi4RetMepStatus - Status of MEP                
 *                                                                           
 *     RETURNS          : ECFM_TRUE/ECFM_FALSE                            
 *                                                                           
 ******************************************************************************/
PRIVATE             BOOL1
EcfmSameMepExists (tCliHandle CliHandle, UINT4 u4MdIndex, UINT4 u4MaIndex,
                   UINT4 u4MepIdentifier, UINT4 u4IfIndex, UINT1 u1MdLevel,
                   UINT4 u4VlanId, INT1 i1MepDirection, UINT4 u4MaPrimaryVid,
                   INT4 *pi4RetMepStatus)
{
    INT4                i4RetRowStatus = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4RetDirection = ECFM_INIT_VAL;
    INT4                i4RetVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    if (nmhGetDot1agCfmMepRowStatus
        (u4MdIndex, u4MaIndex, u4MepIdentifier,
         &i4RetRowStatus) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    if (nmhGetDot1agCfmMepIfIndex
        (u4MdIndex, u4MaIndex, u4MepIdentifier, &i4RetIfIndex) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    if (nmhGetDot1agCfmMepDirection
        (u4MdIndex, u4MaIndex, u4MepIdentifier,
         &i4RetDirection) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    if (nmhGetDot1agCfmMepPrimaryVid (u4MdIndex, u4MaIndex, u4MepIdentifier,
                                      (UINT4 *) &i4RetVid) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    if (nmhGetDot1agCfmMepActive
        (u4MdIndex, u4MaIndex, u4MepIdentifier,
         pi4RetMepStatus) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    if (nmhGetDot1agCfmMdMdLevel (u4MdIndex, &i4RetMdLevel) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }

    /* Check if it is same MEP and it is not active */
    if ((i4RetRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
        ((UINT4) (i4RetIfIndex) == u4IfIndex) &&
        (u1MdLevel == (UINT1) i4RetMdLevel) &&
        (i4RetDirection == i1MepDirection) &&
        ((u4VlanId == (UINT4) (i4RetVid)) || (u4VlanId == u4MaPrimaryVid)))

    {
        return ECFM_TRUE;
    }
    CliPrintf (CliHandle, " \r\n");
    return ECFM_FALSE;
}

/*******************************************************************************
 *                                                                            
 *     FUNCTION NAME    : EcfmCompareVids                                   
 *                                                                              
 *     DESCRIPTION      : This function will check that Mep's Primary Vid 
 *                        is one of the VIDs assigned to its MA.
 *                                                                             
 *     INPUT            : u4MaPrimaryVid - Ma's PrimaryVid                     
 *                        u4MepVlanId - Vlan at which Mep is to be configured
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : ECFM_TRUE/ECFM_FALSE                            
 *                                                                           
 *****************************************************************************/
PRIVATE             BOOL1
EcfmCompareVids (tCliHandle CliHandle, UINT4 u4MaPrimaryVid, UINT4 u4MepVlanId)
{
    UINT4               u4VlanVid = ECFM_INIT_VAL;
    UINT4               u4NextVlanVid = ECFM_INIT_VAL;
    UINT4               u4VlanPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    if (nmhGetFirstIndexIeee8021CfmVlanTable (&u4ContextId,
                                              &u4VlanVid) == SNMP_FAILURE)

    {
        return ECFM_FALSE;
    }
    while (i4RetVal == SNMP_SUCCESS)

    {
        if (u4VlanVid == u4MepVlanId)

        {
            nmhGetIeee8021CfmVlanPrimarySelector (ECFM_CC_CURR_CONTEXT_ID (),
                                                  u4VlanVid, &u4VlanPrimaryVid);
            if (u4VlanPrimaryVid == u4MaPrimaryVid)

            {
                return ECFM_TRUE;
            }
        }
        i4RetVal =
            nmhGetNextIndexIeee8021CfmVlanTable (ECFM_CC_CURR_CONTEXT_ID (),
                                                 &u4ContextId, u4VlanVid,
                                                 &u4NextVlanVid);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4VlanVid = u4NextVlanVid;
        }
    }
    CliPrintf (CliHandle, " \r\n");
    return ECFM_FALSE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database config 
 *                        mode. New Mep will be created when that mep is not 
 *                        present at that level and vlan in the database 
 *                                                                           
 *     INPUT            : u1MdLevel   - level at which it needs to be created
 *                        Direction   - up/down                              
 *                        u4MepId     - MepIdentifier                        
 *                        u4VlanId      - PrimaryVid                           
 *                        i1MepActiveStatus - its active status after        
 *                        creation
 *                        u4PortNum - Port Number
 *                        pu1MdName - MdName 
 *
 *     OUTPUT           : None                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigMep (tCliHandle CliHandle, UINT1 u1MdLevel, INT1 i1MepDirection,
                  UINT4 u4VlanId, UINT4 u4MepIdentifier,
                  INT1 i1MepActiveStatus, UINT4 u4PortNum, UINT1 *pu1MaName,
                  UINT1 *pu1MdName)
{
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4RetNoOfVids = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVlanId = ECFM_INIT_VAL;
    UINT4               u4OrigVlanId = u4VlanId;
    INT4                i4CmpRetVal = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepStatus = ECFM_SNMP_FALSE;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    BOOL1               b1UnAwareMep = ECFM_FALSE;
    BOOL1               b1OrigUnAwareMep = ECFM_FALSE;
    BOOL1               b1EntryFound = ECFM_TRUE;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4OffLoadStatus = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);

    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    if (nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex) ==
        SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ERR);
        return CLI_FAILURE;
    }

    /* Checking if its Vlan-Unaware MEP or not */
    if (u4VlanId == ECFM_INIT_VAL)

    {
        b1UnAwareMep = ECFM_TRUE;
        b1OrigUnAwareMep = ECFM_TRUE;
    }

    /* Scan Ma table for this Md level */
    while (i4RetVal == SNMP_SUCCESS)
    {
        u4RetMdLevel = ECFM_INIT_VAL;
        u4RetPrimaryVlanId = ECFM_INIT_VAL;
        u4RetNoOfVids = ECFM_INIT_VAL;
        ECFM_MEMSET (gaEcfmMepPromptInfo, ECFM_INIT_VAL, sizeof
                     (tEcfmMepPromptInfo));
        ECFM_MEMSET (au1Cmd, ECFM_INIT_VAL, MAX_PROMPT_LEN);
        /* Reset the MA name */
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        if ((pu1MdName == NULL) || (STRCMP (au1StrMdName, pu1MdName) == 0))
        {
            nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            /* Check if this entry is having this Md Level */
            if ((UINT1) u4RetMdLevel == u1MdLevel)

            {
                nmhGetIeee8021CfmMaCompPrimarySelectorOrNone
                    (ECFM_CC_CURR_CONTEXT_ID (), u4MdIndex, u4MaIndex,
                     &u4RetPrimaryVlanId);
                nmhGetIeee8021CfmMaCompNumberOfVids (ECFM_CC_CURR_CONTEXT_ID (),
                                                     u4MdIndex, u4MaIndex,
                                                     &u4RetNoOfVids);
                if ((u4RetPrimaryVlanId != 0) && (u4RetNoOfVids > 1))
                {
                    if (u4VlanId != u4RetPrimaryVlanId)
                    {
                        i4CmpRetVal =
                            EcfmCompareVids (CliHandle, u4RetPrimaryVlanId,
                                             u4VlanId);
                    }
                    else
                    {
                        i4CmpRetVal = ECFM_TRUE;
                    }
                }

                if ((pu1MaName != NULL) && (u4RetPrimaryVlanId != 0))
                {
                    b1UnAwareMep = ECFM_FALSE;
                    u4VlanId = u4RetPrimaryVlanId;
                }

                /* Check if this is the required Ma entry */
                if ((((!b1UnAwareMep) && (u4RetPrimaryVlanId == u4VlanId) &&
                      (pu1MaName == NULL ||
                       ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))) ||
                    (((b1UnAwareMep) && (u4RetPrimaryVlanId == 0)) &&
                     ((pu1MaName == NULL) ||
                      (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))) ||
                    (((!b1UnAwareMep) && (i4CmpRetVal)) &&
                     (pu1MaName == NULL ||
                      ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)) ||
                    ((pu1MaName != NULL) &&
                     ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1EntryFound =
                        EcfmSearchMepIdInMA (u4MdIndex, u4MaIndex,
                                             u4MepIdentifier);

                    if (b1EntryFound != ECFM_TRUE)
                    {
                        /* No required MEPID found, search in other MA */
                        i4RetVal =
                            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex,
                                                                &u4NextMdIndex,
                                                                u4MaIndex,
                                                                &u4NextMaIndex);
                        if (i4RetVal == SNMP_SUCCESS)
                        {
                            u4MdIndex = u4NextMdIndex;
                            u4MaIndex = u4NextMaIndex;
                            continue;
                        }
                    }
                    /* Create row by checking its row status */
                    if (nmhTestv2Dot1agCfmMepRowStatus
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)

                    {
                        if (u4ErrorCode == SNMP_ERR_GEN_ERR)
                        {
                            return CLI_FAILURE;
                        }
                        /* Check if MEP is already configured and user wants to change
                         * its status */
                        if (EcfmSameMepExists
                            (CliHandle, u4MdIndex, u4MaIndex, u4MepIdentifier,
                             u4PortNum, u1MdLevel, u4VlanId, i1MepDirection,
                             u4RetPrimaryVlanId, &i4RetMepStatus) == ECFM_TRUE)

                        {
                            if ((i1MepActiveStatus == ECFM_SNMP_TRUE) &&
                                (i1MepActiveStatus != i4RetMepStatus))

                            {
                                nmhSetDot1agCfmMepRowStatus (u4MdIndex,
                                                             u4MaIndex,
                                                             u4MepIdentifier,
                                                             ECFM_ROW_STATUS_NOT_IN_SERVICE);
                                nmhSetDot1agCfmMepActive (u4MdIndex, u4MaIndex,
                                                          u4MepIdentifier,
                                                          i1MepActiveStatus);
                                if (nmhTestv2Dot1agCfmMepRowStatus
                                    (&u4ErrorCode, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier,
                                     ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
                                {

                                    nmhSetDot1agCfmMepActive (u4MdIndex,
                                                              u4MaIndex,
                                                              u4MepIdentifier,
                                                              i4RetMepStatus);
                                    nmhSetDot1agCfmMepRowStatus (u4MdIndex,
                                                                 u4MaIndex,
                                                                 u4MepIdentifier,
                                                                 ECFM_ROW_STATUS_ACTIVE);
                                    return CLI_FAILURE;
                                }
                                nmhSetDot1agCfmMepRowStatus (u4MdIndex,
                                                             u4MaIndex,
                                                             u4MepIdentifier,
                                                             ECFM_ROW_STATUS_ACTIVE);
                            }

                            /* MEP already exists and user does not want to change its
                             * status */
                            /* Y.1731 : ENTER MEP Config Mode */
                            SPRINTF ((CHR1 *) au1Cmd, "%s", CLI_MEP_MODE);
                            if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)

                            {
                                CLI_SET_ERR (CLI_ECFM_MEP_CHMOD_ERR);
                                return CLI_FAILURE;
                            }
                            gaEcfmMepPromptInfo[CliHandle].u4MdIndex =
                                u4MdIndex;
                            gaEcfmMepPromptInfo[CliHandle].u4MaIndex =
                                u4MaIndex;
                            gaEcfmMepPromptInfo[CliHandle].u4MepIndex =
                                u4MepIdentifier;
                            return CLI_SUCCESS;
                        }

                        else

                        {
                            /* move to next Ma */
                            i4RetVal =
                                nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex,
                                                                    &u4NextMdIndex,
                                                                    u4MaIndex,
                                                                    &u4NextMaIndex);
                            if (i4RetVal == SNMP_SUCCESS)

                            {
                                u4MdIndex = u4NextMdIndex;
                                u4MaIndex = u4NextMaIndex;
                            }
                            b1EntryFound = ECFM_FALSE;
                            continue;
                        }
                    }

                    /* MEP can be created with this MA */
                    if (nmhSetDot1agCfmMepRowStatus
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)

                    {
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }

                    /* Set MEPs other values */
                    if (nmhTestv2Dot1agCfmMepIfIndex
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         u4PortNum) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }
                    if (nmhSetDot1agCfmMepIfIndex
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         u4PortNum) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }
                    if (nmhTestv2Dot1agCfmMepDirection
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         i1MepDirection) == SNMP_FAILURE)

                    {
                        nmhGetFsEcfmMepCcmOffload (u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   &i4OffLoadStatus);
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        if ((i4OffLoadStatus == ECFM_TRUE)
                            && (i1MepDirection == ECFM_MP_DIR_UP))
                        {
                            printf("EcfmCliConfigMep : %d",__LINE__);
                            CliPrintf (CliHandle,
                                       "\r%%Offload should be disabled for Up Mep\r\n ");
                            return CLI_FAILURE;
                        }
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }
                    if (nmhSetDot1agCfmMepDirection
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         i1MepDirection) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }

                    /* Test only if it is vlan aware mep to be configured */
                    if (b1UnAwareMep != ECFM_TRUE)

                    {
                        if (nmhTestv2Dot1agCfmMepPrimaryVid
                            (&u4ErrorCode, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, u4VlanId) == SNMP_FAILURE)

                        {
                            nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                         u4MepIdentifier,
                                                         ECFM_ROW_STATUS_DESTROY);
                            CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                            return CLI_FAILURE;
                        }
                        if (nmhSetDot1agCfmMepPrimaryVid
                            (u4MdIndex, u4MaIndex, u4MepIdentifier,
                             u4VlanId) == SNMP_FAILURE)

                        {
                            nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                         u4MepIdentifier,
                                                         ECFM_ROW_STATUS_DESTROY);
                            CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                            return CLI_FAILURE;
                        }
                    }
                    if (nmhTestv2Dot1agCfmMepActive
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         i1MepActiveStatus) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }
                    if (nmhSetDot1agCfmMepActive
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         i1MepActiveStatus) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }

                    /* Change its row status to Active */
                    if (nmhTestv2Dot1agCfmMepRowStatus
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }
                    if (nmhSetDot1agCfmMepRowStatus
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_FAILED);
                        return CLI_FAILURE;
                    }

                    /* Y.1731 : ENTER MEP Config Mode */
                    SPRINTF ((CHR1 *) au1Cmd, "%s", CLI_MEP_MODE);
                    if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)

                    {
                        CLI_SET_ERR (CLI_ECFM_MEP_CHMOD_ERR);
                        return CLI_FAILURE;
                    }
                    gaEcfmMepPromptInfo[CliHandle].u4MdIndex = u4MdIndex;
                    gaEcfmMepPromptInfo[CliHandle].u4MaIndex = u4MaIndex;
                    gaEcfmMepPromptInfo[CliHandle].u4MepIndex = u4MepIdentifier;
                    return CLI_SUCCESS;
                }
            }
        }

        /* move to next Ma */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4VlanId = u4OrigVlanId;
            b1UnAwareMep = b1OrigUnAwareMep;
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    if (b1EntryFound != ECFM_TRUE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MEP_LIST_ERR);
    }
    else
    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ERR);
    }
    return CLI_FAILURE;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliConfigOamMep
 *
 *     DESCRIPTION      : This function will configure a MEP for MPLSTPOAM
 *                        The New Mep is added into to the MPLS_MEP_TABLE
 *
 *
 *     INPUT            : u4MepIdentifier - MepIdentifier
 *                        u4ServiceType   - Service Type
 *                        u4PathInfo1     - TunnelId/VcId
 *                        u4PathInfo2     - TunnelInstance
 *                        u4PathInfo3     - IngressLSR ID
 *                        u4PathInfo4     - EgressLSR ID
 *                        pu1MaName       - MaName
 *                        u4MepActiveStatus - MEP Status
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/

INT4
EcfmCliConfigOamMep (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4MepIdentifier, UINT4 u4ServiceType,
                     UINT4 u4PathInfo1, UINT4 u4PathInfo2, UINT4 u4PathInfo3,
                     UINT4 u4PathInfo4, UINT1 *pu1MaName,
                     UINT4 u4MepActiveStatus, UINT4 *pu4RMepId)
{
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    INT4                i4RetMepActiveStatus = ECFM_INIT_VAL;
    INT4                i4RetRowStatus = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    BOOL1               b1EntryFound = ECFM_TRUE;
    BOOL1               b1RMepConf = ECFM_FALSE;
    BOOL1               b1RMepServiceConf = ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tEcfmMplsParams    *pMplsPathId = NULL;
    tServicePtr        *pServicePtr = NULL;
    tSNMP_OID_TYPE      ServiceRowPtr;
    tSNMP_OID_TYPE      RetServiceRowPtr;
    tEcfmCcMaInfo      *pMeNode = NULL;

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    u4PromptMdIndex = CLI_GET_MDINDEX ();

    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return CLI_FAILURE;
    }

    if (nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex) ==
        SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ERR);
        return CLI_FAILURE;
    }

    /* Scan Ma table for this Md level */
    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (gaEcfmMepPromptInfo, ECFM_INIT_VAL, sizeof
                     (tEcfmMepPromptInfo));
        ECFM_MEMSET (au1Cmd, ECFM_INIT_VAL, MAX_PROMPT_LEN);
        /* Reset the MA name */
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);

        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
        nmhGetDot1agCfmMaNetRowStatus (u4MdIndex, u4MaIndex, &i4RetRowStatus);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';

        /* Check if this is the required Ma entry */
        if ((u4PromptMdIndex == u4MdIndex) &&
            (i4RetRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
            (ECFM_STRCMP (RetMaName.pu1_OctetList, pu1MaName) == 0))
        {
            b1EntryFound =
                EcfmSearchMepIdInMA (u4MdIndex, u4MaIndex, u4MepIdentifier);
            if (b1EntryFound != ECFM_TRUE)
            {
                /* No required MEPID found, search in other MA */
                i4RetVal =
                    nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex,
                                                        &u4NextMdIndex,
                                                        u4MaIndex,
                                                        &u4NextMaIndex);
                if (i4RetVal == SNMP_SUCCESS)
                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    continue;
                }
            }
            /* Search for the presence of Remote Mep Id in the
             * MA, if not present then return failure.
             */
            if (pu4RMepId != NULL)
            {
                b1EntryFound =
                    EcfmSearchMepIdInMA (u4MdIndex, u4MaIndex, *pu4RMepId);
                if (b1EntryFound != ECFM_TRUE)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Remote MEP \r\n");
                    return CLI_FAILURE;
                }

                if (nmhGetDot1agCfmMepRowStatus
                    (u4MdIndex, u4MaIndex, *pu4RMepId,
                     &i4RetRowStatus) == SNMP_SUCCESS)
                {
                    CliPrintf (CliHandle,
                               "\r%% : Already a local MEP is configured with "
                               "the given RMep Id\r\n");
                    return CLI_FAILURE;
                }
            }

            if (nmhGetDot1agCfmMepRowStatus
                (u4MdIndex, u4MaIndex, u4MepIdentifier,
                 &i4RetRowStatus) != SNMP_SUCCESS)
            {
                /* Create row by checking its row status */
                if (nmhTestv2Dot1agCfmMepRowStatus
                    (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                {
                    CliPrintf (CliHandle,
                               "\r%% : Cannot create Local MEP entry\r\n");
                    return CLI_FAILURE;
                }

                /* MEP can be created with this MA */
                if (nmhSetDot1agCfmMepRowStatus
                    (u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)

                {
                    CliPrintf (CliHandle,
                               "\r%% : Unable to create Local MEP entry\r\n");
                    return CLI_FAILURE;
                }
            }

            if (u4MepActiveStatus != 0)
            {
                if (nmhGetDot1agCfmMepActive (u4MdIndex, u4MaIndex,
                                              u4MepIdentifier,
                                              &i4RetMepActiveStatus) !=
                    SNMP_SUCCESS)
                {
                    CliPrintf (CliHandle, "\r%% : Unable to retrieve "
                               "the current Mep Active Status\r\n");
                    return CLI_FAILURE;
                }

                if ((INT4) u4MepActiveStatus != i4RetMepActiveStatus)
                {
                    if (nmhSetDot1agCfmMepRowStatus
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_NOT_IN_SERVICE) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% : Unable to de-activate the Local MEP "
                                   "RowStatus\r\n");
                        return CLI_FAILURE;
                    }
                    if (nmhTestv2Dot1agCfmMepActive
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         (INT4) u4MepActiveStatus) == SNMP_FAILURE)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% : Cannot activate Local MEP entry\r\n");

                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        return CLI_FAILURE;
                    }

                    if (nmhSetDot1agCfmMepActive
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         (INT4) u4MepActiveStatus) == SNMP_FAILURE)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% : Unable to activate Local MEP entry\r\n");
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        return CLI_FAILURE;
                    }

                    if (nmhTestv2Dot1agCfmMepRowStatus
                        (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_ACTIVE) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% : Cannot activate the Local MEP entry\r\n");
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        return CLI_FAILURE;
                    }

                    if (nmhSetDot1agCfmMepRowStatus
                        (u4MdIndex, u4MaIndex, u4MepIdentifier,
                         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

                    {
                        nmhSetDot1agCfmMepRowStatus (u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_ROW_STATUS_DESTROY);
                        CLI_FATAL_ERROR (CliHandle);
                        return CLI_FAILURE;
                    }
                }
            }

            if (pu4RMepId != NULL)
            {
                pMeNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
                if (pMeNode == NULL)
                {
                    CliPrintf (CliHandle,
                               "\r%% No Maintaince Association for "
                               "given Indices\n");
                    return CLI_FAILURE;
                }
                if (pMeNode->u1SelectorType != u4ServiceType)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Service Type" "\n");
                    return CLI_FAILURE;
                }

                pMplsPathId = (tEcfmMplsParams *) MemAllocMemBlk
                    (ECFM_MPLSTP_INPARAMS_POOLID);

                if (pMplsPathId == NULL)
                {
                    CliPrintf (CliHandle,
                               "\r%% EcfmCliConfigOamMep: "
                               "Mempool allocation failed\r\n");
                    return CLI_FAILURE;
                }

                MEMSET (pMplsPathId, 0, sizeof (tEcfmMplsParams));

                if (u4ServiceType == ECFM_SERVICE_SELECTION_LSP)
                {
                    pMplsPathId->MplsPathParams.MplsLspParams.u4TunnelId =
                        u4PathInfo1;
                    pMplsPathId->MplsPathParams.MplsLspParams.u4TunnelInst =
                        u4PathInfo2;
                    pMplsPathId->MplsPathParams.MplsLspParams.u4SrcLer =
                        u4PathInfo3;
                    pMplsPathId->MplsPathParams.MplsLspParams.u4DstLer =
                        u4PathInfo4;
                    pMplsPathId->u1MplsPathType = MPLS_PATH_TYPE_TUNNEL;
                }
                else if (u4ServiceType == ECFM_SERVICE_SELECTION_PW)
                {
                    pMplsPathId->MplsPathParams.u4PswId = u4PathInfo1;
                    pMplsPathId->u1MplsPathType = MPLS_PATH_TYPE_PW;
                }

                pServicePtr = (tServicePtr *) MemAllocMemBlk
                    (ECFM_MPLSTP_SERVICE_PTR_POOLID);

                if (pServicePtr == NULL)
                {
                    CliPrintf (CliHandle,
                               "\r%% EcfmCliConfigOamMep: "
                               "Mempool allocation failed\r\n");
                    MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                        (UINT1 *) pMplsPathId);
                    return CLI_FAILURE;
                }
                MEMSET (pServicePtr, 0, sizeof (tServicePtr));

                /* Assigning contextId as Zero because the MPLS supports only
                 * default context ID which is Zero.
                 */
                if (EcfmMplsGetOidFromPathId (0, pMplsPathId, pServicePtr)
                    != ECFM_SUCCESS)
                {
                    MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                        (UINT1 *) pMplsPathId);
                    MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                        (UINT1 *) pServicePtr);
                    CliPrintf (CliHandle,
                               "\r%% EcfmCliConfigOamMep: "
                               "Unable to get the OID from the Path ID\r\n");
                    return CLI_FAILURE;
                }

                ServiceRowPtr.pu4_OidList = pServicePtr->au4ServicePtr;

                ServiceRowPtr.u4_Length = (pServicePtr->u4OidLength *
                                           sizeof (UINT4));

                if (nmhGetFsMIY1731MplstpExtRMepRowStatus
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     *pu4RMepId, &i4RetRowStatus) != SNMP_SUCCESS)
                {
                    b1RMepConf = ECFM_TRUE;
                    if (nmhTestv2FsMIY1731MplstpExtRMepRowStatus
                        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, *pu4RMepId,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Invalid RMep Parameters\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }

                    if (nmhSetFsMIY1731MplstpExtRMepRowStatus
                        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         *pu4RMepId,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Unable to create RMep entry\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }
                }

                if (b1RMepConf == ECFM_FALSE)
                {
                    ECFM_MEMSET (&RetServiceRowPtr, ECFM_INIT_VAL,
                                 sizeof (tSNMP_OID_TYPE));
                    RetServiceRowPtr.pu4_OidList = pServicePtr->au4ServicePtr;
                    RetServiceRowPtr.u4_Length = (pServicePtr->u4OidLength *
                                                  sizeof (UINT4));

                    if (nmhGetFsMIY1731MplstpExtRMepServicePointer
                        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         *pu4RMepId, &RetServiceRowPtr) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Unable to retrieve MPLS Path Params\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }

                    if ((RetServiceRowPtr.u4_Length !=
                         ServiceRowPtr.u4_Length) ||
                        (MEMCMP (ServiceRowPtr.pu4_OidList,
                                 RetServiceRowPtr.pu4_OidList,
                                 RetServiceRowPtr.u4_Length) != 0))
                    {
                        b1RMepServiceConf = ECFM_TRUE;
                    }
                }

                if (b1RMepServiceConf == ECFM_TRUE)
                {
                    if (nmhSetFsMIY1731MplstpExtRMepRowStatus
                        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         *pu4RMepId, ECFM_ROW_STATUS_NOT_IN_SERVICE)
                        != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Unable to temporarily deactivate the "
                                   "RMep entry status\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }
                }

                if ((b1RMepConf == ECFM_TRUE) ||
                    (b1RMepServiceConf == ECFM_TRUE))
                {
                    if (nmhTestv2FsMIY1731MplstpExtRMepServicePointer
                        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, *pu4RMepId,
                         &ServiceRowPtr) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r%%: Invalid MPLS Path "
                                   "Params\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }

                    if (nmhSetFsMIY1731MplstpExtRMepServicePointer
                        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         *pu4RMepId, &ServiceRowPtr) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Unable to configure MPLS Path Params\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }

                    if (nmhTestv2FsMIY1731MplstpExtRMepRowStatus
                        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, *pu4RMepId,
                         ECFM_ROW_STATUS_ACTIVE) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r%%: Cannot active RMep "
                                   "Entry\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }

                    if (nmhSetFsMIY1731MplstpExtRMepRowStatus
                        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         *pu4RMepId, ECFM_ROW_STATUS_ACTIVE) != SNMP_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%: Unable to Active RMep Entry\n");
                        MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                            (UINT1 *) pMplsPathId);
                        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                            (UINT1 *) pServicePtr);
                        return CLI_FAILURE;
                    }
                }

                MemReleaseMemBlock (ECFM_MPLSTP_INPARAMS_POOLID,
                                    (UINT1 *) pMplsPathId);
                MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                    (UINT1 *) pServicePtr);
            }

            /* Y.1731 : ENTER MEP Config Mode */
            SPRINTF ((CHR1 *) au1Cmd, "%s", CLI_MEP_MPLS_MODE);
            if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_CHMOD_ERR);
                return CLI_FAILURE;
            }
            gaEcfmMepPromptInfo[CliHandle].u4MdIndex = u4MdIndex;
            gaEcfmMepPromptInfo[CliHandle].u4MaIndex = u4MaIndex;
            gaEcfmMepPromptInfo[CliHandle].u4MepIndex = u4MepIdentifier;
            return CLI_SUCCESS;
        }
        /* move to next Ma */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    if (b1EntryFound != ECFM_TRUE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MEP_LIST_ERR);
    }
    else
    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ERR);
    }
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteOrDisableMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database         
 *                        Delete or disable the configured Mep, if present.             
 *                                                                           
 *     INPUT            : u1MdLevel  -  MdLevel 
 *                        u4Type     -   Type of the command(Disable or delete)
 *                        *pu4VlanId -   pointer to VlanId
 *                        u4VlanId    -  PrimaryVid                           
 *                        u4MepIdentifier  - MepIdentifier                       
 *                        u4PortNum - Port Number
 *                        pu1MdName - MdName 
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliDeleteOrDisableMep (tCliHandle CliHandle, UINT4 u4Type, UINT4 u4MdLevel,
                           UINT4 *pu4VlanId, UINT4 u4MepIdentifier,
                           UINT4 u4PortNum, UINT1 *pu1MdName)
{
    INT4                i4IfIndex = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4Level = ECFM_INIT_VAL;
    INT4                i4ServiceSelectType = ECFM_INIT_VAL;
    UINT4               u4VlanId = ECFM_INIT_VAL;
    INT4                i4Dir = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4LocalPortNum = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMepIndex = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    BOOL1               b1Delete = ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    /* Check if there is any MEP */
    if (nmhGetFirstIndexIeee8021CfmStackTable
        (&i4IfIndex, &i4ServiceSelectType, &u4VlanId, &i4Level,
         &i4Dir) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    switch (u4Type)

    {
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_UP_LEV_VSI_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_VSI_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_UP_LEV_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_SER_MEP_CTRL_NOCONF:
            u4VlanId = *pu4VlanId;
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_TRUE;
            break;
        case CLI_ECFM_UP_LEV_UNAWARE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_UNAWARE_MEP_CTRL_NOCONF:
            u4VlanId = 0;
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_TRUE;
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_LEV_VSI_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_VSI_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_DOWN_LEV_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_VLAN_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_SER_MEP_CTRL_NOCONF:
            u4VlanId = *pu4VlanId;
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_TRUE;
            break;
        case CLI_ECFM_DOWN_LEV_UNAWARE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_UNAWARE_MEP_CTRL_NOCONF:
            u4VlanId = 0;
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_TRUE;
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_UP_LEV_VSI_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_VSI_ACTIVE_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_UP_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_SER_ACTIVE_MEP_CTRL_NOCONF:
            u4VlanId = *pu4VlanId;
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_FALSE;
            break;
        case CLI_ECFM_UP_LEV_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
            u4VlanId = 0;
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_FALSE;
            break;
#ifdef DCSG_EXT_WANTED
        case CLI_ECFM_DOWN_LEV_VSI_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_VSI_ACTIVE_MEP_CTRL_NOCONF:
#endif
        case CLI_ECFM_DOWN_LEV_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_VLAN_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_SER_ACTIVE_MEP_CTRL_NOCONF:
            u4VlanId = *pu4VlanId;
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_FALSE;
            break;
        case CLI_ECFM_DOWN_LEV_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_UNAWARE_ACTIVE_MEP_CTRL_NOCONF:
            u4VlanId = 0;
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_FALSE;
            break;
        default:
            break;
    }

    /* Ieee802.1ag Standard MIB has SelectorType and SelectorValue 
     * as Seperate Indices. So Internal Vlan Id is converted to 
     * ServiceSelectoType and ServiceSelectorValue
     */
    if (u4VlanId > ECFM_INTERNAL_ISID_MIN)
    {
        u4VlanId = ECFM_ISID_INTERNAL_TO_ISID (u4VlanId);
        i4ServiceSelectType = ECFM_SERVICE_SELECTION_ISID;

    }
    else
    {
        i4ServiceSelectType = ECFM_SERVICE_SELECTION_VLAN;
    }

    if (nmhValidateIndexInstanceIeee8021CfmStackTable
        (u4PortNum, i4ServiceSelectType, u4VlanId, u4MdLevel,
         i4Dir) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    i4RetVal = nmhGetFirstIndexDot1agCfmMdTable (&u4MdIndex);
    while ((i4RetVal == SNMP_SUCCESS) && (pu1MdName != NULL))

    {
        MEMSET (au1RetMdName, 0, ECFM_MD_NAME_ARRAY_SIZE);
        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        if ((pu1MdName == NULL) || (STRCMP (au1StrMdName, pu1MdName) == 0))
        {
            nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
            if (u4RetMdLevel == u4MdLevel)

            {
                u4RetMdIndex = u4MdIndex;
                break;
            }
            else
            {
                CLI_SET_ERR (CLI_ECFM_DOM_LEVEL_CONF_ERR);
                return CLI_FAILURE;
            }
        }
        i4RetVal = nmhGetNextIndexDot1agCfmMdTable (u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
        }
    }

    if (pu1MdName == NULL)
    {
        nmhGetIeee8021CfmStackMdIndex (u4PortNum, i4ServiceSelectType, u4VlanId,
                                       u4MdLevel, i4Dir, &u4RetMdIndex);
    }

    nmhGetIeee8021CfmStackMaIndex (u4PortNum, i4ServiceSelectType, u4VlanId,
                                   u4MdLevel, i4Dir, &u4RetMaIndex);
    nmhGetIeee8021CfmStackMepId (u4PortNum, i4ServiceSelectType, u4VlanId,
                                 u4MdLevel, i4Dir, &u4RetMepIndex);

    /* Check if it MEP */
    if ((u4RetMdIndex == 0) || (u4RetMaIndex == 0) || (u4RetMepIndex == 0))

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Required MEP */
    if (u4RetMepIndex != u4MepIdentifier)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Disable or Delete MEP */
    if (b1Delete != ECFM_TRUE)

    {

        /* Deactivate MEP by setting MEP's row status to
         * not_in_service */
        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Test whether MEP can be de-activated */
        if (nmhTestv2Dot1agCfmMepActive
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepActive
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set MEP's row status to active */
        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        return CLI_SUCCESS;
    }

    nmhGetDot1agCfmMepIfIndex (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
                               &i4LocalPortNum);
    if ((INT4) u4PortNum != i4LocalPortNum)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    /*Delete row by checking its row status */
    if (nmhTestv2Dot1agCfmMepRowStatus
        (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
         ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    nmhSetDot1agCfmMepRowStatus (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
                                 ECFM_ROW_STATUS_DESTROY);
    return CLI_SUCCESS;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliDeleteOrDisableOamMep
 *
 *     DESCRIPTION      : This function will enter into Mep database
 *                        Delete or disable the configured MPLS Mep, if present.
 *
 *     INPUT            : u1MdLevel  -  MdLevel
 *                        u4Type     -   Type of the command(Disable or delete)
 *                        *pu4VlanId -   pointer to VlanId
 *                        u4VlanId    -  PrimaryVid
 *                        u4MepIdentifier  - MepIdentifier
 *                        u4PortNum - Port Number
 *
 *     OUTPUT           : CliHandle - Contains error messages
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
EcfmCliDeleteOrDisableOamMep (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4MepIdentifier, UINT4 u4ServiceType,
                              UINT4 u4PathInfo1, UINT4 u4PathInfo2,
                              UINT4 u4PathInfo3, UINT4 u4PathInfo4,
                              UINT1 *pu1MaName, UINT4 u4MepActiveStatus,
                              UINT4 *pu4RMepId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMepIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetVal = SNMP_SUCCESS;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE MaName;
    tSNMP_OCTET_STRING_TYPE RetMaName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (&MaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    MaName.pu1_OctetList = au1MaName;
    MEMSET (au1MaName, 0, ECFM_MA_NAME_ARRAY_SIZE);
    MaName.i4_Length = ECFM_MA_NAME_ARRAY_SIZE;

    u4PromptMdIndex = CLI_GET_MDINDEX ();
    /* Using the Ma Name and Md Name get the Ma index */
    /* Check for the existence of the already created Association */
    i4RetVal =
        nmhGetNextIndexDot1agCfmMaNetTable (u4PromptMdIndex, &u4NextMdIndex,
                                            0, &u4NextMaIndex);
    if (i4RetVal != SNMP_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% No Service entry exists\n");
        return CLI_FAILURE;
    }

    if (u4NextMdIndex != u4PromptMdIndex)
    {
        CliPrintf (CliHandle, "\r%% No matching domain present\n");
        return CLI_FAILURE;
    }

    u4SavedMdIndex = u4NextMdIndex;
    u4MaIndex = u4NextMaIndex;

    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;
        nmhGetDot1agCfmMaNetFormat (u4SavedMdIndex, u4MaIndex, &i4RetMaFormat);
        nmhGetDot1agCfmMaNetName (u4SavedMdIndex, u4MaIndex, &RetMaName);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (STRCMP (au1StrMaName, pu1MaName) == 0)
        {
            u4SavedMaIndex = u4MaIndex;
            break;
        }
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4SavedMdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (u4NextMdIndex != u4PromptMdIndex)
            {
                CliPrintf (CliHandle, "\r%% No matching domain present\n");
                return CLI_FAILURE;
            }
            u4SavedMdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    if (nmhValidateIndexInstanceDot1agCfmMepTable (u4SavedMdIndex,
                                                   u4SavedMaIndex,
                                                   u4MepIdentifier) !=
        SNMP_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% No MEP exists for the indices\n");
        return CLI_FAILURE;
    }

    u4RetMdIndex = u4SavedMdIndex;
    u4RetMaIndex = u4SavedMaIndex;
    u4RetMepIndex = u4MepIdentifier;

    if (pu4RMepId != NULL)
    {
        if (nmhTestv2FsMIY1731MplstpExtRMepRowStatus
            (&u4ErrorCode, u4ContextId, u4RetMdIndex, u4RetMaIndex,
             u4RetMepIndex, *pu4RMepId, ECFM_ROW_STATUS_DESTROY)
            != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, "\r%%: Cannot delete RMep Entry\n");
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MplstpExtRMepRowStatus
            (u4ContextId, u4RetMdIndex, u4RetMaIndex,
             u4RetMepIndex, *pu4RMepId, ECFM_ROW_STATUS_DESTROY)
            != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, "\r%%: Unable to delete RMep Entry\n");
            return CLI_FAILURE;
        }
    }
    /* Disable or Delete MEP */
    if (u4MepActiveStatus == ECFM_TRUE)
    {
        /* Deactivate MEP by setting MEP's row status to
         * not_in_service */
        if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
        {
            return CLI_FAILURE;
        }
        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CliPrintf (CliHandle, "\r%% Cannot De-Activate Local "
                       "Mep row status.\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CliPrintf (CliHandle, "\r%% Unable to De-Activate Local "
                       "Mep row status.\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }

        /* Test whether MEP can be de-activated */
        if (nmhTestv2Dot1agCfmMepActive
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            CliPrintf (CliHandle, "\r%% Cannot De-Activate the Local " "Mep\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepActive
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Unable to De-Activate the Local "
                       "Mep\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }

        /* Set MEP's row status to active */
        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Cannot Activate Local "
                       "Mep row status.\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }
        if (nmhSetDot1agCfmMepRowStatus
            (u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Unable to Activate Local "
                       "Mep row status.\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }
        ECFM_CC_RELEASE_CONTEXT ();
        return CLI_SUCCESS;
    }
    else
    {
        if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
        {
            return CLI_FAILURE;
        }
        /* Delete row by checking its row status */
        if (nmhTestv2Dot1agCfmMepRowStatus
            (&u4ErrorCode, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
        {
            CliPrintf (CliHandle, "\r%% Cannot delete Local Mep entry\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }

        if (nmhSetDot1agCfmMepRowStatus (u4RetMdIndex, u4RetMaIndex,
                                         u4RetMepIndex,
                                         ECFM_ROW_STATUS_DESTROY) !=
            SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, "\r%% Unable to delete Local Mep entry\n");
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_FAILURE;
        }
    }

    UNUSED_PARAM (u4ContextId);
    UNUSED_PARAM (u4ServiceType);
    UNUSED_PARAM (u4PathInfo1);
    UNUSED_PARAM (u4PathInfo2);
    UNUSED_PARAM (u4PathInfo3);
    UNUSED_PARAM (u4PathInfo4);

    ECFM_CC_RELEASE_CONTEXT ();
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetPortModuleStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable ECFM module, for
 *                        all Meps on a Port     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Command - Type of the command
 *                        u4PortNum - Port Number 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetPortModuleStatus (tCliHandle CliHandle, UINT4 u4Command,
                            UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Status = ECFM_INIT_VAL;
    if (u4Command == CLI_ECFM_ENABLE_CFM_ON_INTF)

    {
        i4Status = ECFM_ENABLE;
    }

    else

    {
        i4Status = ECFM_DISABLE;
    }
    if (nmhTestv2FsMIEcfmPortModuleStatus (&u4ErrorCode, u4PortNum, i4Status) ==
        SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmPortModuleStatus (u4PortNum, i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetPortY1731OperStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable Y.1731 module, for
 *                        all Meps on a Port     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Command - Type of the command
 *                        u4ContextId - Context Id
 *                        u4IfIndex - Interface Index
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetPortY1731OperStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4Command, UINT4 u4IfIndex)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Status = ECFM_INIT_VAL;

    if (u4Command == CLI_ECFM_ENABLE_Y1731_ON_INTF)
    {
        i4Status = ECFM_ENABLE;
    }
    else
    {
        i4Status = ECFM_DISABLE;
    }
    if (nmhTestv2FsMIY1731PortOperStatus
        (&u4ErrorCode, u4IfIndex, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731PortOperStatus (u4IfIndex, i4Status) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    UNUSED_PARAM (u4ContextId);
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetEthbnTrStatus
 *
 *     DESCRIPTION      : This function will enable/disable trap for ethbn
 *
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4EthBnSt - EthBn status
 *                        u4EthBnTrapSt - Interface Index
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *****************************************************************************/
INT4
EcfmCliSetEthbnTrStatus (tCliHandle CliHandle, UINT4 u4IfIndex, UINT4 u4EthBnSt, UINT4 u4EthBnTrapSt)
{
   UINT4               u4ErrorCode = 0;

   if ((INT4) u4EthBnSt != ECFM_ETHBN_INVALID_STATUS)
   {
       if (nmhTestv2FsMIY1731EthBnPortStatus (&u4ErrorCode, u4IfIndex, u4EthBnSt) == SNMP_FAILURE)
       {
           return CLI_FAILURE;
       }

       if (nmhSetFsMIY1731EthBnPortStatus (u4IfIndex, u4EthBnSt) == SNMP_FAILURE)
       {
           CLI_FATAL_ERROR (CliHandle);
           return CLI_FAILURE;
       }
   }
   if ((INT4) u4EthBnTrapSt != ECFM_ETHBN_INVALID_STATUS)
   {
       if (nmhTestv2FsMIY1731EthBnTrapStatus (&u4ErrorCode, u4IfIndex, u4EthBnTrapSt) == SNMP_FAILURE)
       {
           return CLI_FAILURE;
       }
       if (nmhSetFsMIY1731EthBnTrapStatus (u4IfIndex, u4EthBnTrapSt) == SNMP_FAILURE)
       {
           CLI_FATAL_ERROR (CliHandle);
           return CLI_FAILURE;
       }
   }       
   UNUSED_PARAM (CliHandle);
   return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetPortLLCEncapStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable LLC encapsulation
 *                        status on a Port     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Command type
 *                        u4PortNum -  Port Number
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetPortLLCEncapStatus (tCliHandle CliHandle, UINT4 u4Type,
                              UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Status = ECFM_INIT_VAL;
    i4Status = (u4Type == CLI_ECFM_LLC_ADD) ? ECFM_SNMP_TRUE : ECFM_SNMP_FALSE;
    if (nmhTestv2FsEcfmPortLLCEncapStatus (&u4ErrorCode, u4PortNum, i4Status)
        == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsEcfmPortLLCEncapStatus (u4PortNum, i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmSetCcInterval                               
 *                                                                          
 *     DESCRIPTION      : This function will set cc interval value for a 
 *                        particular Ma
 *                                                                          
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        i4CcInterval - Cc Interval                                                 
 *                        b1EntryFound - VLAN/ISID
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
PRIVATE INT4
EcfmSetCcInterval (tCliHandle CliHandle, UINT4 u4MdIndex, UINT4 u4MaIndex,
                   INT4 i4CcInterval, BOOL1 b1EntryFound)
{

    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4CurrCcInterval = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    u4CurrentContextId = ECFM_CC_CURR_CONTEXT_ID ();
    nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (u4CurrentContextId, u4MdIndex,
                                                  u4MaIndex, &u4RetPrimaryVid);
    if (b1EntryFound == ECFM_TRUE)
    {
        u4Isid = ECFM_ISID_INTERNAL_TO_ISID (u4RetPrimaryVid);
        nmhGetFsMIEcfmExtMaCcmInterval (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, ECFM_SERVICE_SELECTION_ISID,
                                        u4Isid, &i4CurrCcInterval);
        if (i4CurrCcInterval == i4CcInterval)
        {
            return CLI_SUCCESS;
        }
        if (nmhTestv2FsMIEcfmExtMaRowStatus
            (&u4ErrorCode, u4CurrentContextId, u4MdIndex,
             u4MaIndex, ECFM_SERVICE_SELECTION_ISID, u4Isid,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaRowStatus
            (u4CurrentContextId, u4MdIndex, u4MaIndex,
             ECFM_SERVICE_SELECTION_ISID, u4Isid,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set the CC Interval */
        do

        {
            if (nmhTestv2FsMIEcfmExtMaCcmInterval
                (&u4ErrorCode, u4CurrentContextId, u4MdIndex,
                 u4MaIndex, ECFM_SERVICE_SELECTION_ISID, u4Isid,
                 i4CcInterval) == SNMP_FAILURE)

            {
                CliPrintf (CliHandle,
                           "\r%% Timer Resolution Not Supported\r\n");
                break;
            }
            if (nmhSetFsMIEcfmExtMaCcmInterval (u4CurrentContextId, u4MdIndex,
                                                u4MaIndex,
                                                ECFM_SERVICE_SELECTION_ISID,
                                                u4Isid,
                                                i4CcInterval) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        while (0);

        /* After setting CC Interval, change RowStatus to Active */
        if (nmhTestv2FsMIEcfmExtMaRowStatus
            (&u4ErrorCode, u4CurrentContextId, u4MdIndex,
             u4MaIndex, ECFM_SERVICE_SELECTION_ISID, u4Isid,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaRowStatus
            (u4CurrentContextId, u4MdIndex,
             u4MaIndex, ECFM_SERVICE_SELECTION_ISID, u4Isid,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

    }
    else
    {
        nmhGetDot1agCfmMaNetCcmInterval (u4MdIndex,
                                         u4MaIndex, &i4CurrCcInterval);
        if (i4CurrCcInterval == i4CcInterval)
        {
            return CLI_SUCCESS;
        }

        /* Check if it can be set */
        if (nmhTestv2Dot1agCfmMaNetRowStatus
            (&u4ErrorCode, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmMaRowStatus
            (u4CurrentContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Set the CC Interval */
        do
        {
            if (nmhTestv2Dot1agCfmMaNetCcmInterval
                (&u4ErrorCode, u4MdIndex, u4MaIndex,
                 i4CcInterval) == SNMP_FAILURE)
            {
                nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex,
                                      &RetMdName);
                RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
                nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex,
                                        &i4RetMdFormat);
                MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
                EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                             au1StrMdName);
                CliPrintf (CliHandle,
                           "\r%% CC Interval not supported as offload is "
                           "disabled for domain %s \r\n", au1StrMdName);
                if (ECFM_CC_SELECT_CONTEXT (u4CurrentContextId) != ECFM_SUCCESS)
                {
                    return SNMP_FAILURE;
                }
                break;
            }

            if (nmhSetDot1agCfmMaNetCcmInterval
                (u4MdIndex, u4MaIndex, i4CcInterval) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        while (0);

        /* After setting CC Interval, change RowStatus to Active */
        if (nmhTestv2Dot1agCfmMaNetRowStatus
            (&u4ErrorCode, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmMaRowStatus
            (u4CurrentContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmSetY1731CcEnableStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable CCM transmission in
 *                        a MA.                         
 *                                                                          
 *     INPUT            : CliHandle       - CliContext ID
 *                        u4ContextId     - ContextId
 *                        u4MdIndex       - MdIndex                     
 *                        u4MaIndex       - MaIndex
 *                        i4CcStatus      - Cc status  
 *                        b1EntryFound    - VLAN/ISID                    
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 *****************************************************************************/
PRIVATE INT4
EcfmSetY1731CcEnableStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4MdIndex, UINT4 u4MaIndex, INT4
                            i4CcStatus, BOOL1 b1EntryFound)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RowStatus = ECFM_INIT_VAL;
    INT4                i4CciEnabled = ECFM_INIT_VAL;
    UNUSED_PARAM (CliHandle);

    if (b1EntryFound == ECFM_TRUE)
    {

        if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)

        {
            return SNMP_FAILURE;
        }
        nmhGetFsMIY1731MeRowStatus (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RowStatus);
        nmhGetFsMIY1731MeCciEnabled (u4ContextId, u4MdIndex, u4MaIndex,
                                     &i4CciEnabled);
        if ((i4RowStatus == ECFM_ROW_STATUS_ACTIVE)
            && (i4CciEnabled == ECFM_TRUE) && (i4CcStatus == ECFM_TRUE))
        {
            return CLI_SUCCESS;
        }
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        do
        {
            if (nmhTestv2FsMIY1731MeCciEnabled
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 i4CcStatus) == SNMP_FAILURE)

            {
                break;
            }

            if (nmhSetFsMIY1731MeCciEnabled
                (u4ContextId, u4MdIndex, u4MaIndex, i4CcStatus) == SNMP_FAILURE)

            {
                break;
            }
        }
        while (0);
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

    }
    else
    {
        if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
        {
            return SNMP_FAILURE;
        }
        nmhGetFsMIY1731MeRowStatus (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RowStatus);
        nmhGetFsMIY1731MeCciEnabled (u4ContextId, u4MdIndex, u4MaIndex,
                                     &i4CciEnabled);
        if ((i4RowStatus == ECFM_ROW_STATUS_ACTIVE)
            && (i4CciEnabled == ECFM_TRUE) && (i4CcStatus == ECFM_TRUE))
        {
            return CLI_SUCCESS;
        }
        /* First set RowStatus to NOT_IN_SERVICE */
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Set the CCI Enable */
        do

        {
            if (nmhTestv2FsMIY1731MeCciEnabled
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 i4CcStatus) == SNMP_FAILURE)

            {
                break;
            }
            if (nmhSetFsMIY1731MeCciEnabled
                (u4ContextId, u4MdIndex, u4MaIndex, i4CcStatus) == SNMP_FAILURE)

            {
                break;
            }
        }
        while (0);

        /* Change RowStatus to Active */
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetCcInterval                               
 *                                                                          
 *     DESCRIPTION      : This function will set CC interval for all MAs on a 
 *                        particular Mdlevel.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4Type        - Type of command  
 *                        au1MdLevel    - array of Levels  
 *                        u2NoOfMdLevels- No of levels in au1MdLevel              
 *                        au1VlanId     - array of VlanIds
 *                        i4CcInterval  - CC Interval
 *                        b1SetCc       - True indicates to set interval 
 *                        pu1MaName     - MA name
 *                        pu1MdName     - MD name
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetCcInterval (tCliHandle CliHandle, UINT4 u4Type, UINT1 au1MdLevel[],
                      UINT2 u2NoOfMdLevels, UINT1 au1VlanId[],
                      UINT1 *pu1ArgIsid, INT4 i4CcInterval, BOOL1 b1SetCc,
                      UINT1 *pu1MaName, UINT1 *pu1MdName)
{
    tVlanId             VlanId;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    BOOL1               ab1LevelSerEntry[ECFM_MD_LEVEL_MAX + 1] =
        { ECFM_FALSE };
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    /* The following block of code will be called in PBB Architecture */
    if (pu1ArgIsid != NULL)
    {
        /* Scan MA table for this MD level */
        while (i4RetVal == SNMP_SUCCESS)
        {
            /* Check if this entry is having this Md Level */
            nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
            nmhGetIeee8021CfmMaCompPrimarySelectorOrNone
                (ECFM_CC_CURR_CONTEXT_ID (), u4MdIndex, u4MaIndex,
                 &u4RetPrimaryVid);
            nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
            RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
            nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);
            nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
            RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
            nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);

            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                    ((pu1MdName == NULL) ||
                     (STRCMP (au1StrMdName, pu1MdName) == 0)))
                {
                    if ((u4Type == CLI_ECFM_LEV_ISID_SET_CC_INT) ||
                        (u4Type == CLI_ECFM_LEV_ISID_SET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_LEV_ISID_RESET_CC_INT) ||
                        (u4Type == CLI_ECFM_LEV_ISID_RESET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_SET_CC_INT) ||
                        (u4Type == CLI_ECFM_DOM_ISID_SET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_RESET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_RESET_CC_INT))
                    {
                        u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;

                        if ((u4RetPrimaryVid ==
                             ECFM_ISID_TO_ISID_INTERNAL (u4Isid))
                            && (pu1MaName == NULL
                                || ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                        {
                            b1EntryFound = ECFM_TRUE;

                            /* Setting CC Interval */
                            EcfmSetCcInterval (CliHandle,
                                               u4MdIndex, u4MaIndex,
                                               i4CcInterval, b1EntryFound);
                            if ((pu1MaName != NULL) &&
                                (u2NoOfMdLevels == ECFM_VAL_1))
                            {
                                return CLI_SUCCESS;
                            }
                        }
                    }
                }
            }
            /* Move to next MA */
            i4RetVal =
                nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                    u4MaIndex, &u4NextMaIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
            }
        }
        if (b1EntryFound != ECFM_TRUE)
        {
            u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                CliPrintf (CliHandle,
                           "\r%% CC Interval cannot be configured at level %d,"
                           " or domain %s for isid %u\r\n",
                           au1MdLevel[u1LevelCounter], pu1MdName, u4Isid);

            }
        }
        return CLI_SUCCESS;
    }

    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
#ifdef VSI_WANTED
        apu1LevelVlanList[u1LevelCounter] = UtilVsiAllocVsiListSize
            (sizeof (tVlanListExt));
#else
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
#endif
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
#ifdef VSI_WANTED
                UtilVsiReleaseVsiListSize (apu1LevelVlanList[u1LevelList]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
#endif
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
        ab1LevelSerEntry[u1LevelCounter] = ECFM_FALSE;
    }

    if (nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex)
        == SNMP_FAILURE)

    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
#ifdef VSI_WANTED
            UtilVsiReleaseVsiListSize (apu1LevelVlanList[u1LevelCounter]);
#else
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
        }
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* If CC Interval is to Reset */
    if (b1SetCc == ECFM_FALSE)

    {

        /* Set it to Default value  */
        i4CcInterval = ECFM_CCM_INTERVAL_1_S;
    }
    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        /* Copying the vlan list into 2-D array at the specified index (i.e.
         * level), this will be further used to display the level and vlan 
         * for which cc status is not set */
        ECFM_MEMCPY (apu1LevelVlanList[au1MdLevel[u1LevelCounter]],
                     au1VlanId, sizeof (tVlanListExt));
        /* Copying the level list into a variable at the specified index (i.e.
         * level), this will be further used to display the level for unware
         * vlan entries */
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }

    /* Scan MA table for this MD level */
    while (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if this entry is having this Md Level */
        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetPrimaryVid);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetDot1agCfmMdName (u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetDot1agCfmMdFormat (u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {

            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                b1EntryFound = ECFM_FALSE;
                if (((u4Type == CLI_ECFM_LEV_SER_SET_CC_INT) ||
                     (u4Type == CLI_ECFM_LEV_SER_SET_CC_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_SET_CC_INT_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT) ||
                     (u4Type == CLI_ECFM_LEV_SER_RESET_CC_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT_ROLE)) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))

                {
                    b1EntryFound = ECFM_TRUE;
                    ab1LevelSerEntry[u4RetMdLevel] = ECFM_TRUE;

                    /* Setting CC Interval */
                    EcfmSetCcInterval (CliHandle,
                                       u4MdIndex,
                                       u4MaIndex, i4CcInterval, ECFM_FALSE);
                }
                else if ((u4Type != CLI_ECFM_LEV_UNAWARE_SET_CC_INT) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_RESET_CC_INT) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_SET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_RESET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_SET_CC_INT_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_RESET_CC_INT_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_SET_CC_INT) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_RESET_CC_INT) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_RESET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE))
                {

                    /* Entry found with this Mdlevel */
                    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                         u4ByteIndex++)

                    {
                        if (au1VlanId[u4ByteIndex] == 0)

                        {
                            continue;
                        }
                        u2VlanFlag = au1VlanId[u4ByteIndex];
                        for (u4BitIndex = 0;
                             ((u4BitIndex < BITS_PER_BYTE)
                              &&
                              (EcfmUtilQueryBitListTable
                               (u2VlanFlag, u4BitIndex) != 0)); u4BitIndex++)
                        {
                            VlanId =
                                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                         EcfmUtilQueryBitListTable (u2VlanFlag,
                                                                    u4BitIndex));

                            if ((u4RetPrimaryVid == VlanId)
                                && (pu1MaName == NULL ||
                                    ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                            {
                                b1EntryFound = ECFM_FALSE;

                                /* Reset the entry for which MA entry is
                                 * found */
                                ECFM_RESET_LIST_MEMBER
                                    (apu1LevelVlanList
                                     [au1MdLevel[u1LevelCounter]],
                                     u4RetPrimaryVid);

                                /* Setting CC Interval */
                                EcfmSetCcInterval (CliHandle,
                                                   u4MdIndex,
                                                   u4MaIndex,
                                                   i4CcInterval, b1EntryFound);
                                if ((pu1MaName != NULL) &&
                                    (u2NoOfMdLevels == ECFM_VAL_1))
                                {
                                    for (u1LevelCounter = 0; u1LevelCounter
                                         < ECFM_MD_LEVEL_MAX + 1;
                                         u1LevelCounter++)
                                    {
                                        /* Releasing memory for Vlan 
                                         * List Size 
                                         */
#ifdef VSI_WANTED
                                        UtilVsiReleaseVsiListSize
                                            (apu1LevelVlanList[u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                                    }
                                    return CLI_SUCCESS;
                                }
                                break;
                            }
                        }

                        if (b1EntryFound)
                        {
                            break;
                        }
                    }
                    break;
                }
                else if ((u4RetPrimaryVid == 0) &&
                         ((pu1MaName == NULL) ||
                          (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)))
                {
                    /* VLAN Unaware, Compare MaName */
                    b1EntryFound = ECFM_FALSE;

                    /* Reset the entry for which MA entry is
                     * found */
                    ECFM_CLEAR_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);

                    /* Setting CC Interval */
                    EcfmSetCcInterval (CliHandle, u4MdIndex, u4MaIndex,
                                       i4CcInterval, b1EntryFound);

                    if ((pu1MaName != NULL) && (u2NoOfMdLevels == ECFM_VAL_1))
                    {
                        /* Releasing memory for Vlan List Size */
                        for (u1LevelCounter = 0; u1LevelCounter <
                             ECFM_MD_LEVEL_MAX + 1; u1LevelCounter++)
                        {
#ifdef VSI_WANTED
                            UtilVsiReleaseVsiListSize (apu1LevelVlanList
                                                         [u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                        }
                        return CLI_SUCCESS;
                    }
                    break;
                }
            }
        }

        /* Move to next MA */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    /* Loop that will display the level and vlan for which cc interval is not set */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)

    {
        if ((u4Type == CLI_ECFM_LEV_UNAWARE_SET_CC_INT) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_SET_CC_ROLE) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_SET_CC_INT_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_SET_CC_INT) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE))

        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% No unaware MEP found at level %d"
                           " or domain %s\r\n", u1Level, pu1MdName);
            }
            else
            {
                break;
            }
        }
        else if ((u4Type == CLI_ECFM_LEV_SER_SET_CC_INT) ||
                 (u4Type == CLI_ECFM_LEV_SER_SET_CC_ROLE) ||
                 (u4Type == CLI_ECFM_LEV_SER_SET_CC_INT_ROLE) ||
                 (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT) ||
                 (u4Type == CLI_ECFM_LEV_SER_RESET_CC_ROLE) ||
                 (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT_ROLE))
        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                if (ab1LevelSerEntry[u1Level] == ECFM_FALSE)
                {
                    CliPrintf (CliHandle,
                               "\r%% No MEP found with service name %s at level %d\r\n",
                               pu1MaName, u1Level);
                }
            }
            else
            {
                break;
            }
        }
        else

        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)

            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] == 0)

                {
                    continue;
                }
                u2VlanFlag = apu1LevelVlanList[u1LevelCounter][u4ByteIndex];

                if ((u4BitIndex < BITS_PER_BYTE)
                    && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) !=
                        0))
                {
                    VlanId =
                        (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                 EcfmUtilQueryBitListTable (u2VlanFlag,
                                                            u4BitIndex));
                    if (u4RetPrimaryVid == VlanId)
                    {
                    CliPrintf (CliHandle,
                               "\r%% No MEP found at level %d, vlan %d\r\n",
                               u1LevelCounter, VlanId);
                }
            }
        }
    }
    }

    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
#ifdef VSI_WANTED
        UtilVsiReleaseVsiListSize (apu1LevelVlanList[u1LevelCounter]);
#else
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetEnableY1731CcStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable CCM transmission in
 *                        a MA.                         
 *                                                                          
 *     INPUT            : CliHandle      - CliContext ID
 *                        u4Type         - Type of command  
 *                        au1Mdlevel     - array of levels  
 *                        u2NoOfMdLevels - No. of Md levels
 *                        au1VlanId      - array of vlanIds
 *                        i4CcStatus     - Cc status          
 *                        u4ConId        - Context Id
 *                        pu1MaName     - MA name
 *                        pu1MdName     - MD name
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetEnableY1731CcStatus (tCliHandle CliHandle, UINT4 u4Type,
                               UINT1 au1MdLevel[], UINT2 u2NoOfMdLevels,
                               UINT1 au1VlanId[], INT4 *pi4ArgIsid,
                               INT4 i4CcStatus, UINT4 u4ConId, UINT1 *pu1MaName,
                               UINT1 *pu1MdName)
{
    tVlanId             VlanId;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMeRowStatus = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;
    u4ContextId = u4ConId;

    /* Check if MA Table is empty */
    i4RetVal =
        nmhGetNextIndexFsMIY1731MeTable (u4ContextId, &u4NextContextId, 0,
                                         &u4MdIndex, 0, &u4MaIndex);
    if (i4RetVal == SNMP_SUCCESS)
    {
        if (u4ContextId != u4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }
    else
    {
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* The following block of code will be called in PBB Architecture */
    if (pi4ArgIsid != NULL)
    {
        /* Scan MA table for this MD level */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
        {
            /* Get its Md Level, primaryVid, CciEnabled */
            nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                           (INT4 *) &u4RetMaPrimaryVid);
            nmhGetFsMIY1731MeRowStatus (u4ContextId, u4MdIndex, u4MaIndex,
                                        &i4RetMeRowStatus);
            nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);
            nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
            RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
            nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);
            /* Checking ME's table RowStatus */
            if (i4RetMeRowStatus != ECFM_ROW_STATUS_ACTIVE)
            {
                if (nmhGetNextIndexFsMIY1731MeTable
                    (u4ContextId, &u4NextContextId, u4MdIndex, &u4NextMdIndex,
                     u4MaIndex, &u4NextMaIndex) == SNMP_SUCCESS)
                {
                    i4RetVal = SNMP_SUCCESS;
                    if (u4NextContextId != u4ContextId)
                    {
                        return CLI_SUCCESS;
                    }
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    continue;
                }
                break;
            }
            /* Check for Mdlevels for which CC is to be enabled */
            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                    ((pu1MdName == NULL) ||
                     (STRCMP (au1StrMdName, pu1MdName) == 0)))
                {
                    if ((u4Type == CLI_ECFM_LEV_ISID_CC_CONF_ENABLE_PARAM) ||
                        (u4Type == CLI_ECFM_LEV_ISID_CC_CONF_DISABLE_PARAM) ||
                        (u4Type == CLI_ECFM_DOM_ISID_CC_CONF_ENABLE_PARAM) ||
                        (u4Type == CLI_ECFM_DOM_ISID_CC_CONF_DISABLE_PARAM))
                    {
                        u4Isid = *pi4ArgIsid;
                        if ((u4RetMaPrimaryVid ==
                             ECFM_ISID_TO_ISID_INTERNAL (u4Isid)) &&
                            (pu1MaName == NULL ||
                             ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                        {
                            b1EntryFound = ECFM_TRUE;
                            EcfmSetY1731CcEnableStatus (CliHandle,
                                                        u4ContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        i4CcStatus,
                                                        b1EntryFound);
                            if ((pu1MaName != NULL) &&
                                (u2NoOfMdLevels == ECFM_VAL_1))
                            {
                                return CLI_SUCCESS;
                            }
                        }
                    }
                    /* The entry's MD Level matched with current User-Input MD,
                     * Hence skip comparison with remaining Input MD Levels.
                     */
                    break;
                }
            }
            /* Move to next ME */
            i4RetVal =
                nmhGetNextIndexFsMIY1731MeTable (u4ContextId, &u4NextContextId,
                                                 u4MdIndex, &u4NextMdIndex,
                                                 u4MaIndex, &u4NextMaIndex);
            if (i4RetVal == SNMP_SUCCESS)
            {
                if (u4ContextId != u4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
            }
        }
        if (b1EntryFound != ECFM_TRUE)
        {
            u4Isid = *pi4ArgIsid;
            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                CliPrintf (CliHandle,
                           "\r%% CC transmission status cannot be configured at level %d, isid %u\r\n",
                           au1MdLevel[u1LevelCounter], u4Isid);

            }
        }
        return CLI_SUCCESS;
    }
    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
#ifdef VSI_WANTED
        apu1LevelVlanList[u1LevelCounter] = UtilVsiAllocVsiListSize
            (sizeof (tVlanListExt));
#else
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
#endif
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
#ifdef VSI_WANTED
                UtilVsiReleaseVsiListSize (apu1LevelVlanList[u1LevelList]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
#endif
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
    }

    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        /* Copying the vlan list into 2-D array at the specified index (i.e.
         * level), this will be further used to display the level and vlan 
         * for which cc status is not set */
        ECFM_MEMCPY (apu1LevelVlanList[au1MdLevel[u1LevelCounter]],
                     au1VlanId, sizeof (tVlanListExt));
        /* Copying the level list into a variable at the specified index (i.e.
         * level), this will be further used to display the level for unware
         * vlan entries */
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }

    /* Scan Mep Table for this Md level and VlanId */
    while (i4RetVal == SNMP_SUCCESS)

    {

        /* Get its Md Level, primaryVid, CciEnabled */
        nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                       (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIY1731MeRowStatus (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMeRowStatus);
        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Checking ME's table RowStatus */
        if (i4RetMeRowStatus != ECFM_ROW_STATUS_ACTIVE)
        {
            if (nmhGetNextIndexFsMIY1731MeTable
                (u4ContextId, &u4NextContextId, u4MdIndex, &u4NextMdIndex,
                 u4MaIndex, &u4NextMaIndex) == SNMP_SUCCESS)
            {
                i4RetVal = SNMP_SUCCESS;
                if (u4NextContextId != u4ContextId)
                {
                    /* Releasing memory for Vlan List Size */
                    for (u1LevelCounter = 0; u1LevelCounter <
                         ECFM_MD_LEVEL_MAX + 1; u1LevelCounter++)
                    {
#ifdef VSI_WANTED
                        UtilVsiReleaseVsiListSize
                            (apu1LevelVlanList[u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                    }
                    return CLI_SUCCESS;
                }
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                continue;
            }
            break;
        }
        /* Check for Mdlevels for which CC is to be enabled */
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {

            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                if ((u4Type != CLI_ECFM_LEV_UNAWARE_CC_CONF_ENABLE_PARAM) &&
                    (u4Type != CLI_ECFM_LEV_UNAWARE_CC_CONF_DISABLE_PARAM) &&
                    (u4Type != CLI_ECFM_DOM_UNAWARE_CC_CONF_ENABLE_PARAM) &&
                    (u4Type != CLI_ECFM_DOM_UNAWARE_CC_CONF_DISABLE_PARAM))
                {
                    b1EntryFound = ECFM_FALSE;
                    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                         u4ByteIndex++)

                    {
                        if (au1VlanId[u4ByteIndex] == 0)

                        {
                            continue;
                        }
                        u2VlanFlag = au1VlanId[u4ByteIndex];
                        for (u4BitIndex = 0;
                             ((u4BitIndex < BITS_PER_BYTE)
                              &&
                              (EcfmUtilQueryBitListTable
                               (u2VlanFlag, u4BitIndex) != 0)); u4BitIndex++)
                        {
                            VlanId =
                                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                         EcfmUtilQueryBitListTable (u2VlanFlag,
                                                                    u4BitIndex));

                            /* Check if this entry is having this Md Level and 
                             * primaryVid */
                            if ((u4RetMaPrimaryVid == VlanId) &&
                                (pu1MaName == NULL ||
                                 ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                            {
                                b1EntryFound = ECFM_TRUE;

                                /* Reset the entry for which MA entry is
                                 * found */
                                ECFM_RESET_LIST_MEMBER
                                    (apu1LevelVlanList
                                     [au1MdLevel[u1LevelCounter]],
                                     u4RetMaPrimaryVid);

                                /* Set CC Enable status */
                                EcfmSetY1731CcEnableStatus
                                    (CliHandle, u4ContextId,
                                     u4MdIndex, u4MaIndex,
                                     i4CcStatus, b1EntryFound);

                                if ((pu1MaName != NULL) &&
                                    (u2NoOfMdLevels == ECFM_VAL_1))
                                {
                                    /* Releasing memory for Vlan List Size */
                                    for (u1LevelCounter = 0; u1LevelCounter
                                         < ECFM_MD_LEVEL_MAX + 1;
                                         u1LevelCounter++)
                                    {
#ifdef VSI_WANTED
                                        UtilVsiReleaseVsiListSize
                                            (apu1LevelVlanList[u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                                    }
                                    return CLI_SUCCESS;
                                }
                                break;
                            }
                        }
                        if (b1EntryFound == ECFM_TRUE)

                        {
                            break;
                        }
                    }
                    break;
                }

                else if ((u4RetMaPrimaryVid == 0) &&
                         ((pu1MaName == NULL) ||
                          (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)))
                {
                    b1EntryFound = ECFM_TRUE;

                    /* Reset the entry for which MA entry is
                     * found */
                    ECFM_CLEAR_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);

                    /* Set CC Enable status */
                    EcfmSetY1731CcEnableStatus (CliHandle, u4ContextId,
                                                u4MdIndex, u4MaIndex,
                                                i4CcStatus, b1EntryFound);

                    if ((pu1MaName != NULL) && (u2NoOfMdLevels == ECFM_VAL_1))
                    {
                        /* Releasing memory for Vlan List Size */
                        for (u1LevelCounter = 0; u1LevelCounter
                             < ECFM_MD_LEVEL_MAX + 1; u1LevelCounter++)
                        {
#ifdef VSI_WANTED
                            UtilVsiReleaseVsiListSize (apu1LevelVlanList
                                                         [u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                        }
                        return CLI_SUCCESS;
                    }
                    break;
                }
            }
        }

        /* Move to next ME */
        i4RetVal =
            nmhGetNextIndexFsMIY1731MeTable (u4ContextId, &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
                /* Releasing memory for Vlan List Size */
                for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
                     u1LevelCounter++)
                {
#ifdef VSI_WANTED
                    UtilVsiReleaseVsiListSize (apu1LevelVlanList
                                                 [u1LevelCounter]);
#else
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
                }
                return CLI_SUCCESS;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    /* Loop that will display the level and vlan for which cc is not set */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)

    {
        if ((u4Type == CLI_ECFM_LEV_UNAWARE_CC_CONF_ENABLE_PARAM) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_CC_CONF_DISABLE_PARAM) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_CC_CONF_ENABLE_PARAM) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_CC_CONF_DISABLE_PARAM))

        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% CC status cannot be configured at level %d\r\n",
                           u1Level);
            }
            else
            {
                break;
            }
        }

        else

        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)

            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] == 0)
                {
                    continue;
                }
                u2VlanFlag = apu1LevelVlanList[u1LevelCounter][u4ByteIndex];

                if ((u4BitIndex < BITS_PER_BYTE)
                    && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) !=
                        0))
                {
                    VlanId =
                        (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                 EcfmUtilQueryBitListTable (u2VlanFlag,
                                                            u4BitIndex));
                    if (u4RetMaPrimaryVid == VlanId)
                    {
                    CliPrintf (CliHandle,
                               "\r%% CC status cannot be configured at level %d, vlan %d\r\n",
                               u1LevelCounter, VlanId);
                }
            }
        }
    }
    }
    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
#ifdef VSI_WANTED
        UtilVsiReleaseVsiListSize (apu1LevelVlanList[u1LevelCounter]);
#else
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
#endif
    }
    return CLI_SUCCESS;
}

#ifdef TRACE_WANTED
/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetDebug                                   
 *                                                                          
 *     DESCRIPTION      : This function configures ECFM debug level            
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - ContextId 
 *                        u4Type - Type of the command
 *                        i4Val - Ecfm Debug Level                       
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ***************************************************************************/
INT4
EcfmCliSetDebug (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                 INT4 i4Val)
{
    UINT4               u4ErrorCode = 0;
    INT4                i4Level = 0;
    if (nmhGetFsMIEcfmTraceOption (u4ContextId, &i4Level) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (u4Type == CLI_ECFM_DEBUG)

    {
        i4Val = i4Val | i4Level;
    }

    else

    {
        i4Val = i4Val & i4Level;
    }
    if (nmhTestv2FsMIEcfmTraceOption (&u4ErrorCode, u4ContextId, i4Val)
        == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmTraceOption (u4ContextId, i4Val) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*****************************************************************************/
/*                                                                           */
/*     FUNCTION NAME    : EcfmCliSetGlobalDebug                              */
/*                                                                           */
/*     DESCRIPTION      : This function configures/deconfigures debug level  */
/*                                                                           */
/*     INPUT            : u4Type - Type of command                           */
/*                                                                           */
/*     OUTPUT           : CliHandle - Contains error messages                */
/*                                                                           */
/*     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            */
/*                                                                           */
/*****************************************************************************/
INT4
EcfmCliSetGlobalDebug (tCliHandle CliHandle, UINT4 u4Type)
{
    INT4                i4Action = ECFM_INIT_VAL;
    UINT4               u4ErrCode;
    i4Action =
        (u4Type == CLI_ECFM_GBL_DEBUG) ? ECFM_SNMP_TRUE : ECFM_SNMP_FALSE;
    if (nmhTestv2FsMIEcfmGlobalTrace (&u4ErrCode, i4Action) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    nmhSetFsMIEcfmGlobalTrace (i4Action);
    CliPrintf (CliHandle, " ");
    return CLI_SUCCESS;
}

#endif /* TRACE_WANTED */
/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigLbmParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for LBM
 *                        transmission.
 *                                                                          
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                                                                        
 *     OUTPUT           : pb1Err - Indicates if any test routine returns
 *                        particular CLI error code
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigLbmParams (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdIndex,
                     UINT4 u4MaIndex, UINT4 u4MepIdentifier,
                     tEcfmLbLtTransRequest * pLbRequest, BOOL1 * pb1Err)
{
    tSNMP_OCTET_STRING_TYPE DataTlv;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;

    ECFM_MEMSET (ECFM_LBLT_PDU, ECFM_INIT_VAL, ECFM_MAX_JUMBO_PDU_SIZE);
    ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
    DataTlv.i4_Length = 0;

    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                       &i4RetPrimaryVid) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /* LBM Managed objects: Steps to initiate a LBM
     * LBM Managed objects in the MEP table
     * enables the management entity to initiate
     * transmission of Loopback messages. It will signal the MEP
     * that it SHOULD transmit some number of Loopback messages
     * and detect the detection (or lack thereof) of the
     * corresponding Loopback messages.

     * Steps to use entries in this table:

     * 1) Wait for dot1agCfmMepTransmitLbmStatus value to be
     * false. To do this do this sequence:
     * a. an SNMP GET for both SnmpSetSerialNo and
     * dot1agCfmMepTransmitLbmStatus objects (in same SNMP
     * PDU).
     * b. Check if value for dot1agCfmMepTransmitLbmStatus is false.
     * - if not, wait x seconds, go to step a above.
     * - if yes, save the value of SnmpSetSerialNo and go
     * to step 2) below
     * 2) Change dot1agCfmMepTransmitLbmStatus value from false to
     * true to ensure no other management entity will use
     * the service. In order to not disturb a possible other NMS
     * do this by sending an SNMP SET for both SnmpSetSerialNo
     * and dot1agCfmMepTransmitLbmStatus objects (in same SNMP
     * PDU, and make sure SNmpSetSerialNo is the first varBind).
     * For the SnmpSetSerialNo varBind, use the value that you
     * obtained in step 1)a.. This ensures that two cooperating
     * NMSes will not step on each others toes.
     * Setting this MIB object does not set the corresponding
     * LBIactive state machine variable.
     * 3) Setup the different data to be sent (number of messages,
     * optional TLVs,...), except do not set
     * dot1agCfmMepTransmitLbmMessages.
     * 4) Record the current values of dot1agCfmMepLbrIn,
     * dot1agCfmMepLbrInOutOfOrder, and dot1agCfmMepLbrBadMsdu.
     * 5) Set dot1agCfmMepTransmitLbmMessages to a non-zero value to
     * initiate transmission of Loopback messages.
     * The dot1agCfmMepTransmitLbmMessages indicates the
     * number of LBMs to be sent and is not decremented as
     * loopbacks are actually sent. dot1agCfmMepTransmitLbmMessages
     * is not equivalent to the LBMsToSend state machine variable.
     * 6) Check the value of dot1agCfmMepTransmitLbmResultOK to
     * find out if the operation was successfully initiated or
     * not.
     * 7) Monitor the value of dot1agCfmMepTransmitLbmStatus.
     * When it is reset to false, the last LBM has been transmitted.
     * Wait an additional 5 seconds to ensure that all LBRs have
     * been returned.
     * 8) Compare dot1agCfmMepLbrIn, dot1agCfmMepLbrInOutOfOrder,
     * and dot1agCfmMepLbrBadMsdu to their old values from step
     * 4, above, to get the results of the test.
     */

    if (ECFM_IS_MEP_ISID_AWARE (i4RetPrimaryVid))
    {
        /* Set MpId or Dest Mac address depending on the input */
        if (pLbRequest->u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

        {
            if (nmhTestv2FsMIEcfmExtMepTransmitLbmDestIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLbmDestIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set MpId of the destination MEP */
            if (nmhTestv2FsMIEcfmExtMepTransmitLbmDestMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->u4TargetMepId) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLbmDestMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->u4TargetMepId) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhTestv2FsMIEcfmExtMepTransmitLbmDestIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLbmDestIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set Mac Address of the destination MEP */
            if (nmhTestv2FsMIEcfmExtMepTransmitLbmDestMacAddress
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLbmDestMacAddress
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set the Data TLV if it is to be included in LBM */
        if (pLbRequest->u1LbTlvOrNone == ECFM_LBLT_LBM_WITH_DATA_TLV)

        {
            DataTlv.i4_Length = ECFM_STRLEN (pLbRequest->pu1LbDataPattern);
            DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
            ECFM_MEMCPY (DataTlv.pu1_OctetList, pLbRequest->pu1LbDataPattern,
                         DataTlv.i4_Length);
        }
        if (nmhTestv2FsMIEcfmExtMepTransmitLbmDataTlv
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepTransmitLbmDataTlv
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &DataTlv) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set the No of Lbms if provided, otherwise put default one */
        if (pLbRequest->u4LbMessages != 0)

        {
            if (nmhTestv2FsMIEcfmExtMepTransmitLbmMessages
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->u4LbMessages) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLbmMessages
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->u4LbMessages) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhSetFsMIEcfmExtMepTransmitLbmMessages
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 1) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set LBM Status */
        if (nmhTestv2FsMIEcfmExtMepTransmitLbmStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepTransmitLbmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

    }
    else                        /* VLAN UNAWARE */
    {
        /* Set MpId or Dest Mac address depending on the input */
        if (pLbRequest->u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

        {
            if (nmhTestv2FsMIEcfmMepTransmitLbmDestIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLbmDestIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set MpId of the destination MEP */
            if (nmhTestv2FsMIEcfmMepTransmitLbmDestMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->u4TargetMepId) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLbmDestMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->u4TargetMepId) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhTestv2FsMIEcfmMepTransmitLbmDestIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLbmDestIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set Mac Address of the destination MEP */
            if (nmhTestv2FsMIEcfmMepTransmitLbmDestMacAddress
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLbmDestMacAddress
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set the Data TLV if it is to be included in LBM */
        if (pLbRequest->u1LbTlvOrNone == ECFM_LBLT_LBM_WITH_DATA_TLV)

        {
            DataTlv.i4_Length = ECFM_STRLEN (pLbRequest->pu1LbDataPattern);
            DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
            ECFM_MEMCPY (DataTlv.pu1_OctetList, pLbRequest->pu1LbDataPattern,
                         DataTlv.i4_Length);
        }
        if (nmhTestv2FsMIEcfmMepTransmitLbmDataTlv
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmMepTransmitLbmDataTlv
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &DataTlv) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set the No of Lbms if provided, otherwise put default one */
        if (pLbRequest->u4LbMessages != 0)

        {
            if (nmhTestv2FsMIEcfmMepTransmitLbmMessages
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->u4LbMessages) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLbmMessages
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->u4LbMessages) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhSetFsMIEcfmMepTransmitLbmMessages
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 1) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set LBM Status */
        if (nmhTestv2FsMIEcfmMepTransmitLbmStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmMepTransmitLbmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    CliPrintf (CliHandle, " \r\n");
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigY1731LbmParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB structures required 
 *                        for LBM transmission.
 *                                                                          
 *     INPUT            : u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        pLbRequest - Various fields to set
 *                                                                        
 *     OUTPUT           : b1Err - Indicates an Error from Test routine
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigY1731LbmParams (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4MdIndex, UINT4 u4MaIndex,
                          UINT4 u4MepIdentifier,
                          tEcfmLbLtTransRequest * pLbRequest, BOOL1 * pb1Err)
{
    tSNMP_OCTET_STRING_TYPE DataTlv;
    tSNMP_OCTET_STRING_TYPE IccCode;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4VaryingBytes = ECFM_SNMP_FALSE;

    ECFM_MEMSET (ECFM_LBLT_PDU, ECFM_INIT_VAL, ECFM_MAX_JUMBO_PDU_SIZE);
    ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
    DataTlv.i4_Length = 0;
    ECFM_MEMSET (&IccCode, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    /* Set Destination type depending on the input */
    if (pLbRequest->u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)
    {
        /* MepId as a target */
        if (nmhTestv2FsMIY1731MepTransmitLbmDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_MEPID) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_MEPID) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepTransmitLbmDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4TargetMepId) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4TargetMepId) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (pLbRequest->u4Cmd == CLI_ECFM_MPTP_LB_LEV_SER)
        {
            if (nmhTestv2FsMIY1731MepLbmTTL
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pLbRequest->u1LbmTtl) == SNMP_FAILURE)
            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }

            if (nmhSetFsMIY1731MepLbmTTL
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pLbRequest->u1LbmTtl) == SNMP_FAILURE)
            {
                return ECFM_FAILURE;
            }
        }
    }
    else if (pLbRequest->u1LbDestType == ECFM_TX_DEST_TYPE_MIPID)
    {
        /* Currently MIP ID type is supported only for MPLS-TP OAM */

        /* MIPId as a target */
        if (nmhTestv2FsMIY1731MepTransmitLbmDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_MIPID) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_MIPID) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (pLbRequest->pu1TgtIccCode != NULL)
        {
            IccCode.pu1_OctetList = pLbRequest->pu1TgtIccCode;
            IccCode.i4_Length = STRLEN (pLbRequest->pu1TgtIccCode);

            if (nmhTestv2FsMIY1731MepLbmIcc
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, &IccCode) == SNMP_FAILURE)
            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
        }

        if (nmhSetFsMIY1731MepLbmIcc
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &IccCode) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepLbmNodeId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4TgtNodeId) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepLbmNodeId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4TgtNodeId) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepLbmIfNum
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4TgtIfNum) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepLbmIfNum
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4TgtIfNum) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepLbmTTL
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u1LbmTtl) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepLbmTTL
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u1LbmTtl) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }
    else if (pLbRequest->u1LbDestType == ECFM_TX_DEST_TYPE_UNICAST)
    {
        /* Unicast Mac Address as a target */
        if (nmhTestv2FsMIY1731MepTransmitLbmDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_UNICAST) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_UNICAST) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepTransmitLbmDestMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->LbTargetMacAddr) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }
    else
    {
        /* Multicast Mac Address as a target */
        if (nmhTestv2FsMIY1731MepTransmitLbmDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_MULTICAST) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitLbmDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_MULTICAST) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }

    /* Set TLV  depending on the input */
    if (pLbRequest->u1LbTlvOrNone == ECFM_LBLT_LBM_WITH_DATA_TLV)
    {

        /* Data TLV */
        if (nmhTestv2FsMIY1731MepTransmitLbmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_LBLT_LBM_WITH_DATA_TLV) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (pLbRequest->pu1LbDataPattern != NULL)
        {
            DataTlv.i4_Length = ECFM_STRLEN (pLbRequest->pu1LbDataPattern);
            DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
            ECFM_STRCPY (DataTlv.pu1_OctetList, pLbRequest->pu1LbDataPattern);
            if (nmhTestv2FsMIY1731MepTransmitLbmDataPattern
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }
        if (nmhTestv2FsMIY1731MepTransmitLbmDataPatternSize
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4LbPatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLbmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_LBLT_LBM_WITH_DATA_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (pLbRequest->pu1LbDataPattern != NULL)

        {
            if (nmhSetFsMIY1731MepTransmitLbmDataPattern
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 &DataTlv) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }
        if (nmhSetFsMIY1731MepTransmitLbmDataPatternSize
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4LbPatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    else if (pLbRequest->u1LbTlvOrNone == ECFM_LBLT_LBM_WITH_TEST_TLV)
    {

        /* Test TLV */
        if (nmhTestv2FsMIY1731MepTransmitLbmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_LBLT_LBM_WITH_TEST_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhTestv2FsMIY1731MepTransmitLbmTestPatternType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4LbTstPatternType) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhTestv2FsMIY1731MepTransmitLbmTestPatternSize
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pLbRequest->u4LbPatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLbmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_LBLT_LBM_WITH_TEST_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLbmTestPatternType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4LbTstPatternType) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLbmTestPatternSize
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pLbRequest->u4LbPatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {

        /* No TLV */
        if (nmhTestv2FsMIY1731MepTransmitLbmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_LBLT_LBM_WITHOUT_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLbmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_LBLT_LBM_WITHOUT_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Interval */
    if (nmhTestv2FsMIY1731MepTransmitLbmIntervalType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u1LbIntervalType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if (nmhTestv2FsMIY1731MepTransmitLbmInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u2LbInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLbmIntervalType
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u1LbIntervalType) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLbmInterval
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u2LbInterval) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* variable bytes */
    if (pLbRequest->b1LbVariableBytes == ECFM_TRUE)

    {
        i4VaryingBytes = ECFM_SNMP_TRUE;
    }

    else

    {
        i4VaryingBytes = ECFM_SNMP_FALSE;
    }
    if (nmhTestv2FsMIY1731MepTransmitLbmVariableBytes
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4VaryingBytes) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* number of LBMs */
    if (nmhTestv2FsMIY1731MepTransmitLbmMessages
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u4LbMessages) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Deadline */
    if (nmhTestv2FsMIY1731MepTransmitLbmDeadline
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u4LbDeadline) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Transmit status */
    if (nmhTestv2FsMIY1731MepTransmitLbmStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* variable bytes */
    if (nmhSetFsMIY1731MepTransmitLbmVariableBytes
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4VaryingBytes) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Set number of LBMs */
    if (nmhSetFsMIY1731MepTransmitLbmMessages
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u4LbMessages) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Set Deadline */
    if (nmhSetFsMIY1731MepTransmitLbmDeadline
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u4LbDeadline) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhTestv2FsMIY1731MepTransmitLbmMode
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u1LbMode) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLbmMode
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pLbRequest->u1LbMode) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    /*LbrTimeout */
    if (nmhTestv2FsMIY1731MepTransmitLbmTimeout
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u4LbrTimeout) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLbmTimeout
        (u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pLbRequest->u4LbrTimeout) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set the status */
    if (nmhSetFsMIY1731MepTransmitLbmStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    CliPrintf (CliHandle, " \r\n");
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigLtmParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for LTM
 *                        transmission initiation.
 *                                                                          
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        u4DestMpId - Destination MepId
 *                        pu1DestAddr - Destination Mac Address
 *                        u4Ttl - Time to live, value to be sent in LTM
 *                        u4MipCcmDb - To use MIP CCM DB or not for forwarding
 *                                                                        
 *     OUTPUT           : b1Err - Indicates an Error from Test routine               
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigLtmParams (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdIndex,
                     UINT4 u4MaIndex, UINT4 u4MepIdentifier,
                     UINT4 u4TargetMpId, UINT1 *pu1TargetMacAddr,
                     UINT4 u4TxTtl, UINT4 u4MipCcmDb, BOOL1 * pb1Err)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT1               u1LtmFlag = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE LtmFlag;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;

    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                       &i4RetPrimaryVid) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    if (ECFM_IS_MEP_ISID_AWARE (i4RetPrimaryVid))
    {
        /* Set MepId or Dest Mac Address depending on the input */
        if (u4TargetMpId != 0)

        {
            if (nmhTestv2FsMIEcfmExtMepTransmitLtmTargetIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLtmTargetIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set MepId of the destination */
            if (nmhTestv2FsMIEcfmExtMepTransmitLtmTargetMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4TargetMpId) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLtmTargetMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4TargetMpId) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhTestv2FsMIEcfmExtMepTransmitLtmTargetIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLtmTargetIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set destination address */
            if (nmhTestv2FsMIEcfmExtMepTransmitLtmTargetMacAddress
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pu1TargetMacAddr) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMepTransmitLtmTargetMacAddress
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pu1TargetMacAddr) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set TTL field */
        if (nmhTestv2FsMIEcfmExtMepTransmitLtmTtl
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4TxTtl) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepTransmitLtmTtl
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TxTtl) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Use MIP CCM DB for forwarding the LTM */
        if (u4MipCcmDb == ECFM_ENABLE)

        {
            ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
            LtmFlag.pu1_OctetList = &u1LtmFlag;
        }

        else

        {
            ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
            ECFM_LBLT_SET_USE_FDB_ONLY (u1LtmFlag);
            LtmFlag.pu1_OctetList = &u1LtmFlag;
        }
        if (nmhTestv2FsMIEcfmExtMepTransmitLtmFlags
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &LtmFlag) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepTransmitLtmFlags
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &LtmFlag) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Initiate LTM */
        if (nmhTestv2FsMIEcfmExtMepTransmitLtmStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepTransmitLtmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

    }
    else
    {
        /* Set MepId or Dest Mac Address depending on the input */
        if (u4TargetMpId != 0)

        {
            if (nmhTestv2FsMIEcfmMepTransmitLtmTargetIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLtmTargetIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_TRUE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set MepId of the destination */
            if (nmhTestv2FsMIEcfmMepTransmitLtmTargetMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4TargetMpId) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLtmTargetMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4TargetMpId) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        else

        {
            if (nmhTestv2FsMIEcfmMepTransmitLtmTargetIsMepId
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLtmTargetIsMepId
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_SNMP_FALSE) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            /* Set destination address */
            if (nmhTestv2FsMIEcfmMepTransmitLtmTargetMacAddress
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, pu1TargetMacAddr) == SNMP_FAILURE)

            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
            if (nmhSetFsMIEcfmMepTransmitLtmTargetMacAddress
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 pu1TargetMacAddr) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

        /* Set TTL field */
        if (nmhTestv2FsMIEcfmMepTransmitLtmTtl
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4TxTtl) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmMepTransmitLtmTtl
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TxTtl) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Use MIP CCM DB for forwarding the LTM */
        if (u4MipCcmDb == ECFM_ENABLE)

        {
            ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
            LtmFlag.pu1_OctetList = &u1LtmFlag;
        }

        else

        {
            ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
            ECFM_LBLT_SET_USE_FDB_ONLY (u1LtmFlag);
            LtmFlag.pu1_OctetList = &u1LtmFlag;
        }
        if (nmhTestv2FsMIEcfmMepTransmitLtmFlags
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &LtmFlag) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmMepTransmitLtmFlags
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &LtmFlag) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Initiate LTM */
        if (nmhTestv2FsMIEcfmMepTransmitLtmStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIEcfmMepTransmitLtmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_STATUS_START) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    UNUSED_PARAM (CliHandle);
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigY1731LtmParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for LTM
 *                        transmission initiation when Y1731 is enabled.
 *                                                                          
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        u4DestMpId - Destination MepId
 *                        pu1DestAddr - Destination Mac Address
 *                        u4Ttl - Time to live, value to be sent in LTM
 *                        i4LtrTimeout - Time till all the LTRs received for a
 *                        initiated LTM 
 *                        u4MipCcmDb - To use MIP CCM DB or not for forwarding
 *                                                                        
 *     OUTPUT           : b1Err - Indicates an Error from Test routine               
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigY1731LtmParams (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4MdIndex, UINT4 u4MaIndex,
                          UINT4 u4MepIdentifier, UINT4 u4TargetMpId,
                          UINT1 *pu1TargetMacAddr, UINT4 u4TxTtl,
                          INT4 i4LtrTimeout, UINT4 u4MipCcmDb, BOOL1 * pb1Err)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT1               u1LtmFlag = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE LtmFlag;

    /* Set MepId or Dest Mac Address depending on the input */
    if (u4TargetMpId != 0)

    {
        if (nmhTestv2FsMIY1731MepTransmitLtmTargetIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLtmTargetIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set MepId of the destination */
        if (nmhTestv2FsMIY1731MepTransmitLtmTargetMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4TargetMpId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLtmTargetMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TargetMpId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {
        if (nmhTestv2FsMIY1731MepTransmitLtmTargetIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLtmTargetIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set destination address */
        if (nmhTestv2FsMIY1731MepTransmitLtmTargetMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pu1TargetMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLtmTargetMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pu1TargetMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Set TTL field */
    if (nmhTestv2FsMIY1731MepTransmitLtmTtl
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4TxTtl) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Set TimeOut value for LTR */
    if (nmhTestv2FsMIY1731MepTransmitLtmTimeout
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4LtrTimeout) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLtmTtl
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         u4TxTtl) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLtmTimeout
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4LtrTimeout) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Use MIP CCM DB for forwarding the LTM */
    if (u4MipCcmDb == ECFM_ENABLE)

    {
        ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
        LtmFlag.pu1_OctetList = &u1LtmFlag;
    }

    else

    {
        ECFM_MEMSET (&LtmFlag, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        LtmFlag.i4_Length = ECFM_FLAGS_FIELD_SIZE;
        ECFM_LBLT_SET_USE_FDB_ONLY (u1LtmFlag);
        LtmFlag.pu1_OctetList = &u1LtmFlag;
    }
    if (nmhTestv2FsMIY1731MepTransmitLtmFlags
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         &LtmFlag) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLtmFlags
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         &LtmFlag) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Initiate LTM */
    if (nmhTestv2FsMIY1731MepTransmitLtmStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLtmStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    UNUSED_PARAM (CliHandle);
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliAssocVlansToPrimaryVlan                                  
 *                                                                          
 *     DESCRIPTION      : This function will associate various vids to a 
 *                        primary vlan.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4Vid - Vlan-Id
 *                        u4PrimaryVid - Primary Vid
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliAssocVlansToPrimaryVlan (tCliHandle CliHandle, INT4 i4PrimaryVid,
                                UINT1 au1VlanId[])
{
    tVlanId             VlanId;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;

    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE; u4ByteIndex++)
    {
        if (au1VlanId[u4ByteIndex] == 0)
        {
            continue;
        }

        u2VlanFlag = au1VlanId[u4ByteIndex];

        for (u4BitIndex = 0;
             ((u4BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) != 0));
             u4BitIndex++)
        {
            VlanId =
                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex));

            /* Check if same entry already exists */
            if (nmhGetIeee8021CfmVlanPrimarySelector
                (ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                 (UINT4 *) &i4RetPrimaryVid) == SNMP_SUCCESS)
            {
                if (i4PrimaryVid == i4RetPrimaryVid)
                {
                    CliPrintf (CliHandle,
                               "\rVlan %u is already associated to "
                               "Primary Vlan %u \r\n", VlanId, i4RetPrimaryVid);
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                    continue;
                }
                else
                {
                    if (nmhTestv2Ieee8021CfmVlanRowStatus
                        (&u4ErrorCode,
                         ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
                    {
                        nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID
                                                        (), VlanId,
                                                        ECFM_ROW_STATUS_DESTROY);
                        u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                        continue;
                    }

                    if (nmhSetIeee8021CfmVlanRowStatus
                        (ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
                    {
                        nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID
                                                        (), VlanId,
                                                        ECFM_ROW_STATUS_DESTROY);
                        u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                        continue;
                    }
                }
            }
            else
            {
                if (nmhTestv2Ieee8021CfmVlanRowStatus
                    (&u4ErrorCode, ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                {
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                    continue;
                }

                if (nmhSetIeee8021CfmVlanRowStatus
                    (ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                {
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                    continue;
                }
            }

            /* Set entry's primary vid */
            if (nmhTestv2Ieee8021CfmVlanPrimarySelector
                (&u4ErrorCode, ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                 i4PrimaryVid) == SNMP_FAILURE)
            {
                nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID (),
                                                VlanId,
                                                ECFM_ROW_STATUS_DESTROY);
                CliPrintf (CliHandle,
                           "%% Cannot Associate Vlan %u to Primary Vlan %u."
                           "\r\n", VlanId, i4PrimaryVid);
                if (u4ErrorCode == SNMP_ERR_RESOURCE_UNAVAILABLE)
                {
                    CliPrintf (CliHandle,
                               "%% Primary Vlan %u is already associated with 32 vlans"
                               "\r\n", VlanId);
                    return CLI_SUCCESS;
                }
                u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                continue;
            }

            if (nmhSetIeee8021CfmVlanPrimarySelector
                (ECFM_CC_CURR_CONTEXT_ID (), VlanId,
                 i4PrimaryVid) == SNMP_FAILURE)
            {
                nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID (),
                                                VlanId,
                                                ECFM_ROW_STATUS_DESTROY);
                u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                continue;
            }

            /* Make corresponding row active */
            if (nmhTestv2Ieee8021CfmVlanRowStatus
                (&u4ErrorCode, ECFM_CC_CURR_CONTEXT_ID (),
                 VlanId, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
            {
                nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID (),
                                                VlanId,
                                                ECFM_ROW_STATUS_DESTROY);
                CliPrintf (CliHandle,
                           "%% Cannot Associate Vlan %u to Primary Vlan %u."
                           "\r\n", VlanId, i4PrimaryVid);
                u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                continue;
            }

            if (nmhSetIeee8021CfmVlanRowStatus
                (ECFM_CC_CURR_CONTEXT_ID (),
                 VlanId, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
            {
                nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID (),
                                                VlanId,
                                                ECFM_ROW_STATUS_DESTROY);
                u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                continue;
            }
            else
            {
                CliPrintf (CliHandle,
                           " Associated Vlan %u to Primary Vlan %u."
                           "\r\n", VlanId, i4PrimaryVid);
            }
        }
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliDeAssocVlansToPrimaryVlan                                  
 *                                                                          
 *     DESCRIPTION      : This function will dis-associate a vlan to primary vlan.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4Vid - Vlan-Id
 *                        u4PrimaryVid - Primary Vid
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliDeAssocVlansToPrimaryVlan (tCliHandle CliHandle, UINT4 u4PrimaryVid,
                                  UINT1 au1VlanId[])
{
    tVlanId             VlanId;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE; u4ByteIndex++)

    {
        if (au1VlanId[u4ByteIndex] == 0)

        {
            continue;
        }
        u2VlanFlag = au1VlanId[u4ByteIndex];
        for (u4BitIndex = 0;
             ((u4BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) != 0));
             u4BitIndex++)
        {
            VlanId =
                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex));

            if (nmhTestv2Ieee8021CfmVlanRowStatus
                (&u4ErrorCode, ECFM_CC_CURR_CONTEXT_ID (),
                 VlanId, ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

            {
                CliPrintf (CliHandle,
                           "Cannot dis-associate Vlan %u to Primary Vlan %u."
                           "\r\n", VlanId, u4PrimaryVid);
                u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                continue;
            }

            else

            {
                i4RetPrimaryVid = ECFM_INIT_VAL;
                nmhGetIeee8021CfmVlanPrimarySelector (ECFM_CC_CURR_CONTEXT_ID
                                                      (), VlanId,
                                                      (UINT4 *)
                                                      &i4RetPrimaryVid);
                if ((UINT4) (i4RetPrimaryVid) != u4PrimaryVid)

                {
                    CliPrintf (CliHandle,
                               " Vlan %u is associated to Primary Vlan %u."
                               "\r\n", VlanId, i4RetPrimaryVid);
                    u2VlanFlag = (UINT2) (u2VlanFlag << 1);
                    continue;
                }

                /* Delete the corresponding vlan entry */
                nmhSetIeee8021CfmVlanRowStatus (ECFM_CC_CURR_CONTEXT_ID (),
                                                VlanId,
                                                ECFM_ROW_STATUS_DESTROY);
                CliPrintf (CliHandle,
                           "de-Associated Vlan %u to Primary Vlan %u." "\r\n",
                           VlanId, u4PrimaryVid);
            }
        }
    }
    return CLI_SUCCESS;
}

/********************************************************************************
 *                                                                              *
 *     FUNCTION NAME    : EcfmCliSetMepLoopbackStatus                           *
 *                                                                              *
 *     DESCRIPTION      : This function will set the loopback status.           *
 *                                                                              *
 *     INPUT            : CliHandle - CliContext ID                             *
 *                        i4LoopbackStatus - Loopback Status                    *
 *                                                                              *
 *     OUTPUT           : None                                                  *
 *                                                                              *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                               *
 *                                                                              *
 *******************************************************************************/
INT4
EcfmCliSetMepLoopbackStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                             INT4 i4LoopbackStatus)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    if (nmhTestv2FsMIY1731MepLoopbackStatus (&u4ErrorCode, u4ContextId,
                                             u4MdIndex, u4MaIndex, u4MepId,
                                             i4LoopbackStatus) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MepLoopbackStatus (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepId,
                                          i4LoopbackStatus) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/********************************************************************************
 *                                                                              *
 *     FUNCTION NAME    : EcfmCliSetMepSrcMacAddress                            *
 *                                                                              *
 *     DESCRIPTION      : This function will set the MAC Address for the MEP    *
 *                        which will used as source MAC in the CFM Messages     *
 *                                                                              *
 *     INPUT            : CliHandle - CliContext ID                             *
 *                        i4LoopbackStatus - Loopback Status                    *
 *                                                                              *
 *     OUTPUT           : None                                                  *
 *                                                                              *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                               *
 *                                                                              *
 *******************************************************************************/
INT4
EcfmCliSetMepSrcMacAddress (tCliHandle CliHandle, UINT4 u4ContextId,
                            tEcfmMacAddr au1MepSrcMac)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetVal = CLI_SUCCESS;
    tEcfmMacAddr        au1InMacAddr;

    ECFM_MEMSET (au1InMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    if (nmhTestv2FsMIEcfmMepRowStatus (&u4ErrorCode, u4ContextId,
                                       u4MdIndex, u4MaIndex, u4MepIndex,
                                       ECFM_ROW_STATUS_NOT_IN_SERVICE)
                                       == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmMepRowStatus (u4ContextId, u4MdIndex,
                                    u4MaIndex, u4MepIndex,
                                    ECFM_ROW_STATUS_NOT_IN_SERVICE)
                                    == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (nmhTestv2FsMIEcfmMepSrcMacAddr (&u4ErrorCode, u4ContextId,
                                        u4MdIndex, u4MaIndex,
                                        u4MepIndex, au1MepSrcMac)
                                        == SNMP_SUCCESS)
    {
        if (nmhSetFsMIEcfmMepSrcMacAddr (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIndex,
                                         au1MepSrcMac) == SNMP_FAILURE)
        {
            i4RetVal = CLI_FAILURE;
        }
    }

    if (nmhTestv2FsMIEcfmMepRowStatus(&u4ErrorCode, u4ContextId,
                                      u4MdIndex, u4MaIndex,
                                      u4MepIndex, ECFM_ROW_STATUS_ACTIVE)
                                      == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmMepRowStatus (u4ContextId, u4MdIndex,
                                    u4MaIndex, u4MepIndex,
                                    ECFM_ROW_STATUS_ACTIVE)
                                    == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return i4RetVal;
}

/*******************************************************************************
 *                                                                             *
 *     FUNCTION NAME    : EcfmCliSetMcLagMepShutdown                           *
 *                                                                             *
 *     DESCRIPTION      : This function will set the status of the McLag Up-Mep*
 *                        behaviour. Enable will make the Up-Mep on a standby  *
 *                        McLag node to act as administratively down.          *
 *                        Disable will make the Up-Mep on a standby McLag Node *
 *                        to act as administratively up.                       *
 *                                                                             *
 *     INPUT            : CliHandle - CliContext ID                            *
 *                        i4McLagMepShutdownStatus - Enable / Disable          *
 *                                                                             *
 *     OUTPUT           : None                                                 *
 *                                                                             *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                              *
 *                                                                             *
 ******************************************************************************/
INT4
EcfmCliSetMcLagMepShutdown (tCliHandle CliHandle, INT4 i4McLagMepShutdownStatus)
{
    UINT4       u4ErrorCode = ECFM_INIT_VAL;
    UNUSED_PARAM(CliHandle);
    if (nmhTestv2FsEcfmMcLagStandbyMepShut
            (&u4ErrorCode, i4McLagMepShutdownStatus) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsEcfmMcLagStandbyMepShut
            (i4McLagMepShutdownStatus) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                             *
 *     FUNCTION NAME    : EcfmCliSetMcLagMepFaultHoldTime                      *
 *                                                                             *
 *     DESCRIPTION      : This function will set the hold time in seconds      *
 *                        before propagating any faults by a mep to its far    *
 *                        end.                                                 *
 *                                                                             *
 *     INPUT            : CliHandle - CliContext ID                            *
 *                        u4McLagMepFaultHoldTime - Hold time in seconds       *
 *                                                                             *
 *     OUTPUT           : None                                                 *
 *                                                                             *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                              *
 *                                                                             *
 ******************************************************************************/
INT4
EcfmCliSetMcLagMepFaultHoldTime (tCliHandle CliHandle,
                                 UINT4 u4McLagMepFaultHoldTime)
{
    UINT4       u4ErrorCode = ECFM_INIT_VAL;
    UNUSED_PARAM(CliHandle);
    if (nmhTestv2FsEcfmMcLagMepFaultHoldTime
            (&u4ErrorCode, u4McLagMepFaultHoldTime) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsEcfmMcLagMepFaultHoldTime
            (u4McLagMepFaultHoldTime) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowLtrsForATransId
 *                                                                          
 *     DESCRIPTION      : This function will display the contents of LinkTrace
 *                        cache for a particular Ltm transaction of a particular 
 *                        MEP.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        pLtrCacheIndices - array of recieve order and Ttl of a 
 *                                       particular Ltm transanction
 *                        u2NoOfEntries - Number of Entries in array 
 *                                        pLtrCacheIndices
 *                        u4MdIndex - Maintenane Domain index of MEP which has
 *                                    initiated LTM transaction.
 *                        u4MaIndex - Maintenane Association index of MEP which has
 *                                    initiated LTM transaction.
 *                        u4MepId - MEP identifier of MEP which has initiated
 *                                  LTM transaction.
 *                        u4LtrSeqNum -LTM transaction identifier. 
 *                                                      
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmShowLtrsForATransId (tCliHandle CliHandle, UINT4 u4ContextId,
                         tEcfmLtrCacheIndices * pLtrCacheIndices,
                         UINT2 u2NoOfEntries, UINT4 u4MdIndex,
                         UINT4 u4MaIndex, UINT4 u4MepId, UINT4 u4LtrSeqNum)
{
    INT4                i4RetValLtrRelayAction = ECFM_INIT_VAL;
    INT4                i4RetValLtrIngressAction = ECFM_INIT_VAL;
    INT4                i4RetValLtrEgressAction = ECFM_INIT_VAL;
    INT4                i4RetValLtrForwarded = ECFM_INIT_VAL;
    INT4                i4RetValLtrTerminalMep = ECFM_INIT_VAL;
    INT4                i4RetVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaVlanId = ECFM_INIT_VAL;
    INT4                i4RetLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    INT4                i4PrintVlanId = ECFM_INIT_VAL;
    INT4                i4RetLtrIngPortIdSubtype = ECFM_INIT_VAL;
    INT4                i4RetLtrEgrPortIdSubtype = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4Ttl = ECFM_INIT_VAL;
    UINT2               u2Counter = ECFM_INIT_VAL;
    UINT2               u2Temp = ECFM_INIT_VAL;
    UINT2               u2Index = ECFM_INIT_VAL;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1NextEgressId[ECFM_EGRESS_ID_LENGTH];
    UINT1               au1LastEgressId[ECFM_EGRESS_ID_LENGTH];
    UINT1               au1LtrManAddr[ECFM_MAX_MAN_ADDR_LEN];
    UINT4               au4LtrManAddrDom[ECFM_MAX_TRANSPORT_DOMAIN_LEN];
    BOOL1               b1NoTlv = ECFM_FALSE;
    tSNMP_OID_TYPE      RetLtrManAddrDom;
    tSNMP_OCTET_STRING_TYPE RetValLtrNextEgressId;
    tSNMP_OCTET_STRING_TYPE RetValLtrLastEgressId;
    tSNMP_OCTET_STRING_TYPE RetDomName;
    tSNMP_OCTET_STRING_TYPE RetLtrManAddr;
    tSNMP_OCTET_STRING_TYPE RetLtrIngrPortId;
    tSNMP_OCTET_STRING_TYPE RetLtrEgrPortId;
    tEcfmMacAddr        MacAddress;
    tEcfmMacAddr        TargetMacAddress;
    tEcfmMacAddr        EgressMacAddress;
    tEcfmMacAddr        NullMacAddress;
    tEcfmLtrCacheIndices LtrTemp;
    UINT1               au1IngressPort[ECFM_PORT_ID_LENGTH];
    UINT1               au1EgressPort[ECFM_PORT_ID_LENGTH];

    RetLtrIngrPortId.pu1_OctetList = au1IngressPort;
    RetLtrEgrPortId.pu1_OctetList = au1EgressPort;

    /* Set NullMacAddress to all Zeros */
    ECFM_MEMSET (NullMacAddress, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);

    /* Sort the array in decreasing order */
    if (u2NoOfEntries > 1)
    {
        for (u2Temp = 0; u2Temp < u2NoOfEntries; u2Temp++)
        {
            for (u2Counter = 0; u2Counter < (u2NoOfEntries - u2Temp - 1);
                 u2Counter++)
            {
                if (pLtrCacheIndices[u2Counter].u1Ttl <
                    pLtrCacheIndices[u2Counter + 1].u1Ttl)
                {
                    LtrTemp.u2RcvOrder = pLtrCacheIndices[u2Counter].u2RcvOrder;
                    LtrTemp.u1Ttl = pLtrCacheIndices[u2Counter].u1Ttl;
                    pLtrCacheIndices[u2Counter].u2RcvOrder =
                        pLtrCacheIndices[u2Counter + 1].u2RcvOrder;
                    pLtrCacheIndices[u2Counter].u1Ttl =
                        pLtrCacheIndices[u2Counter + 1].u1Ttl;
                    pLtrCacheIndices[u2Counter + 1].u2RcvOrder =
                        LtrTemp.u2RcvOrder;
                    pLtrCacheIndices[u2Counter + 1].u1Ttl = LtrTemp.u1Ttl;
                }
            }
        }
    }

    /*  Get target mac address, domain, level, VlanId for a particular LTM
     *  transacton */
    ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (MacAddress, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (TargetMacAddress, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (EgressMacAddress, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
    ECFM_MEMSET (&RetDomName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetDomName.pu1_OctetList = au1MdName;
    RetDomName.i4_Length = ECFM_INIT_VAL;
    i4RetLevel = ECFM_INIT_VAL;
    i4RetMaVlanId = ECFM_INIT_VAL;
    i4RetVlanId = ECFM_INIT_VAL;

    /* take cc lock as now we are going to access variable controlled under CC
     * task*/
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetDomName);
    nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);

    nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetLevel);
    nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaVlanId);
    nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                                 (UINT4 *) &i4RetVlanId);
    nmhGetFsMIEcfmMepIfIndex (u4ContextId, u4MdIndex, u4MaIndex,
                              u4MepId, &i4MepIfIndex);
    nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4RetPortOperStatus);

    ECFM_UNREGISTER_CLI_CC_LOCK ();

    MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    EcfmUtilMdNameOctetStrToStr (&RetDomName, i4RetMdFormat, au1StrMdName);

    ECFM_REGISTER_CLI_LBLT_LOCK ();

    nmhGetFsMIEcfmLtmTargetMacAddress (u4ContextId, u4MdIndex, u4MaIndex,
                                       u4MepId, u4LtrSeqNum, &TargetMacAddress);
    PrintMacAddress (TargetMacAddress, au1String);
    au1String[ECFM_INDEX_SEVENTEEN] = '\0';

    /* TTL Value */
    nmhGetFsMIEcfmLtmTtl (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                          u4LtrSeqNum, &u4Ttl);
    if (i4RetVlanId != 0)
    {
#ifdef VSI_WANTED
        if (EcfmUtilCfaIsVsiId (i4RetVlanId) == ECFM_SUCCESS)
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with VsiId %d \r\n", au1String,
                       au1StrMdName, i4RetLevel, i4RetVlanId);
        }
        else if (i4RetVlanId < ECFM_INTERNAL_ISID_MIN)
#else
			if (i4RetVlanId < ECFM_INTERNAL_ISID_MIN)
#endif
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with vlanId %d \r\n", au1String,
                       au1StrMdName, i4RetLevel, i4RetVlanId);
        }
        else
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with Isid %d \r\n", au1String,
                       au1StrMdName, i4RetLevel,
                       ECFM_ISID_INTERNAL_TO_ISID (i4RetVlanId));

        }
    }
    else
    {
#ifdef VSI_WANTED
        if (EcfmUtilCfaIsVsiId (i4RetMaVlanId) == ECFM_SUCCESS)
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with VsiId %d \r\n", au1String,
                       au1StrMdName, i4RetLevel, i4RetMaVlanId);
        }
        else if (i4RetMaVlanId < ECFM_INTERNAL_ISID_MIN)
#else
        if (i4RetMaVlanId < ECFM_INTERNAL_ISID_MIN)
#endif

        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s at"
                       " level %d \r\n with vlanId %d \r\n", au1String,
                       au1StrMdName, i4RetLevel, i4RetMaVlanId);
        }
        else
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s at"
                       " level %d \r\n with Isid %d \r\n", au1String,
                       au1StrMdName, i4RetLevel,
                       ECFM_ISID_INTERNAL_TO_ISID (i4RetMaVlanId));
        }
    }

    for (u2Temp = ECFM_INIT_VAL; u2Temp < ECFM_CLI_MAX_LINE_LENGTH; u2Temp++)
    {
        CliPrintf (CliHandle, "-");
    }

    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "%-6s%-25s%-18s%-17s%-15s", "Hops", "    Host",
               "Ingress MAC", "Ingress Action", "Relay Action");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "%-10s%-20s%-18s%-18s%-17s", " ", "Next Host",
               " Egress MAC", " Egress Action", "Fwd Status");
    CliPrintf (CliHandle, "\r\n");

    for (u2Temp = 0; u2Temp < ECFM_CLI_MAX_LINE_LENGTH; u2Temp++)
    {
        CliPrintf (CliHandle, "-");
    }

    CliPrintf (CliHandle, "\r\n");

    for (u2Counter = 0; u2Counter < u2NoOfEntries; u2Counter++)
    {
        ECFM_MEMSET (MacAddress, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (au1NextEgressId, ECFM_INIT_VAL, ECFM_EGRESS_ID_LENGTH);
        ECFM_MEMSET (au1LastEgressId, ECFM_INIT_VAL, ECFM_EGRESS_ID_LENGTH);
        i4RetValLtrIngressAction = ECFM_INIT_VAL;
        i4RetValLtrEgressAction = ECFM_INIT_VAL;
        i4RetValLtrRelayAction = ECFM_INIT_VAL;
        i4RetValLtrForwarded = ECFM_INIT_VAL;
        i4RetValLtrTerminalMep = ECFM_INIT_VAL;
        RetValLtrLastEgressId.pu1_OctetList = au1LastEgressId;
        RetValLtrNextEgressId.pu1_OctetList = au1NextEgressId;

        /* Ingress Action Value */
        nmhGetFsMIEcfmLtrIngress (u4ContextId, u4MdIndex, u4MaIndex,
                                  u4MepId, u4LtrSeqNum,
                                  pLtrCacheIndices[u2Counter].u2RcvOrder,
                                  &i4RetValLtrIngressAction);

        /* Egress Action Value */
        nmhGetFsMIEcfmLtrEgress (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                                 u4LtrSeqNum,
                                 pLtrCacheIndices[u2Counter].u2RcvOrder,
                                 &i4RetValLtrEgressAction);

        /* Relay Action Value */
        nmhGetFsMIEcfmLtrRelay (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                                u4LtrSeqNum,
                                pLtrCacheIndices[u2Counter].u2RcvOrder,
                                &i4RetValLtrRelayAction);

        /* Forwarded or Not */
        nmhGetFsMIEcfmLtrForwarded (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, u4LtrSeqNum,
                                    pLtrCacheIndices[u2Counter].u2RcvOrder,
                                    &i4RetValLtrForwarded);

        /* Terminal Mep or Not */
        nmhGetFsMIEcfmLtrTerminalMep (u4ContextId, u4MdIndex, u4MaIndex,
                                      u4MepId, u4LtrSeqNum,
                                      pLtrCacheIndices[u2Counter].
                                      u2RcvOrder, &i4RetValLtrTerminalMep);

        /* Ingress Mac Address */
        nmhGetFsMIEcfmLtrIngressMac (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, u4LtrSeqNum,
                                     pLtrCacheIndices[u2Counter].
                                     u2RcvOrder, &MacAddress);

        /* Egress Mac Address */
        nmhGetFsMIEcfmLtrEgressMac (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, u4LtrSeqNum,
                                    pLtrCacheIndices[u2Counter].u2RcvOrder,
                                    &EgressMacAddress);

        /* Host */
        nmhGetFsMIEcfmLtrLastEgressIdentifier (u4ContextId, u4MdIndex,
                                               u4MaIndex, u4MepId,
                                               u4LtrSeqNum,
                                               pLtrCacheIndices[u2Counter].
                                               u2RcvOrder,
                                               &RetValLtrLastEgressId);

        /* Next Host */
        nmhGetFsMIEcfmLtrNextEgressIdentifier (u4ContextId, u4MdIndex,
                                               u4MaIndex, u4MepId,
                                               u4LtrSeqNum,
                                               pLtrCacheIndices[u2Counter].
                                               u2RcvOrder,
                                               &RetValLtrNextEgressId);

        CliPrintf (CliHandle, "%-4d",
                   u4Ttl - ((UINT4) pLtrCacheIndices[u2Counter].u1Ttl));

        if (i4RetPortOperStatus == ECFM_DISABLE)
        {
            CliPrintf (CliHandle, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_ZERO],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_ONE],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_TWO],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_THREE],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_FOUR],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_FIVE],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_SIX],
                       RetValLtrLastEgressId.pu1_OctetList[ECFM_INDEX_SEVEN]);
            CliPrintf (CliHandle, "%-2s", "");
        }
        else
        {
            CliPrintf (CliHandle, "%-2s", "          -              ");
        }

        /* The contents of this object are 
         * meaningless for the MIB objects dot1agCfmLtrIngressMac, 
         * dot1agCfmLtrIngressPortIdSubtype and dot1agCfmLtrIngressPortId 
         * if the dot1agCfmLtrIngress object contains the value ingNoTlv(0).
         * REFERENCE "802.1ag clauses 12.14.7.5.3:l and 20.36.2.7"
         */

        /* Skip if no Reply Ingress TLV */
        if (i4RetValLtrIngressAction !=
            ECFM_LBLT_PORT_FILTERING_ACTION_ING_NOTLV)
        {
            if (ECFM_MEMCMP (MacAddress, NullMacAddress, ECFM_MAC_ADDR_LENGTH)
                == 0)
            {
                CliPrintf (CliHandle, "%-17s", "      -");
            }
            else
            {
                ECFM_MEMSET (au1String, ECFM_INIT_VAL,
                             ECFM_CLI_MAX_MAC_STRING_SIZE);
                PrintMacAddress (MacAddress, au1String);
                CliPrintf (CliHandle, "%s", au1String);
            }
        }
        else
        {
            CliPrintf (CliHandle, "%-20s", "      NONE   ");
            b1NoTlv = ECFM_TRUE;
        }

        switch (i4RetValLtrIngressAction)
        {
            case ECFM_LBLT_PORT_FILTERING_ACTION_ING_NOTLV:
                CliPrintf (CliHandle, "%-17s", "IngNoTlv");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_ING_OK:
                CliPrintf (CliHandle, "%-17s", "IngOK");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_ING_BLOCKED:
                CliPrintf (CliHandle, "%-17s", "IngBlocked");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_ING_VID:
                CliPrintf (CliHandle, "%-17s", "IngVID");
                break;
            default:
                CliPrintf (CliHandle, "%-20s", "     -");
                break;
        }

        switch (i4RetValLtrRelayAction)
        {
            case ECFM_LTR_RLY_HIT:
                CliPrintf (CliHandle, "%-12s", "RlyHit");
                break;
            case ECFM_LTR_RLY_FDB:
                CliPrintf (CliHandle, "%-12s", "RlyFDB");
                break;
            case ECFM_LTR_RLY_MPDB:
                CliPrintf (CliHandle, "%-12s", "RlyMPDB");
                break;
            default:
                CliPrintf (CliHandle, "%-12s", " ");
                break;
        }

        CliPrintf (CliHandle, "\r\n");
        CliPrintf (CliHandle, "%-4s", "");

        if (i4RetPortOperStatus == ECFM_DISABLE)
        {
            CliPrintf (CliHandle, "%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_ZERO],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_ONE],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_TWO],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_THREE],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_FOUR],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_FIVE],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_SIX],
                       RetValLtrNextEgressId.pu1_OctetList[ECFM_INDEX_SEVEN]);
            CliPrintf (CliHandle, "%-2s", "");
        }
        else
        {
            CliPrintf (CliHandle, "%-2s", "          -              ");
        }

        /* The contents of this object are meaningless for the MIB objects 
         * dot1agCfmLtrEgressMac, dot1agCfmLtrEgressPortIdSubtype and 
         * dot1agCfmLtrEgressPortId if the dot1agCfmLtrEgress object 
         * contains the value egrNoTlv(0).
         */

        /* Skip if no Reply Egress Tlv */
        if (i4RetValLtrEgressAction !=
            ECFM_LBLT_PORT_FILTERING_ACTION_EGR_NOTLV)
        {
            if (ECFM_MEMCMP (EgressMacAddress, NullMacAddress,
                             ECFM_MAC_ADDR_LENGTH) == 0)
            {
                CliPrintf (CliHandle, "%-17s", "       -");
            }
            else
            {
                /* Egress MAC */
                ECFM_MEMSET (au1String, ECFM_INIT_VAL,
                             ECFM_CLI_MAX_MAC_STRING_SIZE);
                PrintMacAddress (EgressMacAddress, au1String);
                CliPrintf (CliHandle, "%s", au1String);
            }
        }
        else
        {
            CliPrintf (CliHandle, "%-20s", "      NONE   ");
            b1NoTlv = ECFM_TRUE;
        }

        switch (i4RetValLtrEgressAction)
        {
            case ECFM_LBLT_PORT_FILTERING_ACTION_EGR_NOTLV:
                CliPrintf (CliHandle, "%-17s", "EgrNoTlv");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_EGR_OK:
                CliPrintf (CliHandle, "%-17s", "EgrOK");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_EGR_BLOCKED:
                CliPrintf (CliHandle, "%-17s", "EgrBlocked");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_EGR_VID:
                CliPrintf (CliHandle, "%-17s", "EgrVID");
                break;
            case ECFM_LBLT_PORT_FILTERING_ACTION_EGR_DOWN:
                CliPrintf (CliHandle, "%-17s", "EgrDown");
                break;
            default:
                CliPrintf (CliHandle, "%-20s", "     -");
                break;
        }
        if (i4RetValLtrForwarded == ECFM_SNMP_TRUE)

        {
            CliPrintf (CliHandle, "%-14s", "Forwarded");
        }

        else

        {
            if (i4RetValLtrTerminalMep == ECFM_SNMP_TRUE)

            {
                CliPrintf (CliHandle, "%-14s", "Terminal MEP");
            }

            else

            {
                CliPrintf (CliHandle, "%-14s", "Not Forwarded");
            }
        }

        u4PagingStatus = CliPrintf (CliHandle, "\r\n\r\n");
        UNUSED_PARAM (u4PagingStatus);
    }

    for (u2Counter = 0; u2Counter < u2NoOfEntries; u2Counter++)
    {
        /* Clear Mgmt address  */
        ECFM_MEMSET (&RetLtrManAddr, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1LtrManAddr, ECFM_INIT_VAL, ECFM_MAX_MAN_ADDR_LEN);
        RetLtrManAddr.pu1_OctetList = au1LtrManAddr;

        /* Clear Mgmt address domain */
        ECFM_MEMSET (&RetLtrManAddrDom, ECFM_INIT_VAL, sizeof (tSNMP_OID_TYPE));
        ECFM_MEMSET (au4LtrManAddrDom, ECFM_INIT_VAL,
                     ECFM_MAX_TRANSPORT_DOMAIN_LEN * sizeof (UINT4));
        RetLtrManAddrDom.pu4_OidList = au4LtrManAddrDom;

        /* Clear Ingress PortId  */
        ECFM_MEMSET (RetLtrIngrPortId.pu1_OctetList, ECFM_INIT_VAL,
                     ECFM_PORT_ID_LENGTH);

        /* Clear Egress PortId  */
        ECFM_MEMSET (RetLtrEgrPortId.pu1_OctetList, ECFM_INIT_VAL,
                     ECFM_PORT_ID_LENGTH);

        i4RetValLtrIngressAction = 0;
        i4RetValLtrEgressAction = 0;
        i4RetLtrIngPortIdSubtype = 0;
        i4RetLtrEgrPortIdSubtype = 0;

        /* Get Ingress Action Value */
        nmhGetFsMIEcfmLtrIngress (u4ContextId, u4MdIndex, u4MaIndex,
                                  u4MepId, u4LtrSeqNum,
                                  pLtrCacheIndices[u2Counter].u2RcvOrder,
                                  &i4RetValLtrIngressAction);

        /* Get Egress Action Value */
        nmhGetFsMIEcfmLtrEgress (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                                 u4LtrSeqNum,
                                 pLtrCacheIndices[u2Counter].u2RcvOrder,
                                 &i4RetValLtrEgressAction);

        /* Get Management Address Domain */
        nmhGetFsMIEcfmLtrManAddressDomain (u4ContextId, u4MdIndex,
                                           u4MaIndex, u4MepId,
                                           u4LtrSeqNum,
                                           pLtrCacheIndices[u2Counter].
                                           u2RcvOrder, &RetLtrManAddrDom);

        /* Get Management Address */
        nmhGetFsMIEcfmLtrManAddress (u4ContextId, u4MdIndex,
                                     u4MaIndex, u4MepId,
                                     u4LtrSeqNum,
                                     pLtrCacheIndices[u2Counter].
                                     u2RcvOrder, &RetLtrManAddr);

        /* Get Ingress PortId Subtype */
        nmhGetFsMIEcfmLtrIngressPortIdSubtype (u4ContextId, u4MdIndex,
                                               u4MaIndex, u4MepId,
                                               u4LtrSeqNum,
                                               pLtrCacheIndices[u2Counter].
                                               u2RcvOrder,
                                               &i4RetLtrIngPortIdSubtype);

        /* Get Ingress PortId */
        nmhGetFsMIEcfmLtrIngressPortId (u4ContextId, u4MdIndex,
                                        u4MaIndex, u4MepId,
                                        u4LtrSeqNum,
                                        pLtrCacheIndices[u2Counter].
                                        u2RcvOrder, &RetLtrIngrPortId);

        /* Get Egress PortId Subtype */
        nmhGetFsMIEcfmLtrEgressPortIdSubtype (u4ContextId, u4MdIndex,
                                              u4MaIndex, u4MepId,
                                              u4LtrSeqNum,
                                              pLtrCacheIndices[u2Counter].
                                              u2RcvOrder,
                                              &i4RetLtrEgrPortIdSubtype);

        /* Get Egress PortId */
        nmhGetFsMIEcfmLtrEgressPortId (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId,
                                       u4LtrSeqNum,
                                       pLtrCacheIndices[u2Counter].
                                       u2RcvOrder, &RetLtrEgrPortId);

        CliPrintf (CliHandle, "HOPS - %-4d:",
                   u4Ttl - ((UINT4) pLtrCacheIndices[u2Counter].u1Ttl));
        CliPrintf (CliHandle, "\r\n");
        CliPrintf (CliHandle, "------------");
        CliPrintf (CliHandle, "\r\n");

        /* The value 'zeroDotZero' (from RFC2578) indicates 'no management
         * address was present in the LTR', in which case the related
         * object dot1agCfmMepDbManAddress MUST have a zero-length OCTET
         * STRING as a value.
         * REFERENCE "802.1ag clauses 12.14.7.5.3:j, 21.5.3.5, 21.9.6 "
         */
        if (RetLtrManAddrDom.u4_Length != 0)
        {
            if (RetLtrManAddr.i4_Length == IPVX_IPV4_ADDR_LEN)
            {
                CliPrintf (CliHandle, "LTR Management Address: %d.%d.%d.%d",
                           RetLtrManAddr.pu1_OctetList[ECFM_INDEX_ZERO],
                           RetLtrManAddr.pu1_OctetList[ECFM_INDEX_ONE],
                           RetLtrManAddr.pu1_OctetList[ECFM_INDEX_TWO],
                           RetLtrManAddr.pu1_OctetList[ECFM_INDEX_THREE]);
                CliPrintf (CliHandle, "\r\n");
            }
            else if (RetLtrManAddr.i4_Length == IPVX_IPV6_ADDR_LEN)
            {
                CliPrintf (CliHandle, "LTR Management Address: ");
                for (u2Index = 0; u2Index < IPVX_IPV6_ADDR_LEN; u2Index++)
                {
                    CliPrintf (CliHandle, "%d",
                               RetLtrManAddr.pu1_OctetList[u2Index]);
                    CliPrintf (CliHandle, "%s",
                               ((u2Index + 1) % 4) ? "." : ":");
                }
                CliPrintf (CliHandle, "\r\n");
            }
        }
        else
        {
            CliPrintf (CliHandle,
                       "LTR Management Address: No management address was present in the LTR");
            CliPrintf (CliHandle, "\r\n");

        }

        /* The value ingNoTlv(0) indicates that no Reply Ingress TLV was
         * returned in the LTM."
         * REFERENCE "802.1ag clauses 12.14.7.5.3:k and 20.36.2.6"
         */
        if (i4RetValLtrIngressAction !=
            ECFM_LBLT_PORT_FILTERING_ACTION_ING_NOTLV)
        {
            CliPrintf (CliHandle, "Ingress PortId Subtype: %d",
                       i4RetLtrIngPortIdSubtype);
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "Ingress PortId        : %s",
                       RetLtrIngrPortId.pu1_OctetList);
            CliPrintf (CliHandle, "\r\n");
        }
        else
        {
            CliPrintf (CliHandle, "Ingress PortId Subtype: NONE");
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "Ingress PortId        : NONE");
            b1NoTlv = ECFM_TRUE;
            CliPrintf (CliHandle, "\r\n");
        }

        /* The value egrNoTlv(0) indicates that no Reply Egress TLV was
         * returned in the LTM."
         * REFERENCE "802.1ag clauses 12.14.7.5.3:o and 20.36.2.10"
         */
        if (i4RetValLtrEgressAction !=
            ECFM_LBLT_PORT_FILTERING_ACTION_EGR_NOTLV)
        {
            CliPrintf (CliHandle, "Egress PortId Subtype : %d",
                       i4RetLtrEgrPortIdSubtype);
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "Egress PortId         : %s",
                       RetLtrEgrPortId.pu1_OctetList);
            CliPrintf (CliHandle, "\r\n");
        }
        else
        {
            CliPrintf (CliHandle, "Egress PortId Subtype : NONE");
            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "Egress PortId         : NONE");
            b1NoTlv = ECFM_TRUE;
            CliPrintf (CliHandle, "\r\n");
        }
        CliPrintf (CliHandle, "\r\n");

    }

    if (b1NoTlv == ECFM_TRUE)
    {
        CliPrintf (CliHandle,
                   "Note: NONE - Values Not Applicable as No Tlv values was present in the CCM");
        CliPrintf (CliHandle, "\r\n\r\n");
    }

    if (i4RetValLtrRelayAction != ECFM_LTR_RLY_HIT)
    {
        PrintMacAddress (TargetMacAddress, au1String);
        au1String[ECFM_INDEX_SEVENTEEN] = '\0';
        i4PrintVlanId = (i4RetVlanId != 0) ? i4RetVlanId : i4RetMaVlanId;
#ifdef VSI_WANTED
        if (EcfmUtilCfaIsVsiId (i4PrintVlanId) == ECFM_SUCCESS)
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with VsiId %d Failed \r\n",
                       au1String, au1StrMdName, i4RetLevel, i4PrintVlanId);
        }
        else if (i4PrintVlanId < ECFM_INTERNAL_ISID_MIN)
#else
        if (i4PrintVlanId < ECFM_INTERNAL_ISID_MIN)
#endif
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with vlanId %d Failed \r\n",
                       au1String, au1StrMdName, i4RetLevel, i4PrintVlanId);
        }
        else
        {
            CliPrintf (CliHandle,
                       "\r\n Traceroute to Macaddress %s in domain  %s "
                       " at level %d \r\n with Isid %d Failed \r\n", au1String,
                       au1StrMdName, i4RetLevel,
                       ECFM_ISID_INTERNAL_TO_ISID (i4PrintVlanId));

        }
    }

    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetNoOfLtrNodes
 * 
 *     DESCRIPTION      : This function returns the no of nodes in LTR cache.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context ID
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : UINT4
 *    
 ******************************************************************************/
PRIVATE UINT4
EcfmGetNoOfLtrNodes (UINT4 u4ContextId)
{
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetCacheSts = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4LtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4LtrRcvOrder = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextLtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4NextLtrRcvOrder = ECFM_INIT_VAL;
    UINT4               u4Count = ECFM_INIT_VAL;
    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetFsMIEcfmLtrCacheStatus (u4ContextId, &i4RetCacheSts) ==
        SNMP_FAILURE)

    {
        return 0;
    }
    if (i4RetCacheSts != ECFM_ENABLE)

    {
        return 0;
    }

    /* Check if LTR Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmLtrTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4LtrSeqNum, 0,
         &u4LtrRcvOrder) == SNMP_FAILURE)

    {
        return 0;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return 0;
    }
    while (i4RetVal == SNMP_SUCCESS)

    {
        u4Count = u4Count + ECFM_INCR_VAL;

        /* Move to next Ltr entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmLtrTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier,
                                                    u4LtrSeqNum,
                                                    &u4NextLtrSeqNum,
                                                    u4LtrRcvOrder,
                                                    &u4NextLtrRcvOrder);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                return u4Count;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4LtrSeqNum = u4NextLtrSeqNum;
            u4LtrRcvOrder = u4NextLtrRcvOrder;
        }
    }
    return u4Count;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowLtCache
 *                                                                          
 *     DESCRIPTION      : This function will display the contents of LinkTrace
 *                        cache.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                                                      
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowLtCache (tCliHandle CliHandle, UINT4 u4ContextId)
{
    INT4                i4RetLtrCacheStatus = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4PrevContextId = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4RetLtrCacheSize = ECFM_INIT_VAL;
    UINT4               u4LtrNodes = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4LtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4LtrRcvOrder = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepId = ECFM_INIT_VAL;
    UINT4               u4PrevLtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4PrevLtrRcvOrder = ECFM_INIT_VAL;
    UINT2               u2NoOfEntries = ECFM_INIT_VAL;
    UINT4               u4RetValLtrTtl = ECFM_INIT_VAL;
    tEcfmLtrCacheIndices *pLtrCacheIndices = NULL;
    if (nmhGetFsMIEcfmLtrCacheStatus (u4ContextId, &i4RetLtrCacheStatus)
        != SNMP_SUCCESS)

    {
        return CLI_SUCCESS;
    }

    /* Check if LTR cache is disabled */
    if (i4RetLtrCacheStatus != ECFM_ENABLE)

    {
        CLI_SET_ERR (CLI_ECFM_LTR_CACHE_SHOW_ERR);
        return CLI_FAILURE;
    }
    u4LtrNodes = EcfmGetNoOfLtrNodes (u4ContextId);
    if (u4LtrNodes == 0)

    {
        return CLI_SUCCESS;
    }
    i4PrevContextId = (INT4) (u4ContextId);
    if (nmhGetFsMIEcfmLtrCacheSize (u4ContextId, &i4RetLtrCacheSize)
        != SNMP_FAILURE)

    {
        CliPrintf (CliHandle,
                   "\r\n LTR cache configured maximum size : %d entries \r\n",
                   i4RetLtrCacheSize);
    }

    /* Check if there is any node in Ltr Table */
    if (nmhGetNextIndexFsMIEcfmLtrTable
        (i4PrevContextId, (UINT4 *) &i4CurrContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepId, 0, &u4LtrSeqNum, 0,
         &u4LtrRcvOrder) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4CurrContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }

    /*Allocate memory for all required entries */
    pLtrCacheIndices = EcfmAllocateLtrMemBlk ();
    if (pLtrCacheIndices == NULL)

    {
        return CLI_FAILURE;
    }

    ECFM_MEMSET (pLtrCacheIndices, ECFM_INIT_VAL,
                 (u4LtrNodes * sizeof (tEcfmLtrCacheIndices)));

    /* Scanning Ltr Table */
    while (i4RetVal == SNMP_SUCCESS)

    {

        /* Ltr Ttl */
        nmhGetFsMIEcfmLtrTtl (i4CurrContextId, u4MdIndex, u4MaIndex,
                              u4MepId, u4LtrSeqNum, u4LtrRcvOrder,
                              &u4RetValLtrTtl);
        if (u2NoOfEntries == 0)

        {

            /* Store the previous values */
            i4PrevContextId = i4CurrContextId;
            u4PrevMdIndex = u4MdIndex;
            u4PrevMaIndex = u4MaIndex;
            u4PrevMepId = u4MepId;
            u4PrevLtrSeqNum = u4LtrSeqNum;
            u4PrevLtrRcvOrder = u4LtrRcvOrder;

            /* Set the entry corresponding required values in array */
            pLtrCacheIndices[u2NoOfEntries].u1Ttl = (UINT1) u4RetValLtrTtl;
            pLtrCacheIndices[u2NoOfEntries].u2RcvOrder = (UINT2) u4LtrRcvOrder;
            u2NoOfEntries = u2NoOfEntries + ECFM_INCR_VAL;
        }

        else

        {

            /* Check if it is for the same MEP and Ltm Sequence Number */
            if ((i4PrevContextId == i4CurrContextId) &&
                (u4PrevMdIndex == u4MdIndex) &&
                (u4PrevMaIndex == u4MaIndex) &&
                (u4PrevMepId == u4MepId) && (u4PrevLtrSeqNum == u4LtrSeqNum))

            {

                /* Set the entry corresponding required values in array */
                pLtrCacheIndices[u2NoOfEntries].u1Ttl = (UINT1) u4RetValLtrTtl;
                pLtrCacheIndices[u2NoOfEntries].u2RcvOrder =
                    (UINT2) u4LtrRcvOrder;
                u2NoOfEntries = u2NoOfEntries + ECFM_INCR_VAL;
                u4PrevLtrRcvOrder = u4LtrRcvOrder;
                i4PrevContextId = i4CurrContextId;
            }

            else

            {

                /* Show LTRs for a MEP for a particular TransactionID */
                EcfmShowLtrsForATransId (CliHandle, i4PrevContextId,
                                         pLtrCacheIndices, u2NoOfEntries,
                                         u4PrevMdIndex, u4PrevMaIndex,
                                         u4PrevMepId, u4PrevLtrSeqNum);
                u2NoOfEntries = ECFM_INIT_VAL;
                u4RetValLtrTtl = ECFM_INIT_VAL;
                ECFM_MEMSET (pLtrCacheIndices, ECFM_INIT_VAL,
                             (u4LtrNodes * sizeof (tEcfmLtrCacheIndices)));
                continue;
            }
        }

        /* Move to next Ltr entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmLtrTable (i4PrevContextId,
                                                    (UINT4 *)
                                                    &i4CurrContextId,
                                                    u4PrevMdIndex,
                                                    &u4MdIndex,
                                                    u4PrevMaIndex,
                                                    &u4MaIndex,
                                                    u4PrevMepId, &u4MepId,
                                                    u4PrevLtrSeqNum,
                                                    &u4LtrSeqNum,
                                                    u4PrevLtrRcvOrder,
                                                    &u4LtrRcvOrder);
        if (i4PrevContextId != i4CurrContextId)

        {
            i4RetVal = SNMP_FAILURE;
        }
    }
    if (u2NoOfEntries > 0)

    {
        EcfmShowLtrsForATransId (CliHandle, i4PrevContextId, pLtrCacheIndices,
                                 u2NoOfEntries, u4PrevMdIndex, u4PrevMaIndex,
                                 u4PrevMepId, u4PrevLtrSeqNum);
    }

    /*  Free the memory allocated for LTR indices */
    if (pLtrCacheIndices != NULL)

    {
        EcfmFreeLtrMemBlk ((UINT1 *) pLtrCacheIndices);
        pLtrCacheIndices = NULL;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigRemoteMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into MaMepList database config 
 *                        mode. New Static remote Mep will be associated with an
 *                        MA, if any MEP with same MEP Id does not exists.
 *                                                                           
 *     INPUT            : u4MepId     - MepIdentifier
 *                        u4VlanId    - VlanId
 *
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigRemoteMep (tCliHandle CliHandle, UINT4 u4MepIdentifier,
                        UINT4 u4VlanId, UINT1 *pu1MaName)
{

    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVlanId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetRowStatus = ECFM_INIT_VAL;
    INT4                i4RetCompRowStatus = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    UNUSED_PARAM (CliHandle);
    /* Get MdIndex from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    if (nmhGetNextIndexDot1agCfmMaNetTable (u4PromptMdIndex, &u4MdIndex,
                                            0, &u4MaIndex) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return CLI_FAILURE;
    }

    if (u4PromptMdIndex != u4MdIndex)
    {
        return CLI_FAILURE;
    }

    /* Scan Ma table for VlanId */
    while (i4RetVal == SNMP_SUCCESS)

    {
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetPrimaryVlanId);
        nmhGetDot1agCfmMaNetRowStatus (u4MdIndex, u4MaIndex, &i4RetRowStatus);
        nmhGetIeee8021CfmMaCompRowStatus (ECFM_CC_CURR_CONTEXT_ID (), u4MdIndex,
                                          u4MaIndex, &i4RetCompRowStatus);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        ECFM_MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        /* Check if this is the required Ma entry */
        if ((i4RetRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
            (i4RetCompRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
            (u4RetPrimaryVlanId == u4VlanId) &&
            ((pu1MaName == NULL)
             || (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)))
        {

            /* Required MA Entry found */
            /* Check if MepList entry creation is possible */
            if (nmhTestv2Dot1agCfmMaMepListRowStatus
                (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_ROW_STATUS_CREATE_AND_GO) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }

            /* Create MepList Entry */
            if (nmhSetDot1agCfmMaMepListRowStatus
                (u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_ROW_STATUS_CREATE_AND_GO) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }

            /* Mep List entry creation successful */
            return CLI_SUCCESS;
        }

        /* move to next MA */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    /* No such MA entry exists */
    CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_VLAN_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteRemoteMep                        
 *                                                                           
 *     DESCRIPTION      : This function deletes remote MEP   
 *                                                                           
 *     INPUT            : u4MepIdentifier - u4MepIdentifier of Remote MEP
 *                        u4VlanId -        VlanId       
 *                        
 *                                                                          
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                         
 ******************************************************************************/
INT4
EcfmCliDeleteRemoteMep (tCliHandle CliHandle, UINT4 u4MepIdentifier,
                        UINT4 u4VlanId, UINT1 *pu1MaName)
{
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMaName;

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    /* Get MdIndex from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    /*Get first index */
    i4RetVal = nmhGetNextIndexDot1agCfmMaNetTable (u4PromptMdIndex, &u4MdIndex,
                                                   0, &u4MaIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_RMEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    if (u4PromptMdIndex != u4MdIndex)
    {
        return CLI_FAILURE;
    }

    while (i4RetVal == SNMP_SUCCESS)
    {

        /* Get u4MaIndex's name */
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetMaPrimaryVid);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Check if this is the required association */
        if ((u4RetMaPrimaryVid == u4VlanId) &&
            ((pu1MaName == NULL)
             || (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)))
        {
            /*That particular entry found */
            /* Now make this row status to DESTROY */
            if (nmhTestv2Dot1agCfmMaMepListRowStatus
                (&u4ErrCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            nmhSetDot1agCfmMaMepListRowStatus (u4MdIndex, u4MaIndex,
                                               u4MepIdentifier,
                                               ECFM_ROW_STATUS_DESTROY);

            /* Remote MEP deleted successfully */
            return CLI_SUCCESS;
        }

        /* Get next index */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_RMEP_NOT_PRESENT_ERR);
    CliPrintf (CliHandle, " ");
    return CLI_FAILURE;
}

/**************************************************************************
 *                                                                         
 *     Function Name : EcfmStrToLevelList                                   
 *                                                                         
 *     Description   : The function is used by other modules to            
 *                     convert the given string to level list.             
 *                                                                         
 *     Input(s)      : pu1Str         : Pointer to the string.             
 *                     pu1Array  : Pointer to the string in which the      
 *                                      bits for the port list will be set 
 *                     u4ArrayLen : Array Length.     
 *                     pu2RetArrLen : No of Md Levels in the list.
 *                                                                         
 *     Output(s)     : NULL                                                
 *                                                                         
 *     Returns       : CLI_SUCCESS/CLI_FAILURE.                          
 *                                                                         
 ***************************************************************************/
PRIVATE INT4
EcfmStrToLevelList (UINT1 *pu1Str, UINT1 *pu1Array, UINT4 u4ArrayLen,
                    UINT2 *pu2RetArrLen)
{
    tCliPortList        CliList;
    INT1               *pi1Temp = (INT1 *) pu1Str;
    INT1               *pi1Pos = NULL;
    INT4                i4RetStatus = CLI_SUCCESS;
    INT4                i4RetType;
    UINT4               u4Val1;
    UINT4               u4Val2;
    INT4                i4Index;
    UINT1               u1NumOfMdLevels = ECFM_INIT_VAL;
    INT1                i1EndFlag = OSIX_FALSE;
    UNUSED_PARAM (u4ArrayLen);
    if (!(pi1Temp))
    {
        i4RetStatus = CLI_FAILURE;
    }
    while ((i4RetStatus != CLI_FAILURE) && (i1EndFlag != OSIX_TRUE))

    {
        pi1Pos = pi1Temp;

        /* Check for port list seperater delimiters */
        pi1Pos = CliGetToken (pi1Pos, CLI_LIST_DELIMIT, CLI_VALIDPORT_LIST);
        if (!pi1Pos)

        {
            i4RetStatus = CLI_FAILURE;
            break;
        }
        if (!(*pi1Pos))
        {
            i1EndFlag = OSIX_TRUE;
        }
        *pi1Pos = '\0';

        /* Get values between the list seperaters based on the type */
        i4RetType = CliGetVal (&CliList, pi1Temp);
        switch (i4RetType)

        {
            case CLI_LIST_TYPE_VAL:
                u4Val1 = (UINT1) (CliList.uPortList.u4PortNum);
                *pu1Array = (UINT1) u4Val1;
                u4Val2 = CliList.uPortList.u4PortNum;
                pu1Array++;
                u1NumOfMdLevels = u1NumOfMdLevels + ECFM_INCR_VAL;
                break;
            case CLI_LIST_TYPE_RANGE:
                u4Val1 = CliList.uPortList.PortListRange.u4PortFrom;
                u4Val2 = CliList.uPortList.PortListRange.u4PortTo;
                i4Index = (INT4) (u4Val2 - u4Val1);
                if (u4Val1 > u4Val2)

                {
                    i4RetStatus = CLI_FAILURE;
                    break;
                }
                for (; i4Index >= 0; --i4Index)

                {
                    *pu1Array = (UINT1) u4Val1++;
                    pu1Array++;
                    u1NumOfMdLevels = u1NumOfMdLevels + ECFM_INCR_VAL;
                } break;
            default:
                i4RetStatus = CLI_FAILURE;
                continue;
        }

        /* pu1PortArray will be passed as NULL from CLI lex functions.
         * This is just for checking the validity of the given port list string.
         * It doesn't converts the given port list array in to bit masks
         */
        pi1Temp = pi1Pos + 1;
    }
    *pu2RetArrLen = (UINT2) u1NumOfMdLevels;
    return i4RetStatus;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowRMepInXChkList
 *                                                                          
 *     DESCRIPTION      : This function will display the status of remote mep
 *                        mpid at a specified level or vlan.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4Type - Type of command
 *                        pu1Arg1 -  
 *                        pu1Arg2 - 
 *                        pu1Arg3 - 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowRMepInXChkList (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4Type, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                           UINT1 *pu1Arg3)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        TempMacAddr;
    tEcfmMacAddr        MacAddr;
    tSNMP_OID_TYPE      RetMepDbManAddrDom;
    tSNMP_OCTET_STRING_TYPE RetMepDbManAddr;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepId = ECFM_INIT_VAL;    /* Input Variable */
    UINT4               u4MdLevel = ECFM_INIT_VAL;    /* Input Variable */
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               au4MepDbManAddrDom[ECFM_MAX_TRANSPORT_DOMAIN_LEN];
    INT4                i4VlanId = ECFM_INIT_VAL;    /* Input Variable */
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetRMepState = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT2               u2Index = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1MepDbManAddr[ECFM_MAX_MAN_ADDR_LEN];
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1NoMgmtAddr = ECFM_FALSE;
    UINT1              *pu1MdName = NULL;    /* Input Variable */
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1              *pu1MaName = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;

    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    ECFM_MEMSET (TempMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (MacAddr, ECFM_DEF_MAC_ADDR, ECFM_MAC_ADDR_LENGTH);

    /* Scan Remote Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll))
    {
        /* Reset variables for each entry */
        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;

        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;

        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;

        /* Clear Mgmt address  */
        ECFM_MEMSET (&RetMepDbManAddr, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1MepDbManAddr, ECFM_INIT_VAL, ECFM_MAX_MAN_ADDR_LEN);
        RetMepDbManAddr.pu1_OctetList = au1MepDbManAddr;

        /* Clear Mgmt address domain */
        ECFM_MEMSET (&RetMepDbManAddrDom, ECFM_INIT_VAL,
                     sizeof (tSNMP_OID_TYPE));
        ECFM_MEMSET (au4MepDbManAddrDom, ECFM_INIT_VAL,
                     ECFM_MAX_TRANSPORT_DOMAIN_LEN * sizeof (UINT4));
        RetMepDbManAddrDom.pu4_OidList = au4MepDbManAddrDom;

        /* Get the required variables */
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMepDbMacAddress (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier,
                                       u4RMepIdentifier, &RetMacAddr);
        nmhGetFsMIEcfmMepDbRMepState (i4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      u4RMepIdentifier, &i4RetRMepState);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);

        nmhGetFsMIEcfmMepDbManAddressDomain (i4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             u4RMepIdentifier,
                                             &RetMepDbManAddrDom);

        nmhGetFsMIEcfmMepDbManAddress (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                       u4MepIdentifier, u4RMepIdentifier,
                                       &RetMepDbManAddr);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Search for remote MEPs satisfying the conditions according to particular
         * command type */
        switch (u4Type)
        {
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_SER:
                /* Get Input parameters according to type of the command */
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_SER:
                /* Get Input parameters according to type of the command */
                pu1MaName = (UINT1 *) pu1Arg3;
                if ((STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VSI:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (u4RMepId == u4RMepIdentifier)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM_VLAN_UNAWARE:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (u4RMepId == u4RMepIdentifier)
                    && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_DOM:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;

                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (u4RMepId == u4RMepIdentifier))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VSI:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV_VLAN_UNAWARE:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_LEV:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VSI:
                pu1MdName = (UINT1 *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;

                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM_VLAN_UNAWARE:
                pu1MdName = (UINT1 *) pu1Arg1;

                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;

                if (STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VSI:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV_VLAN_UNAWARE:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((UINT4) (i4RetMdLevel) == u4MdLevel)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VSI:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID_VLAN_UNAWARE:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4RMepIdentifier == u4RMepId) && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_MPID:
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4RMepIdentifier == u4RMepId)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_ISID:
            case CLI_ECFM_SHOW_RMEP_XCHK_VLAN:
            case CLI_ECFM_SHOW_RMEP_XCHK_VSI:
                i4VlanId = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetPrimaryVid == i4VlanId) ||
                    (i4RetMaPrimaryVid == i4VlanId))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK_VLAN_UNAWARE:
                if ((i4RetPrimaryVid == 0) && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_XCHK:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            if (b1Header == ECFM_TRUE)
            {
                if (i4RetPrimaryVid == 0)
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\n%-6s%-5s%-6s%-6s%-9s%-8s%-11s\r\n",
                                   "RMPID", "MPID", "Level", "VSI ID", "ISID", "Mep-Up",
                                   "Remote Mac");
                    }
                    else
#endif
                    {
                CliPrintf (CliHandle, "\r\n%-6s%-5s%-6s%-6s%-9s%-8s%-11s\r\n",
                           "RMPID", "MPID", "Level", "VLAN", "ISID", "Mep-Up",
                           "Remote Mac");
                    }
                }
                else
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\n%-6s%-5s%-6s%-6s%-9s%-8s%-11s\r\n",
                                   "RMPID", "MPID", "Level", "VSI ID", "ISID", "Mep-Up",
                                   "Remote Mac");
                    }
                    else
#endif
                    {
                CliPrintf (CliHandle, "\r\n%-6s%-5s%-6s%-6s%-9s%-8s%-11s\r\n",
                           "RMPID", "MPID", "Level", "VLAN", "ISID", "Mep-Up",
                           "Remote Mac");
                    }
                }
                CliPrintf (CliHandle, "MepDb Management Address\r\n");
                b1Header = ECFM_FALSE;
            }

            /* MEPID of mep */
            CliPrintf (CliHandle, "%-6u", u4RMepIdentifier);

            /* MEPID of remote mep */
            CliPrintf (CliHandle, "%-5u", u4MepIdentifier);

            /* Level of remote mep */
            CliPrintf (CliHandle, "%-6d", i4RetMdLevel);

            /* Vlan of remote mep */
            if (i4RetPrimaryVid == 0)
            {
                if (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                {
                    CliPrintf (CliHandle, "%-6u", i4RetMaPrimaryVid);
                }
                else
                {
                    CliPrintf (CliHandle, "%-6s", "-");
                }
            }
            else
            {
                if (i4RetPrimaryVid > ECFM_VLANID_MAX)
                {
                    CliPrintf (CliHandle, "%-6s", "-");
                }
                else
                {
                    CliPrintf (CliHandle, "%-6u", i4RetPrimaryVid);
                }
            }

            if (i4RetPrimaryVid == 0)
            {
                if (i4RetMaPrimaryVid > ECFM_VLANID_MAX)
                {
                    CliPrintf (CliHandle, "%-9u",
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "%-9s", "-");
                }
            }

            /* Status of remote MEP */
            if (i4RetRMepState == ECFM_RMEP_OK)

            {
                CliPrintf (CliHandle, "%-6s", "Yes");
            }

            else

            {
                CliPrintf (CliHandle, "%-6s", "No");
            }

            if ((ECFM_MEMCMP (RetMacAddr, TempMacAddr, ECFM_MAC_ADDR_LENGTH) ==
                 0) || (ECFM_MEMCMP (RetMacAddr, MacAddr,
                                     ECFM_MAC_ADDR_LENGTH) == 0))
            {
                CliPrintf (CliHandle, "%-18s", "No entry in CCM DB");
            }
            else
            {
                CliPrintf (CliHandle, "%-2s", "");

                /* Mac address of the remote mep */
                PrintMacAddress (RetMacAddr, au1String);
                CliPrintf (CliHandle, "%s", au1String);
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");

            /* The value 'zeroDotZero' (from RFC2578) indicates 'no management
             * address was present in the CCM', in which case the related
             * object dot1agCfmMepDbManAddress MUST have a zero-length OCTET
             * STRING as a value. 
             * REFERENCE "802.1ag clauses 12.14.7.6.3:h, 21.5.3.5, 21.6.7"
             */

            /* Mep Db Management Address */
            if (RetMepDbManAddrDom.u4_Length != 0)
            {
                if (RetMepDbManAddr.i4_Length == IPVX_IPV4_ADDR_LEN)
                {
                    CliPrintf (CliHandle, "%d.%d.%d.%d",
                               RetMepDbManAddr.pu1_OctetList[ECFM_INDEX_ZERO],
                               RetMepDbManAddr.pu1_OctetList[ECFM_INDEX_ONE],
                               RetMepDbManAddr.pu1_OctetList[ECFM_INDEX_TWO],
                               RetMepDbManAddr.pu1_OctetList[ECFM_INDEX_THREE]);
                }
                else if (RetMepDbManAddr.i4_Length == IPVX_IPV6_ADDR_LEN)
                {
                    for (u2Index = 0; u2Index < IPVX_IPV6_ADDR_LEN; u2Index++)
                    {
                        CliPrintf (CliHandle, "%d",
                                   RetMepDbManAddr.pu1_OctetList[u2Index]);
                        CliPrintf (CliHandle, "%s",
                                   ((u2Index + 1) % 4) ? "." : ":");
                    }
                }
            }
            else
            {
                CliPrintf (CliHandle, "NONE");
                b1NoMgmtAddr = ECFM_TRUE;
            }
            CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId,
                                                      u4MdIndex,
                                                      &u4NextMdIndex,
                                                      u4MaIndex,
                                                      &u4NextMaIndex,
                                                      u4MepIdentifier,
                                                      &u4NextMepIdentifier,
                                                      u4RMepIdentifier,
                                                      &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1ShowAll = ECFM_FALSE;
            }

            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }

        /* Reset for next entry */
        b1Entry = ECFM_FALSE;
    }

    if (b1NoMgmtAddr == ECFM_TRUE)
    {
        CliPrintf (CliHandle,
                   "Note: NONE - No management address was present in the CCM\r\n");
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowRMep
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the remote
 *                        mep .          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Type - Type of command
 *                        pu1Arg1 -  
 *                        pu1Arg2 - 
 *                        pu1Arg3 - 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowRMep (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                 UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT1 *pu1Arg3)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        NullMacAddr;
    tEcfmMacAddr        TempMacAddr;
    tEcfmMacAddr        MacAddr;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4RMepId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4RetCcmSeqErrors = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetRMepRdi = ECFM_INIT_VAL;
    INT4                i4RetRMepState = ECFM_INIT_VAL;
    INT4                i4RetRMepPortStatus = ECFM_INIT_VAL;
    INT4                i4RetRMepInterfaceStatus = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1              *pu1MdName = NULL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1Flag = ECFM_FALSE;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1              *pu1MaName = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
#ifdef DISS_WANTED
    tEcfmCcRMepDbInfo  *pCcRMepDbInfo = NULL;
#endif

    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }
    ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (NullMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (TempMacAddr, ECFM_DEF_MAC_ADDR, ECFM_MAC_ADDR_LENGTH);

    /* Scan Remote Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll))

    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;

        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;

        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        u4RetCcmSeqErrors = ECFM_INIT_VAL;
        i4RetRMepRdi = ECFM_INIT_VAL;
        i4RetRMepState = ECFM_INIT_VAL;
        i4RetRMepPortStatus = ECFM_INIT_VAL;
        i4RetRMepInterfaceStatus = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMepDbMacAddress (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier,
                                       u4RMepIdentifier, &RetMacAddr);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepCcmSequenceErrors (i4CurrentContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            &u4RetCcmSeqErrors);
        nmhGetFsMIEcfmMepDbRMepState (i4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      u4RMepIdentifier, &i4RetRMepState);
        nmhGetFsMIEcfmMepDbRdi (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                u4MepIdentifier, u4RMepIdentifier,
                                &i4RetRMepRdi);
        nmhGetFsMIEcfmMepDbPortStatusTlv (i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4RMepIdentifier,
                                          &i4RetRMepPortStatus);
        nmhGetFsMIEcfmMepDbInterfaceStatusTlv (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex, u4MepIdentifier,
                                               u4RMepIdentifier,
                                               &i4RetRMepInterfaceStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Search for Remote Mep satisfying particular condition for particular
         * command */
        switch (u4Type)

        {
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MAC_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MaName = (UINT1 *) pu1Arg3;
                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_SER:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VSI:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_DOM:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VSI:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_LEV:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VSI:
                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4RMepIdentifier == u4RMepId) && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MPID:

                /* Get Input parameters according to type of the command */
                u4RMepId = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4RMepIdentifier == u4RMepId)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0)
                    && (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_DOM:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && ((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && ((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_LEV:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && ((UINT4) (i4RetMdLevel) == u4MdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_ISID:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VLAN:
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && ((i4RetPrimaryVid == i4VlanId)
                               || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC_VLAN_UNAWARE:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH)
                     == 0) && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_CC_MAC:

                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if (ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) ==
                    0)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_DOMAIN:

                /* Get Input parameters according to type of the command */
                pu1MdName = (UINT1 *) pu1Arg1;
                if (STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_LEVEL:

                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((UINT4) (i4RetMdLevel) == u4MdLevel)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_RMEP_ALL:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }
        if ((b1Entry == ECFM_TRUE))
        {
            b1Flag = ECFM_TRUE;
            if ((u4Type != CLI_ECFM_SHOW_RMEP_DOMAIN) &&
                (u4Type != CLI_ECFM_SHOW_RMEP_LEVEL) &&
                (u4Type != CLI_ECFM_SHOW_RMEP_ALL))

            {
                PrintMacAddress (RetMacAddr, au1String);

                /* Mac address of the remote mep */
		if((ECFM_MEMCMP (RetMacAddr, NullMacAddr, ECFM_MAC_ADDR_LENGTH) !=
					0) && (ECFM_MEMCMP (RetMacAddr, TempMacAddr,
							ECFM_MAC_ADDR_LENGTH) != 0))
		{
			PrintMacAddress (RetMacAddr, au1String);
                CliPrintf (CliHandle, "\r\nMAC Address          : %s",
                           au1String);
		}
                else
                {
			CliPrintf (CliHandle, "\r\nMAC Address          : -");
                }

                /* Domain/Level of remote mep */
                CliPrintf (CliHandle, "\r\nDomain/Level         : %s/%d",
                           au1StrMdName, i4RetMdLevel);
                if (i4RetPrimaryVid == 0)

                {
                    if (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN)

                    {
#ifdef VSI_WANTED
                        if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                        {
                            /* Vsi of remote mep */
                            CliPrintf (CliHandle,
                                       "\r\nVSI ID               : %u",
                                       i4RetMaPrimaryVid);
                        }
                        else
#endif
                        {

                        /* Vlan of remote mep */
                        CliPrintf (CliHandle,
                                   "\r\nVLAN                 : %u",
                                   i4RetMaPrimaryVid);
                    }
                    }
                    else

                    {

                        /* Unaware MEP */
                        CliPrintf (CliHandle, "\r\nVLAN                 : -");
                    }
                }
                else
                {
                    if (i4RetPrimaryVid > ECFM_VLANID_MAX)
                    {
                        CliPrintf (CliHandle, "\r\nVLAN                 : -");
                    }
                    else
                    {
#ifdef VSI_WANTED
                        if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) ==
                                ECFM_SUCCESS)
                        {
                            /* Vsi of remote mep */
                            CliPrintf (CliHandle,
                                       "\r\nVSI ID               : %u",
                                       i4RetMaPrimaryVid);
                        }
                        else
#endif
                        {

                        /* Vlan of remote mep */
                        CliPrintf (CliHandle,
                                   "\r\nVLAN                 : %u",
                                   i4RetMaPrimaryVid);
                    }
                }
                }
                if (i4RetPrimaryVid == 0)
                {
                    if (i4RetMaPrimaryVid > ECFM_VLANID_MAX)
                    {
                        /* Vlan of remote mep */
                        CliPrintf (CliHandle,
                                   "\r\nISID                 : %u",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nISID                 : -");
                    }
                }

                /* MEPID of mep */
                CliPrintf (CliHandle, "\r\nMPID                 : %u",
                           u4MepIdentifier);

                /* MEPID of remote mep */
                CliPrintf (CliHandle, "\r\nRMPID                : %u",
                           u4RMepIdentifier);
                switch (i4RetRMepState)

                {
                    case ECFM_RMEP_IDLE:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Idle");
                        break;
                    case ECFM_RMEP_START:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Start");
                        break;
                    case ECFM_RMEP_FAILED:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Failed");
                        break;
                    case ECFM_RMEP_OK:
                        CliPrintf (CliHandle, "\r\nRemote MEP State     : Ok");
                        break;
                    default:
                        break;
                }
                if (i4RetRMepState == ECFM_RMEP_OK)

                {

                    /* RDI bit of Remote MEP */
                    if (i4RetRMepRdi == ECFM_SNMP_TRUE)

                    {
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP Rdi       : True");
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP Rdi       : False");
                    }
                    switch (i4RetRMepPortStatus)

                    {
                        case ECFM_NO_PORT_STATUS_TLV:
                            CliPrintf (CliHandle,
                                       "\r\nPort Status TLV      :"
                                       " Not Received ");
                            break;
                        case ECFM_PORT_IS_BLOCKED:
                            CliPrintf (CliHandle,
                                       "\r\nPort Status TLV      : Blocked ");
                            break;
                        case ECFM_PORT_IS_UP:
                            CliPrintf (CliHandle,
                                       "\r\nPort Status TLV      : Up ");
                            break;
                        default:
                            break;
                    }
                    switch (i4RetRMepInterfaceStatus)

                    {
                        case ECFM_IS_NO_INTERFACE_STATUS_TLV:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV :"
                                       " Not Received ");
                            break;
                        case ECFM_INTERFACE_UP:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Up ");
                            break;
                        case ECFM_INTERFACE_IS_DOWN:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Down ");
                            break;
                        case ECFM_INTERFACE_IS_TESTING:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Testing ");
                            break;
                        case ECFM_INTERFACE_IS_UNKNOWN:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Unknown ");
                            break;
                        case ECFM_INTERFACE_IS_DORMANT:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Dormant ");
                            break;
                        case ECFM_INTERFACE_IS_NOT_PRESENT:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Not present ");
                            break;
                        case ECFM_INTERFACE_IS_LOWER_LAYER_DOWN:
                            CliPrintf (CliHandle,
                                       "\r\nInterface Status TLV : Lower layer"
                                       " down");
                            break;
                    }
                }
#ifdef DISS_WANTED
        /* HW RMEP-ID of the configured Remote mep */
        pCcRMepDbInfo = EcfmSnmpLwGetRMepEntry(u4MdIndex, u4MaIndex, 
                                            u4MepIdentifier, u4RMepIdentifier);
        if (pCcRMepDbInfo != NULL)
        {
                CliPrintf (CliHandle, "\r\nHW RMEP-ID           : %u",
                           pCcRMepDbInfo->u4HwRMepId);
        }
#endif
            }

            else

            {
                if (b1Header == ECFM_TRUE)
                {
                    if (i4RetPrimaryVid == 0)
                    {
#ifdef VSI_WANTED
                        if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle, "%-6s%-5s%-5s%-10s%-22s%-8s%-6s",
                                       "RMPID", "MPID", "VSI ID", "ISID", "Domain",
                                       "Level", "Mep-Up");
                        }
                        else
#endif
                        {
                    CliPrintf (CliHandle, "%-6s%-5s%-5s%-10s%-22s%-8s%-6s",
                               "RMPID", "MPID", "Vlan", "ISID", "Domain",
                               "Level", "Mep-Up");
                        }
                    }
                    else
                    {
#ifdef VSI_WANTED
                        if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle, "%-6s%-5s%-5s%-10s%-22s%-8s%-6s",
                                       "RMPID", "MPID", "VSI ID", "ISID", "Domain",
                                       "Level", "Mep-Up");
                        }
                        else
#endif
                        {
                    CliPrintf (CliHandle, "%-6s%-5s%-5s%-10s%-22s%-8s%-6s",
                               "RMPID", "MPID", "Vlan", "ISID", "Domain",
                               "Level", "Mep-Up");
                        }
                    }
                    CliPrintf (CliHandle, "\r\n");
                    b1Header = ECFM_FALSE;
                }

                /* MEPID of remote mep */
                CliPrintf (CliHandle, "%-6u", u4RMepIdentifier);

                /* MEPID of mep */
                CliPrintf (CliHandle, "%-5u", u4MepIdentifier);
                if (i4RetPrimaryVid == 0)

                {
                    if (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle, "%-6u", i4RetMaPrimaryVid);
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-6s", "-");
                    }
                }
                else
                {
                    if (i4RetPrimaryVid > ECFM_VLANID_MAX)
                    {
                        CliPrintf (CliHandle, "%-6s", "-");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-6u", i4RetPrimaryVid);
                    }
                }

                if (i4RetPrimaryVid == 0)
                {
                    if (i4RetMaPrimaryVid > ECFM_VLANID_MAX)
                    {
                        CliPrintf (CliHandle, "%-9u",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-9s", "-");
                    }
                }

                /* Domain of remote mep */
                CliPrintf (CliHandle, "%-22s", au1StrMdName);
                CliPrintf (CliHandle, "%-8u", i4RetMdLevel);

                /* Status */
                if (i4RetRMepState == ECFM_RMEP_OK)

                {
                    CliPrintf (CliHandle, "%-6s", "Yes");
                }

                else

                {
                    CliPrintf (CliHandle, "%-6s", "No");
                }
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId,
                                                      u4MdIndex,
                                                      &u4NextMdIndex,
                                                      u4MaIndex,
                                                      &u4NextMaIndex,
                                                      u4MepIdentifier,
                                                      &u4NextMepIdentifier,
                                                      u4RMepIdentifier,
                                                      &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1ShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }
    if (ECFM_FALSE == b1Flag)
    {
        if (u4RMepId != ECFM_INIT_VAL)
        {
            CliPrintf (CliHandle,
                       "RMEP Information not available " "for RMPID:%d\r\n",
                       u4RMepId);
        }
        else if ((ECFM_MEMCMP (MacAddr, NullMacAddr, ECFM_MAC_ADDR_LENGTH) !=
                  0))
        {
            PrintMacAddress (MacAddr, au1String);
            au1String[ECFM_INDEX_SEVENTEEN] = '\0';
            CliPrintf (CliHandle, "RMEP Information not available for "
                       "MAC Address:%s\r\n", au1String);
        }
        else
        {
            CliPrintf (CliHandle, "RMEP Information not available\r\n");
        }
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitY1731Lbm
 * 
 *     DESCRIPTION      : This function will initiate LBM message for the mep at
 *                        the provided domain and vlan to the destination mp.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Type of command
 *                        u4MpId - Destination MpId
 *                        pu1Arg1 - MdName/MdLevel of the MEP initiating LBM
 *                                  depending upon the type of command.
 *                        u4VlanId - VlanId of the MEP initiating LBM.
 *                        LbRequest - Variable of structure LbRequest contains
 *                        various values to be set for LBM.
 *                        u4CmdType - Start/Stop Trace route
 *                        pu1Arg2 - MaName
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitY1731Lbm (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                     UINT1 *pu1Arg1, UINT4 u4VlanIdIsid, INT4 i4IfIndex,
                     INT4 i4MepDir, tEcfmLbLtTransRequest LbRequest,
                     UINT4 u4CmdType, UINT1 *pu1Arg2, UINT4 *pu4Target)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT2               u2TotalRMeps = ECFM_INIT_VAL;
    UINT1              *pu1MdName = NULL;
    UINT1              *pu1MaName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;
    UINT1              *pau1PrintStr = NULL;
    UINT1               au1PrintStr[CLI_ECFM_PRINT_STR_LEN];
    MEMSET (au1PrintStr, 0, sizeof (au1PrintStr));
    pau1PrintStr = au1PrintStr;

    u4CurrentContextId = u4ContextId;
    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    if (u4NextContextId != u4ContextId)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get Required values corresponding to MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMaFormat (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);

        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        switch (u4Type)
        {
            case CLI_ECFM_LB_DOM_VLAN:
            case CLI_ECFM_LB_DOM_VSI:
            case CLI_ECFM_LB_DOM_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanIdIsid)
                        || (u4RetMaPrimaryVid == u4VlanIdIsid))
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4MepIfIndex == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (pu1MdName != NULL) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LB_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV_VLAN:
            case CLI_ECFM_LB_LEV_VSI:
            case CLI_ECFM_LB_LEV_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanIdIsid) ||
                     (u4RetMaPrimaryVid == u4VlanIdIsid)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_MPTP_LB_LEV_SER:
                if ((u4MdIndex == LbRequest.u4MdIndex) &&
                    (u4MaIndex == LbRequest.u4MaIndex) &&
                    (u4MepIdentifier == LbRequest.u4LocalMepId))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Required MEP found */
        if (b1Entry == ECFM_TRUE)
        {
            tEcfmMacAddr        RetMepMacAddr = {
                0
            };
            tEcfmMacAddr        MCastMacAddr = {
                0
            };
            tEcfmLbrRcvdInfo   *pLbrRcvdInfo = NULL;
            tEcfmLbrRcvdInfo   *pSavedLbrRcvdInfo = NULL;
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            UINT1               au1SrcMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];
            UINT1               au1DestMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];
            UINT1               au1PercentageLoss[ECFM_ARRAY_SIZE_32] = { 0 };
            UINT4               u4SavedUnexpLbrIn = ECFM_INIT_VAL;
            UINT4               u4SavedErrLbrIn = ECFM_INIT_VAL;
            UINT4               u4SavedBadLbrIn = ECFM_INIT_VAL;
            UINT4               u4UnexpLbrIn = ECFM_INIT_VAL;
            UINT4               u4ErrLbrIn = ECFM_INIT_VAL;
            UINT4               u4BadLbrIn = ECFM_INIT_VAL;
            UINT4               u4LbmSent = ECFM_INIT_VAL;
            UINT4               u4LbrIn = ECFM_INIT_VAL;
            UINT4               u4AvgTime = ECFM_INIT_VAL;
            UINT4               u4MinTime = ECFM_INIT_VAL;
            UINT4               u4MaxTime = ECFM_INIT_VAL;
            UINT4               u4TransId = ECFM_INIT_VAL;
            UINT4               u4CountDupLbrs = ECFM_INIT_VAL;
            UINT4               u4AvgLbrsPerResponder = ECFM_INIT_VAL;
            UINT4               u4TotalResponders = ECFM_INIT_VAL;
            UINT4               u4ExpLbrs = ECFM_INIT_VAL;
            UINT4               u4LbrsLost = ECFM_INIT_VAL;
            UINT4               u4SavedLbmOut = ECFM_INIT_VAL;
            UINT4               u4SavedValidLbrIn = ECFM_INIT_VAL;
            FLT4                f4PercentageLoss = 0.0;
            INT4                i4VlanIdIsid = ECFM_INIT_VAL;
            INT4                i4MaVlanId = ECFM_INIT_VAL;
            INT4                i4MepVlanId = ECFM_INIT_VAL;
            INT4                i4Direction = ECFM_INIT_VAL;
            INT4                i4CliRetVal = CLI_FAILURE;
            INT4                i4RetValLbrCacheStatus = ECFM_INIT_VAL;
            UINT2               u2RetMepPortNum = ECFM_INIT_VAL;
            UINT1               u1EventId = ECFM_INIT_VAL;
            ECFM_MEMSET (RetMepMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (MCastMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* Saving the foll. values for display */
            nmhGetFsMIEcfmMepLbrInOutOfOrder (u4CurrentContextId, u4MdIndex,
                                              u4MaIndex, u4MepIdentifier,
                                              &u4SavedUnexpLbrIn);
            nmhGetFsMIY1731MepBitErroredLbrIn (u4CurrentContextId, u4MdIndex,
                                               u4MaIndex, u4MepIdentifier,
                                               &u4SavedErrLbrIn);
            nmhGetFsMIEcfmMepLbrBadMsdu (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         &u4SavedBadLbrIn);
            nmhGetFsMIEcfmMepLbrIn (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &u4SavedValidLbrIn);
            nmhGetFsMIY1731MepLbmOut (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      &u4SavedLbmOut);

            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();

            nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);

            nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier,
                                        &i4Direction);
            if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
            {
                nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             (UINT4 *) &i4MepVlanId);
                nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                               u4MaIndex, &i4MaVlanId);
                if (i4MepVlanId == 0)

                {
                    i4VlanIdIsid = i4MaVlanId;
                }

                else

                {
                    i4VlanIdIsid = i4MepVlanId;
                }
                nmhGetFsMIEcfmMepMacAddress (u4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             &RetMepMacAddr);
                nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          &i4MepIfIndex);
                if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
                    ((UINT4) i4MepIfIndex, &u4CurrentContextId,
                     &u2RetMepPortNum) != ECFM_VCM_SUCCESS)
                {
                    return CLI_FAILURE;
                }
            }

            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            if (u4CmdType == CLI_ECFM_LOOPBACK_STOP)
            {
                UINT4               u4ErrorCode = ECFM_INIT_VAL;

                /* Transmit status */
                if (nmhTestv2FsMIY1731MepTransmitLbmStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

                {
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                /* Set the status */
                if (nmhSetFsMIY1731MepTransmitLbmStatus
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

                {
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                CliPrintf (CliHandle, " \r\n");
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            /* Global pointer for receiving evnts from LB initiator and receiver */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);

            do

            {
                if (pCliEvent == NULL)

                {
                    break;
                }

                pCliEvent->u4ContextId = u4ContextId;

                if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
                {
                    pCliEvent->u4PortNum = u2RetMepPortNum;
                    pCliEvent->u4VidIsid = i4VlanIdIsid;
                }
                else
                {
                    /* Used in case of MPLS-TP */
                    pCliEvent->u4MdIndex = LbRequest.u4MdIndex;
                    pCliEvent->u4MaIndex = LbRequest.u4MaIndex;
                    pCliEvent->u4LocalMepId = LbRequest.u4LocalMepId;
                }

                pCliEvent->u1MdLevel = (UINT1) i4RetMdLevel;
                pCliEvent->u1Direction = (UINT1) (i4Direction);
                TMO_SLL_Init (&(pCliEvent->Msg.List));

                if (EcfmConfigureCliSession
                    (u4CurrentContextId, u4MdIndex, u4MaIndex,
                     (UINT2) u4MepIdentifier, CliHandle,
                     ECFM_CLI_SESSION_LBM) == ECFM_FAILURE)

                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);

            /* Check if lb cli session was created succesfully */
            if (i4CliRetVal != CLI_SUCCESS)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            if ((u4Type != CLI_ECFM_LB_DOM_SER) &&
                (LbRequest.u1LbDestType != ECFM_TX_DEST_TYPE_MEPID)
                && ((i4IfIndex == 0) || (i4MepDir == 0)))
            {
                mmi_printf ("\rPing is initiated from first Possible MEP %d\n"
                            "\rPlease use Interface Index and Direction to "
                            "initiate from Specific MEP\r\n", u4MepIdentifier);
            }
            /* Configure MEP values for ping transmission */
            if (EcfmConfigY1731LbmParams
                (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, (tEcfmLbLtTransRequest *) & LbRequest,
                 &b1Err) != ECFM_SUCCESS)

            {
                if (((i4IfIndex != 0) && (i4MepDir != 0)) ||
                    (u4Type == CLI_ECFM_MPTP_LB_LEV_SER))
                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_LBM_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                /* Move to next entry */
                i4RetVal =
                    nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                     &u4NextContextId,
                                                     u4MdIndex, &u4NextMdIndex,
                                                     u4MaIndex, &u4NextMaIndex,
                                                     u4MepIdentifier,
                                                     &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_LBM_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                if (u4CurrentContextId != u4NextContextId)

                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                continue;
            }

            if (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE)

            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT, ECFM_CONTROL_PLANE_TRC,
                              "ECFM: CLI task should not enter Ping display loop"
                              " instead finish transaction and exit .\n");
                return CLI_SUCCESS;
            }

            /* Display of the initiation */
            if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
            {
                PrintMacAddress (RetMepMacAddr, au1SrcMacAddr);
                au1SrcMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
            }

            if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)
            {
                if (LbRequest.b1LbVariableBytes != ECFM_TRUE)
                {
                    if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
                    {
                        mmi_printf
                            ("\rPING %d from %s with %d(%d) bytes of data. \r\n",
                             LbRequest.u4TargetMepId, au1SrcMacAddr,
                             LbRequest.u4LbPatternSize, LbRequest.u4LbPduSize);
                    }
                    else
                    {
                        mmi_printf
                            ("\rPING to MPLS-TP Target MEP: %u with %u(%u) "
                             "bytes of data. \r\n", LbRequest.u4TargetMepId,
                             LbRequest.u4LbPatternSize, LbRequest.u4LbPduSize);
                    }
                }
                else
                {
                    if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
                    {
                        mmi_printf
                            ("\rPING %d from %s with varying bytes of data. \r\n",
                             LbRequest.u4TargetMepId, au1SrcMacAddr);
                    }
                    else
                    {
                        mmi_printf
                            ("\rPING to MPLS-TP Target MEP: %u with varying "
                             "bytes of data. \r\n", LbRequest.u4TargetMepId);
                    }
                }
            }
            else if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MIPID)
            {
                /* Currently MIP type is supported for MPLS-TP MEPs */
                if (LbRequest.b1LbVariableBytes != ECFM_TRUE)
                {
                    mmi_printf
                        ("\rPING to MPLS-TP Target MIP ICC: %s NodeId: %u "
                         "IfNum: %u with %d(%d) bytes of data. \r\n",
                         LbRequest.pu1TgtIccCode, LbRequest.u4TgtNodeId,
                         LbRequest.u4TgtIfNum,
                         LbRequest.u4LbPatternSize, LbRequest.u4LbPduSize);
                }
                else
                {
                    mmi_printf
                        ("\rPING to MPLS-TP Target MIP ICC: %s NodeId: %u "
                         "IfNum: %u with varying bytes of data. \r\n",
                         LbRequest.pu1TgtIccCode, LbRequest.u4TgtNodeId,
                         LbRequest.u4TgtIfNum);
                }
            }
            else if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_UNICAST)
            {
                PrintMacAddress (LbRequest.LbTargetMacAddr, au1DestMacAddr);
                au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
                if (LbRequest.b1LbVariableBytes != ECFM_TRUE)

                {
                    mmi_printf
                        ("\rPING %s from %s with %d(%d) bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr,
                         LbRequest.u4LbPatternSize, LbRequest.u4LbPduSize);
                }

                else

                {
                    mmi_printf
                        ("\rPING %s from %s with varying bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr);
                }
            }
            else
            {
                ECFM_GEN_MULTICAST_CLASS1_ADDR (MCastMacAddr,
                                                (UINT1) i4RetMdLevel);
                PrintMacAddress (MCastMacAddr, au1DestMacAddr);
                au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
                if (LbRequest.b1LbVariableBytes != ECFM_TRUE)

                {
                    mmi_printf
                        ("\rPING %s from %s with %d(%d) bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr,
                         LbRequest.u4LbPatternSize, LbRequest.u4LbPduSize);
                }

                else

                {
                    mmi_printf
                        ("\rPING %s from %s with varying bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr);
                }
            }

            /* release LBLT task to that loopback can begin */
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();

            do

            {

                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
                 * till the time LB Intiator or Receiver has got expired */
                
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                while (pCliEvent->u1Events != 0)
                {
                    u1EventId = EcfmGetBit (&(pCliEvent->u1Events));
                    switch (u1EventId)

                    {
                        case CLI_EV_ECFM_LBR_RECEIVED:
                            pLbrRcvdInfo = (tEcfmLbrRcvdInfo *) TMO_SLL_First
                                (&(pCliEvent->Msg.List));

                            while (pLbrRcvdInfo != NULL)
                            {
                                if (u4Type != CLI_ECFM_MPTP_LB_LEV_SER)
                                {
                                    PrintMacAddress (pLbrRcvdInfo->
                                                     RxLbrSrcMacAddr,
                                                     pau1PrintStr);
                                    pau1PrintStr[ECFM_INDEX_SEVENTEEN] = '\0';
                                }
                                else
                                {
                                    if (LbRequest.u1LbDestType ==
                                        ECFM_TX_DEST_TYPE_MEPID)
                                    {
                                        SPRINTF ((CHR1 *) pau1PrintStr,
                                                 "MEP: %u",
                                                 LbRequest.u4TargetMepId);
                                    }
                                    else
                                    {
                                        SPRINTF ((CHR1 *) pau1PrintStr,
                                                 "MIP: ICC: %s NodeId: %u IfNum: %u",
                                                 LbRequest.pu1TgtIccCode,
                                                 LbRequest.u4TgtNodeId,
                                                 LbRequest.u4TgtIfNum);
                                    }
                                }

                                switch (pLbrRcvdInfo->u1LbrType)
                                {
                                    case CLI_ECFM_VALID_LBR:
                                        mmi_printf
                                            ("\r%d bytes from %s: seq_no=%d time=%d ms\r\n",
                                             pLbrRcvdInfo->u2LbrPduSize,
                                             pau1PrintStr,
                                             pLbrRcvdInfo->u4LbrSeqNumber,
                                             pLbrRcvdInfo->u4LbrRcvTime);
                                        break;
                                    case CLI_ECFM_UNEXP_LBR:
                                        mmi_printf
                                            ("\r%d bytes from %s: seq_no=%d "
                                             "time=%d ms(!UNEXP)\r\n",
                                             pLbrRcvdInfo->u2LbrPduSize,
                                             pau1PrintStr,
                                             pLbrRcvdInfo->u4LbrSeqNumber,
                                             pLbrRcvdInfo->u4LbrRcvTime);
                                        break;
                                    case CLI_ECFM_BIT_ERR_LBR:
                                        mmi_printf
                                            ("\r%d bytes from %s: seq_no=%d "
                                             "time=%d ms(!CRC32)\r\n",
                                             pLbrRcvdInfo->u2LbrPduSize,
                                             pau1PrintStr,
                                             pLbrRcvdInfo->u4LbrSeqNumber,
                                             pLbrRcvdInfo->u4LbrRcvTime);
                                        break;
                                    case CLI_ECFM_BAD_MSDU_LBR:
                                        mmi_printf
                                            ("\r%d bytes from %s: seq_no=%d "
                                             "time=%d ms(!BAD)\r\n",
                                             pLbrRcvdInfo->u2LbrPduSize,
                                             pau1PrintStr,
                                             pLbrRcvdInfo->u4LbrSeqNumber,
                                             pLbrRcvdInfo->u4LbrRcvTime);
                                        break;
                                    case CLI_ECFM_DUP_MSG_LBR:
                                        u4CountDupLbrs = u4CountDupLbrs + 1;
                                        mmi_printf
                                            ("\r%d bytes from %s: seq_no=%d "
                                             "time=%d ms(!DUP)\r\n",
                                             pLbrRcvdInfo->u2LbrPduSize,
                                             pau1PrintStr,
                                             pLbrRcvdInfo->u4LbrSeqNumber,
                                             pLbrRcvdInfo->u4LbrRcvTime);
                                        break;
                                    default:
                                        mmi_printf
                                            ("\rfailure processing packet!! retrying!!\r\n");
                                        break;
                                }    /* end of switch */

                                pSavedLbrRcvdInfo = pLbrRcvdInfo;
                                pLbrRcvdInfo = NULL;
                                pLbrRcvdInfo =
                                    (tEcfmLbrRcvdInfo *) TMO_SLL_Next
                                    (&(pCliEvent->Msg.List),
                                     (tEcfmSllNode *) & (pSavedLbrRcvdInfo->
                                                         SllNode));
                                TMO_SLL_Delete (&(pCliEvent->Msg.List),
                                                &(pSavedLbrRcvdInfo->SllNode));
                                ECFM_FREE_MEM_BLOCK (ECFM_LBR_RCVD_INFO_POOL,
                                                     (UINT1 *)
                                                     pSavedLbrRcvdInfo);
                                pSavedLbrRcvdInfo = NULL;
                            }    /* end of while - case */
                            break;
                        case CLI_EV_ECFM_LBR_TIMEOUT:
                            mmi_printf ("\rrequest timed out: seq_no=%d\r\n ",
                                        pCliEvent->Msg.u4Msg1);
                            break;
                        case CLI_EV_ECFM_LB_TRANS_ERROR:
                            mmi_printf
                                ("\rfailure in transaction!! transaction abort!!\r\n");
                            pCliEvent->u1Events = 0;
                            u1EventId = CLI_EV_ECFM_LB_TRANS_STOP;
                            break;
                        case CLI_EV_ECFM_LB_TRANS_STOP:
                            break;
                        default:
                            mmi_printf
                                ("\runknown event received!! transaction abort!!\r\n");
                            pCliEvent->u1Events = 0;
                            u1EventId = CLI_EV_ECFM_LB_TRANS_STOP;
                            break;
                    }
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (u1EventId != CLI_EV_ECFM_LB_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;

            nmhGetFsMIY1731LbrCacheStatus (u4ContextId,
                                           &i4RetValLbrCacheStatus);

            /* Getting the current trans id */
            if (i4RetValLbrCacheStatus == ECFM_ENABLE)
            {
                nmhGetFsMIY1731MepLbmCurrentTransId (u4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     &u4TransId);
                nmhGetFsMIY1731LbStatsLbmOut (u4CurrentContextId, u4MdIndex,
                                              u4MaIndex, u4MepIdentifier,
                                              u4TransId, &u4LbmSent);
                nmhGetFsMIY1731LbStatsLbrIn (u4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             u4TransId, &u4LbrIn);
                nmhGetFsMIY1731LbStatsLbrTimeAverage (u4CurrentContextId,
                                                      u4MdIndex, u4MaIndex,
                                                      u4MepIdentifier,
                                                      u4TransId,
                                                      (INT4 *) &u4AvgTime);
                nmhGetFsMIY1731LbStatsLbrTimeMin (u4CurrentContextId, u4MdIndex,
                                                  u4MaIndex, u4MepIdentifier,
                                                  u4TransId,
                                                  (INT4 *) &u4MinTime);
                nmhGetFsMIY1731LbStatsLbrTimeMax (u4CurrentContextId, u4MdIndex,
                                                  u4MaIndex, u4MepIdentifier,
                                                  u4TransId,
                                                  (INT4 *) &u4MaxTime);
                nmhGetFsMIEcfmMepLbrInOutOfOrder (u4CurrentContextId, u4MdIndex,
                                                  u4MaIndex, u4MepIdentifier,
                                                  &u4UnexpLbrIn);
                nmhGetFsMIY1731MepBitErroredLbrIn (u4CurrentContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   &u4ErrLbrIn);
                nmhGetFsMIEcfmMepLbrBadMsdu (u4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             &u4BadLbrIn);
                nmhGetFsMIY1731LbStatsAvgLbrsPerResponder (u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           u4TransId,
                                                           &u4AvgLbrsPerResponder);
                nmhGetFsMIY1731LbStatsTotalResponders (u4CurrentContextId,
                                                       u4MdIndex, u4MaIndex,
                                                       u4MepIdentifier,
                                                       u4TransId,
                                                       &u4TotalResponders);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                u2TotalRMeps =
                    EcfmGetNumOfRMeps (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                       u4MepIdentifier);
                if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MULTICAST)

                {
                    u4ExpLbrs = u2TotalRMeps * u4LbmSent;
                    u4LbrsLost = u4ExpLbrs - u4LbrIn;
                    if ((u4LbmSent == 0) || (u4ExpLbrs == 0))

                    {

                        /* No packet sent out */
                        f4PercentageLoss = 0.0;
                    }

                    else

                    {
                        f4PercentageLoss =
                            ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) /
                             u4ExpLbrs);
                    }
                }

                else

                {
                    u4LbrsLost = u4LbmSent - u4LbrIn;
                    if (u4LbmSent == 0)

                    {

                        /* No packet sent out */
                        f4PercentageLoss = 0.0;
                    }

                    else

                    {
                        f4PercentageLoss =
                            ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) /
                             u4LbmSent);
                    }
                }
                if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

                {
                    mmi_printf ("\r--- %d ping statistics --- \r\n",
                                LbRequest.u4TargetMepId);
                }
                else if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MIPID)
                {
                    mmi_printf ("\r--- ping statistics --- \r\n");
                }
                else

                {
                    mmi_printf ("\r--- %s ping statistics --- \r\n",
                                au1DestMacAddr);
                }
                mmi_printf ("packets sent = %d, ", u4LbmSent);
                mmi_printf ("packets received = %d, ", u4LbrIn);
                SPRINTF ((CHR1 *) au1PercentageLoss, "%f", f4PercentageLoss);
                au1PercentageLoss[ECFM_INDEX_FIVE] = '%';
                au1PercentageLoss[ECFM_INDEX_SIX] = '\0';
                mmi_printf ("packets lost  = %d (%s loss), \r\n", u4LbrsLost,
                            au1PercentageLoss);
                mmi_printf ("unexpected received = %d, ",
                            u4UnexpLbrIn - u4SavedUnexpLbrIn);
                mmi_printf ("duplicate received = %d, ", u4CountDupLbrs);
                mmi_printf ("bad received = %d, \r\n",
                            u4BadLbrIn - u4SavedBadLbrIn);
                mmi_printf ("checksum errors = %d, ",
                            u4ErrLbrIn - u4SavedErrLbrIn);
                mmi_printf ("responders = %d, ", u4TotalResponders);
                mmi_printf ("average packets per responder = %d, \r\n",
                            u4AvgLbrsPerResponder);
                mmi_printf ("rtt min/avg/max = %d/%d/%d ms \r\n",
                            u4MinTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                            u4AvgTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                            u4MaxTime * ECFM_NUM_OF_TICKS_IN_A_MSEC);
            }
            else
            {
                nmhGetFsMIEcfmMepLbrIn (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier, &u4LbrIn);
                nmhGetFsMIY1731MepLbmOut (u4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          &u4LbmSent);
                u4LbmSent = u4LbmSent - u4SavedLbmOut;
                u4LbrIn = u4LbrIn - u4SavedValidLbrIn;

                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                u2TotalRMeps =
                    EcfmGetNumOfRMeps (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                       u4MepIdentifier);
                if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MULTICAST)

                {
                    u4ExpLbrs = u2TotalRMeps * u4LbmSent;
                    u4LbrsLost = u4ExpLbrs - u4LbrIn;
                    if ((u4LbmSent == 0) || (u4ExpLbrs == 0))

                    {

                        /* No packet sent out */
                        f4PercentageLoss = 0.0;
                    }

                    else

                    {
                        f4PercentageLoss =
                            ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) /
                             u4ExpLbrs);
                    }
                }

                else

                {
                    u4LbrsLost = u4LbmSent - u4LbrIn;
                    if (u4LbmSent == 0)

                    {

                        /* No packet sent out */
                        f4PercentageLoss = 0.0;
                    }

                    else

                    {
                        f4PercentageLoss =
                            ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) /
                             u4LbmSent);
                    }
                }

                if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)
                {
                    mmi_printf ("\r--- %d ping statistics --- \r\n",
                                LbRequest.u4TargetMepId);
                }
                else if (LbRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MIPID)
                {
                    mmi_printf ("\r--- ping statistics --- \r\n");
                }
                else
                {
                    mmi_printf ("\r--- %s ping statistics --- \r\n",
                                au1DestMacAddr);
                }
                mmi_printf ("packets sent = %d, ", u4LbmSent);
                mmi_printf ("packets received = %d, ", u4LbrIn);
                SPRINTF ((CHR1 *) au1PercentageLoss, "%f", f4PercentageLoss);
                au1PercentageLoss[ECFM_INDEX_FIVE] = '%';
                au1PercentageLoss[ECFM_INDEX_SIX] = '\0';
                mmi_printf ("packets lost  = %d (%s loss) \r\n", u4LbrsLost,
                            au1PercentageLoss);

            }
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                             &u4NextContextId, u4MdIndex,
                                             &u4NextMdIndex, u4MaIndex,
                                             &u4NextMaIndex, u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)

        {

            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }
    CliPrintf (CliHandle, " ");
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetY1731Status
 * 
 *     DESCRIPTION      : This function will check the status of Y1731 Module 
 *                        on port where Mep is present.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Type of command
 *                        u4MpId - Destination MpId
 *                        pu1Arg1 - MdName/MdLevel of the MEP initiating LBM
 *                                  depending upon the type of command.
 *                        u4VlanId - VlanId of the MEP initiating LBM.
 *                        LbRequest - Variable of structure LbRequest contains
 *                        various values to be set for LBM.
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmGetY1731Status (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                    UINT1 *pu1Arg1, UINT4 u4VlanId, INT4 i4IfIndex,
                    INT4 i4MepDir, UINT1 *pu1PortOperStatus, UINT1 *pu1Arg2,
                    UINT1 u1DestType, UINT4 *pu4Target)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1              *pu1MdName = NULL;
    UINT1              *pu1MaName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    u4CurrentContextId = u4ContextId;

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get Required values corresponding to MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);

        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        switch (u4Type)
        {
            case CLI_ECFM_LB_DOM_VLAN:
            case CLI_ECFM_LB_DOM_VSI:
            case CLI_ECFM_LB_DOM_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (pu1MdName != NULL) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanId)
                        || (u4RetMaPrimaryVid == u4VlanId))
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4MepIfIndex == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           u1DestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           u1DestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((pu1MdName != NULL) &&
                     (STRCMP (au1StrMdName, pu1MdName) == 0)) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LB_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           u1DestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV_VLAN:
            case CLI_ECFM_LB_LEV_VSI:
            case CLI_ECFM_LB_LEV_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           u1DestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           u1DestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            default:
                break;
        }

        /* Required MEP found */
        if (b1Entry == ECFM_TRUE)

        {
            i4MepIfIndex = ECFM_INIT_VAL;
            nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                      u4MepIdentifier, &i4MepIfIndex);
            nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4RetPortOperStatus);
            *pu1PortOperStatus = (UINT1) i4RetPortOperStatus;
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                             &u4NextContextId, u4MdIndex,
                                             &u4NextMdIndex, u4MaIndex,
                                             &u4NextMaIndex, u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)

        {

            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }
    CliPrintf (CliHandle, " ");
#ifdef DCSG_EXT_WANTED
#ifdef NPAPI_WANTED
    /* Intiating LB/LT with Mpid in Offloading case is limited */

    if (gu1EcfmHwGlobalOffEnable == FNP_TRUE)
    {
        CLI_SET_ERR (CLI_ECFM_OFFLOAD_LBM_LTM_MPID_ERR);
    }
    else
    {
#endif        
#endif
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
#ifdef DCSG_EXT_WANTED
#ifdef NPAPI_WANTED
    }
#endif   
#endif
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitLbm
 * 
 *     DESCRIPTION      : This function will initiate ECFM LBM message for the
 *                        mep at the provided domain and vlan to the destination 
 *                        MP.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Type of command
 *                        u4MpId - Destination MpId
 *                        pu1Arg2 - MdName/MdLevel of the MEP initiating LBM
 *                                  depending upon the type of command.
 *                        u4VlanId - VlanId of the MEP initiating LBM   
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitLbm (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                UINT1 *pu1Arg1, UINT4 u4VlanId, INT4 i4IfIndex, INT4 i4MepDir,
                tEcfmLbLtTransRequest LbRequest, UINT4 u4CmdType,
                UINT1 *pu1Arg2, UINT4 *pu4Target)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4LbrIn = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1              *pu1MaName = NULL;
    UINT1              *pu1MdName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;

    u4CurrentContextId = (INT4) (u4ContextId);
    if (u4CmdType == CLI_ECFM_LOOPBACK_STOP)
    {
        CLI_SET_ERR (CLI_ECFM_INVALID_ECFM_OPTIONS_ERR);
        return CLI_FAILURE;
    }

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, (UINT4 *) &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get Required values corresponding to MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        switch (u4Type)

        {
            case CLI_ECFM_LB_DOM_VLAN:
            case CLI_ECFM_LB_DOM_VSI:
            case CLI_ECFM_LB_DOM_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanId)
                        || (u4RetMaPrimaryVid == u4VlanId))
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4MepIfIndex == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_DOM_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (pu1MdName != NULL) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LB_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (pu1MaName != NULL) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV_VLAN:
            case CLI_ECFM_LB_LEV_VSI:
            case CLI_ECFM_LB_LEV_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            case CLI_ECFM_LB_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLbmTarget (CliHandle,
                                                           LbRequest.
                                                           u1LbDestType,
                                                           u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier,
                                                           pu4Target);
                }
                break;
            default:
                break;
        }

        /* Check if this entry is having this MdName and Primary Vid */
        if (b1Entry == ECFM_TRUE)

        {
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            FLT4                fSuccessRate = 0.0;
            UINT4               u4SavedLbrIn = ECFM_INIT_VAL;
            INT4                i4LbrRcvd = ECFM_INIT_VAL;
            INT4                i4Direction = ECFM_INIT_VAL;
            INT4                i4MepVlanId = ECFM_INIT_VAL;
            INT4                i4MaVlanId = ECFM_INIT_VAL;
            INT4                i4VlanIdIsid = ECFM_INIT_VAL;
            INT4                i4CliRetVal = CLI_FAILURE;
            UINT2               u2RetMepPortNum = ECFM_INIT_VAL;
            UINT1               au1Percentage[ECFM_ARRAY_SIZE_32] = { 0 };
            UINT1               u1EventId = ECFM_INIT_VAL;
            nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);
            nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier,
                                        &i4Direction);
            nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         (UINT4 *) &i4MepVlanId);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                           u4MaIndex, &i4MaVlanId);
            nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                      u4MepIdentifier, &i4MepIfIndex);
            /* Save the Number of LBRs received till now */
            nmhGetFsMIEcfmMepLbrIn (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &u4SavedLbrIn);

            if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX ((UINT4) i4MepIfIndex,
                                                    &u4CurrentContextId,
                                                     &u2RetMepPortNum)
                != ECFM_VCM_SUCCESS)
            {
                return CLI_FAILURE;
            }
            if (i4MepVlanId == 0)

            {
                i4VlanIdIsid = i4MaVlanId;
            }

            else

            {
                i4VlanIdIsid = i4MepVlanId;
            }
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
             * till the time LBI State Machine has got expired */
            /* Global pointer for receiving evnts from LB initiator and receiver */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);

            do

            {
                if (pCliEvent == NULL)

                {
                    break;
                }
                pCliEvent->u4ContextId = u4ContextId;
                pCliEvent->u4PortNum = u2RetMepPortNum;
                pCliEvent->u4VidIsid = i4VlanIdIsid;
                pCliEvent->u1MdLevel = (UINT1) i4RetMdLevel;
                pCliEvent->u1Direction = (UINT1) (i4Direction);
                TMO_SLL_Init (&(pCliEvent->Msg.List));
                if (EcfmConfigureCliSession
                    (u4CurrentContextId, u4MdIndex, u4MaIndex,
                     (UINT2) u4MepIdentifier, CliHandle,
                     ECFM_CLI_SESSION_LBM) == ECFM_FAILURE)

                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);

            /* Check if lb cli session was created succesfully */
            if (i4CliRetVal != CLI_SUCCESS)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            if ((u4Type != CLI_ECFM_LB_DOM_SER) &&
                (LbRequest.u1LbDestType != ECFM_TX_DEST_TYPE_MEPID)
                && ((i4IfIndex == 0) || (i4MepDir == 0)))
            {
                mmi_printf ("\rPing is initiated from first Possible MEP %d\n"
                            "\rPlease use Interface Index and Direction to "
                            "initiate from Specific MEP\r\n", u4MepIdentifier);
            }
            if (EcfmConfigLbmParams
                (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, (tEcfmLbLtTransRequest *) & LbRequest,
                 &b1Err) != ECFM_SUCCESS)

            {
                if ((i4IfIndex != 0) && (i4MepDir != 0))
                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_LBM_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                EcfmDeInitLbLtCliEventInfo (CliHandle);

                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();

                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                            &u4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_LBM_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                if (u4CurrentContextId != u4NextContextId)

                {
                    /* Current context entry not found */
                    b1SameContext = ECFM_FALSE;
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                continue;
            }
            if (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE)

            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT, ECFM_CONTROL_PLANE_TRC,
                              "ECFM: Only the Active node needs to send the"
                              " CLI Command Sync message .\n");

                /*Only the Active node needs to send the SyncUp message */
                return CLI_SUCCESS;
            }
            /* by default we will only send 1 lbm */
            LbRequest.u4LbMessages =
                (LbRequest.u4LbMessages == 0) ? 1 : LbRequest.u4LbMessages;
            mmi_printf ("\rSending %d Ethernet CFM loopback messages, timeout"
                        " is 5 seconds \r\n", LbRequest.u4LbMessages);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();

            do

            {

                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to
                 * block the  CLI shell* till the time LB Intiator or
                 * Receiver has got expired */
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                while (ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events != 0)

                {
                    u1EventId = EcfmGetBit (&
                                            (ECFM_LBLT_CLI_EVENT_INFO
                                             (CliHandle)->u1Events));
                    if ((u1EventId ==
                         CLI_EV_ECFM_LB_TRANS_STOP) || (u1EventId ==
                                                        CLI_EV_ECFM_LB_TRANS_ERROR))

                    {
                        break;
                    }
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (u1EventId != CLI_EV_ECFM_LB_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;

            /* show number of lbrs received */
            nmhGetFsMIEcfmMepLbrIn (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &u4LbrIn);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            i4LbrRcvd = (u4LbrIn - u4SavedLbrIn);
            if (i4LbrRcvd < 0)

            {
                i4LbrRcvd = 0;
            }
            fSuccessRate = (((FLT4) i4LbrRcvd / LbRequest.u4LbMessages) *
                            ECFM_100_PERCENT);
            SPRINTF ((CHR1 *) au1Percentage, "%f", fSuccessRate);
            au1Percentage[ECFM_INDEX_FIVE] = '\0';
            mmi_printf ("\rSuccess rate is %s percent %d/%d", au1Percentage,
                        i4LbrRcvd, LbRequest.u4LbMessages);
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)

        {

            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetLtrsForATransId
 * 
 *     DESCRIPTION      : This function will get LTRs from LTR table
 *                        correponding to a particular MEP and its 
 *                        Ltm sequence no.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier 
 *                        u4MdId- Md Index of initiating MEP
 *                        u4MaId - Ma Index initiating MEP
 *                        u4MepId - MepIdentifier of the initiating MEP
 *                        u4LtmSeqNum - Ltm Sequence Number
 *    
 *     OUTPUT           : pLtrCacheIndices - array of Ltr receive order and Ttl
 *                        pu2NoOfEntries - No of LTR entries.
 *     
 *    
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE
 *    
 ******************************************************************************/
PRIVATE INT4
EcfmGetLtrsForATransId (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdId,
                        UINT4 u4MaId, UINT4 u4MepId, UINT4 u4LtmSeqNum,
                        tEcfmLtrCacheIndices * pLtrCacheIndices,
                        UINT2 *pu2NoOfEntries)
{
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4LtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4LtrRcvOrder = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextLtrSeqNum = ECFM_INIT_VAL;
    UINT4               u4NextLtrRcvOrder = ECFM_INIT_VAL;
    UINT4               u4RetValLtrTtl = ECFM_INIT_VAL;
    UINT2               u2NoOfEntries = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmLtrTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4NextMdIndex,
         0, &u4NextMaIndex, 0, &u4NextMepIdentifier, 0, &u4NextLtrSeqNum,
         0, &u4NextLtrRcvOrder) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_FAILURE;
    }
    u4MdIndex = u4NextMdIndex;
    u4MaIndex = u4NextMaIndex;
    u4MepIdentifier = u4NextMepIdentifier;
    u4LtrSeqNum = u4NextLtrSeqNum;
    u4LtrRcvOrder = u4NextLtrRcvOrder;
    while (i4RetVal == SNMP_SUCCESS)

    {
        if (((UINT4) (i4CurrentContextId) == u4ContextId) &&
            (u4MdIndex == u4MdId) &&
            (u4MaIndex == u4MaId) &&
            (u4MepIdentifier == u4MepId) && (u4LtrSeqNum == u4LtmSeqNum))

        {
            nmhGetFsMIEcfmLtrTtl (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, u4LtrSeqNum,
                                  u4LtrRcvOrder, &u4RetValLtrTtl);
            pLtrCacheIndices[u2NoOfEntries].u2RcvOrder = (UINT2) u4LtrRcvOrder;
            pLtrCacheIndices[u2NoOfEntries].u1Ttl = (UINT1) u4RetValLtrTtl;
            u2NoOfEntries = u2NoOfEntries + 1;
            *pu2NoOfEntries = u2NoOfEntries;
            b1Entry = ECFM_TRUE;
        }

        /* Move to next Ltr entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmLtrTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier,
                                                    u4LtrSeqNum,
                                                    &u4NextLtrSeqNum,
                                                    u4LtrRcvOrder,
                                                    &u4NextLtrRcvOrder);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4LtrSeqNum = u4NextLtrSeqNum;
            u4LtrRcvOrder = u4NextLtrRcvOrder;
            i4CurrentContextId = i4NextContextId;
        }
    }
    if (b1Entry == ECFM_TRUE)

    {
        *pu2NoOfEntries = u2NoOfEntries;
        return ECFM_SUCCESS;
    }
    CliPrintf (CliHandle, "");
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitLtmForMpId
 * 
 *     DESCRIPTION      : This function will initiate LTM message for the mep at
 *                        the provided domain and vlan for the destination mp.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Type - Command Type
 *                        u4MpId - Destination MpId
 *                        pu1Arg1 - MdName/MdLevel of the initiating MEP
 *                        pu1Arg2 - VlanId of the initiating MEP
 *                        u4TxTtl - Time to live, to be included in LTR
 *                        i4RxLtrTimeout - Time for all the replies (LTR) of a
 *                        LTM to be received by the MEP
 *                        u4UseMipCcDb - To use MIP CCM DB or not for forwarding
 *                        i4MepDir - Direction of initiating MEP
 *                        i4IfIndex - Interface Index
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitLtmForMpId (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                       UINT4 u4TargetMpId, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                       UINT4 u4TxTtl, UINT1 *pu1Arg3, UINT4 u4UseMipCcDb,
                       INT4 i4MepDir, INT4 i4IfIndex, UINT1 *pu1MaName)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4VlanIdIsid = ECFM_INIT_VAL;
    UINT4               u4LtrNodes = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4Result = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    INT4                i4RxLtrTimeout = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4LtmSeqNum = ECFM_INIT_VAL;
    UINT2               u2NoOfEntries = ECFM_INIT_VAL;
    UINT2               u2RetMepPortNum = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Err = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tEcfmLtrCacheIndices *pLtrCacheIndices = NULL;
    u4CurrentContextId = u4ContextId;

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepDirection = ECFM_INIT_VAL;
        u2RetMepPortNum = ECFM_INIT_VAL;
        u4VlanIdIsid = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get the required values from corresponding MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX ((UINT4) i4MepIfIndex,
                                                &u4CurrentContextId,
                                                &u2RetMepPortNum) !=
            ECFM_VCM_SUCCESS)
        {
            return CLI_FAILURE;
        }
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);
        switch (u4Type)

        {
            case CLI_ECFM_LT_DOMAIN_VLAN:
            case CLI_ECFM_LT_DOMAIN_VSI:
            case CLI_ECFM_LT_DOMAIN_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                ECFM_MEMCPY (&u4VlanIdIsid, pu1Arg2, sizeof (UINT4));
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanIdIsid)
                        || (u4RetMaPrimaryVid == u4VlanIdIsid))
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4MepIfIndex == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLtmTarget (CliHandle,
                                                           ECFM_TX_DEST_TYPE_MEPID,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           &u4TargetMpId);
                }
                break;
            case CLI_ECFM_LT_DOMAIN:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLtmTarget (CliHandle,
                                                           ECFM_TX_DEST_TYPE_MEPID,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           &u4TargetMpId);
                }
                break;
            case CLI_ECFM_LT_DOMAIN_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                u4VlanIdIsid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((u4RetMepPrimaryVid == u4VlanIdIsid) ||
                     (u4RetMaPrimaryVid == u4VlanIdIsid)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_LEVEL_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLtmTarget (CliHandle,
                                                           ECFM_TX_DEST_TYPE_MEPID,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           &u4TargetMpId);
                }
                break;
      
            case CLI_ECFM_LT_LEVEL_VLAN:
            case CLI_ECFM_LT_LEVEL_VSI:
            case CLI_ECFM_LT_LEVEL_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                u4VlanIdIsid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanIdIsid) ||
                     (u4RetMaPrimaryVid == u4VlanIdIsid)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = EcfmCliMepValidateLtmTarget (CliHandle,
                                                           ECFM_TX_DEST_TYPE_MEPID,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           &u4TargetMpId);
                }
                break;
            case CLI_ECFM_LT_LEVEL:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0) && (i4MepIfIndex == i4IfIndex))) &&
                    ((i4MepDir == 0) ||
                     ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = EcfmCliMepValidateLtmTarget (CliHandle,
                                                           ECFM_TX_DEST_TYPE_MEPID,
                                                           u4CurrentContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           &u4TargetMpId);
                }
                break;
            default:
                break;
        }

        /* Required MEP found */
        if (b1Entry == ECFM_TRUE)

        {
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            INT4                i4CliRetVal = CLI_FAILURE;
            UINT1               u1EventId = 0;
            b1Err = ECFM_FALSE;
            i4RetPortOperStatus = ECFM_INIT_VAL;

            nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                     (INT4 *) &u4MdLevel);
            nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier, &i4MepDir);
            nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4RetPortOperStatus);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
             * till the time LBI State Machine has got expired */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);

            do

            {
                if (pCliEvent == NULL)

                {
                    break;
                }
                pCliEvent->u4ContextId = u4CurrentContextId;
                pCliEvent->u4PortNum = u2RetMepPortNum;
                pCliEvent->u4VidIsid = u4VlanIdIsid;
                pCliEvent->u1MdLevel = (UINT1) u4MdLevel;
                pCliEvent->u1Direction = (UINT1) i4MepDir;
                if (EcfmConfigureCliSession
                    (u4CurrentContextId, u4MdIndex, u4MaIndex,
                     (UINT2) u4MepIdentifier, CliHandle,
                     ECFM_CLI_SESSION_LTM) == ECFM_FAILURE)

                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);

            /* Check if lb cli session was created succesfully */
            if (i4CliRetVal != CLI_SUCCESS)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Configuring LTM params when Y1731 is enabled */
            if (i4RetPortOperStatus == ECFM_ENABLE)

            {

                /* If user has provided Timeout value */
                if (pu1Arg3 != NULL)

                {
                    i4RxLtrTimeout = (*((UINT4 *) (VOID *) pu1Arg3) /
                                      ECFM_NUM_OF_TICKS_IN_A_MSEC);
                }

                else

                {
                    i4RxLtrTimeout = ECFM_LTR_TIMEOUT_DEF_VAL;
                }
                if (EcfmConfigY1731LtmParams
                    (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4TargetMpId, NULL, u4TxTtl,
                     i4RxLtrTimeout, u4UseMipCcDb, &b1Err) != ECFM_SUCCESS)

                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_LTM_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            /* Configuring LTM params when ECFM is enabled */
            else

            {

                /* If user has provided Timeout value */
                if (pu1Arg3 != NULL)

                {
                    CLI_SET_ERR (CLI_ECFM_INVALID_ECFM_OPTIONS_ERR);
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if (EcfmConfigLtmParams
                    (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4TargetMpId, NULL, u4TxTtl,
                     u4UseMipCcDb, &b1Err) != ECFM_SUCCESS)

                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_LTM_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }
            if (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE)

            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT, ECFM_CONTROL_PLANE_TRC,
                              "ECFM: CLI task should not enter Test display loop"
                              " instead finish transaction and exit .\n");
                return CLI_SUCCESS;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            do

            {

                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to
                 * block the  CLI shell* till the time LB Intiator or
                 * Receiver has got expired */
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                while (ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events != 0)

                {
                    u1EventId = EcfmGetBit (&
                                            (ECFM_LBLT_CLI_EVENT_INFO
                                             (CliHandle)->u1Events));
                    if (u1EventId == CLI_EV_ECFM_LT_TRANS_STOP)

                    {
                        break;
                    }
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (u1EventId != CLI_EV_ECFM_LT_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;
            u4LtrNodes = EcfmGetNoOfLtrNodes (u4CurrentContextId);
            if (u4LtrNodes == 0)

            {
                CliPrintf (CliHandle, "\r%% No traceroute reply received\r\n");
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            /*Allocate memory for all required entries */
            pLtrCacheIndices = EcfmAllocateLtrMemBlk ();
            if (pLtrCacheIndices == NULL)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            ECFM_MEMSET (pLtrCacheIndices, ECFM_INIT_VAL,
                         (MAX_ECFM_LTR_CACHE_STRUCT_SIZE *
                          sizeof (tEcfmLtrCacheIndices)));

            /* Show All LTRs corresponding to this transaction */
            nmhGetFsMIEcfmMepTransmitLtmSeqNumber (u4CurrentContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   &u4LtmSeqNum);
            if (EcfmGetLtrsForATransId
                (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4LtmSeqNum, pLtrCacheIndices,
                 &u2NoOfEntries) == ECFM_SUCCESS)

            {
                if (u2NoOfEntries != 0)

                {
                    EcfmShowLtrsForATransId (CliHandle, u4CurrentContextId,
                                             pLtrCacheIndices, u2NoOfEntries,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIdentifier, u4LtmSeqNum);
                }

                else

                {
                    i4Result = ECFM_INIT_VAL;
                    nmhGetFsMIEcfmMepTransmitLtmResult (u4CurrentContextId,
                                                        u4MdIndex, u4MaIndex,
                                                        u4MepIdentifier,
                                                        &i4Result);
                    if (i4Result == ECFM_SNMP_TRUE)

                    {
                        CliPrintf (CliHandle, "\r%% No traceroute reply"
                                   " received\r\n");
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% Traceroute transaction "
                                   "unsuccessful\r\n");
                    }
                }
            }

            /*  Free the memory allocated for LTR indices */
            if (pLtrCacheIndices != NULL)

            {
                EcfmFreeLtrMemBlk ((UINT1 *) pLtrCacheIndices);
                pLtrCacheIndices = NULL;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next MEP entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }

#ifdef DCSG_EXT_WANTED
#ifdef NPAPI_WANTED
   /*  Intiating LB/LT with Mpid in Offloading case is limited */

    if (gu1EcfmHwGlobalOffEnable == FNP_TRUE)
    {
        CLI_SET_ERR (CLI_ECFM_OFFLOAD_LBM_LTM_MPID_ERR);
    }
    else
    {
#endif 
#endif
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
#ifdef DCSG_EXT_WANTED
#ifdef NPAPI_WANTED
    }
#endif 
#endif
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitLtmForMacAddr
 * 
 *     DESCRIPTION      : This function will initiate LTM message for the mep at
 *                        the provided domain and vlan for the destination mp.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context ID
 *                        u4Type - Command Type
 *                        pu1TargetMacAddr - Destination MacAddress
 *                        pu1Arg1 - MdName/MdLevel of the initiating MEP
 *                        pu1Arg2 - VlanId of the initiating MEP
 *                        u4TxTtl - Time to live, to be included in LTR
 *                        i4RxLtrTimeout - Time for all the replies (LTR) of a
 *                        LTM to be received by the MEP
 *                        u4UseMipCcDb - To use MIP CCM DB or not for forwarding
 *                        i4MepDir - Direction of initiating MEP
 *                        u4PortNum - Port of initiating MEP
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitLtmForMacAddr (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                          UINT1 *pu1TargetMacAddr, UINT1 *pu1Arg1,
                          UINT1 *pu1Arg2, UINT4 u4TxTtl, UINT1 *pu1Arg3,
                          UINT4 u4UseMipCcDb, INT4 i4MepDir, UINT4 u4PortNum,
                          UINT1 *pu1MaName)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4VlanIdIsid = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4LtrNodes = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4Result = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    INT4                i4RxLtrTimeout = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4LtmSeqNum = ECFM_INIT_VAL;
    UINT2               u2NoOfEntries = ECFM_INIT_VAL;
    UINT2               u2RetMepPortNum = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Err = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tEcfmLtrCacheIndices *pLtrCacheIndices = NULL;
    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepDirection = ECFM_INIT_VAL;
        u2RetMepPortNum = ECFM_INIT_VAL;
        u4VlanIdIsid = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get the required values from corresponding MEP entry */
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX ((UINT4) i4MepIfIndex,
                                                (UINT4 *) &i4CurrentContextId,
                                                &u2RetMepPortNum) !=
            ECFM_VCM_SUCCESS)
        {
            return CLI_FAILURE;
        }
        nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);

        /* Check the condition according to particular type of command */
        switch (u4Type)

        {
            case CLI_ECFM_LT_DOMAIN_VLAN:
            case CLI_ECFM_LT_DOMAIN_VSI:
            case CLI_ECFM_LT_DOMAIN_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                MEMCPY (&u4VlanIdIsid, pu1Arg2, sizeof (UINT4));
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanIdIsid)
                        || (u4RetMaPrimaryVid == u4VlanIdIsid))
                    && ((u4PortNum == 0)
                        || ((u4PortNum != 0)
                            && (u2RetMepPortNum == u4PortNum)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_DOMAIN:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((u4PortNum == 0) || 
                    ((u4PortNum != 0) && (u2RetMepPortNum ==  u4PortNum))) &&
                    ((i4MepDir == 0) || 
                    ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_DOMAIN_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                u4VlanIdIsid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((STRCMP (au1StrMdName, pu1MdName) == 0)) &&
                    ((STRCMP (au1StrMaName, pu1MaName) == 0)) &&
                    ((u4RetMepPrimaryVid == u4VlanIdIsid) ||
                     (u4RetMaPrimaryVid == u4VlanIdIsid)) &&
                    ((u4PortNum == 0) ||
                     ((u4PortNum != 0)
                      && (u2RetMepPortNum ==  u4PortNum)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_LEVEL_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((STRCMP (au1StrMaName, pu1MaName) == 0)) &&
                    ((u4PortNum == 0) ||
                     ((u4PortNum != 0)
                      && (u2RetMepPortNum ==  u4PortNum)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_LEVEL_VLAN:
            case CLI_ECFM_LT_LEVEL_VSI:
            case CLI_ECFM_LT_LEVEL_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                u4VlanIdIsid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanIdIsid) ||
                     (u4RetMaPrimaryVid == u4VlanIdIsid)) &&
                    ((u4PortNum == 0) ||
                     ((u4PortNum != 0)
                      && (u2RetMepPortNum == u4PortNum)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_LT_LEVEL:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
		    ((u4PortNum == 0) || 
                    ((u4PortNum != 0) && (u2RetMepPortNum == u4PortNum))) &&
                    ((i4MepDir == 0) || 
                    ((i4MepDir != 0) && (i4RetMepDirection == i4MepDir))))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Check if Required MEP found */
        if (b1Entry == ECFM_TRUE)

        {
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            INT4                i4CliRetVal = CLI_FAILURE;
            UINT1               u1EventId = 0;
            b1Err = ECFM_FALSE;
            i4RetPortOperStatus = ECFM_INIT_VAL;

            nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                     (INT4 *) &u4MdLevel);
            nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier, &i4MepDir);
            nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4RetPortOperStatus);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* Required MEP found */
            /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
             * till the time LBI State Machine has got expired */
            /* Global pointer for receiving evnts from LB initiator and receiver */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);

            do

            {
                if (pCliEvent == NULL)

                {
                    break;
                }
                pCliEvent->u4ContextId = i4CurrentContextId;
                pCliEvent->u4PortNum = u2RetMepPortNum;
                pCliEvent->u4VidIsid = u4VlanIdIsid;
                pCliEvent->u1MdLevel = (UINT1) u4MdLevel;
                pCliEvent->u1Direction = (UINT1) i4MepDir;
                if (EcfmConfigureCliSession
                    (i4CurrentContextId, u4MdIndex, u4MaIndex,
                     (UINT2) u4MepIdentifier, CliHandle,
                     ECFM_CLI_SESSION_LTM) == ECFM_FAILURE)

                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);

            /* Check if lb cli session was created succesfully */
            if (i4CliRetVal != CLI_SUCCESS)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Configuring LTM params when Y1731 is enabled */
            if (i4RetPortOperStatus == ECFM_ENABLE)

            {

                /* If user has provided Timeout value */
                if (pu1Arg3 != NULL)

                {
                    i4RxLtrTimeout = (*((UINT4 *) (VOID *) pu1Arg3) /
                                      ECFM_NUM_OF_TICKS_IN_A_MSEC);
                }

                else

                {
                    i4RxLtrTimeout = ECFM_LTR_TIMEOUT_DEF_VAL;
                }
                if ((u4Type != CLI_ECFM_LT_DOMAIN_SER) &&
                    ((u4PortNum == 0) || (i4MepDir == 0)))
                {
                    mmi_printf
                        ("\rTrace is initiated from first Possible MEP %d\n"
                         "\rPlease use Interface Index and Direction to "
                         "initiate from Specific MEP\r\n", u4MepIdentifier);
                }
                if (EcfmConfigY1731LtmParams
                    (CliHandle, i4CurrentContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, 0, pu1TargetMacAddr, u4TxTtl,
                     i4RxLtrTimeout, u4UseMipCcDb, &b1Err) != ECFM_SUCCESS)

                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_LTM_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
            }

            /* Configuring LTM params when Y1731 is disabled */
            else

            {

                /* If user has provided Timeout value */
                if (pu1Arg3 != NULL)

                {
                    CLI_SET_ERR (CLI_ECFM_INVALID_ECFM_OPTIONS_ERR);
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }

                if ((u4Type != CLI_ECFM_LT_DOMAIN_SER) &&
                    ((u4PortNum == 0) || (i4MepDir == 0)))
                {
                    mmi_printf
                        ("\rTrace is initiated from first Possible MEP %d\n"
                         "\rPlease use Interface Index and Direction to "
                         "initiate from Specific MEP\r\n", u4MepIdentifier);
                }

                if (EcfmConfigLtmParams
                    (CliHandle, i4CurrentContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, 0, pu1TargetMacAddr, u4TxTtl,
                     u4UseMipCcDb, &b1Err) != ECFM_SUCCESS)

                {
                    if ((u4PortNum != 0) && (i4MepDir != 0))
                    {
                        if (b1Err != ECFM_TRUE)

                        {
                            CLI_SET_ERR (CLI_ECFM_LTM_INITIATION_ERR);
                        }
                        EcfmDeInitLbLtCliEventInfo (CliHandle);
                        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                        ECFM_REGISTER_CLI_CC_LOCK ();
                        return CLI_FAILURE;
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();

                    i4RetVal =
                        nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                         (UINT4 *)
                                                         &i4NextContextId,
                                                         u4MdIndex,
                                                         &u4NextMdIndex,
                                                         u4MaIndex,
                                                         &u4NextMaIndex,
                                                         u4MepIdentifier,
                                                         &u4NextMepIdentifier);
                    if (i4RetVal == SNMP_SUCCESS)

                    {
                        u4MdIndex = u4NextMdIndex;
                        u4MaIndex = u4NextMaIndex;
                        u4MepIdentifier = u4NextMepIdentifier;
                    }
                    else
                    {
                        if (b1Err != ECFM_TRUE)

                        {
                            CLI_SET_ERR (CLI_ECFM_LTM_INITIATION_ERR);
                        }
                        return CLI_FAILURE;
                    }

                    if (i4CurrentContextId != i4NextContextId)

                    {
                        CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                        return CLI_FAILURE;
                    }
                    b1Entry = ECFM_FALSE;
                    continue;
                }
            }
            if (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE)

            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT, ECFM_CONTROL_PLANE_TRC,
                              "ECFM: CLI task should not enter Test display loop"
                              " instead finish transaction and exit .\n");
                return CLI_SUCCESS;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();

            do

            {

                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to
                 * block the  CLI shell* till the time LB Intiator or
                 * Receiver has got expired */
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                while (ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events != 0)

                {
                    u1EventId = EcfmGetBit (&
                                            (ECFM_LBLT_CLI_EVENT_INFO
                                             (CliHandle)->u1Events));
                    if (u1EventId == CLI_EV_ECFM_LT_TRANS_STOP)

                    {
                        break;
                    }
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (u1EventId != CLI_EV_ECFM_LT_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;
            u4LtrNodes = EcfmGetNoOfLtrNodes (i4CurrentContextId);
            if (u4LtrNodes == 0)

            {
                CliPrintf (CliHandle, "\r%% No traceroute reply received \r\n");
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            /*Allocate memory for all required entries */
            pLtrCacheIndices = EcfmAllocateLtrMemBlk ();
            if (pLtrCacheIndices == NULL)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            ECFM_MEMSET (pLtrCacheIndices, ECFM_INIT_VAL,
                         (u4LtrNodes * sizeof (tEcfmLtrCacheIndices)));
            nmhGetFsMIEcfmMepTransmitLtmSeqNumber (i4CurrentContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   &u4LtmSeqNum);
            if (EcfmGetLtrsForATransId
                (CliHandle, i4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4LtmSeqNum, pLtrCacheIndices,
                 &u2NoOfEntries) == ECFM_SUCCESS)

            {
                if (u2NoOfEntries != 0)

                {
                    EcfmShowLtrsForATransId (CliHandle, i4CurrentContextId,
                                             pLtrCacheIndices, u2NoOfEntries,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIdentifier, u4LtmSeqNum);
                }

                else

                {
                    i4Result = ECFM_INIT_VAL;
                    nmhGetFsMIEcfmMepTransmitLtmResult (i4CurrentContextId,
                                                        u4MdIndex, u4MaIndex,
                                                        u4MepIdentifier,
                                                        &i4Result);
                    if (i4Result == ECFM_SNMP_TRUE)

                    {
                        CliPrintf (CliHandle, "\r%% No traceroute reply"
                                   " received\r\n");
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% Traceroute transaction "
                                   "unsuccessful\r\n");
                    }
                }
            }

            /*  Free the memory allocated for LTR indices */
            if (pLtrCacheIndices != NULL)

            {
                EcfmFreeLtrMemBlk ((UINT1 *) pLtrCacheIndices);
                pLtrCacheIndices = NULL;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next MEP entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetImplicitMipEvalStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable the implicit mip
 *                        evaluation and creation of MIP.
 *                        all Meps.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status   - Mip evaluation and creation status                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetImplicitMipEvalStatus (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if MipEvaluation status can be set */
    if (nmhTestv2FsEcfmMipDynamicEvaluationStatus (&u4ErrorCode, i4Status)
        == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set the status */
    nmhSetFsEcfmMipDynamicEvaluationStatus (i4Status);
    CliPrintf (CliHandle, " ");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *    FUNCTION NAME    : EcfmCliMipCcmDbSetStatus                         
 *                                                                          
 *    DESCRIPTION      : This function will enable/disable Ecfm Mip Ccm 
 *                       Database.     
 *                                                                          
 *    INPUT            : CliHandle  - CliContext ID
 *                       i4Status   - Mip Ccm database status                     
 *                                                                          
 *    OUTPUT           : None               
 *                                                                         
 *    RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliMipCcmDbSetStatus (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    if (nmhTestv2FsEcfmMipCcmDbStatus (&u4ErrorCode, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set the status */
    if (nmhSetFsEcfmMipCcmDbStatus (i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetRestrictDynMipEvalStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will restrict the implicit mip
 *                        evaluation and creation of MIP.
 *                        all Meps.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u2Level   - Mip evaluation and creation level
 *                        u4VlanIdIsid - VlanId / ISID
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetRestrictDynMipEvalStatus (tCliHandle CliHandle, UINT4 u4IfIndex,
                                    UINT2 u2Level, UINT4 u4VlanIdIsid)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    UNUSED_PARAM (CliHandle);

    if (nmhTestv2FsEcfmDynMipPreventionRowStatus (&u4ErrorCode,
                                                  u4IfIndex,
                                                  u2Level,
                                                  u4VlanIdIsid,
                                                  ECFM_ROW_STATUS_CREATE_AND_GO)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsEcfmDynMipPreventionRowStatus (u4IfIndex,
                                               u2Level,
                                               u4VlanIdIsid,
                                               ECFM_ROW_STATUS_CREATE_AND_GO)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;

    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliReSetRestrictDynMipEvalStatus                   
 *                                                                          
 *     DESCRIPTION      : This function will clear the restrict the implicit 
 *                        mip evaluation and creation of MIP all Meps.     
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u2Level   - Mip evaluation and creation level
 *                        u4VlanIdIsid - VlanId / ISID
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliReSetRestrictDynMipEvalStatus (tCliHandle CliHandle, UINT4 u4IfIndex,
                                      UINT2 u2Level, UINT4 u4VlanIdIsid)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    if (nmhTestv2FsEcfmDynMipPreventionRowStatus (&u4ErrorCode,
                                                  u4IfIndex,
                                                  u2Level,
                                                  u4VlanIdIsid,
                                                  ECFM_ROW_STATUS_DESTROY)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsEcfmDynMipPreventionRowStatus (u4IfIndex,
                                               u2Level,
                                               u4VlanIdIsid,
                                               ECFM_ROW_STATUS_DESTROY)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;

    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliMepArchiveSetHoldTime                               
 *                                                                          
 *     DESCRIPTION      : This function will set/reset Ecfm Mep archive 
 *                        hold time.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        i4HoldTime - Hold Time to be set                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliMepArchiveSetHoldTime (tCliHandle CliHandle, INT4 i4HoldTime)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;

    /* Get MdIndex from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();
    if (nmhTestv2FsEcfmMepArchiveHoldTime
        (&u4ErrorCode, u4PromptMdIndex, i4HoldTime) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set the hold time */
    if (nmhSetFsEcfmMepArchiveHoldTime (u4PromptMdIndex, i4HoldTime) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliMipCcmDbSetHoldTimeOrSize                               
 *                                                                          
 *     DESCRIPTION      : This function will set/reset Ecfm Mip Ccm 
 *                        database parameters.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        i4SetVal - value to be set                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliMipCcmDbSetHoldTimeOrSize (tCliHandle CliHandle, UINT4 u4Command,
                                  INT4 *pi4SetVal)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4SetVal = ECFM_INIT_VAL;
    BOOL1               b1SetHoldTime = ECFM_FALSE;
    switch (u4Command)

    {
        case CLI_ECFM_CCM_DB_SET_HOLDTIME:
            b1SetHoldTime = ECFM_TRUE;
            i4SetVal = *pi4SetVal;
            break;
        case CLI_ECFM_CCM_DB_RESET_HOLDTIME:
            b1SetHoldTime = ECFM_TRUE;
            i4SetVal = ECFM_MIP_CCM_DB_DEF_HOLD_TIME;
            break;
        case CLI_ECFM_CCM_DB_SET_SIZE:
            b1SetHoldTime = ECFM_FALSE;
            i4SetVal = *pi4SetVal;
            break;
        case CLI_ECFM_CCM_DB_RESET_SIZE:
            b1SetHoldTime = ECFM_FALSE;
            i4SetVal = ECFM_MIP_CCM_DB_DEF_SIZE;
            break;
        default:
            break;
    }
    if (b1SetHoldTime == ECFM_TRUE)

    {
        if (nmhTestv2FsEcfmMipCcmDbHoldTime (&u4ErrorCode, i4SetVal) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Set the hold time */
        if (nmhSetFsEcfmMipCcmDbHoldTime (i4SetVal) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        return CLI_SUCCESS;
    }
    if (nmhTestv2FsEcfmMipCcmDbSize (&u4ErrorCode, i4SetVal) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set the size */
    if (nmhSetFsEcfmMipCcmDbSize (i4SetVal) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetSysCtrl                           
 *                                                                          
 *     DESCRIPTION      : This function will start/shutdown Ecfm Module 
 *                        globally. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4Status  - Status to be set                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetSysCtrl (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if this can be set */
    if (nmhTestv2FsEcfmSystemControl (&u4ErrorCode, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    /* Then Set the size */
    if (nmhSetFsEcfmSystemControl (i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMipVlanDefParams                           
 *                                                                          
 *     DESCRIPTION      : This function will set the parameters required 
 *                        by default Md table for MIP creation.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4VlanId  - VlanId                     
 *                        i4DefMdLevel  - Md Level                     
 *                        i4DefCriteria  - Mhf Creation                     
 *                        i4DefIdPermission  - Sender-Id Permission                     
 *                        u4Mask - Bit Mask
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMipVlanDefParams (tCliHandle CliHandle, INT4 i4VlanId,
                            INT4 i4DefMdLevel, INT4 i4DefCriteria,
                            INT4 i4DefIdPermission, UINT4 u4Mask)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    tEcfmCcMipInfo     *pMipNode = NULL;
    tEcfmCcDefaultMdTableInfo *pDefaultMdNode = NULL;

    u4ContextId = ECFM_CC_CURR_CONTEXT_ID ();
    /**Test if any MIP is associated with default-domain**/
    pDefaultMdNode = EcfmCcSnmpLwGetDefaultMdEntry ((UINT4) i4VlanId);
    if (pDefaultMdNode != NULL)
    {
        pMipNode = (tEcfmCcMipInfo *) RBTreeGetFirst (ECFM_CC_GLOBAL_MIP_TABLE);
        while (pMipNode != NULL)
        {
            if ((u4Mask != CLI_MD_DEFAULT_DOMAIN_SID) &&
                (pMipNode->u4VlanIdIsid == (UINT4) i4VlanId) &&
                (pMipNode->u1RowStatus == ACTIVE))
            {
                if (i4DefMdLevel == ECFM_DEF_MD_LEVEL_DEF_VAL)
                {
                    CLI_SET_ERR (CLI_ECFM_DEL_MIP_ERR);
                    return CLI_FAILURE;
                }
                else if ((pMipNode->u1MdLevel != (UINT1) i4DefMdLevel) &&
                         (i4DefMdLevel != 0))
                {
                    CLI_SET_ERR (CLI_ECFM_DEL_MIP_ERR);
                    return CLI_FAILURE;
                }
                else if (pMipNode->u1MdLevel == (UINT1) i4DefMdLevel)
                {
                    if ((pDefaultMdNode->u1MhfCreation != (UINT1) i4DefCriteria)
                        && (i4DefCriteria != 0))
                    {
                        CLI_SET_ERR (CLI_ECFM_DEL_MIP_ERR);
                        return CLI_FAILURE;
                    }
                }
                else if (pDefaultMdNode->u1MhfCreation != (UINT1) i4DefCriteria)
                {
                    CLI_SET_ERR (CLI_ECFM_DEL_MIP_ERR);
                    return CLI_FAILURE;
                }
            }

            pMipNode = RBTreeGetNext (ECFM_CC_GLOBAL_MIP_TABLE,
                                      (tRBElem *) pMipNode, NULL);
        }
    }
    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_LEVEL) == CLI_MD_DEFAULT_DOMAIN_LEVEL)

    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdLevel
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefMdLevel) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Md level */
        if (nmhSetFsMIEcfmExtDefaultMdLevel
            (u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefMdLevel) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_CRITERIA)
        == CLI_MD_DEFAULT_DOMAIN_CRITERIA)

    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdMhfCreation
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefCriteria) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Mhf Creation */
        if (nmhSetFsMIEcfmExtDefaultMdMhfCreation
            (u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefCriteria) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_SID) == CLI_MD_DEFAULT_DOMAIN_SID)
    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdIdPermission
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefIdPermission) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Sender id permission */
        if (nmhSetFsMIEcfmExtDefaultMdIdPermission
            (u4ContextId, ECFM_SERVICE_SELECTION_VLAN, i4VlanId,
             i4DefIdPermission) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMipIsidDefParams                           
 *                                                                          
 *     DESCRIPTION      : This function will set the parameters required 
 *                        by default Md table for MIP creation.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4VlanId  - VlanId                     
 *                        i4DefMdLevel  - Md Level                     
 *                        i4DefCriteria  - Mhf Creation                     
 *                        i4DefIdPermission  - Sender-Id Permission                     
 *                        u4Mask - Mask
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMipIsidDefParams (tCliHandle CliHandle, INT4 i4VlanId,
                            INT4 i4DefMdLevel, INT4 i4DefCriteria,
                            INT4 i4DefIdPermission, UINT4 u4Mask)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;

    u4ContextId = ECFM_CC_CURR_CONTEXT_ID ();
    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_LEVEL) == CLI_MD_DEFAULT_DOMAIN_LEVEL)
    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdLevel
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefMdLevel) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Md level */
        if (nmhSetFsMIEcfmExtDefaultMdLevel
            (u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefMdLevel) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_CRITERIA)
        == CLI_MD_DEFAULT_DOMAIN_CRITERIA)
    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdMhfCreation
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefCriteria) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Mhf Creation */
        if (nmhSetFsMIEcfmExtDefaultMdMhfCreation
            (u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefCriteria) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_SID) == CLI_MD_DEFAULT_DOMAIN_SID)
    {
        /* Test if this can be set */
        if (nmhTestv2FsMIEcfmExtDefaultMdIdPermission
            (&u4ErrorCode, u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefIdPermission) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then Set the Sender id permission */
        if (nmhSetFsMIEcfmExtDefaultMdIdPermission
            (u4ContextId, ECFM_SERVICE_SELECTION_ISID, i4VlanId,
             i4DefIdPermission) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMipDefParams                           
 *                                                                          
 *     DESCRIPTION      : This function will set the parameters required 
 *                        by default Md objects for MIP creation.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4DefMdLevel  - Md Level                     
 *                        i4DefCriteria  - Mhf Creation                     
 *                        i4DefIdPermission  - Sender-Id Permission                     
 *                        u4Mask - Mask
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMipDefParams (tCliHandle CliHandle, INT4 i4DefMdLevel,
                        INT4 i4DefCriteria, INT4 i4DefIdPermission,
                        UINT4 u4Mask)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    UNUSED_PARAM (CliHandle);

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_LEVEL) == CLI_MD_DEFAULT_DOMAIN_LEVEL)

    {
        /* Test if this can be set */
        if (nmhTestv2Dot1agCfmDefaultMdDefLevel (&u4ErrorCode, i4DefMdLevel)
            == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then Set the Md level */
        nmhSetDot1agCfmDefaultMdDefLevel (i4DefMdLevel);
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_CRITERIA)
        == CLI_MD_DEFAULT_DOMAIN_CRITERIA)

    {
        /* Test if this can be set */
        if (nmhTestv2Dot1agCfmDefaultMdDefMhfCreation
            (&u4ErrorCode, i4DefCriteria) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then Set the Mhf Creation */
        nmhSetDot1agCfmDefaultMdDefMhfCreation (i4DefCriteria);
    }

    if ((u4Mask & CLI_MD_DEFAULT_DOMAIN_SID) == CLI_MD_DEFAULT_DOMAIN_SID)

    {
        /* Test if this can be set */
        if (nmhTestv2Dot1agCfmDefaultMdDefIdPermission
            (&u4ErrorCode, i4DefIdPermission) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then Set the Sender id permission */
        nmhSetDot1agCfmDefaultMdDefIdPermission (i4DefIdPermission);
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 *                                                                          
 *    FUNCTION NAME    : EcfmGetNoOfMepsInMa 
 *                                                                          
 *    DESCRIPTION      : This function returns number of Meps in a MA. indexed
 *                       by u4MdIndex and u4MaIndex. 
 *
 *    INPUT            : u4MdId - Index of Md Table 
 *                       u4MaId - Index of Ma Table 
 *                                                                          
 *    OUTPUT           : None.
 *                                                                          
 *    RETURNS          : Number of Meps in a MA 
 *    
 *                                                                          
 ****************************************************************************/
PRIVATE UINT4
EcfmGetNoOfMepsInMa (UINT4 u4ContextId, UINT4 u4MdId, UINT4 u4MaId)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4Count = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    i4CurrentContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrentContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId, 0,
                                                      &u4MdIndex, 0,
                                                      &u4MaIndex, 0,
                                                      &u4MaMepListIndex);
    if (i4RetVal == SNMP_FAILURE)

    {
        return 0;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return 0;
    }

    /* Meplist Table not empty, now scan its each row */
    while (i4RetVal == SNMP_SUCCESS)

    {
        if ((u4MdIndex == u4MdId) && (u4MaIndex == u4MaId))

        {
            u4Count = u4Count + ECFM_INCR_VAL;
        }
        i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrentContextId,
                                                          (UINT4 *)
                                                          &i4NextContextId,
                                                          u4MdIndex,
                                                          &u4NextMdIndex,
                                                          u4MaIndex,
                                                          &u4NextMaIndex,
                                                          u4MaMepListIndex,
                                                          &u4NextMaMepListIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                return u4Count;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MaMepListIndex = u4NextMaMepListIndex;
        }
    }
    return u4Count;
}

/****************************************************************************
 *                                                                          
 *    FUNCTION NAME    : EcfmGetNoOfMPsAtPort 
 *                                                                          
 *    DESCRIPTION      : This function returns number of MEPs and MIPs at an
 *                       interface. 
 *
 *    INPUT            : u4IfIndex - Interface Index at which MPs needs to find 
 *                                                                          
 *    OUTPUT           : pu4MepCount - Number of MEPs 
 *                       pu4Mipcount - Number of MIPs
 *                                                                          
 *    RETURNS          : None. 
 *    
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmGetNoOfMPsAtPort (UINT4 u4ContextId, UINT4 u4IfIndex, UINT4 *pu4MepCount,
                      UINT4 *pu4MipCount)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIndex = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4MipMdLevel = ECFM_INIT_VAL;
    INT4                i4MipVid = ECFM_INIT_VAL;
    INT4                i4MipIfIndex = ECFM_INIT_VAL;
    INT4                i4NextMipMdLevel = ECFM_INIT_VAL;
    INT4                i4NextMipVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                (UINT4 *) &i4NextContextId,
                                                0, &u4MdIndex, 0, &u4MaIndex,
                                                0, &u4MepIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        if ((UINT4) (i4NextContextId) != u4ContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* Mep Table not empty for this context */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        nmhGetFsMIEcfmMepIfIndex (i4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIndex, &i4MepIfIndex);
        if (u4IfIndex == (UINT4) i4MepIfIndex)
        {
            *pu4MepCount = *pu4MepCount + 1;
        }
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIndex,
                                                    &u4NextMepIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrContextId != i4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIndex = u4NextMepIndex;
        }
    }
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;

    i4RetVal =
        nmhGetNextIndexFsMIEcfmMipTable ((INT4) u4IfIndex, &i4MipIfIndex, 0,
                                         &i4MipMdLevel, 0, &i4MipVid);
    while (i4RetVal == SNMP_SUCCESS)
    {
        if (u4IfIndex == (UINT4) i4MipIfIndex)
        {
            *pu4MipCount = *pu4MipCount + 1;
            i4RetVal = nmhGetNextIndexFsMIEcfmMipTable ((INT4) u4IfIndex,
                                                        &i4MipIfIndex,
                                                        i4MipMdLevel,
                                                        &i4NextMipMdLevel,
                                                        i4MipVid,
                                                        &i4NextMipVid);
        }
        else
        {
            break;
        }
        i4MipMdLevel = i4NextMipMdLevel;
        i4MipVid = i4NextMipVid;
    }
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowVlansForAPrimaryVid                        */
/*                                                                           */
/*     DESCRIPTION      : This function displays Vids associated with        */
/*                        a Primary Vid                                      */
/*                                                                           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u4PrimaryVid - Primary Vlan                        */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmShowVlansForAPrimaryVid (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4PrimaryVid)
{
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT4               u4VlanVid = ECFM_INIT_VAL;
    UINT4               u4NextVlanVid = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    UINT2               u2Count = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                 (UINT4 *) &i4NextContextId,
                                                 0, (INT4 *) &u4VlanVid);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        nmhGetFsMIEcfmVlanPrimaryVid (i4CurrContextId, u4VlanVid,
                                      (INT4 *) &u4RetPrimaryVid);
        if (u4RetPrimaryVid == u4PrimaryVid)

        {
            if (u2Count == 0)

            {
                CliPrintf (CliHandle, "%u", u4VlanVid);
                u2Count = u2Count + ECFM_INCR_VAL;
            }

            else if (u2Count < ECFM_VAL_10)

            {
                u2Count = u2Count + ECFM_INCR_VAL;
                CliPrintf (CliHandle, ", %u", u4VlanVid);
                if (u2Count == ECFM_VAL_10)

                {
                    CliPrintf (CliHandle, ",\r\n");
                    u2Count = 0;
                }
            }
        }

        /* move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                     (UINT4 *)
                                                     &i4NextContextId,
                                                     u4VlanVid,
                                                     (INT4 *) &u4NextVlanVid);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4VlanVid = u4NextVlanVid;
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
}

/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowServices                                       
 *                                                                          
 *     DESCRIPTION      : This function will show the configured associations.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId   - context Identifier  
 *                        u4Type - Command
 *                        pu1MaName     - Service Name
 *                        pu1Arg        - Domain Name or Level
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowServices (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                     UINT1 *pu1MaName, UINT1 *pu1Arg)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMegIdCode;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetNoOfVids = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4Count = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4RetMhfCreation = ECFM_INIT_VAL;
    INT4                i4RetIdPermission = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4XchkSts = ECFM_INIT_VAL;
    INT4                i4CcRole = ECFM_INIT_VAL;
    INT4                i4RetCcInterval = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = 0;
    INT4                i4MdLevel = ECFM_INIT_VAL;
#ifdef VSI_WANTED
    INT4                i4OamVlanId = ECFM_INIT_VAL;
#endif    
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMegIdCode[ECFM_UMC_CODE_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Flag = ECFM_FALSE;
    BOOL1               b1IsHeaderPrinted = ECFM_FALSE;

    i4CurrentContextId = (INT4) (u4ContextId);

    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    CliPrintf (CliHandle, "\r\n");

    /* MaTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))
    {
        i4RetMaRowStatus = ECFM_INIT_VAL;

        /* first check its row status */
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        if (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE)

        {
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;
            ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMdName.pu1_OctetList = au1RetMdName;
            RetMdName.i4_Length = 0;
            i4RetMhfCreation = ECFM_INIT_VAL;
            i4RetMdLevel = ECFM_INIT_VAL;
            i4RetPriVlanId = ECFM_INIT_VAL;
            u4RetNoOfVids = ECFM_INIT_VAL;
            i4RetIdPermission = ECFM_INIT_VAL;
            u4Count = ECFM_INIT_VAL;
            i4RetMaFormat = ECFM_INIT_VAL;

            /* Get u4MaIndex's name, primaryvlanid, no. of vids, mhf creation and
             * no. of meps associated with this MA */
            nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
            nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
            nmhGetFsMIEcfmMaNumberOfVids (i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, &u4RetNoOfVids);
            nmhGetFsMIEcfmMaMhfCreation (i4CurrentContextId, u4MdIndex,
                                         u4MaIndex, &i4RetMhfCreation);
            nmhGetFsMIEcfmMaIdPermission (i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, &i4RetIdPermission);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);
            nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex,
                                    &i4RetMdFormat);

            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);

            u4Count =
                EcfmGetNoOfMepsInMa (i4CurrentContextId, u4MdIndex, u4MaIndex);

            do
            {
                MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                             au1StrMaName);
                if ((pu1MaName != NULL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1MaName) != 0))
                {
                    break;
                }

                switch (u4Type)
                {
                    case CLI_ECFM_SHOW_SERVICE_DOM_BRIEF:
                    case CLI_ECFM_SHOW_SERVICE_DOMAIN:
                        pu1MdName = (UINT1 *) pu1Arg;
                        /* Compare MdName if passed through CLI */
                        if ((pu1MdName != NULL) &&
                            (STRCMP (au1StrMdName, pu1MdName) == 0))
                        {
                            b1Entry = ECFM_TRUE;
                        }
                        break;

                    case CLI_ECFM_SHOW_SERVICE_LEV_BRIEF:
                    case CLI_ECFM_SHOW_SERVICE_LEVEL:
                        if (pu1Arg != NULL)
                            MEMCPY (&i4MdLevel, pu1Arg, sizeof (INT4));

                        if (i4RetMdLevel == i4MdLevel)
                        {
                            b1Entry = ECFM_TRUE;
                        }
                        break;

                    default:
                        break;
                }

                /* If no Domain or Service name provided, show all the 
                 * services or a given service.
                 */
                if ((b1Entry != ECFM_TRUE) && (pu1Arg != NULL))
                {
                    /* If Domain/Service name is provided and is not found then
                     * donot display
                     */
                    break;
                }

                b1Flag = ECFM_TRUE;

                /* Entry/ies is/are there to be printed. So print header */
                if ((u4Type == CLI_ECFM_SHOW_SERVICE_BRIEF) &&
                    (b1IsHeaderPrinted == ECFM_FALSE))
                {
                    CliPrintf (CliHandle,
                               "%-22s%-8s%-13s%-11s%-6s%-5s%-15s",
                               "ServiceName", "Index", "Primary-Vlan", "ISID",
                               "Level", "MEPs", "CCM Interval");
                    CliPrintf (CliHandle, "\r\n");

                    b1IsHeaderPrinted = ECFM_TRUE;
                }

                if ((u4Type == CLI_ECFM_SHOW_SERVICE_BRIEF) ||
                    (u4Type == CLI_ECFM_SHOW_SERVICE_DOM_BRIEF) ||
                    (u4Type == CLI_ECFM_SHOW_SERVICE_LEV_BRIEF))
                {

                    i4RetCcInterval = ECFM_INIT_VAL;
                    nmhGetFsMIEcfmMaCcmInterval (i4CurrentContextId, u4MdIndex,
                                                 u4MaIndex, &i4RetCcInterval);
                    CliPrintf (CliHandle, "%-22s", au1StrMaName);

                    CliPrintf (CliHandle, "%-8u", u4MaIndex);

                    if (i4RetPriVlanId != 0)
                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                        {
                            CliPrintf (CliHandle, "%-13s", "-");
                            CliPrintf (CliHandle, "%-11u",
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4RetPriVlanId));
                        }
                        else
                        {
                            CliPrintf (CliHandle, "%-13u", i4RetPriVlanId);
                            CliPrintf (CliHandle, "%-11s", "-");
                        }
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-13s", "-");
                        CliPrintf (CliHandle, "%-11s", "-");
                    }

                    CliPrintf (CliHandle, "%-6u", i4RetMdLevel);
                    CliPrintf (CliHandle, "%-5u", u4Count);

                    switch (i4RetCcInterval)
                    {
                        case ECFM_CCM_INTERVAL_300Hz:
                            CliPrintf (CliHandle, "%-15s", "3.33 milliseconds");
                            break;
                        case ECFM_CCM_INTERVAL_10_Ms:
                            CliPrintf (CliHandle, "%-15s", "10 milliseconds");
                            break;
                        case ECFM_CCM_INTERVAL_100_Ms:
                            CliPrintf (CliHandle, "%-15s", "100 millseconds");
                            break;
                        case ECFM_CCM_INTERVAL_1_S:
                            CliPrintf (CliHandle, "%-15s", "1 second ");
                            break;
                        case ECFM_CCM_INTERVAL_10_S:
                            CliPrintf (CliHandle, "%-15s", "10 seconds ");
                            break;
                        case ECFM_CCM_INTERVAL_1_MIN:
                            CliPrintf (CliHandle, "%-15s", "1 minute ");
                            break;
                        case ECFM_CCM_INTERVAL_10_MIN:
                            CliPrintf (CliHandle, "%-15s", "10 minutes ");
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    CliPrintf (CliHandle,
                               "-------------------------------------------\r\n");
                    CliPrintf (CliHandle, "Service Name : %s\r\n",
                               au1StrMaName);

                    CliPrintf (CliHandle, "Domain Name  : %s\r\n",
                               au1StrMdName);
                    CliPrintf (CliHandle, "Index        : %u\r\n", u4MaIndex);

                    if (i4RetPriVlanId != 0)
                    {
                        if (!ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                        {
                            CliPrintf (CliHandle, "Primary Vid  : %u\r\n",
                                       i4RetPriVlanId);
                        }
                        else
                        {
                            CliPrintf (CliHandle, "Service Instance  : %u\r\n",
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4RetPriVlanId));
                        }
                    }
                    else
                    {
                        CliPrintf (CliHandle, "Primary Vid  : -\r\n");
                    }

                    CliPrintf (CliHandle, "Level        : %u\r\n",
                               i4RetMdLevel);

                    switch (i4RetMhfCreation)
                    {
                        case ECFM_MHF_CRITERIA_NONE:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : none");
                            break;
                        case ECFM_MHF_CRITERIA_DEFAULT:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : default");
                            break;
                        case ECFM_MHF_CRITERIA_EXPLICIT:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : explicit");
                            break;
                        case ECFM_MHF_CRITERIA_DEFER:
                            CliPrintf (CliHandle,
                                       "\r\nMHF Creation Criteria : defer");
                            break;
                        default:
                            break;
                    }

                    switch (i4RetIdPermission)
                    {
                        case ECFM_SENDER_ID_NONE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission  : none");
                            break;
                        case ECFM_SENDER_ID_CHASSIS:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission  : Chassis-Id");
                            break;
                        case ECFM_SENDER_ID_MANAGE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission  : Mgt-Address");
                            break;
                        case ECFM_SENDER_ID_CHASSID_MANAGE:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission  : Chassis-Id and Mgt-Address ");
                            break;
                        case ECFM_SENDER_ID_DEFER:
                            CliPrintf (CliHandle,
                                       "\r\nSender Id Permission  : defer ");
                            break;
                        default:
                            break;
                    }

                    i4CcRole = ECFM_INIT_VAL;

                    ECFM_MEMSET (au1RetMegIdCode, ECFM_INIT_VAL,
                                 ECFM_CARRIER_CODE_ARRAY_SIZE);
                    ECFM_MEMSET (&RetMegIdCode, ECFM_INIT_VAL,
                                 sizeof (tSNMP_OCTET_STRING_TYPE));

                    RetMegIdCode.pu1_OctetList = au1RetMegIdCode;
                    RetMegIdCode.i4_Length = 0;

                    nmhGetFsMIY1731MeCcmApplication (i4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     &i4CcRole);
                    nmhGetFsMIY1731MeMegIdIcc (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex, &RetMegIdCode);
                    switch (i4CcRole)
                    {
                        case ECFM_CC_ROLE_FM:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : fault management");
                            break;
                        case ECFM_CC_ROLE_PM:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : performance monitoring");
                            break;
                        case ECFM_CC_ROLE_PS:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : protection switching");
                            break;
                        default:
                            break;
                    }

                    CliPrintf (CliHandle, "\r\nICC Code   : %s",
                               RetMegIdCode.pu1_OctetList);

                    ECFM_MEMSET (au1RetMegIdCode, ECFM_INIT_VAL,
                                 ECFM_UMC_CODE_ARRAY_SIZE);
                    ECFM_MEMSET (&RetMegIdCode, ECFM_INIT_VAL,
                                 sizeof (tSNMP_OCTET_STRING_TYPE));
                    RetMegIdCode.pu1_OctetList = au1RetMegIdCode;
                    RetMegIdCode.i4_Length = 0;

                    nmhGetFsMIY1731MeMegIdUmc (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex, &RetMegIdCode);
                    CliPrintf (CliHandle, "\r\nUMC Code   : %s",
                               RetMegIdCode.pu1_OctetList);

                    /* VlanIds associated with Primary Vlan */
                    CliPrintf (CliHandle, "\r\nTotal MEPs : %-5u", u4Count);
                    CliPrintf (CliHandle,
                               "\r\nPrimary Vlan Associations : \r\n");

#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                      
                        nmhGetFsMIEcfmMaOamVlanId (i4CurrentContextId, u4MdIndex,
                                                   u4MaIndex, &i4OamVlanId);
                        if (i4OamVlanId != ECFM_INVALID_RANGE_VLAN_ID )
                        {
                            CliPrintf (CliHandle, "Oam Vlan   : %d \r\n",
                                       i4OamVlanId);
                        }

                    }
#endif

                    if ((u4RetNoOfVids != 0) && (u4RetNoOfVids != 1))
                    {
                        EcfmShowVlansForAPrimaryVid (CliHandle,
                                                     i4CurrentContextId,
                                                     i4RetPriVlanId);
                        CliPrintf (CliHandle, "\r\n");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "None \r\n");
                    }

                    /* crosscheck status */
                    nmhGetFsMIEcfmMaCrosscheckStatus (i4CurrentContextId,
                                                      u4MdIndex, u4MaIndex,
                                                      &i4XchkSts);
                    if (i4XchkSts == ECFM_ENABLE)
                    {
                        CliPrintf (CliHandle,
                                   "Crosscheck status : Enabled\r\n");
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "Crosscheck status : Disabled\r\n");
                    }

                    /* Crosscheck parameters */
                    EcfmShowXchkParams (CliHandle, CLI_ECFM_SHOW_SERVICE,
                                        i4CurrentContextId, u4MdIndex,
                                        u4MaIndex, ECFM_TRUE);
                }
                u4PagingStatus = CliPrintf (CliHandle, "\r\n");
            }
            while (0);

            b1Entry = ECFM_FALSE;
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1IsShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {

            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }

    if (b1Flag == ECFM_FALSE)
    {
        CliPrintf (CliHandle, "%% Given service not present \r\n");
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliConfigMIP                           
 *                                                                          
 *     DESCRIPTION      : This function will create/activate Mip. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4MdLevel  - MdLevel                     
 *                        i4VlanId  - VlanId
 *                        u4PortNum - port number
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliConfigMip (tCliHandle CliHandle, UINT4 u4Type, INT4 i4MdLevel,
                  INT4 i4VlanId, UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4RetMipstatus = ECFM_INIT_VAL;
    INT4                i4SetMipstatus = ECFM_INIT_VAL;
    tEcfmCcPortInfo    *pPortInfo = NULL;

    /*MIP status can be made to Active only ECFM is enabled at that */
    /*particular interface */
    pPortInfo = ECFM_CC_GET_PORT_INFO (u4PortNum);
    if (NULL != pPortInfo)
    {
        if (pPortInfo->u1PortEcfmStatus == ECFM_ENABLE)
        {
            i4SetMipstatus = ECFM_TRUE;
        }
        else
        {
            i4SetMipstatus = ECFM_FALSE;
            CliPrintf (CliHandle, "\r%% MIP status is kept inactive "
                       "since ECFM is disabled at this Interface\r\n");
        }
    }

    /* Check if Mip exists */
    if (nmhGetFsEcfmMipRowStatus
        (u4PortNum, i4MdLevel, i4VlanId, &i4RetRowStatus) != SNMP_FAILURE)

    {

        /* User wants to create MIP but MIP already exists */
        if (u4Type == CLI_ECFM_CONFIG_MIP_DOM_VLAN ||
            u4Type == CLI_ECFM_CONFIG_MIP_DOM_SER ||
            u4Type == CLI_ECFM_CONFIG_MIP_LEV_VLAN)

        {
            CLI_SET_ERR (CLI_ECFM_MIP_CONFIG_EXIST_ERR);
            return CLI_FAILURE;
        }

        /* Check if it is already active */
        nmhGetFsEcfmMipActive (u4PortNum, i4MdLevel, i4VlanId, &i4RetMipstatus);
        if (i4RetMipstatus == ECFM_SNMP_TRUE)

        {

            /* Already active */
            CLI_SET_ERR (CLI_ECFM_MIP_CONFIG_EXIST_ERR);
            return CLI_FAILURE;
        }

        /* If MIP exists is disabled and user wants to make it Active */
        if (nmhTestv2FsEcfmMipRowStatus
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipRowStatus
            (u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsEcfmMipActive
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             i4SetMipstatus) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipActive
            (u4PortNum, i4MdLevel, i4VlanId, i4SetMipstatus) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsEcfmMipRowStatus
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipRowStatus
            (u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* MIP is enabled/active now */
        return CLI_SUCCESS;
    }

    /* User wants to create MIP */
    if (nmhTestv2FsEcfmMipRowStatus
        (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
         ECFM_ROW_STATUS_CREATE_AND_GO) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsEcfmMipRowStatus
        (u4PortNum, i4MdLevel, i4VlanId,
         ECFM_ROW_STATUS_CREATE_AND_GO) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    /* MIP is created */
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliDeleteMip                           
 *                                                                          
 *     DESCRIPTION      : This function will delete/deactivate Mip. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Command type 
 *                        i4MdLevel  - MdLevel                     
 *                        i4VlanId  - VlanId
 *                        u4PortNum - Port Number
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliDeleteMip (tCliHandle CliHandle, UINT4 u4Type, INT4 i4MdLevel,
                  INT4 i4VlanId, UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4IsActive = ECFM_INIT_VAL;

    /* If there any Mip exists */
    if (nmhGetFsEcfmMipRowStatus
        (u4PortNum, i4MdLevel, i4VlanId, &i4RetRowStatus) != SNMP_SUCCESS)

    {
        CLI_SET_ERR (CLI_ECFM_MIP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    i4IsActive =
        ((u4Type == CLI_ECFM_DELETE_MIP_DOM_VLAN)
         || (u4Type == CLI_ECFM_DELETE_MIP_DOM_SER)
         || (u4Type == CLI_ECFM_DELETE_MIP_LEV_VLAN)
         || (u4Type == CLI_ECFM_DELETE_MIP_LEV_VSI))
        ? ECFM_SNMP_TRUE : ECFM_SNMP_FALSE;

    /* If Mip exists and user wants to make it de-active */
    if (i4IsActive == ECFM_SNMP_FALSE)

    {
        if (nmhTestv2FsEcfmMipRowStatus
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipRowStatus
            (u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsEcfmMipActive
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipActive
            (u4PortNum, i4MdLevel, i4VlanId, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsEcfmMipRowStatus
            (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsEcfmMipRowStatus
            (u4PortNum, i4MdLevel, i4VlanId,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        return CLI_SUCCESS;
    }

    /* If Mip exists and user wants to delete it */
    if (nmhTestv2FsEcfmMipRowStatus
        (&u4ErrorCode, u4PortNum, i4MdLevel, i4VlanId,
         ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    nmhSetFsEcfmMipRowStatus (u4PortNum, i4MdLevel, i4VlanId,
                              ECFM_ROW_STATUS_DESTROY);
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowCtxOrPortStats                           
 *                                                                          
 *     DESCRIPTION      : This function will displays  Context or Port specific
 *                        statistics. If the Port number is Zero then the
 *                        context Specific Statistics is displayed. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context  Identifier 
 *                        u4Command - Type of the command
 *                        u4PortNum - Port Number
 *                        pu1Arg1 - Agrument depending on type of the command
 *                        pu1Arg2 - Agrument depending on type of the command
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 *****************************************************************************/
PRIVATE VOID
EcfmShowCtxOrPortStats (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4PortNum)
{
    UINT4               u4TxCfmCount = ECFM_INIT_VAL;
    UINT4               u4TxCcmCount = ECFM_INIT_VAL;
    UINT4               u4TxLbmCount = ECFM_INIT_VAL;
    UINT4               u4TxLtmCount = ECFM_INIT_VAL;
    UINT4               u4TxLbrCount = ECFM_INIT_VAL;
    UINT4               u4TxLtrCount = ECFM_INIT_VAL;
    UINT4               u4RxCfmCount = ECFM_INIT_VAL;
    UINT4               u4RxCcmCount = ECFM_INIT_VAL;
    UINT4               u4RxLbmCount = ECFM_INIT_VAL;
    UINT4               u4RxLtmCount = ECFM_INIT_VAL;
    UINT4               u4RxLbrCount = ECFM_INIT_VAL;
    UINT4               u4RxLtrCount = ECFM_INIT_VAL;
    UINT4               u4RxBadCfmCount = ECFM_INIT_VAL;
    UINT4               u4FwdCfmCount = ECFM_INIT_VAL;
    UINT4               u4DsrdCfmCount = ECFM_INIT_VAL;
    UINT4               u4TxFailedCount = ECFM_INIT_VAL;
    UINT4               u4TxAisCount = ECFM_INIT_VAL;
    UINT4               u4RxAisCount = ECFM_INIT_VAL;
    UINT4               u4TxLckCount = ECFM_INIT_VAL;
    UINT4               u4RxLckCount = ECFM_INIT_VAL;
    UINT4               u4TxTstCount = ECFM_INIT_VAL;
    UINT4               u4RxTstCount = ECFM_INIT_VAL;
    UINT4               u4TxLmmCount = ECFM_INIT_VAL;
    UINT4               u4RxLmmCount = ECFM_INIT_VAL;
    UINT4               u4TxLmrCount = ECFM_INIT_VAL;
    UINT4               u4RxLmrCount = ECFM_INIT_VAL;
    UINT4               u4Tx1DmCount = ECFM_INIT_VAL;
    UINT4               u4Rx1DmCount = ECFM_INIT_VAL;
    UINT4               u4TxDmmCount = ECFM_INIT_VAL;
    UINT4               u4RxDmmCount = ECFM_INIT_VAL;
    UINT4               u4TxDmrCount = ECFM_INIT_VAL;
    UINT4               u4RxDmrCount = ECFM_INIT_VAL;
    UINT4               u4TxApsCount = ECFM_INIT_VAL;
    UINT4               u4RxApsCount = ECFM_INIT_VAL;
    UINT4               u4TxMccCount = ECFM_INIT_VAL;
    UINT4               u4RxMccCount = ECFM_INIT_VAL;
    UINT4               u4TxVsmCount = ECFM_INIT_VAL;
    UINT4               u4RxVsmCount = ECFM_INIT_VAL;
    UINT4               u4TxVsrCount = ECFM_INIT_VAL;
    UINT4               u4RxVsrCount = ECFM_INIT_VAL;
    UINT4               u4TxExmCount = ECFM_INIT_VAL;
    UINT4               u4RxExmCount = ECFM_INIT_VAL;
    UINT4               u4TxExrCount = ECFM_INIT_VAL;
    UINT4               u4RxExrCount = ECFM_INIT_VAL;
    UINT4               u4RxCsfCount = ECFM_INIT_VAL;
    if (u4PortNum != ECFM_INIT_VAL)
    {
        nmhGetFsMIEcfmPortTxCfmPduCount (u4PortNum, &u4TxCfmCount);
        nmhGetFsMIEcfmPortTxCcmCount (u4PortNum, &u4TxCcmCount);
        nmhGetFsMIEcfmPortRxCfmPduCount (u4PortNum, &u4RxCfmCount);
        nmhGetFsMIEcfmPortRxCcmCount (u4PortNum, &u4RxCcmCount);
        nmhGetFsMIEcfmPortRxBadCfmPduCount (u4PortNum, &u4RxBadCfmCount);
        nmhGetFsMIEcfmPortFrwdCfmPduCount (u4PortNum, &u4FwdCfmCount);
        nmhGetFsMIEcfmPortDsrdCfmPduCount (u4PortNum, &u4DsrdCfmCount);
        nmhGetFsMIEcfmPortTxFailedCount (u4PortNum, &u4TxFailedCount);
        nmhGetFsMIY1731PortAisOut (u4PortNum, &u4TxAisCount);
        nmhGetFsMIY1731PortAisIn (u4PortNum, &u4RxAisCount);
        nmhGetFsMIY1731PortLckOut (u4PortNum, &u4TxLckCount);
        nmhGetFsMIY1731PortLckIn (u4PortNum, &u4RxLckCount);
        nmhGetFsMIY1731PortLmmOut (u4PortNum, &u4TxLmmCount);
        nmhGetFsMIY1731PortLmmIn (u4PortNum, &u4RxLmmCount);
        nmhGetFsMIY1731PortLmrOut (u4PortNum, &u4TxLmrCount);
        nmhGetFsMIY1731PortLmrIn (u4PortNum, &u4RxLmrCount);

        /* LBLT task specific port stats */
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        nmhGetFsMIEcfmPortTxLbmCount (u4PortNum, &u4TxLbmCount);
        nmhGetFsMIEcfmPortTxLtmCount (u4PortNum, &u4TxLtmCount);
        nmhGetFsMIEcfmPortTxLbrCount (u4PortNum, &u4TxLbrCount);
        nmhGetFsMIEcfmPortTxLtrCount (u4PortNum, &u4TxLtrCount);
        nmhGetFsMIEcfmPortRxLbmCount (u4PortNum, &u4RxLbmCount);
        nmhGetFsMIEcfmPortRxLtmCount (u4PortNum, &u4RxLtmCount);
        nmhGetFsMIEcfmPortRxLbrCount (u4PortNum, &u4RxLbrCount);
        nmhGetFsMIEcfmPortRxLtrCount (u4PortNum, &u4RxLtrCount);
        nmhGetFsMIY1731PortTstOut (u4PortNum, &u4TxTstCount);
        nmhGetFsMIY1731PortTstIn (u4PortNum, &u4RxTstCount);
        nmhGetFsMIY1731Port1DmOut (u4PortNum, &u4Tx1DmCount);
        nmhGetFsMIY1731Port1DmIn (u4PortNum, &u4Rx1DmCount);
        nmhGetFsMIY1731PortDmmOut (u4PortNum, &u4TxDmmCount);
        nmhGetFsMIY1731PortDmmIn (u4PortNum, &u4RxDmmCount);
        nmhGetFsMIY1731PortDmrOut (u4PortNum, &u4TxDmrCount);
        nmhGetFsMIY1731PortDmrIn (u4PortNum, &u4RxDmrCount);
        nmhGetFsMIY1731PortApsOut (u4PortNum, &u4TxApsCount);
        nmhGetFsMIY1731PortApsIn (u4PortNum, &u4RxApsCount);
        nmhGetFsMIY1731PortMccOut (u4PortNum, &u4TxMccCount);
        nmhGetFsMIY1731PortMccIn (u4PortNum, &u4RxMccCount);
        nmhGetFsMIY1731PortVsmOut (u4PortNum, &u4TxVsmCount);
        nmhGetFsMIY1731PortVsmIn (u4PortNum, &u4RxVsmCount);
        nmhGetFsMIY1731PortVsrOut (u4PortNum, &u4TxVsrCount);
        nmhGetFsMIY1731PortVsrIn (u4PortNum, &u4RxVsrCount);
        nmhGetFsMIY1731PortExmOut (u4PortNum, &u4TxExmCount);
        nmhGetFsMIY1731PortExmIn (u4PortNum, &u4RxExmCount);
        nmhGetFsMIY1731PortExrOut (u4PortNum, &u4TxExrCount);
        nmhGetFsMIY1731PortExrIn (u4PortNum, &u4RxExrCount);
		nmhGetFsMIY1731PortCsfIn (u4PortNum, &u4RxCsfCount);
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    else
    {
        nmhGetFsMIEcfmTxCfmPduCount (u4ContextId, &u4TxCfmCount);
        nmhGetFsMIEcfmTxCcmCount (u4ContextId, &u4TxCcmCount);
        nmhGetFsMIEcfmRxCfmPduCount (u4ContextId, &u4RxCfmCount);
        nmhGetFsMIEcfmRxCcmCount (u4ContextId, &u4RxCcmCount);
        nmhGetFsMIEcfmRxBadCfmPduCount (u4ContextId, &u4RxBadCfmCount);
        nmhGetFsMIEcfmFrwdCfmPduCount (u4ContextId, &u4FwdCfmCount);
        nmhGetFsMIEcfmDsrdCfmPduCount (u4ContextId, &u4DsrdCfmCount);
        nmhGetFsMIEcfmTxFailedCount (u4ContextId, &u4TxFailedCount);
        nmhGetFsMIY1731AisOut (u4ContextId, &u4TxAisCount);
        nmhGetFsMIY1731AisIn (u4ContextId, &u4RxAisCount);
        nmhGetFsMIY1731LckOut (u4ContextId, &u4TxLckCount);
        nmhGetFsMIY1731LckIn (u4ContextId, &u4RxLckCount);
        nmhGetFsMIY1731LmmOut (u4ContextId, &u4TxLmmCount);
        nmhGetFsMIY1731LmmIn (u4ContextId, &u4RxLmmCount);
        nmhGetFsMIY1731LmrOut (u4ContextId, &u4TxLmrCount);
        nmhGetFsMIY1731LmrIn (u4ContextId, &u4RxLmrCount);

        /* LBLT task specific port stats */
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        nmhGetFsMIEcfmTxLbmCount (u4ContextId, &u4TxLbmCount);
        nmhGetFsMIEcfmTxLtmCount (u4ContextId, &u4TxLtmCount);
        nmhGetFsMIEcfmTxLbrCount (u4ContextId, &u4TxLbrCount);
        nmhGetFsMIEcfmTxLtrCount (u4ContextId, &u4TxLtrCount);
        nmhGetFsMIEcfmRxLbmCount (u4ContextId, &u4RxLbmCount);
        nmhGetFsMIEcfmRxLtmCount (u4ContextId, &u4RxLtmCount);
        nmhGetFsMIEcfmRxLbrCount (u4ContextId, &u4RxLbrCount);
        nmhGetFsMIEcfmRxLtrCount (u4ContextId, &u4RxLtrCount);
        nmhGetFsMIY1731TstOut (u4ContextId, &u4TxTstCount);
        nmhGetFsMIY1731TstIn (u4ContextId, &u4RxTstCount);
        nmhGetFsMIY17311DmOut (u4ContextId, &u4Tx1DmCount);
        nmhGetFsMIY17311DmIn (u4ContextId, &u4Rx1DmCount);
        nmhGetFsMIY1731DmmOut (u4ContextId, &u4TxDmmCount);
        nmhGetFsMIY1731DmmIn (u4ContextId, &u4RxDmmCount);
        nmhGetFsMIY1731DmrOut (u4ContextId, &u4TxDmrCount);
        nmhGetFsMIY1731DmrIn (u4ContextId, &u4RxDmrCount);
        nmhGetFsMIY1731ApsOut (u4ContextId, &u4TxApsCount);
        nmhGetFsMIY1731ApsIn (u4ContextId, &u4RxApsCount);
        nmhGetFsMIY1731MccOut (u4ContextId, &u4TxMccCount);
		nmhGetFsMIY1731CsfIn (u4ContextId, &u4RxCsfCount);
        nmhGetFsMIY1731MccIn (u4ContextId, &u4RxMccCount);
        nmhGetFsMIY1731VsmOut (u4ContextId, &u4TxVsmCount);
        nmhGetFsMIY1731VsmIn (u4ContextId, &u4RxVsmCount);
        nmhGetFsMIY1731VsrOut (u4ContextId, &u4TxVsrCount);
        nmhGetFsMIY1731VsrIn (u4ContextId, &u4RxVsrCount);
        nmhGetFsMIY1731ExmOut (u4ContextId, &u4TxExmCount);
        nmhGetFsMIY1731ExmIn (u4ContextId, &u4RxExmCount);
        nmhGetFsMIY1731ExrOut (u4ContextId, &u4TxExrCount);
        nmhGetFsMIY1731ExrIn (u4ContextId, &u4RxExrCount);
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    CliPrintf (CliHandle,
               "\r\n-------------------------------------------------------"
               "--------\r\n");

    /* Display statistics */
    CliPrintf (CliHandle, "\r%-20s", "Transmitted CFM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxCfmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received CFM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxCfmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted CCM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxCcmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received CCM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxCcmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LBM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLbmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LBM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLbmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LBR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLbrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LBR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLbrCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LTM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLtmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LTM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLtmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LTR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLtrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LTR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLtrCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted TST PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxTstCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received TST PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxTstCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LCK PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLckCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LCK PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLckCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted AIS PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxAisCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received AIS PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxAisCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LMM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLmmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LMM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLmmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted LMR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxLmrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received LMR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxLmrCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted 1DM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4Tx1DmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received 1DM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4Rx1DmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted DMM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxDmmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received DMM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxDmmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted DMR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxDmrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received DMR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxDmrCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted APS PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxApsCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received APS PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxApsCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted MCC PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxMccCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received MCC PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxMccCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted VSM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxVsmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received VSM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxVsmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted VSR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxVsrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received VSR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxVsrCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted EXM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxExmCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received EXM PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxExmCount);
    CliPrintf (CliHandle, "\r\n%-20s", "Transmitted EXR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4TxExrCount);
    CliPrintf (CliHandle, "%4s", " ");
    CliPrintf (CliHandle, "%-20s", "Received EXR PDU");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%-12u", u4RxExrCount);
	CliPrintf (CliHandle, "\r\n%-30s", "CFM CSF PDU Received");
	CliPrintf (CliHandle, "%3s", ": ");
	CliPrintf (CliHandle, "%10u", u4RxCsfCount);
    CliPrintf (CliHandle, "\r\n%-30s", "Bad CFM PDU Received");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%10u", u4RxBadCfmCount);
    CliPrintf (CliHandle, "\r\n%-30s", "CFM PDU Forwarded");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%10u", u4FwdCfmCount);
    CliPrintf (CliHandle, "\r\n%-30s", "CFM PDU Discarded");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%10u", u4DsrdCfmCount);
    CliPrintf (CliHandle, "\r\n%-30s", "CFM PDU Transmission Failures");
    CliPrintf (CliHandle, "%3s", ": ");
    CliPrintf (CliHandle, "%10u", u4TxFailedCount);
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle,
               "\r-------------------------------------------------------"
               "--------");
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowMepStats                           
 *                                                                          
 *     DESCRIPTION      : This function will display MEP related statistics. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context  Identifier 
 *                        u4Command - Type of the command
 *                        u4IfIndex - Interface Index of the Port
 *                        pu1Arg1 - Argument depending upon type of the command
 *                        pu1Arg2 - Argument depending upon type of the command
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 *****************************************************************************/
PRIVATE VOID
EcfmShowMepStats (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Command,
                  UINT4 u4IfIndex, UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE MdName;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIndex = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMepVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaVlanId = ECFM_INIT_VAL;
    INT4                i4MepDirection = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4MepIfIndex = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    INT4                i4TxCcms = ECFM_INIT_VAL;
    UINT4               u4CcmSequenceErrors = ECFM_INIT_VAL;
    UINT4               u4SentCcmsCount = ECFM_INIT_VAL;
    UINT4               u4LbrInCount = ECFM_INIT_VAL;
    UINT4               u4LbrInOutOfOrderCount = ECFM_INIT_VAL;
    UINT4               u4LbrBadMsduCount = ECFM_INIT_VAL;
    UINT4               u4UnexpLtrInCount = ECFM_INIT_VAL;
    UINT4               u4LbrOutCount = ECFM_INIT_VAL;
    UINT4               u4BitErrLbrInCount = ECFM_INIT_VAL;
    UINT4               u4BitErrTstInCount = ECFM_INIT_VAL;
    UINT4               u4TstOutCount = ECFM_INIT_VAL;
    UINT4               u4TstInCount = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT2               u2MepPortNum = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1MdTempName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1FindSelectorType = ECFM_TRUE;
    BOOL1               b1MplstpMep = ECFM_FALSE;
    BOOL1               b1CxtPort = ECFM_FALSE;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    INT1               *pi1IfName = NULL;

    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;

    CfaCliGetIfName (u4IfIndex, pi1IfName);
    CliPrintf (CliHandle, "\r\n-------------------------\r\n");
    if (u4IfIndex != ECFM_INIT_VAL)
    {
        CliPrintf (CliHandle, "interface %s Counters", pi1IfName);
    }
    else
    {
        CliPrintf (CliHandle, "Context Specific Counters");
    }
    CliPrintf (CliHandle, "\r\n-------------------------");

    i4CurrContextId = (INT4) (u4ContextId);

    i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                (UINT4 *) &i4NextContextId,
                                                0, &u4MdIndex, 0,
                                                &u4MaIndex, 0, &u4MepIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {
        /* Entry is for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* MEP related statistics */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4MepIfIndex = ECFM_INIT_VAL;
        i4RetMepVlanId = ECFM_INIT_VAL;
        i4RetMaVlanId = ECFM_INIT_VAL;
        u4RetMdLevel = ECFM_INIT_VAL;
        u4MdLevel = ECFM_INIT_VAL;
        i4VlanId = ECFM_INIT_VAL;
        MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        MEMSET (au1MdTempName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&MdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;
        MdName.pu1_OctetList = au1MdTempName;
        MdName.i4_Length = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMepIfIndex (i4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIndex, (INT4 *) &u4MepIfIndex);
        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4MepIfIndex,
                                                (UINT4 *) &i4CurrContextId,
                                                &u2MepPortNum) !=
            ECFM_VCM_SUCCESS)
        {
            return;
        }
        nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIndex, (UINT4 *) &i4RetMepVlanId);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex, u4MaIndex,
                                       &i4RetMaVlanId);
        nmhGetFsMIEcfmMaName (i4CurrContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (i4CurrContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        ECFM_MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMdName (i4CurrContextId, u4MdIndex, &MdName);
        nmhGetFsMIEcfmMdFormat (i4CurrContextId, u4MdIndex, &i4RetMdFormat);
        ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat, au1StrMdName);

        if (b1FindSelectorType)
        {
            nmhGetNextIndexFsMIEcfmExtMaTable (i4CurrContextId,
                                               (UINT4 *) &i4NextContextId,
                                               u4MdIndex,
                                               &u4NextMdIndex,
                                               u4MaIndex,
                                               &u4NextMdIndex,
                                               0,
                                               &i4NextSelectorType,
                                               0, &u4NextSelectorOrNone);

            if ((i4NextSelectorType == ECFM_SERVICE_SELECTION_LSP) ||
                (i4NextSelectorType == ECFM_SERVICE_SELECTION_PW))
            {
                b1MplstpMep = ECFM_TRUE;
            }
            else
            {
                b1MplstpMep = ECFM_FALSE;
            }
        }
        /* Valid entry depending upon command */
        switch (u4Command)

        {
            case CLI_ECFM_SHOW_STATS_INTF:
                if (u4IfIndex == u4MepIfIndex)
                {
                    b1Entry = ECFM_TRUE;
                }
                else if (u4IfIndex != ECFM_INIT_VAL)
                {
                    b1CxtPort = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS:
                b1Entry = ECFM_TRUE;
                break;

            case CLI_ECFM_MPLS_SHOW_STATS:
                b1Entry = ECFM_TRUE;
                break;

            case CLI_ECFM_SHOW_STATS_INTF_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4IfIndex == u4MepIfIndex) && (u4MdLevel == u4RetMdLevel))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_DOM:
                if ((u4IfIndex == u4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_MPLS_SHOW_STATS_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4MdLevel == u4RetMdLevel) &&
                    (ECFM_STRLEN (au1StrMdName) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_VLAN:
            case CLI_ECFM_SHOW_STATS_INTF_VSI:
            case CLI_ECFM_SHOW_STATS_INTF_ISID:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                if ((u4IfIndex == u4MepIfIndex) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_SER:
                if ((u4IfIndex == u4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg1) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_DOM_VLAN:
            case CLI_ECFM_SHOW_STATS_INTF_DOM_VSI:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == u4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == 0) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_DOM_SER:
                if ((u4IfIndex == u4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == 0) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_DOM_ISID:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == u4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == 0) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_LEV_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == u4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_LEV_VLAN:
            case CLI_ECFM_SHOW_STATS_INTF_LEV_VSI:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == u4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_INTF_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4IfIndex == u4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MPLS_STATS_DOM_SER:
                if ((ECFM_STRLEN (au1StrMdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_STATS_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (((UINT4) (u4RetMdLevel) == u4MdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            i4MepDirection = ECFM_INIT_VAL;
            i4TxCcms = ECFM_INIT_VAL;
            u4SentCcmsCount = ECFM_INIT_VAL;
            u4CcmSequenceErrors = ECFM_INIT_VAL;
            u4LbrInCount = ECFM_INIT_VAL;
            u4LbrInOutOfOrderCount = ECFM_INIT_VAL;
            u4LbrBadMsduCount = ECFM_INIT_VAL;
            u4UnexpLtrInCount = ECFM_INIT_VAL;
            u4LbrOutCount = ECFM_INIT_VAL;
            u4BitErrLbrInCount = ECFM_INIT_VAL;
            u4BitErrTstInCount = ECFM_INIT_VAL;
            u4TstOutCount = ECFM_INIT_VAL;
            u4TstInCount = ECFM_INIT_VAL;
            b1CxtPort = ECFM_TRUE;

            /* Valid entry, display the required parameters */
            nmhGetFsMIEcfmMepDirection (i4CurrContextId, u4MdIndex,
                                        u4MaIndex, u4MepIndex, &i4MepDirection);
            nmhGetFsMIEcfmMepCciSentCcms (i4CurrContextId, u4MdIndex,
                                          u4MaIndex, u4MepIndex,
                                          &u4SentCcmsCount);
            i4TxCcms = u4SentCcmsCount - 1;
            if (i4TxCcms < 0)

            {
                i4TxCcms = 0;
            }
            nmhGetFsMIEcfmMepCcmSequenceErrors (i4CurrContextId, u4MdIndex,
                                                u4MaIndex, u4MepIndex,
                                                (UINT4 *) &u4CcmSequenceErrors);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            nmhGetFsMIEcfmMepLbrIn (i4CurrContextId, u4MdIndex, u4MaIndex,
                                    u4MepIndex, (UINT4 *) &u4LbrInCount);
            nmhGetFsMIEcfmMepLbrInOutOfOrder (i4CurrContextId, u4MdIndex,
                                              u4MaIndex, u4MepIndex,
                                              (UINT4 *)
                                              &u4LbrInOutOfOrderCount);
            nmhGetFsMIEcfmMepLbrBadMsdu (i4CurrContextId, u4MdIndex, u4MaIndex,
                                         u4MepIndex,
                                         (UINT4 *) &u4LbrBadMsduCount);
            nmhGetFsMIEcfmMepUnexpLtrIn (i4CurrContextId, u4MdIndex, u4MaIndex,
                                         u4MepIndex,
                                         (UINT4 *) &u4UnexpLtrInCount);
            nmhGetFsMIEcfmMepLbrOut (i4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIndex, (UINT4 *) &u4LbrOutCount);
            nmhGetFsMIY1731MepBitErroredLbrIn (i4CurrContextId, u4MdIndex,
                                               u4MaIndex, u4MepIndex,
                                               (UINT4 *) &u4BitErrLbrInCount);
            nmhGetFsMIY1731MepBitErroredTstIn (i4CurrContextId, u4MdIndex,
                                               u4MaIndex, u4MepIndex,
                                               (UINT4 *) &u4BitErrTstInCount);
            nmhGetFsMIY1731MepValidTstIn (i4CurrContextId, u4MdIndex,
                                          u4MaIndex, u4MepIndex,
                                          (UINT4 *) &u4TstInCount);
            nmhGetFsMIY1731MepTstOut (i4CurrContextId, u4MdIndex, u4MaIndex,
                                      u4MepIndex, (UINT4 *) &u4TstOutCount);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            CliPrintf (CliHandle,
                       "\r\n-------------------------------------------------------");
            if (i4RetMepVlanId == 0)
            {
                if (i4RetMaVlanId < ECFM_INTERNAL_ISID_MIN)
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4RetMaVlanId) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                       "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                       i4RetMaVlanId);
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                   "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                   i4RetMaVlanId);
                    }
                    }

                    else

                    {
                        if (i4RetMaVlanId != 0)
                        {
#ifdef VSI_WANTED                        
                            if (EcfmUtilCfaIsVsiId (i4RetMaVlanId) == ECFM_SUCCESS)
                            {
                                CliPrintf (CliHandle,
                                           "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                           "%-4d Dir: Down", u4MepIndex,
                                           u4RetMdLevel, i4RetMaVlanId);
                            }
                            else
#endif
                            {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                       "%-4d Dir: Down", u4MepIndex,
                                       u4RetMdLevel, i4RetMaVlanId);
                        }
                        }
                        else
                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d UNAWARE "
                                       " Dir: Down", u4MepIndex, u4RetMdLevel);
                        }
                    }
                }
                else
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)
                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4RetMaVlanId));
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-9d Dir: Down", u4MepIndex,
                                   u4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4RetMaVlanId));
                    }
                }
            }
            else
            {
                if (i4RetMepVlanId < ECFM_INTERNAL_ISID_MIN)
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4RetMepVlanId) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                       "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                       i4RetMepVlanId);
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                   "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                   i4RetMepVlanId);
                    }
                    }

                    else

                    {
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4RetMepVlanId) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                       "%-4d Dir: Down", u4MepIndex,
                                       u4RetMdLevel, i4RetMepVlanId);
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                   "%-4d Dir: Down", u4MepIndex,
                                   u4RetMdLevel, i4RetMepVlanId);
                    }
                }
                }
                else
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)
                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-4d Dir: Up", u4MepIndex, u4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4RetMepVlanId));
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-9d Dir: Down", u4MepIndex,
                                   u4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4RetMepVlanId));
                    }
                }
            }
            CliPrintf (CliHandle, "\r\n%-33s", "CCM PDU Transmitted");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", i4TxCcms);
            CliPrintf (CliHandle, "\r\n%-33s", "LBR PDU Transmitted");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4LbrOutCount);
            CliPrintf (CliHandle, "\r\n%-33s", "LBR PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4LbrInCount);
            CliPrintf (CliHandle, "\r\n%-33s", "TST PDU Transmitted");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4TstOutCount);
            CliPrintf (CliHandle, "\r\n%-33s", "TST PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4TstInCount);
            CliPrintf (CliHandle, "\r\n%-33s",
                       "Out-of-sequence CCM PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4CcmSequenceErrors);
            CliPrintf (CliHandle, "\r\n%-33s", "Unexpected LTR PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4UnexpLtrInCount);
            CliPrintf (CliHandle, "\r\n%-33s", "Out-of-order LBR PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4LbrInOutOfOrderCount);
            CliPrintf (CliHandle, "\r\n%-33s", "Bad LBR MSDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4LbrBadMsduCount);
            CliPrintf (CliHandle, "\r\n%-33s", "Bit-errored LBR PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4BitErrLbrInCount);
            CliPrintf (CliHandle, "\r\n%-33s", "Bit-errored TST PDU Received");
            CliPrintf (CliHandle, "%3s", ":");
            CliPrintf (CliHandle, "%18u", u4BitErrTstInCount);
            CliPrintf (CliHandle,
                       "\r\n-------------------------------------------------"
                       "------\r\n");
        }

        /* Move to next MEP */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIndex,
                                                    &u4NextMepIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIndex = u4NextMepIndex;
            b1Entry = ECFM_FALSE;

            /* MEP entry is for the required context */
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }

            if ((u4NextMaIndex != u4MaIndex) || (u4NextMdIndex != u4MdIndex))
            {
                b1FindSelectorType = ECFM_TRUE;
            }

            if (u4NextMdIndex != u4MdIndex)
            {
                b1FindSelectorType = ECFM_TRUE;
            }
        }
    }

    if (b1CxtPort == ECFM_TRUE)
    {
        /* Display a Context & port specifice parameters (statistics) */
        EcfmShowCtxOrPortStats (CliHandle, u4ContextId, u4IfIndex);
    }
    CliPrintf (CliHandle, "\r\n");
    UNUSED_PARAM (b1MplstpMep);
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowStatistics                           
 *                                                                          
 *     DESCRIPTION      : This function will display ECFM statistics. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context  Identifier 
 *                        u4Command   - Type of the command
 *                        u4ReqPortNum - Interface Index of Port
 *                        pu1Arg1 - Argument depending upon type of the command
 *                        pu1Arg2 - Argument depending upon type of the command
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliShowStatistics (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4Command, UINT4 u4ReqPortNum,
                       UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT4               u4IfIndex = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4MemFailCount = ECFM_INIT_VAL;
    UINT4               u4BuffFailCount = ECFM_INIT_VAL;
    UINT4               u4UpCount = ECFM_INIT_VAL;
    UINT4               u4DownCount = ECFM_INIT_VAL;
    UINT4               u4NoDefCount = ECFM_INIT_VAL;
    UINT4               u4RdiDefCount = ECFM_INIT_VAL;
    UINT4               u4MacStatusDefCount = ECFM_INIT_VAL;
    UINT4               u4RemCcmDefCount = ECFM_INIT_VAL;
    UINT4               u4ErrCcmDefCount = ECFM_INIT_VAL;
    UINT4               u4XconDefCount = ECFM_INIT_VAL;
    UINT4               u4PreIfIndex = 0;
    UINT2               u2LocalPort = ECFM_INIT_VAL;

    /* Validate context */
    if (nmhValidateIndexInstanceFsMIEcfmContextTable (u4ContextId) !=
        SNMP_SUCCESS)

    {
        CliPrintf (CliHandle, "\r\n Context %d not validated", u4ContextId);
        return SNMP_SUCCESS;
    }

    /* Get all the required values global to context */
    nmhGetFsMIEcfmMemoryFailureCount (u4ContextId, &u4MemFailCount);
    nmhGetFsMIEcfmBufferFailureCount (u4ContextId, &u4BuffFailCount);
    nmhGetFsMIEcfmUpCount (u4ContextId, &u4UpCount);
    nmhGetFsMIEcfmDownCount (u4ContextId, &u4DownCount);
    nmhGetFsMIEcfmNoDftCount (u4ContextId, &u4NoDefCount);
    nmhGetFsMIEcfmRdiDftCount (u4ContextId, &u4RdiDefCount);
    nmhGetFsMIEcfmMacStatusDftCount (u4ContextId, &u4MacStatusDefCount);
    nmhGetFsMIEcfmRemoteCcmDftCount (u4ContextId, &u4RemCcmDefCount);
    nmhGetFsMIEcfmErrorCcmDftCount (u4ContextId, &u4ErrCcmDefCount);
    nmhGetFsMIEcfmXconDftCount (u4ContextId, &u4XconDefCount);

    /* Display global statistics */
    CliPrintf (CliHandle, "\r\n-----------------------------------------\r\n");
    CliPrintf (CliHandle, "Global Counters");
    CliPrintf (CliHandle, "\r\n-----------------------------------------");
    CliPrintf (CliHandle, "\r\n%-35s", "Memory Allocation Failed");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4MemFailCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Buffer Allocation Failed");
    CliPrintf (CliHandle, "%-s", ": ");
    CliPrintf (CliHandle, "%u", u4BuffFailCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Module was Enabled");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4UpCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Module was Disabled");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4DownCount);
    CliPrintf (CliHandle, "\r\n%-35s", "No defect occurred" " in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4NoDefCount);
    CliPrintf (CliHandle, "\r\n%-35s", "RDI defect occurred" " in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4RdiDefCount);
    CliPrintf (CliHandle, "\r\n%-35s", "MACStatus defect" " occurred in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4MacStatusDefCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Remote CCM defect" " occurred in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4RemCcmDefCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Error CCM defect" " occurred in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4ErrCcmDefCount);
    CliPrintf (CliHandle, "\r\n%-35s", "Xconn defect occurred in MEP");
    CliPrintf (CliHandle, "%s", ": ");
    CliPrintf (CliHandle, "%u", u4XconDefCount);
    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
    if (u4PagingStatus == CLI_FAILURE)

    {
        return CLI_SUCCESS;
    }

    /* Display other statistics, depending upon the command */
    switch (u4Command)

    {

            /* Display port specific statistics, for all the ports in context */
        case CLI_ECFM_SHOW_STATS:
        case CLI_ECFM_MPLS_SHOW_STATS:
            /* Display Context Specific MEP Statistics */
            EcfmShowMepStats (CliHandle, u4ContextId, u4Command, 0,
                              pu1Arg1, pu1Arg2);
            i4CurrContextId = (INT4) (u4ContextId);
            i4RetVal =
                nmhGetNextIndexFsMIEcfmPortTable (0, (INT4 *) &u4IfIndex);
            while (i4RetVal == SNMP_SUCCESS)

            {
                i4RetVal = ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4IfIndex,
                                                               (UINT4 *)
                                                               &i4NextContextId,
                                                               &u2LocalPort);
                if (i4NextContextId != i4CurrContextId)
                {
                    u4PreIfIndex = u4IfIndex;
                    i4RetVal =
                        nmhGetNextIndexFsMIEcfmPortTable (u4PreIfIndex,
                                                          (INT4 *) &u4IfIndex);
                    continue;
                }

                /* Display a port specifice MEP parameters (statistics) */
                EcfmShowMepStats (CliHandle, u4ContextId,
                                  CLI_ECFM_SHOW_STATS_INTF, u4IfIndex,
                                  pu1Arg1, pu1Arg2);
                u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                if (u4PagingStatus == CLI_FAILURE)
                {
                    return CLI_SUCCESS;
                }
                /* Get the next index */
                u4PreIfIndex = u4IfIndex;
                i4RetVal =
                    nmhGetNextIndexFsMIEcfmPortTable (u4PreIfIndex,
                                                      (INT4 *) &u4IfIndex);
            }
            break;

        case CLI_ECFM_SHOW_STATS_INTF:
        case CLI_ECFM_SHOW_STATS_INTF_LEV:
        case CLI_ECFM_SHOW_STATS_INTF_DOM:
        case CLI_ECFM_SHOW_STATS_INTF_VLAN:
        case CLI_ECFM_SHOW_STATS_INTF_VSI:
        case CLI_ECFM_SHOW_STATS_INTF_LEV_VSI:
        case CLI_ECFM_SHOW_STATS_INTF_DOM_VSI:
        case CLI_ECFM_SHOW_STATS_INTF_LEV_VLAN:
        case CLI_ECFM_SHOW_STATS_INTF_LEV_SER:
        case CLI_ECFM_SHOW_STATS_INTF_DOM_VLAN:
        case CLI_ECFM_SHOW_STATS_INTF_DOM_SER:
        case CLI_ECFM_SHOW_STATS_INTF_ISID:
        case CLI_ECFM_SHOW_STATS_INTF_SER:
        case CLI_ECFM_SHOW_STATS_INTF_DOM_ISID:
        case CLI_ECFM_SHOW_STATS_INTF_LEV_ISID:
        case CLI_ECFM_SHOW_STATS_LEV_SER:
        case CLI_ECFM_SHOW_MPLS_STATS_DOM_SER:
            /* Display MEP related stats */
            EcfmShowMepStats (CliHandle, u4ContextId, u4Command, u4ReqPortNum,
                              pu1Arg1, pu1Arg2);
            break;
        default:
            break;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *    FUNCTION NAME    : EcfmCliLbrCacheSetStatus                         
 *                                                                          
 *    DESCRIPTION      : This function will enable/disable Ecfm Lbr Cache.     
 *                                                                          
 *    INPUT            : CliHandle  - CliContext ID
 *                       i4Status   - Lbr cache status                     
 *                                                                          
 *    OUTPUT           : None               
 *                                                                         
 *    RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliLbrCacheSetStatus (tCliHandle CliHandle, INT4 i4Status,
                          UINT4 u4ContextId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if this can be set */
    if (nmhTestv2FsMIY1731LbrCacheStatus
        (&u4ErrorCode, u4ContextId, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the status */
    if (nmhSetFsMIY1731LbrCacheStatus (u4ContextId, i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *    FUNCTION NAME    : EcfmCliLtrCacheSetStatus                         
 *                                                                          
 *    DESCRIPTION      : This function will enable/disable Ecfm Ltr Cache.     
 *                                                                          
 *    INPUT            : CliHandle  - CliContext ID
 *                       i4Status   - Ltr cache status                     
 *                                                                          
 *    OUTPUT           : None               
 *                                                                         
 *    RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliLtrCacheSetStatus (tCliHandle CliHandle, INT4 i4Status)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if this can be set */
    if (nmhTestv2FsEcfmLtrCacheStatus (&u4ErrorCode, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the status */
    if (nmhSetFsEcfmLtrCacheStatus (i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliLtrCacheSetHoldTimeOrSize                               
 *                                                                          
 *     DESCRIPTION      : This function will set/reset Ecfm Ltr cache 
 *                        parameters.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        i4SetVal - Value to be set                     
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliLtrCacheSetHoldTimeOrSize (tCliHandle CliHandle, UINT4 u4Command,
                                  INT4 *pi4SetVal)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4SetVal = ECFM_INIT_VAL;
    BOOL1               b1SetHoldTime = ECFM_FALSE;
    switch (u4Command)

    {
        case CLI_ECFM_LTR_CACHE_SET_HOLDTIME:
            b1SetHoldTime = ECFM_TRUE;
            i4SetVal = *pi4SetVal;
            break;
        case CLI_ECFM_LTR_CACHE_RESET_HOLDTIME:
            i4SetVal = ECFM_LTR_CACHE_DEF_HOLD_TIME;
            b1SetHoldTime = ECFM_TRUE;
            break;
        case CLI_ECFM_LTR_CACHE_SET_SIZE:
            b1SetHoldTime = ECFM_FALSE;
            i4SetVal = *pi4SetVal;
            break;
        case CLI_ECFM_LTR_CACHE_RESET_SIZE:
            i4SetVal = ECFM_LTR_CACHE_DEF_SIZE;
            b1SetHoldTime = ECFM_FALSE;
            break;
        default:
            break;
    }
    if (b1SetHoldTime == ECFM_TRUE)

    {
        if (nmhTestv2FsEcfmLtrCacheHoldTime (&u4ErrorCode, i4SetVal) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Then Set the hold time */
        if (nmhSetFsEcfmLtrCacheHoldTime (i4SetVal) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        return CLI_SUCCESS;
    }
    if (nmhTestv2FsEcfmLtrCacheSize (&u4ErrorCode, i4SetVal) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the size */
    if (nmhSetFsEcfmLtrCacheSize (i4SetVal) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowLocalMp                                       
 *                                                                          
 *     DESCRIPTION      : This function will display  Mip or Mep 
 *                        related information.      
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - ContextIdentifier
 *                        u4Type - Type of command
 *                        pu1MdName - Maintenace Domain of MIP
 *                        u4IfIndex - Interface Index where MIP is configured
 *                        u1Level - MD Level of MIP
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowLocalMp (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4Type, INT1 *pi1MdName, UINT4 u4IfIndex,
                    INT1 *pi1Level)
{
    tSNMP_OCTET_STRING_TYPE MdName;
    tSNMP_OCTET_STRING_TYPE MaName;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4StkRetMdIndex = ECFM_INIT_VAL;
    UINT4               u4StkRetMaIndex = ECFM_INIT_VAL;
    UINT4               u4StkRetMepId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4NextIfIndex = ECFM_INIT_VAL;
    INT4                i4CurrIfIndex = ECFM_INIT_VAL;
    INT4                i4CurrMdLevel = ECFM_INIT_VAL;
    INT4                i4PrevMdLevel = ECFM_INIT_VAL;
    INT4                i4CurrVid = ECFM_INIT_VAL;
    INT4                i4PrevVid = ECFM_INIT_VAL;
    INT4                i4CurrDir = ECFM_INIT_VAL;
    INT4                i4PrevDir = ECFM_INIT_VAL;
    INT4                i4MaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4MepLowPriDef = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    UINT2               u2NextLocalPort = ECFM_INIT_VAL;
    UINT1               au1MdTempName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    BOOL1               b1MipEntry = ECFM_FALSE;
    BOOL1               b1MepEntry = ECFM_FALSE;
    BOOL1               b1AssocWithMa = ECFM_FALSE;
    BOOL1               b1Header = ECFM_FALSE;

    MEMSET (au1MaName, 0, ECFM_MA_NAME_ARRAY_SIZE);
    MEMSET (au1MdTempName, 0, ECFM_MD_NAME_ARRAY_SIZE);
    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);

    pi1IfName = (INT1 *) au1IfName;
    MdName.pu1_OctetList = au1MdTempName;
    MdName.i4_Length = ECFM_INIT_VAL;

    i4RetVal = EcfmL2IwfGetNextValidPortForContext
        (u4ContextId, 0, &u2NextLocalPort, (UINT4 *)&i4CurrIfIndex);

    while (i4RetVal == L2IWF_SUCCESS)
    {
        while (nmhGetNextIndexFsMIEcfmStackTable (i4CurrIfIndex,
                                                  &i4NextIfIndex, i4PrevVid,
                                                  &i4CurrVid, i4PrevMdLevel,
                                                  &i4CurrMdLevel, i4PrevDir,
                                                  &i4CurrDir) == SNMP_SUCCESS)

        {
            if (i4CurrIfIndex == i4NextIfIndex)
            {

                nmhGetFsMIEcfmStackMepId (i4NextIfIndex, i4CurrVid,
                                          i4CurrMdLevel, i4CurrDir,
                                          &u4StkRetMepId);

                /* Check if it is required entry based on particulare type 
                 * of command */
                MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);

                switch (u4Type)
                {
                    case CLI_ECFM_SHOW_MIP_AT_DOMAIN:
                        MEMSET (au1MdTempName, 0, ECFM_MD_NAME_ARRAY_SIZE);
                        MdName.pu1_OctetList = au1MdTempName;
                        MdName.i4_Length = ECFM_INIT_VAL;
                        nmhGetFsMIEcfmStackMdIndex (i4NextIfIndex,
                                                    i4CurrVid,
                                                    i4CurrMdLevel,
                                                    i4CurrDir,
                                                    &u4StkRetMdIndex);
                        nmhGetFsMIEcfmMdName (u4ContextId, u4StkRetMdIndex,
                                              &MdName);
                        nmhGetFsMIEcfmMdFormat (u4ContextId, u4StkRetMdIndex,
                                                &i4RetMdFormat);
                        EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat,
                                                     au1StrMdName);
                        if ((u4StkRetMepId == 0) &&
                            (ECFM_STRCMP (au1StrMdName, pi1MdName) == 0))
                        {
                            b1MipEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MIP_AT_INTF:
                        if ((u4StkRetMepId == 0)
                            && (i4NextIfIndex == (INT4) (u4IfIndex)))

                        {
                            b1MipEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MIP_AT_LEVEL:
                        if ((u4StkRetMepId == 0)
                            && (i4CurrMdLevel == *pi1Level))

                        {
                            b1MipEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MIP_ALL:
                        if (u4StkRetMepId == 0)

                        {
                            b1MipEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MEP_AT_DOMAIN:
                        MEMSET (au1MdTempName, 0, ECFM_MD_NAME_ARRAY_SIZE);
                        MdName.pu1_OctetList = au1MdTempName;
                        MdName.i4_Length = ECFM_INIT_VAL;
                        nmhGetFsMIEcfmStackMdIndex (i4NextIfIndex,
                                                    i4CurrVid,
                                                    i4CurrMdLevel,
                                                    i4CurrDir,
                                                    &u4StkRetMdIndex);
                        nmhGetFsMIEcfmMdName (u4ContextId, u4StkRetMdIndex,
                                              &MdName);
                        nmhGetFsMIEcfmMdFormat (u4ContextId, u4StkRetMdIndex,
                                                &i4RetMdFormat);
                        EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat,
                                                     au1StrMdName);
                        if ((u4StkRetMepId != 0) &&
                            (ECFM_STRCMP (au1StrMdName, pi1MdName) == 0))
                        {
                            b1MepEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MEP_AT_INTF:
                        if ((u4StkRetMepId != 0)
                            && (i4NextIfIndex == (INT4) (u4IfIndex)))

                        {
                            b1MepEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MEP_AT_LEVEL:
                        if ((u4StkRetMepId != 0)
                            && (i4CurrMdLevel == *pi1Level))

                        {
                            b1MepEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MEP_ALL:
                        if (u4StkRetMepId != 0)

                        {
                            b1MepEntry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_MP_AT_DOMAIN:
                        MEMSET (au1MdTempName, 0, ECFM_MD_NAME_ARRAY_SIZE);
                        MdName.pu1_OctetList = au1MdTempName;
                        MdName.i4_Length = ECFM_INIT_VAL;
                        nmhGetFsMIEcfmStackMdIndex (i4NextIfIndex,
                                                    i4CurrVid,
                                                    i4CurrMdLevel,
                                                    i4CurrDir,
                                                    &u4StkRetMdIndex);
                        nmhGetFsMIEcfmMdName (u4ContextId, u4StkRetMdIndex,
                                              &MdName);
                        nmhGetFsMIEcfmMdFormat (u4ContextId, u4StkRetMdIndex,
                                                &i4RetMdFormat);
                        EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat,
                                                     au1StrMdName);
                        if (ECFM_STRCMP (au1StrMdName, pi1MdName) == 0)
                        {
                            if (u4StkRetMepId != 0)

                            {
                                b1MepEntry = ECFM_TRUE;
                            }
                            if (u4StkRetMepId == 0)

                            {
                                b1MipEntry = ECFM_TRUE;
                            }
                        }
                        break;
                    case CLI_ECFM_SHOW_MP_AT_INTF:
                        if (i4NextIfIndex == (INT4) (u4IfIndex))

                        {
                            if (u4StkRetMepId != 0)

                            {
                                b1MepEntry = ECFM_TRUE;
                            }
                            if (u4StkRetMepId == 0)

                            {
                                b1MipEntry = ECFM_TRUE;
                            }
                        }
                        break;
                    case CLI_ECFM_SHOW_MP_AT_LEVEL:
                        if (i4CurrMdLevel == *pi1Level)

                        {
                            if (u4StkRetMepId != 0)

                            {
                                b1MepEntry = ECFM_TRUE;
                            }
                            if (u4StkRetMepId == 0)

                            {
                                b1MipEntry = ECFM_TRUE;
                            }
                        }
                        break;
                    case CLI_ECFM_SHOW_MP_ALL:
                        if (u4StkRetMepId != 0)

                        {
                            b1MepEntry = ECFM_TRUE;
                        }
                        if (u4StkRetMepId == 0)

                        {
                            b1MipEntry = ECFM_TRUE;
                        }
                        break;
                    default:
                        break;
                }

                /*  If entry found */
                if ((b1MipEntry == ECFM_TRUE) || (b1MepEntry == ECFM_TRUE))

                {
                    INT4                i4RetMipActive = ECFM_INIT_VAL;
                    INT4                i4RetMepActive = ECFM_INIT_VAL;
                    INT4                i4MepCciEnabled = ECFM_INIT_VAL;
                    UINT1               au1MaTempName[ECFM_MA_NAME_ARRAY_SIZE];
                    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
                    tEcfmMacAddr        MacAddr;
                    tEcfmMacAddr        NullMacAddr;

                    if (b1MipEntry == ECFM_TRUE)
                    {
                        if ((i4PrevVid == i4CurrVid)
                            && (i4PrevMdLevel == i4CurrMdLevel))
                        {
                            b1MipEntry = ECFM_FALSE;
                            /* Skip this MIP entry if everything is same except
                             * for direction */
                            i4PrevVid = i4CurrVid;
                            i4PrevMdLevel = i4CurrMdLevel;
                            i4PrevDir = i4CurrDir;
                            continue;
                        }
                    }

                    /* If header needs to be printed */
                    if (b1Header == ECFM_FALSE)

                    {
                        UINT4               u4Temp = ECFM_INIT_VAL;
                        for (u4Temp = 0; u4Temp < ECFM_CLI_MAX_LINE_LENGTH;
                             u4Temp++)

                        {
                            CliPrintf (CliHandle, "-");
                        }
                        CliPrintf (CliHandle, "\r\n");
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4CurrVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "%-6s%-22s%-7s%-9s%-6s%-19s%s",
                                       "MPID", "DomainName", "Level", "VSI ID",
                                       "Type", "Port", "CC-Status");
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle,
                                   "%-6s%-22s%-7s%-9s%-6s%-19s%s",
                                   "MPID", "DomainName", "Level", "VLAN",
                                   "Type", "Port", "CC-Status");
                        }
                        CliPrintf (CliHandle, "\r\n");
                        CliPrintf (CliHandle, "%6s", " ");
                        CliPrintf (CliHandle,
                                   "%-29s%-9s%-6s%-19s%s", "ServiceName",
                                   "ISID", "Dir", "MAC", "MP-Status");
                        CliPrintf (CliHandle, "\r\n");
                        CliPrintf (CliHandle, "%6s", " ");
                        CliPrintf (CliHandle, "%s", "lowestPriorityDefect");
                        CliPrintf (CliHandle, "\r\n");
                        for (u4Temp = 0; u4Temp < ECFM_CLI_MAX_LINE_LENGTH;
                             u4Temp++)

                        {
                            CliPrintf (CliHandle, "-");
                        }
                        CliPrintf (CliHandle, "\r\n");
                        b1Header = ECFM_TRUE;
                    }
                    ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                    ECFM_MEMSET (NullMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                    ECFM_MEMSET (au1MdTempName, ECFM_INIT_VAL,
                                 ECFM_MD_NAME_ARRAY_SIZE);
                    MdName.pu1_OctetList = au1MdTempName;
                    MdName.i4_Length = ECFM_INIT_VAL;
                    ECFM_MEMSET (au1MaTempName, ECFM_INIT_VAL,
                                 ECFM_MA_NAME_ARRAY_SIZE);
                    MaName.pu1_OctetList = au1MaTempName;
                    MaName.i4_Length = ECFM_INIT_VAL;

                    /* Get the required values */
                    nmhGetFsMIEcfmMipActive (i4NextIfIndex,
                                             i4CurrMdLevel, i4CurrVid,
                                             &i4RetMipActive);
                    nmhGetFsMIEcfmStackMacAddress (i4NextIfIndex, i4CurrVid,
                                                   i4CurrMdLevel, i4CurrDir,
                                                   &MacAddr);
                    nmhGetFsMIEcfmStackMdIndex (i4NextIfIndex, i4CurrVid,
                                                i4CurrMdLevel, i4CurrDir,
                                                &u4StkRetMdIndex);
                    nmhGetFsMIEcfmStackMaIndex (i4NextIfIndex, i4CurrVid,
                                                i4CurrMdLevel, i4CurrDir,
                                                &u4StkRetMaIndex);
                    nmhGetFsMIEcfmMepSrcMacAddr (u4ContextId, u4StkRetMdIndex,
                                                 u4StkRetMaIndex, u4StkRetMepId,
                                                 &MacAddr);
                    if (ECFM_MEMCMP (MacAddr, NullMacAddr, ECFM_MAC_ADDR_LENGTH)
                                == ECFM_INIT_VAL)
                    {
                        nmhGetFsMIEcfmStackMacAddress (i4NextIfIndex, i4CurrVid,
                                                       i4CurrMdLevel, i4CurrDir,
                                                       &MacAddr);
                    }
                    nmhGetFsMIEcfmMdName (u4ContextId, u4StkRetMdIndex,
                                          &MdName);
                    nmhGetFsMIEcfmMdFormat (u4ContextId, u4StkRetMdIndex,
                                            &i4RetMdFormat);

                    nmhGetFsMIEcfmMaName (u4ContextId, u4StkRetMdIndex,
                                          u4StkRetMaIndex, &MaName);
                    nmhGetFsMIEcfmMaFormat (u4ContextId, u4StkRetMdIndex,
                                            u4StkRetMaIndex, &i4RetMaFormat);

                    nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId,
                                                   u4StkRetMdIndex,
                                                   u4StkRetMaIndex,
                                                   &i4MaPrimaryVid);
                    nmhGetFsMIEcfmMepCciEnabled (u4ContextId,
                                                 u4StkRetMdIndex,
                                                 u4StkRetMaIndex,
                                                 u4StkRetMepId,
                                                 &i4MepCciEnabled);
                    nmhGetFsMIEcfmMepActive (u4ContextId, u4StkRetMdIndex,
                                             u4StkRetMaIndex, u4StkRetMepId,
                                             &i4RetMepActive);
                    nmhGetFsMIEcfmStackMepId (i4NextIfIndex, i4CurrVid,
                                              i4CurrMdLevel, i4CurrDir,
                                              &u4StkRetMepId);

                    MEMSET (au1StrMdName, ECFM_INIT_VAL,
                            ECFM_MD_NAME_ARRAY_SIZE);
                    EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat,
                                                 au1StrMdName);

                    MEMSET (au1StrMaName, ECFM_INIT_VAL,
                            ECFM_MA_NAME_ARRAY_SIZE);
                    EcfmUtilMaNameOctetStrToStr (&MaName, i4RetMaFormat,
                                                 au1StrMaName);

                    /* print paricular values based on MEP or MIP */
                    /* MEP Identifier */
                    if (b1MipEntry == ECFM_TRUE)

                    {
                        CliPrintf (CliHandle, "%-6s", "-");
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-6u", u4StkRetMepId);
                    }

                    /* Md Name */
                    if ((u4StkRetMdIndex != 0) && (u4StkRetMaIndex != 0))

                    {
                        CliPrintf (CliHandle, "%-22s", au1StrMdName);
                        b1AssocWithMa = ECFM_TRUE;
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-22s", "-");
                    }

                    /* Level and VLAN ID */
                    CliPrintf (CliHandle, "%-7u", i4CurrMdLevel);

                    if (i4CurrVid != 0)

                    {
                        if (i4CurrVid > ECFM_VLANID_MAX)
                        {
                            CliPrintf (CliHandle, "%-9s", "-");
                        }
                        else
                        {
                            CliPrintf (CliHandle, "%-9u", i4CurrVid);
                        }
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-9s", "-");
                    }

                    /* ENTITY */
                    if (b1MipEntry == ECFM_TRUE)

                    {
                        CliPrintf (CliHandle, "%-6s", "MIP");
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-6s", "MEP");
                    }
                    CfaCliGetIfName ((UINT4) i4NextIfIndex, pi1IfName);
                    CliPrintf (CliHandle, "%-19s", pi1IfName);

                    /* CCI Enabled Status */
                    if (b1MipEntry != ECFM_TRUE)

                    {
                        if (i4MepCciEnabled == ECFM_SNMP_TRUE)

                        {
                            CliPrintf (CliHandle, "%s", "Enabled");
                        }

                        else

                        {
                            CliPrintf (CliHandle, "%s", "Disabled");
                        }
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%s", "-");
                    }
                    CliPrintf (CliHandle, "\r\n");
                    CliPrintf (CliHandle, "%6s", " ");

                    /* MA Name */
                    if (b1AssocWithMa == ECFM_TRUE)
                    {
                        CliPrintf (CliHandle, "%-29s", au1StrMaName);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-29s", "-");
                    }

                    if (i4CurrVid > ECFM_VLANID_MAX)
                    {
                        CliPrintf (CliHandle, "%-9u",
                                   ECFM_ISID_INTERNAL_TO_ISID (i4CurrVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-9s", "-");

                    }

                    /* ENTITY DIRECTION */
                    if (b1MepEntry == ECFM_TRUE)

                    {
                        if (i4CurrDir == 1)

                        {
                            CliPrintf (CliHandle, "%-6s", "Down");
                        }

                        else

                        {
                            CliPrintf (CliHandle, "%-6s", "Up");
                        }
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-6s", "-");
                    }
                    ECFM_MEMSET (au1String, ECFM_INIT_VAL,
                                 ECFM_CLI_MAX_MAC_STRING_SIZE);
                    PrintMacAddress (MacAddr, au1String);
                    au1String[ECFM_INDEX_SEVENTEEN] = '\0';
                    CliPrintf (CliHandle, "%-19s", au1String);

                    /* MEP or MIP status */
                    if ((i4RetMipActive == ECFM_SNMP_TRUE) ||
                        (i4RetMepActive == ECFM_SNMP_TRUE))

                    {
                        u4PagingStatus =
                            CliPrintf (CliHandle, "%-2s", "Active");
                    }

                    else

                    {
                        u4PagingStatus =
                            CliPrintf (CliHandle, "%-2s", "InActive");
                    }

                    CliPrintf (CliHandle, "\r\n");
                    CliPrintf (CliHandle, "%6s", " ");

                    /* Lowest priority defect */
                    nmhGetFsMIEcfmMepLowPrDef (u4ContextId, u4StkRetMdIndex,
                                               u4StkRetMaIndex, u4StkRetMepId,
                                               &i4MepLowPriDef);

                    if (i4MepLowPriDef == ECFM_DEF_ALL)
                    {
                        CliPrintf (CliHandle, "%-29s", "all-Defects");
                    }
                    else if (i4MepLowPriDef == ECFM_DEF_REM_ERR_XCON)
                    {
                        CliPrintf (CliHandle, "%-29s", "rem-Err-Xcon-Defects");
                    }
                    else if (i4MepLowPriDef == ECFM_DEF_ERR_XCON)
                    {
                        CliPrintf (CliHandle, "%-29s", "err-Xcon-Defects");
                    }
                    else if (i4MepLowPriDef == ECFM_DEF_XCON)
                    {
                        CliPrintf (CliHandle, "%-29s", "xcon-Defects");
                    }
                    else if (i4MepLowPriDef == ECFM_DEF_NO_XCON)
                    {
                        CliPrintf (CliHandle, "%-29s", "noXcon-Defects");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-29s",
                                   "mac-Rem-Err-Xcon-Defects");
                    }
                    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                }

                /* Reset Flags for next entry */
                b1MipEntry = ECFM_FALSE;
                b1MepEntry = ECFM_FALSE;
                b1AssocWithMa = ECFM_FALSE;
            }
            else
            {
                break;
            }
            i4PrevVid = i4CurrVid;
            i4PrevMdLevel = i4CurrMdLevel;
            i4PrevDir = i4CurrDir;
        }
        i4PrevVid = ECFM_INIT_VAL;
        i4PrevMdLevel = ECFM_INIT_VAL;
        i4PrevDir = ECFM_INIT_VAL;
        i4RetVal = EcfmL2IwfGetNextValidPortForContext
            (u4ContextId,  u2NextLocalPort, &u2NextLocalPort,
             (UINT4 *) &i4CurrIfIndex);
    }
    UNUSED_PARAM (u4PagingStatus);
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearErrors                                       
 *                                                                          
 *     DESCRIPTION      : This function will clear all remote MEPs related
 *                        errors belonging to same domain or level or all 
 *                        and for all remote MEPs if no input is specified
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId  - Context Identtifier
 *                        u4Type - Type of command
 *                        pu1arg1 - Maintenance Domain or Level og  MEP
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliClearErrors (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4Type, INT1 *pu1Arg1)
{

    /* Input parameters */
    UINT1              *pu1MdName = NULL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;

    /* Variables to scan remote MEP table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1MDEntry = ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check if there is any Remote MEP at this context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId, 0,
                                                   &u4MdIndex, 0,
                                                   &u4MaIndex, 0,
                                                   &u4MepIdentifier, 0,
                                                   &u4RMepIdentifier) ==
        SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }

    /* Scan Remote Mep Table to clear errors for MEP as well as remote MEPs */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4RetMdLevel = ECFM_INIT_VAL;
        ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1MdName;
        RetMdName.i4_Length = 0;
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        /* check if this entry is having Md Level/Domain name */
        switch (u4Type)
        {
            case CLI_ECFM_CLR_ERR_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;

                if (STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1MDEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_ERR_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4RetMdLevel == u4MdLevel)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_ERR_ALL:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        /* Clear all the errors corresponding to remote MEP and its associated
         * MEP */
        if (b1Entry == ECFM_TRUE)

        {

            /* Clear all defects */
            /* per MEP */
            nmhSetFsMIEcfmXconnRMepId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier, 0);
            nmhSetFsMIEcfmErrorRMepId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier, 0);
            nmhSetFsMIEcfmMepDefectRDICcm (i4CurrentContextId, u4MdIndex,
                                           u4MaIndex, u4MepIdentifier,
                                           ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmMepDefectMacStatus (i4CurrentContextId, u4MdIndex,
                                              u4MaIndex, u4MepIdentifier,
                                              ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmMepDefectErrorCcm (i4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmMepDefectXconnCcm (i4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmMepDefectRemoteCcm (i4CurrentContextId, u4MdIndex,
                                              u4MaIndex, u4MepIdentifier,
                                              ECFM_SNMP_FALSE);

            /* per Remote MEP defects */
            nmhSetFsMIEcfmRMepCcmDefect (i4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4RMepIdentifier, ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepInterfaceStatusDefect (i4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     u4RMepIdentifier,
                                                     ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepPortStatusDefect (i4CurrentContextId,
                                                u4MdIndex, u4MaIndex,
                                                u4MepIdentifier,
                                                u4RMepIdentifier,
                                                ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepRDIDefect (i4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4RMepIdentifier, ECFM_SNMP_FALSE);
        }
        b1Entry = ECFM_FALSE;

        /* move to next remote MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex,
                                                       u4MepIdentifier,
                                                       &u4NextMepIdentifier,
                                                       u4RMepIdentifier,
                                                       &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
    if ((u4Type == CLI_ECFM_CLR_ERR_DOM) && (b1MDEntry == ECFM_FALSE))
    {
        CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
        CliPrintf (CliHandle, " ");
        return CLI_FAILURE;
    }

    CliPrintf (CliHandle, "");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetXcheckEnableStatus                               
 *                                                                          
 *     DESCRIPTION      : This function will enable or disable MEPs crosscheck
 *                        operation. 
 *                        
 *                                                                          
 *     INPUT            : CliHandle      - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Type -        Type of command
 *                        au1Mdlevel     - array of levels  
 *                        u2NoOfMdLevels - No. of Md levels
 *                        au1VlanId      - array of vlanIds
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetXcheckEnableStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4Type, UINT1 au1MdLevel[],
                              UINT2 u2NoOfMdLevels, UINT1 au1VlanId[],
                              UINT1 *pu1MdName)
{
    tVlanId             VlanId;

    /* Variables to scan MA table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;

    /* Variables for the values returned by each MA table entry */
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4XchkStatus = ECFM_INIT_VAL;

    /* Counter variables */
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
    }
    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)

    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
        }
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
        }
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((u4Type == CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) ||
        (u4Type == CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_LEV_VLAN_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_DOM_VLAN_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_DOM_SER_XCHKING))
    {
        i4XchkStatus = ECFM_ENABLE;
    }

    else

    {
        i4XchkStatus = ECFM_DISABLE;
    }
    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        /* Copying the vlan list into 2-D array at the specified index (i.e.
         * level), this will be further used to display the level and vlan 
         * for which cc status is not set */
        ECFM_MEMCPY (apu1LevelVlanList[au1MdLevel[u1LevelCounter]],
                     au1VlanId, sizeof (tVlanListExt));
        /* Copying the level list into a variable at the specified index (i.e.
         * level), this will be further used to display the level for unware
         * vlan entries */
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }

    /* Scan MA Table for this Md level and VlanId */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Get its Md Level, primaryVid, CciEnabled */
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Checking MA RowStatus */
        if (i4RetMaRowStatus != ECFM_ROW_STATUS_ACTIVE)

        {
            if (nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                (UINT4 *) &i4NextContextId,
                                                u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex,
                                                &u4NextMaIndex) == SNMP_SUCCESS)

            {
                i4RetVal = SNMP_SUCCESS;
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                if (i4CurrentContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                continue;
            }
            break;
        }

        /* Check for Mdlevels for which crosscheck is to be enabled */
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {

            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                b1EntryFound = ECFM_FALSE;
                if ((u4Type != CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_DOM_UNAWARE_DISABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_LEV_UNAWARE_DISABLE_XCHKING))

                {
                    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                         u4ByteIndex++)

                    {
                        if (au1VlanId[u4ByteIndex] == 0)

                        {
                            continue;
                        }
                        u2VlanFlag = au1VlanId[u4ByteIndex];
                        for (u4BitIndex = 0;
                             ((u4BitIndex < BITS_PER_BYTE)
                              &&
                              (EcfmUtilQueryBitListTable
                               (u2VlanFlag, u4BitIndex) != 0)); u4BitIndex++)
                        {
                            VlanId =
                                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                         EcfmUtilQueryBitListTable (u2VlanFlag,
                                                                    u4BitIndex));
                            /* Check if this entry is having this Md Level and 
                             * primaryVid */
                            if (u4RetMaPrimaryVid == VlanId)

                            {
                                b1EntryFound = ECFM_TRUE;

                                /* Reset the entry for which MA entry is
                                 * found */
                                ECFM_RESET_LIST_MEMBER
                                    (apu1LevelVlanList
                                     [au1MdLevel[u1LevelCounter]],
                                     u4RetMaPrimaryVid);

                                /* Set crosscheck enable status */
                                nmhSetFsMIEcfmMaCrosscheckStatus
                                    (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, i4XchkStatus);
                                break;
                            }
                        }
                        if (b1EntryFound)

                        {
                            break;
                        }
                    }
                    break;
                }

                else if (u4RetMaPrimaryVid == 0)

                {
                    b1EntryFound = ECFM_TRUE;
                    ECFM_CLEAR_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);

                    /* Set crosscheck enable status */
                    nmhSetFsMIEcfmMaCrosscheckStatus
                        (i4CurrentContextId, u4MdIndex, u4MaIndex,
                         i4XchkStatus);
                    break;
                }
            }
        }

        /* Move to next MA */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* Loop that will display the level and vlan for which cc role is not set */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)

    {
        if ((u4Type == CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_DISABLE_XCHKING) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_DISABLE_XCHKING))

        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% Crosscheck status cannot be configured at level %d\r\n",
                           u1Level);
            }
            else
            {
                break;
            }
        }

        else

        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)

            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] == 0)

                {
                    continue;
                }
                u2VlanFlag = apu1LevelVlanList[u1LevelCounter][u4ByteIndex];

                if ((u4BitIndex < BITS_PER_BYTE)
                    && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) !=
                        0))
                {
                    VlanId =
                        (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                 EcfmUtilQueryBitListTable (u2VlanFlag,
                                                            u4BitIndex));

                    CliPrintf (CliHandle,
                               "\r%% Crosscheck status cannot be configured at level %d, vlan %d\r\n",
                               u1LevelCounter, VlanId);
                }
            }
        }
    }

    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowRMepDefects                                       
 *                                                                          
 *     DESCRIPTION      : This function will show all remote MEPs related
 *                        errors corresponding to particular MEP indices.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId - Md Index of MEP
 *                        u4MaId - Ma Index of MEP
 *                        u4MepId - MepId of MEP
 *                        u4MdLevel - MdLevel of MEP
 *                        i1Def - Particular defect to be shown
 *                        b1Header - Boolean flag to indicate if header is to 
 *                                   be shown.
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmShowRMepDefects (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId,
                     UINT4 u4MdLevel, INT1 i1Def, BOOL1 b1Header)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RDIDefect = ECFM_INIT_VAL;
    INT4                i4RCcmDefect = ECFM_INIT_VAL;
    INT4                i4PortStsDefect = ECFM_INIT_VAL;
    INT4                i4IfStsDefect = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4ErrRMepId = ECFM_INIT_VAL;
    UINT4               u4XconnRMepId = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1RMepFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1Reason[] = {
        (UINT1 *) "remote defect indication",
        (UINT1 *) "mac status defect",
        (UINT1 *) "remote CCM defect occurred",
        (UINT1 *) "errored ccm received",
        (UINT1 *) "cross-connect"
    };
    nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdId, u4MaId, u4MepId,
                                 &u4RetPrimaryVid);
    nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdId, u4MaId,
                                   (INT4 *) &u4RetMaPrimaryVid);
    if (b1Header == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "\r\n%-10s%-10d", "MEP-ID : ", u4MepId);
        if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
        {
            CliPrintf (CliHandle,
                       "\r\n%-6s%-5s%-10s%-35s\r\n",
                       "Level", "ISID", "RMEP-ID", "Current defect type");
        }
        else
        {
            CliPrintf (CliHandle,
                       "\r\n%-6s%-5s%-10s%-35s\r\n",
                       "Level", "VLAN", "RMEP-ID", "Current defect type");

        }
        CliPrintf (CliHandle, "%-6s%-5s%-10s%-35s\r\n", "-----", "----",
                   "-------", "-------------------");
    }

    /* Check if error is xconn or error CCM which is related to a particualar
     * remote MEP */
    if ((i1Def == ECFM_DEF_ERROR_CCM) || (i1Def == ECFM_DEF_XCON_CCM))

    {
        CliPrintf (CliHandle, "%-6u", u4MdLevel);
        if (u4RetPrimaryVid != 0)

        {
            CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
        }

        else

        {
            if (u4RetMaPrimaryVid != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
                {
                    CliPrintf (CliHandle, "%-5u",
                               ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
                }
            }

            else

            {
                CliPrintf (CliHandle, "%-5s", "-");
            }
        }
        if (i1Def == ECFM_DEF_XCON_CCM)

        {
            nmhGetFsMIEcfmXconnRMepId (u4ContextId, u4MdId, u4MaId, u4MepId,
                                       &u4XconnRMepId);
            CliPrintf (CliHandle, "%-10u", u4XconnRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Reason[i1Def - 1]);
        }

        else

        {
            nmhGetFsMIEcfmErrorRMepId (u4ContextId, u4MdId, u4MaId, u4MepId,
                                       &u4ErrRMepId);
            CliPrintf (CliHandle, "%-10u", u4ErrRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Reason[i1Def - 1]);
        }
        CliPrintf (CliHandle, "\r\n");
        return;
    }
    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return;
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Check if remote MEP is remote to MEP with indices u4MdId, u4MaId,
         * u4MepId */
        if ((u4MdIndex == u4MdId) &&
            (u4MaIndex == u4MaId) && (u4MepIdentifier == u4MepId))

        {

            /* Check if remote MEP is cause of particular defect  */
            switch (i1Def)

            {
                case ECFM_DEF_RDI_CCM:
                    nmhGetFsMIEcfmRMepRDIDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RDIDefect);
                    if (i4RDIDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                case ECFM_DEF_MAC_STS:
                    nmhGetFsMIEcfmRMepPortStatusDefect (i4CurrentContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        u4MepIdentifier,
                                                        u4RMepIdentifier,
                                                        &i4PortStsDefect);
                    nmhGetFsMIEcfmRMepInterfaceStatusDefect
                        (i4CurrentContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, u4RMepIdentifier, &i4IfStsDefect);
                    if ((i4PortStsDefect == ECFM_SNMP_TRUE)
                        || (i4IfStsDefect == ECFM_SNMP_TRUE))

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                case ECFM_DEF_REMOTE_CCM:
                    nmhGetFsMIEcfmRMepCcmDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RCcmDefect);
                    if (i4RCcmDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                default:
                    break;
            }
        }

        /* Check if entry found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Show particular defect corresponding to remote MEP  */
            CliPrintf (CliHandle, "%-6u", u4MdLevel);
            if (u4RetPrimaryVid != 0)

            {
                CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
            }

            else

            {
                if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
                {
                    CliPrintf (CliHandle, "%-5u",
                               ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
                }
            }
            CliPrintf (CliHandle, "%-10u", u4RMepIdentifier);
            CliPrintf (CliHandle, "%-35s", apu1Reason[i1Def - 1]);
            CliPrintf (CliHandle, "\r\n");
        }

        /* move to next remote MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex,
                                                       u4MepIdentifier,
                                                       &u4NextMepIdentifier,
                                                       u4RMepIdentifier,
                                                       &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* Reset variables for the next entry */
        b1Entry = ECFM_FALSE;
        i4RDIDefect = ECFM_INIT_VAL;
        i4PortStsDefect = ECFM_INIT_VAL;
        i4IfStsDefect = ECFM_INIT_VAL;
        i4RCcmDefect = ECFM_INIT_VAL;
    }

    /* When there is no remote MEP with the defect */
    if (b1RMepFound != ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-6u", u4MdLevel);
        if (u4RetPrimaryVid != 0)

        {
            CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
        }

        else

        {
            if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
            {
                CliPrintf (CliHandle, "%-5u",
                           ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
            }
            else
            {
                CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
            }
        }
        CliPrintf (CliHandle, "%-10s", "-");
        CliPrintf (CliHandle, "%-35s", apu1Reason[i1Def - 1]);
        CliPrintf (CliHandle, "\r\n");
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowRMepY1731Defects                                       
 *                                                                          
 *     DESCRIPTION      : This function will show all remote MEPs related
 *                        errors corresponding to particular MEP indices.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId - Md Index of MEP
 *                        u4MaId - Ma Index of MEP
 *                        u4MepId - MepId of MEP
 *                        u4MdLevel - MdLevel of MEP
 *                        i1Def - Particular defect to be shown
 *                        b1Header - Boolean flag to indicate if header is to 
 *                                   be shown.
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmShowRMepY1731Defects (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId,
                          UINT4 u4MdLevel, INT1 i1Def, BOOL1 b1Header)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrRMepId = ECFM_INIT_VAL;
    UINT4               u4XconnRMepId = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RDIDefect = ECFM_INIT_VAL;
    INT4                i4RCcmDefect = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1RMepFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1Y1731Reason[] = {
        (UINT1 *) "remote defect indication",
        (UINT1 *) "loss of continuity",
        (UINT1 *) "unexpected period",
        (UINT1 *) "unexpected MEP",
        (UINT1 *) "mismerge",
        (UINT1 *) "unexpected level",
        (UINT1 *) "locally link failure",
        (UINT1 *) "internal h/w failure",
        (UINT1 *) "internal s/w failure",
        (UINT1 *) "ais condition",
        (UINT1 *) "lck condition"
    };
    nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdId, u4MaId, u4MepId,
                                 &u4RetPrimaryVid);
    nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdId, u4MaId,
                                   (INT4 *) &u4RetMaPrimaryVid);
    if (b1Header == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "\r\n%-10s%-10d", "MEP-ID : ", u4MepId);
        if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
        {
            CliPrintf (CliHandle,
                       "\r\n%-6s%-5s%-10s%-35s\r\n",
                       "Level", "ISID", "RMEP-ID", "Current defect type");
        }
        else
        {
            CliPrintf (CliHandle,
                       "\r\n%-6s%-5s%-10s%-35s\r\n",
                       "Level", "VLAN", "RMEP-ID", "Current defect type");
        }
        CliPrintf (CliHandle, "%-6s%-5s%-10s%-35s\r\n", "-----", "----",
                   "-------", "-------------------");
    }

    /* Check if the error is software failure or hardware failure which 
     * are not related to any remote MEP. */
    if ((i1Def == ECFM_INTERNAL_SW_FAIL_DFCT_ENTRY) ||
        (i1Def == ECFM_INTERNAL_HW_FAIL_DFCT_ENTRY) ||
        (i1Def == ECFM_AIS_CONDITION_ENTRY) ||
        (i1Def == ECFM_LCK_CONDITION_ENTRY))

    {
        CliPrintf (CliHandle, "%-6u", u4MdLevel);
        if (u4RetPrimaryVid != 0)

        {
            CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
        }

        else

        {
            if (u4RetMaPrimaryVid != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
                {
                    CliPrintf (CliHandle, "%-5u",
                               ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
                }
            }

            else

            {
                CliPrintf (CliHandle, "%-5s", "-");
            }
        }
        CliPrintf (CliHandle, "%-10s", "-");
        CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        CliPrintf (CliHandle, "\r\n");
        return;
    }

    /* Check if the error is Unexp Period, Unexp MEP, Unexp Level or Mismerge 
     * which are related to a particular remote MEP. */
    if ((i1Def == ECFM_UNEXP_PERIOD_DFCT_ENTRY) ||
        (i1Def == ECFM_UNEXP_MEP_DFCT_ENTRY) ||
        (i1Def == ECFM_MISMERGE_DFCT_ENTRY) ||
        (i1Def == ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY))

    {
        CliPrintf (CliHandle, "%-6u", u4MdLevel);
        if (u4RetPrimaryVid != 0)

        {
            CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
        }

        else
        {
            if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
            {
                CliPrintf (CliHandle, "%-5u",
                           ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
            }
            else
            {
                CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
            }
        }

        if ((i1Def == ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY) ||
            i1Def == ECFM_MISMERGE_DFCT_ENTRY)
        {
            nmhGetFsMIEcfmXconnRMepId (u4ContextId, u4MdId, u4MaId,
                                       u4MepId, &u4XconnRMepId);
            CliPrintf (CliHandle, "%-10u", u4XconnRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        }
        else if ((i1Def == ECFM_UNEXP_PERIOD_DFCT_ENTRY) ||
                 (i1Def == ECFM_UNEXP_MEP_DFCT_ENTRY))
        {
            nmhGetFsMIEcfmErrorRMepId (u4ContextId, u4MdId, u4MaId,
                                       u4MepId, &u4ErrRMepId);
            CliPrintf (CliHandle, "%-10u", u4ErrRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        }

        CliPrintf (CliHandle, "\r\n");
        return;
    }
    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return;
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Check if remote MEP is remote to MEP with indices u4MdId, u4MaId,
         * u4MepId */
        if ((u4MdIndex == u4MdId) &&
            (u4MaIndex == u4MaId) && (u4MepIdentifier == u4MepId))

        {

            /* Y.1731 related defects */
            /* Check if remote MEP is cause of particular defect  */
            switch (i1Def)

            {
                case ECFM_RDI_CCM_DFCT_ENTRY:
                    nmhGetFsMIEcfmRMepRDIDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RDIDefect);
                    if (i4RDIDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                case ECFM_LOC_DFCT_ENTRY:
                    nmhGetFsMIEcfmRMepCcmDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RCcmDefect);
                    if (i4RCcmDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                default:
                    break;
            }
        }

        /* Check if entry found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Show particular defect corresponding to remote MEP  */
            CliPrintf (CliHandle, "%-6u", u4MdLevel);
            if (u4RetPrimaryVid != 0)

            {
                CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
            }

            else
            {
                if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
                {
                    CliPrintf (CliHandle, "%-5u",
                               ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
                }
            }
            CliPrintf (CliHandle, "%-10u", u4RMepIdentifier);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
            CliPrintf (CliHandle, "\r\n");
        }

        /* move to next remote MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex,
                                                       u4MepIdentifier,
                                                       &u4NextMepIdentifier,
                                                       u4RMepIdentifier,
                                                       &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* Reset variables for the next entry */
        b1Entry = ECFM_FALSE;
        i4RDIDefect = ECFM_SNMP_FALSE;
        i4RCcmDefect = ECFM_SNMP_FALSE;
    }

    /* When there is no remote MEP with the defect */
    if (b1RMepFound != ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-6u", u4MdLevel);
        if (u4RetPrimaryVid != 0)

        {
            CliPrintf (CliHandle, "%-5u", u4RetPrimaryVid);
        }

        else
        {
            if (ECFM_IS_MEP_ISID_AWARE (u4RetMaPrimaryVid))
            {
                CliPrintf (CliHandle, "%-5u",
                           ECFM_ISID_INTERNAL_TO_ISID (u4RetMaPrimaryVid));
            }
            else
            {
                CliPrintf (CliHandle, "%-5u", u4RetMaPrimaryVid);
            }
        }
        CliPrintf (CliHandle, "%-10s", "-");
        CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        CliPrintf (CliHandle, "\r\n");
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowErrors                                       
 *                                                                          
 *     DESCRIPTION      : This function will show all remote MEPs related
 *                        errors belonging to same domain or level or all 
 *                        and for all remote MEPs if no input is specified
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier 
 *                        u4Type - Type of command
 *                        pu1arg1 - Maintenance Domain or Level of MEP
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowErrors (tCliHandle CliHandle, UINT4 u4ContextId,
                   UINT4 u4Type, INT1 *pu1Arg1)
{

    /* Input parameters */
    UINT1              *pu1MdName = NULL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;

    /* Variables to scan MEP table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;

    /* Various defects */
    INT4                i4ErrCcmDefect = ECFM_INIT_VAL;
    INT4                i4XconnCcmDefect = ECFM_INIT_VAL;
    INT4                i4RCcmDefect = ECFM_INIT_VAL;
    INT4                i4MacStatusDefect = ECFM_INIT_VAL;
    INT4                i4RDICcm = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMepPortNum = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    UINT2               u2Header = ECFM_INIT_VAL;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1Defects[ECFM_NUM_OF_MEP_DEFECTS];
    UINT1               u1Defects = ECFM_INIT_VAL;
    UINT1               u1DftsVal = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetDefects;
    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        b1SameContext = ECFM_FALSE;
        return CLI_SUCCESS;
    }

    /* Scan Mep Table to show errors for MEP as well as remote MEPs */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Initialise variable for the entry */
        u4RetMdLevel = ECFM_INIT_VAL;
        ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1Defects, ECFM_INIT_VAL, ECFM_NUM_OF_MEP_DEFECTS);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&RetDefects, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetDefects.pu1_OctetList = au1Defects;
        RetDefects.i4_Length = 0;
        RetMdName.pu1_OctetList = au1MdName;
        RetMdName.i4_Length = 0;
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* check if this entry is having Md Level/Domain name */
        switch (u4Type)

        {
            case CLI_ECFM_SHOW_ERR_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if (STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4RetMdLevel == u4MdLevel)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_ALL:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        /* Show all the errors corresponding to MEP and its associated
         * remote MEPs */
        if (b1Entry == ECFM_TRUE)

        {
            i4RetMepPortNum = ECFM_INIT_VAL;
            i4RetPortOperStatus = ECFM_INIT_VAL;
            nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      &i4RetMepPortNum);
            nmhGetFsMIY1731PortOperStatus (i4RetMepPortNum,
                                           &i4RetPortOperStatus);

            /* Display only ECFM related errors */
            if (i4RetPortOperStatus == ECFM_DISABLE)

            {
                nmhGetFsMIEcfmMepDefectErrorCcm (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 &i4ErrCcmDefect);
                nmhGetFsMIEcfmMepDefectXconnCcm (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 &i4XconnCcmDefect);
                nmhGetFsMIEcfmMepDefectRemoteCcm (i4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier,
                                                  &i4RCcmDefect);
                nmhGetFsMIEcfmMepDefectMacStatus (i4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier,
                                                  &i4MacStatusDefect);
                nmhGetFsMIEcfmMepDefectRDICcm (i4CurrentContextId,
                                               u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, &i4RDICcm);
                if (i4ErrCcmDefect == ECFM_SNMP_TRUE)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepDefects (CliHandle, i4CurrentContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4RetMdLevel,
                                         ECFM_DEF_ERROR_CCM, b1Header);
                }
                if (i4XconnCcmDefect == ECFM_SNMP_TRUE)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepDefects (CliHandle, i4CurrentContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4RetMdLevel,
                                         ECFM_DEF_XCON_CCM, b1Header);
                }
                if (i4RCcmDefect == ECFM_SNMP_TRUE)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepDefects (CliHandle, i4CurrentContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4RetMdLevel,
                                         ECFM_DEF_REMOTE_CCM, b1Header);
                }
                if (i4MacStatusDefect == ECFM_SNMP_TRUE)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepDefects (CliHandle, i4CurrentContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4RetMdLevel,
                                         ECFM_DEF_MAC_STS, b1Header);
                }
                if (i4RDICcm == ECFM_SNMP_TRUE)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepDefects (CliHandle, i4CurrentContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4RetMdLevel,
                                         ECFM_DEF_RDI_CCM, b1Header);
                }
            }

            /* Display only Y1731 related errors */
            else

            {
                nmhGetFsMIY1731MepDefectConditions (i4CurrentContextId,
                                                    u4MdIndex, u4MaIndex,
                                                    u4MepIdentifier,
                                                    &RetDefects);
                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ZERO];
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_RDI_ERRS) == CLI_ECFM_CC_RDI_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_RDI_CCM_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_LOC_ERRS) == CLI_ECFM_CC_LOC_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_LOC_DFCT_ENTRY, b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_PERIOD_ERRS) ==
                    CLI_ECFM_CC_UNEXP_PERIOD_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_UNEXP_PERIOD_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_MEP_ERRS) ==
                    CLI_ECFM_CC_UNEXP_MEP_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_UNEXP_MEP_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_MISMERGE_ERRS) ==
                    CLI_ECFM_CC_MISMERGE_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_MISMERGE_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_LEV_ERRS) ==
                    CLI_ECFM_CC_UNEXP_LEV_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_CC_LINK_FAIL_ERRS) ==
                    CLI_ECFM_CC_LINK_FAIL_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_LOCAL_LINK_FAIL_DFCT_ENTRY,
                                              b1Header);
                }
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_HW_FAIL_ERRS) ==
                    CLI_ECFM_HW_FAIL_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_INTERNAL_HW_FAIL_DFCT_ENTRY,
                                              b1Header);
                }
                u1Defects = ECFM_INIT_VAL;
                u1DftsVal = ECFM_INIT_VAL;
                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_SW_FAIL_ERRS) ==
                    CLI_ECFM_SW_FAIL_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_INTERNAL_SW_FAIL_DFCT_ENTRY,
                                              b1Header);
                }
                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_AIS_ERRS) == CLI_ECFM_AIS_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_AIS_CONDITION_ENTRY,
                                              b1Header);
                }
                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;
                if ((u1DftsVal & CLI_ECFM_LCK_ERRS) == CLI_ECFM_LCK_ERRS)

                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)

                    {
                        b1Header = ECFM_TRUE;
                    }

                    else

                    {
                        b1Header = ECFM_FALSE;
                    }
                    EcfmShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RetMdLevel,
                                              ECFM_LCK_CONDITION_ENTRY,
                                              b1Header);
                }
            }
        }

        /* move to next MEP */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;

            /* Reset variables for the next entry */
            b1Entry = ECFM_FALSE;
            i4ErrCcmDefect = ECFM_INIT_VAL;
            i4XconnCcmDefect = ECFM_INIT_VAL;
            i4RCcmDefect = ECFM_INIT_VAL;
            i4MacStatusDefect = ECFM_INIT_VAL;
            i4RDICcm = ECFM_INIT_VAL;
            b1Header = ECFM_FALSE;
            u2Header = ECFM_INIT_VAL;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
            b1Header = ECFM_FALSE;
            u2Header = ECFM_INIT_VAL;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowErrLog                                       
 *                                                                          
 *     DESCRIPTION      : This function will show the contents of the error log
 *                        maintained for all the MEPs.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier 
 *                        u4Type - Type of command
 *                        pu1arg1 - Maintenance Domain or Level of MEP
 *                        pu1arg2 - Vlan of MEP
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowErrLog (tCliHandle CliHandle, UINT4 u4ContextId,
                   UINT4 u4Type, INT1 *pu1Arg1, INT1 *pu1Arg2)
{
    UINT1              *pu1MdName = NULL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4SavedMdIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SavedContextId = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevSeqNum = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMepPrimaryVid = ECFM_INIT_VAL;
    INT4                i4Vid = ECFM_INIT_VAL;
    INT4                i4RetErrLogStatus = ECFM_DISABLE;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1ShowAll = ECFM_TRUE;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    u4CurrentContextId = u4ContextId;
    if (nmhGetFsMIY1731ErrorLogStatus
        (u4CurrentContextId, &i4RetErrLogStatus) != SNMP_SUCCESS)

    {
        return CLI_FAILURE;
    }

    /* Check if Error Log is disabled */
    if (i4RetErrLogStatus != ECFM_ENABLE)

    {
        CLI_SET_ERR (CLI_ECFM_ERROR_LOG_SHOW_ERR);
        return CLI_FAILURE;
    }

    /* Check if Error Log is empty */
    if (nmhGetNextIndexFsMIY1731ErrorLogTable
        (u4CurrentContextId, &u4NextContextId, u4PrevMdIndex, &u4MdIndex,
         u4PrevMaIndex, &u4MaIndex, u4PrevMepIdentifier,
         &u4MepIdentifier, u4PrevSeqNum, &u4SeqNum) != SNMP_SUCCESS)

    {
        CLI_SET_ERR (CLI_ECFM_ERROR_LOG_EMPTY_ERR);
        return CLI_FAILURE;
    }
    while ((nmhGetNextIndexFsMIY1731ErrorLogTable
            (u4CurrentContextId, &u4NextContextId, u4PrevMdIndex,
             &u4MdIndex, u4PrevMaIndex, &u4MaIndex, u4PrevMepIdentifier,
             &u4MepIdentifier, u4PrevSeqNum,
             &u4SeqNum) == SNMP_SUCCESS) && (u4CurrentContextId ==
                                             u4NextContextId) && (b1ShowAll
                                                                  == ECFM_TRUE))

    {

        /* Compare the entry indices with saved one for skipping the entries if
         * already printed */
        if ((u4SavedContextId == u4NextContextId) &&
            (u4SavedMdIndex == u4MdIndex) &&
            (u4SavedMaIndex == u4MaIndex) &&
            (u4SavedMepIdentifier == u4MepIdentifier))

        {
            u4PrevMdIndex = u4MdIndex;
            u4PrevMaIndex = u4MaIndex;
            u4PrevMepIdentifier = u4MepIdentifier;
            u4PrevSeqNum = u4SeqNum;
            b1Entry = ECFM_FALSE;
            continue;
        }
        u4RetMdLevel = ECFM_INIT_VAL;
        ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1MdName;
        RetMdName.i4_Length = 0;

        ECFM_MEMSET (au1MaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1MaName;
        RetMaName.i4_Length = 0;

        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetMepPrimaryVid);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex,
                              u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4CurrentContextId, u4MdIndex,
                                u4MaIndex, &i4RetMaFormat);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Check if this entry for MEP is having same Md Level/Domain name or vlan */
        switch (u4Type)

        {
            case CLI_ECFM_SHOW_ERR_LOG_DOM_SER:
                if ((STRCMP (au1StrMaName, pu1Arg2) == 0)
                    && (STRCMP (au1StrMdName, pu1Arg1) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_ERR_LOG_SER:
                if (STRCMP (au1StrMaName, pu1Arg1) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_ERR_LOG_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if (STRCMP (au1StrMdName, pu1MdName) == 0)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4RetMdLevel == u4MdLevel)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG:
                b1Entry = ECFM_TRUE;
                break;
            case CLI_ECFM_SHOW_ERR_LOG_DOM_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_DOM_VSI:
            case CLI_ECFM_SHOW_ERR_LOG_DOM_ISID:
                pu1MdName = (UINT1 *) pu1Arg1;
                i4Vid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4Vid == i4RetMaPrimaryVid)
                        || (i4Vid == i4RetMepPrimaryVid)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_DOM_UNAWARE:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_LEV_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_VSI:
            case CLI_ECFM_SHOW_ERR_LOG_LEV_ISID:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4Vid = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4RetMdLevel == u4MdLevel) &&
                    ((i4Vid == i4RetMaPrimaryVid) ||
                     (i4Vid == i4RetMepPrimaryVid)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_LEV_UNAWARE:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4RetMdLevel == u4MdLevel) && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_ISID:
            case CLI_ECFM_SHOW_ERR_LOG_VLAN:
            case CLI_ECFM_SHOW_ERR_LOG_VSI:
                i4Vid = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4Vid == i4RetMaPrimaryVid) ||
                    (i4Vid == i4RetMepPrimaryVid))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_ERR_LOG_UNAWARE:
                if (i4RetMaPrimaryVid == 0)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* If the entry is found */
        if (b1Entry == ECFM_TRUE)

        {
            u4SavedContextId = u4CurrentContextId;
            u4SavedMdIndex = u4MdIndex;
            u4SavedMaIndex = u4MaIndex;
            u4SavedMepIdentifier = u4MepIdentifier;

            /* Display the error log */
            EcfmShowErrorLog (CliHandle, u4CurrentContextId, u4MdIndex,
                              u4MaIndex, u4MepIdentifier);
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to Next entry */
        u4PrevMdIndex = u4MdIndex;
        u4PrevMaIndex = u4MaIndex;
        u4PrevMepIdentifier = u4MepIdentifier;
        u4PrevSeqNum = u4SeqNum;
        b1Entry = ECFM_FALSE;
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmShowErrorLog
 *                                                                          
 *     DESCRIPTION      : This function will show the contents of error log.
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId      - Md Index of MEP
 *                        u4MaId      - Ma Index of MEP
 *                        u4MepId     - MepId of MEP
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
EcfmShowErrorLog (tCliHandle CliHandle, UINT4 u4ConId, UINT4 u4MdId,
                  UINT4 u4MaId, UINT4 u4MepId)
{
    time_t              ltime;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4ErrorTimeStamp = ECFM_INIT_VAL;
    UINT4               u4TempSeqNum = ECFM_INIT_VAL;
    UINT4               u4StartSeqNum = ECFM_INIT_VAL;
    UINT4               u4EndSeqNum = ECFM_INIT_VAL;
    INT4                i4ErrorType = ECFM_INIT_VAL;
    BOOL1               b1Header = ECFM_TRUE;
    UINT1               au1Date[ECFM_ARRAY_SIZE_64] = { 0 };
    UINT1              *apu1Reason[] = {
        (UINT1 *) "remote defect indication",
        (UINT1 *) "loss of continuity",
        (UINT1 *) "unexpected period",
        (UINT1 *) "unexpected MEP",
        (UINT1 *) "mismerge",
        (UINT1 *) "unexpected level",
        (UINT1 *) "locally link failure",
        (UINT1 *) "internal h/w failure",
        (UINT1 *) "internal s/w failure",
        (UINT1 *) "ais condition", (UINT1 *) "lck condition",
    };
    u4ContextId = u4ConId;
    u4MdIndex = u4MdId;
    u4MaIndex = u4MaId;
    u4MepIdentifier = u4MepId;

    /* Print the defects/errors in the decreasing order */
    EcfmGetSeqNumFrmErrLog (u4ContextId, u4MdIndex, u4MaIndex,
                            u4MepIdentifier, &u4StartSeqNum, &u4EndSeqNum);
    if ((u4StartSeqNum == 0) || (u4EndSeqNum == 0))

    {
        return;
    }
    for (u4TempSeqNum = u4EndSeqNum; u4TempSeqNum >= u4StartSeqNum;
         u4TempSeqNum = u4TempSeqNum - ECFM_DECR_VAL)

    {
        i4ErrorType = ECFM_INIT_VAL;
        u4ErrorTimeStamp = ECFM_INIT_VAL;
        u4RMepIdentifier = ECFM_INIT_VAL;
        ECFM_MEMSET (au1Date, ECFM_INIT_VAL, sizeof (au1Date));
        if (nmhGetFsMIY1731ErrorLogTimeStamp
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TempSeqNum, &u4ErrorTimeStamp) == SNMP_FAILURE)

        {
            continue;
        }

        ltime = (INT4) u4ErrorTimeStamp;

        if (nmhGetFsMIY1731ErrorLogRMepIdentifier
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TempSeqNum, &u4RMepIdentifier) == SNMP_FAILURE)

        {
            continue;
        }
        if (nmhGetFsMIY1731ErrorLogType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4TempSeqNum, &i4ErrorType) == SNMP_FAILURE)

        {
            continue;
        }
        if (b1Header == ECFM_TRUE)

        {
            CliPrintf (CliHandle, "\r\n%-10s%-10d", "MEP-ID : ", u4MepId);
            CliPrintf (CliHandle, "\r\n%-26s%-11s%-28s%-14s\r\n",
                       "Time Of Occurrence", " RMEP-ID", " Error Type",
                       " Error Status");
            CliPrintf (CliHandle, "%-26s%-11s%-28s%-14s\r\n",
                       "------------------", " -------", " ----------",
                       " ------------");
            b1Header = ECFM_FALSE;
        }

        /* ctime() function converts the time value pointed to by time to local time
         * in the form of a character string. The string result that is produced by
         * ctime() contains exactly 26 characters and has the format
         * "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n". Because of this new line character,
         * mep Id and defect type are coming in the next line. To avoid this
         * subtracting the string length by 1.*/

        MEMCPY (au1Date, ctime (&ltime),
                (STRLEN (ctime (&ltime)) - ECFM_VAL_1));

        CliPrintf (CliHandle, "%-27s", au1Date);
        if (u4RMepIdentifier != 0)

        {
            CliPrintf (CliHandle, "%-11u", u4RMepIdentifier);
        }

        else

        {
            CliPrintf (CliHandle, "%-11s", "-");
        }
        if ((i4ErrorType <= ECFM_LCK_CONDITION_ENTRY) &&
            (i4ErrorType >= ECFM_RDI_CCM_DFCT_ENTRY))

        {
            CliPrintf (CliHandle, "%-28s", apu1Reason[i4ErrorType - 1]);
            CliPrintf (CliHandle, "%-15s", "entry");
        }

        else

        {
            CliPrintf (CliHandle, "%-28s",
                       apu1Reason[i4ErrorType - ECFM_VAL_12]);
            CliPrintf (CliHandle, "%-15s", "exit");
        }
        CliPrintf (CliHandle, "\r\n");
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetSeqNumFrmErrLog
 *                                                                          
 *     DESCRIPTION      : This function will return the first and last 
 *                        sequence number from the Error Log for the MEP
 *                                                                          
 *     INPUT            : u4ContextId - Context Id of the MEP
 *                        u4MdIndex   - Md Index of the MEP
 *                        u4MaIndex   - Ma Index of the MEP
 *                        u4MepId     - MEPID of the MEP
 *                                                                          
 *     OUTPUT           : *pu4StartSeqNum - First Seq number
 *                        *pu4EndSeqNum   - Last Seq number 
 *                                                                          
 *     RETURNS          : None                          
 *                                                                          
 **************************************************************************** */
PRIVATE VOID
EcfmGetSeqNumFrmErrLog (UINT4 u4ContextId, UINT4 u4MdId, UINT4 u4MaId,
                        UINT4 u4MepId, UINT4 *pu4StartSeqNum,
                        UINT4 *pu4EndSeqNum)
{
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4CurrMdId = ECFM_INIT_VAL;
    UINT4               u4CurrMaId = ECFM_INIT_VAL;
    UINT4               u4CurrMepId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdId = ECFM_INIT_VAL;
    UINT4               u4NextMaId = ECFM_INIT_VAL;
    UINT4               u4NextMepId = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    BOOL1               b1SameContext = ECFM_TRUE;
    u4CurrContextId = u4ContextId;
    u4CurrMdId = u4MdId;
    u4CurrMaId = u4MaId;
    u4CurrMepId = u4MepId;

    /* For the first sequence num for the MEP */
    i4RetVal =
        nmhGetNextIndexFsMIY1731ErrorLogTable (u4CurrContextId,
                                               &u4NextContextId, u4CurrMdId,
                                               &u4NextMdId, u4CurrMaId,
                                               &u4NextMaId, u4CurrMepId,
                                               &u4NextMepId, 0, &u4SeqNum);
    if (i4RetVal == SNMP_SUCCESS)

    {
        *pu4StartSeqNum = u4SeqNum;
        *pu4EndSeqNum = u4SeqNum;
        if ((u4CurrContextId != u4NextContextId) ||
            (u4CurrMdId != u4NextMdId) ||
            (u4CurrMaId != u4NextMaId) || (u4CurrMepId != u4NextMepId))

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* For the last sequence num for the MEP */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4CurrContextId = u4NextContextId;
        u4CurrMdId = u4NextMdId;
        u4CurrMaId = u4NextMaId;
        u4CurrMepId = u4NextMepId;
        i4RetVal =
            nmhGetNextIndexFsMIY1731ErrorLogTable (u4CurrContextId,
                                                   &u4NextContextId,
                                                   u4CurrMdId, &u4NextMdId,
                                                   u4CurrMaId, &u4NextMaId,
                                                   u4CurrMepId,
                                                   &u4NextMepId, u4SeqNum,
                                                   &u4NextSeqNum);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if ((u4NextContextId != u4ContextId) ||
                (u4NextMdId != u4MdId) ||
                (u4NextMaId != u4MaId) || (u4NextMepId != u4MepId))

            {
                b1SameContext = ECFM_FALSE;
                break;
            }
            *pu4EndSeqNum = u4NextSeqNum;
        }
        u4SeqNum = u4NextSeqNum;
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMepXChkDelay                               
 *                                                                          
 *     DESCRIPTION      : This function will set crosscheck delay, No of CCMs to
 *                         be missed, for which device waits before remote MEPs
 *                         to come up.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Delay   - No of CCMs to be missed, for which device
 *                        waits before remote MEPs to come up.
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 **************************************************************************** */
INT4
EcfmCliSetMepXChkDelay (tCliHandle CliHandle, UINT4 u4Delay)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if value can be set */
    if (nmhTestv2FsEcfmCrosscheckDelay (&u4ErrorCode, u4Delay) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then set the value */
    nmhSetFsEcfmCrosscheckDelay (u4Delay);
    CliPrintf (CliHandle, "");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearRemoteMep                                       
 *                                                                          
 *     DESCRIPTION      : This function will clear all remote MEPs contents
 *                        belonging to same domain or level or all 
 *                        and for all remote MEPs if no input is specified
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Type - Type of command
 *                        pu1MdName - Maintenance Domain 
 *                        pu1Level  - Level of  remote MEP.
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliClearRemoteMep (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4Type, UINT1 *pu1MdName, UINT1 *pu1Level)
{

    /* Variables to scan remote MEP table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE ChassisId;
    tSNMP_OCTET_STRING_TYPE ManAddress;
    tSNMP_OID_TYPE      ManAddressDomain;
    tEcfmMacAddr        MacAddr;
    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check if there is any Remote MEP at this context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }

    /* Scan Remote Mep Table to clear errors for MEP as well as remote MEPs */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4RetMdLevel = ECFM_INIT_VAL;
        ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1MdName;
        RetMdName.i4_Length = 0;
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* check if this entry is having Md Level/Domain name */
        switch (u4Type)

        {
            case CLI_ECFM_CLR_RMEP_DB_DOM:

                if (STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_RMEP_DB_LEV:
                if (u4RetMdLevel == *(UINT4 *) (VOID *) pu1Level)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_RMEP_DB_ALL:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        /* Clear all the contents corresponding to remote MEP */
        if (b1Entry == ECFM_TRUE)

        {

            /* per Remote MEP defects */
            nmhSetFsMIEcfmRMepCcmDefect (i4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4RMepIdentifier, ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepInterfaceStatusDefect (i4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     u4MepIdentifier,
                                                     u4RMepIdentifier,
                                                     ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepPortStatusDefect (i4CurrentContextId,
                                                u4MdIndex, u4MaIndex,
                                                u4MepIdentifier,
                                                u4RMepIdentifier,
                                                ECFM_SNMP_FALSE);
            nmhSetFsMIEcfmRMepRDIDefect (i4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4RMepIdentifier, ECFM_SNMP_FALSE);

            /* Clear  Man address */
            ECFM_MEMSET (ECFM_CC_PDU, ECFM_INIT_VAL, ECFM_MAN_ADDRESS_LENGTH);
            ECFM_MEMSET (&ManAddress, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            ManAddress.pu1_OctetList = ECFM_CC_PDU;
            ManAddress.i4_Length = ECFM_MAN_ADDRESS_LENGTH;
            nmhSetFsMIEcfmRMepManAddress (i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4RMepIdentifier, &ManAddress);

            /* Clear man address domain */
            ECFM_MEMSET (&ManAddressDomain, ECFM_INIT_VAL,
                         sizeof (tSNMP_OID_TYPE));
            ManAddressDomain.pu4_OidList = NULL;
            ManAddressDomain.u4_Length = 0;
            nmhSetFsMIEcfmRMepManAddressDomain
                (i4CurrentContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4RMepIdentifier, &ManAddressDomain);

            /* Clear chassisId subtype */
            nmhSetFsMIEcfmRMepChassisIdSubtype
                (i4CurrentContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4RMepIdentifier, ECFM_LOCAL_CHASSIS_ID);

            /* Clear chassis Id */
            ECFM_MEMSET (&ChassisId, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            ChassisId.pu1_OctetList = ECFM_CC_PDU;
            ChassisId.i4_Length = ECFM_CHASSIS_ID_LENGTH;
            nmhSetFsMIEcfmRMepDbChassisId (i4CurrentContextId, u4MdIndex,
                                           u4MaIndex, u4MepIdentifier,
                                           u4RMepIdentifier, &ChassisId);

            /* Clear InterfaceStatusTlv */
            nmhSetFsMIEcfmRMepInterfaceStatusTlv
                (i4CurrentContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4RMepIdentifier, 0);

            /* Clear PortStatusTlv */
            nmhSetFsMIEcfmRMepPortStatusTlv (i4CurrentContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             u4RMepIdentifier, 0);

            /* Clear MacAddress */
            ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            nmhSetFsMIEcfmRMepMacAddress (i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4RMepIdentifier, MacAddr);
        }
        b1Entry = ECFM_FALSE;

        /* move to next remote MEP */
        i4RetVal = nmhGetNextIndexFsMIEcfmRemoteMepDbExTable
            (i4CurrentContextId, (UINT4 *) &i4NextContextId, u4MdIndex,
             &u4NextMdIndex, u4MaIndex, &u4NextMaIndex, u4MepIdentifier,
             &u4NextMepIdentifier, u4RMepIdentifier, &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    CliPrintf (CliHandle, "");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *    FUNCTION NAME    : EcfmCliClearLtrCache                         
 *                                                                          
 *    DESCRIPTION      : This function will clear Ecfm LTR Cache.     
 *                                                                          
 *    INPUT            : CliHandle  - CliContext ID
 *                       u4ContextId - Context Identifier
 *                                                                          
 *    OUTPUT           : None               
 *                                                                         
 *    RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliClearLtrCache (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    if (nmhTestv2FsMIEcfmLtrCacheClear
        (&u4ErrorCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmLtrCacheClear (u4ContextId, ECFM_SNMP_TRUE) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    CliPrintf (CliHandle, "");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *    FUNCTION NAME    : EcfmCliClearMipCcmDb                         
 *                                                                          
 *    DESCRIPTION      : This function will clear Ecfm MIP CCM Database.     
 *                                                                          
 *    INPUT            : CliHandle  - CliContext ID
 *                                                                          
 *    OUTPUT           : None               
 *                                                                         
 *    RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliClearMipCcmDb (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    if (nmhTestv2FsMIEcfmMipCcmDbClear
        (&u4ErrorCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmMipCcmDbClear
        (u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    CliPrintf (CliHandle, "");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetTraps                                   
 *                                                                          
 *     DESCRIPTION      : This function enables or disables the ECFM and Y1731
 *                        proprietary Traps.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Command -  Command type
 *                        u1EcfmVal - Control variable for enabling or disabling of 
 *                                any ECFM trap.
 *                        u1Y1731Val - Control variable for enabling or disabling of 
 *                                any Y1731 trap.
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ***************************************************************************/
INT4
EcfmCliSetTraps (tCliHandle CliHandle, UINT4 u4ContextId,
                 UINT4 u4Command, UINT1 u1EcfmVal, UINT2 u2Y1731Val)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT2               u2Y1731Trap = ECFM_INIT_VAL;
    UINT1               u1Trap = ECFM_INIT_VAL;
    UINT1               u1TrapOption = ECFM_INIT_VAL;
    UINT1               au1Y1731TrapOption[ECFM_ARRAY_SIZE_2];
    UINT1               u1TrapMsbVal = ECFM_INIT_VAL;
    UINT1               u1TrapLsbVal = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE TrapOption;

    /* Enable/Disable ECFM Traps */
    if ((u1EcfmVal != 0) || (u4Command == CLI_ECFM_DISABLE_TRAP))

    {
        ECFM_MEMSET (&TrapOption, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        TrapOption.pu1_OctetList = &u1TrapOption;
        TrapOption.i4_Length = 1;
        if (nmhGetFsEcfmTrapControl (&TrapOption) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Set the corresponding Trap value which is to be set */
        u1Trap = TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
        if (u4Command == CLI_ECFM_ENABLE_TRAP)

        {
            u1Trap = u1Trap | u1EcfmVal;
        }

        else

        {
            u1Trap = u1Trap & u1EcfmVal;
        }
        TrapOption.pu1_OctetList[ECFM_INDEX_ZERO] = u1Trap;
        TrapOption.i4_Length = 1;

        /* Test if Trap value can be set or not */
        if (nmhTestv2FsEcfmTrapControl (&u4ErrorCode, &TrapOption) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Set the corresponding Trap value */
        nmhSetFsEcfmTrapControl (&TrapOption);
    }

    /* Enable/Disable Y1731 Traps */
    if ((u2Y1731Val != 0) || (u4Command == CLI_ECFM_DISABLE_TRAP))

    {
        ECFM_MEMSET (au1Y1731TrapOption, ECFM_INIT_VAL, sizeof
                     (au1Y1731TrapOption));
        ECFM_MEMSET (&TrapOption, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        TrapOption.pu1_OctetList = au1Y1731TrapOption;
        TrapOption.i4_Length = 0;
        if (nmhGetFsMIY1731TrapControl (u4ContextId, &TrapOption) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        u2Y1731Trap = TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
        u2Y1731Trap = u2Y1731Trap << 8;
        u2Y1731Trap = u2Y1731Trap | TrapOption.pu1_OctetList[ECFM_INDEX_ONE];

        /* Set the corresponding Trap value which is to be set */
        if (u4Command == CLI_ECFM_ENABLE_TRAP)

        {
            u2Y1731Trap = u2Y1731Trap | u2Y1731Val;
        }

        else

        {
            u2Y1731Trap = u2Y1731Trap & u2Y1731Val;
        }
        u1TrapMsbVal = (UINT1) (u2Y1731Trap >> ECFM_SHIFT_8BITS);
        TrapOption.pu1_OctetList[ECFM_INDEX_ZERO] = u1TrapMsbVal;
        TrapOption.i4_Length = 1;
        u1TrapLsbVal = (UINT1) (u2Y1731Trap & ECFM_MASK_WITH_VAL_255);
        TrapOption.pu1_OctetList[ECFM_INDEX_ONE] = u1TrapLsbVal;
        TrapOption.i4_Length = ECFM_VAL_2;

        /* Test if Trap value can be set or not */
        if (nmhTestv2FsMIY1731TrapControl
            (&u4ErrorCode, u4ContextId, &TrapOption) != SNMP_SUCCESS)

        {
            return CLI_FAILURE;
        }

        /* Set the corresponding Trap value */
        if (nmhSetFsMIY1731TrapControl (u4ContextId, &TrapOption) !=
            SNMP_SUCCESS)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliSetDot1agCfmMepLowPrDef
 *
 *     DESCRIPTION      : This function will set the MEP lowest priority 
 *                        defect.
 *
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u1EcfmMepLowPrDefVal - lowest priority defect value
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ****************************************************************************/
INT4
EcfmCliSetDot1agCfmMepLowPrDef (tCliHandle CliHandle, UINT4 u4ContextId,
                                UINT1 u1EcfmMepLowPrDefVal)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    if (nmhTestv2FsMIEcfmMepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmMepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if ((nmhTestv2FsMIEcfmMepLowPrDef (&u4ErrorCode, u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepIndex,
                                       u1EcfmMepLowPrDefVal)) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if ((nmhSetFsMIEcfmMepLowPrDef (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepIndex, u1EcfmMepLowPrDefVal))
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (nmhSetFsMIEcfmMepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowMipCcmDb                                       
 *                                                                          
 *     DESCRIPTION      : This function will show the configured MipCcm
 *                        Database.
 *                        (Filtering Identifier (VLAN), source Mac Address,
 *                        Interface Index)      
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Command - Type of the command
 *                        pu1Arg1 - arument dependending on the type of command
 *                        pu1Arg2 - arument dependending on the type of command
 *                        u4IfIndex - Interface Index
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowMipCcmDb (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4Command, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                     UINT4 u4IfIndex)
{
    UINT4               u4VlanId = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT4               u4RetIfIndex = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4Fid = ECFM_INIT_VAL;
    UINT4               u4NextFid = ECFM_INIT_VAL;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    tEcfmMacAddr        MacAddr;
    tEcfmMacAddr        SrcMacAddr;
    tEcfmMacAddr        NextSrcMacAddr;
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_TRUE;
    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;

    ECFM_MEMSET (SrcMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (NextSrcMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMipCcmDbTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4NextFid,
         SrcMacAddr, &NextSrcMacAddr) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }
    u4Fid = u4NextFid;
    ECFM_MEMCPY (SrcMacAddr, NextSrcMacAddr, ECFM_MAC_ADDR_LENGTH);

    /* Scan and print valid entry according to particular command */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))

    {
        u4RetIfIndex = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMipCcmIfIndex (i4CurrentContextId, u4Fid, SrcMacAddr,
                                     (INT4 *) &u4RetIfIndex);

        switch (u4Command)

        {
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_INTF:
                u4VlanId = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4VlanId == u4Fid) && (u4IfIndex == u4RetIfIndex))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI:
                u4VlanId = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4VlanId == u4Fid)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_MIP_CCM_DB_MAC_INTF:
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if ((ECFM_MEMCMP
                     (SrcMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && (u4IfIndex == u4RetIfIndex))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_MIP_CCM_DB_MAC:
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if (ECFM_MEMCMP
                    (SrcMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_MIP_CCM_DB_INTF:
                if (u4IfIndex == u4RetIfIndex)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_MIP_CCM_DB:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC_INTF:
            case CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }
        if (b1Entry == ECFM_TRUE)
        {
            CfaCliGetIfName (u4RetIfIndex, pi1IfName);
            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "--------------------------------- \r\n");
                CliPrintf (CliHandle, "Vlan     Mac Address      Port \r\n");
                CliPrintf (CliHandle, "--------------------------------- \r\n");
                b1Header = ECFM_FALSE;
            }
            ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            if ((u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC_INTF) ||
                (u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_VLAN_MAC) ||
                (u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC_INTF) ||
                (u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_VSI_MAC) ||
                (u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC_INTF) ||
                (u4Command == CLI_ECFM_SHOW_MIP_CCM_DB_SER_MAC))
            {
                u4VlanId = *(UINT4 *) (VOID *) pu1Arg1;
                StrToMac ((UINT1 *) pu1Arg2, MacAddr);
                if (nmhGetFsMIEcfmMipCcmIfIndex
                    (u4ContextId, u4VlanId, MacAddr,
                     (INT4 *) &u4RetIfIndex) == SNMP_SUCCESS)

                {
                    if ((u4IfIndex == 0) || (u4IfIndex == u4RetIfIndex))

                    {
                        CliPrintf (CliHandle, "%-6d%-20s%-10s \r\n\r\n",
                                   u4VlanId, pu1Arg2, pi1IfName);
                    }
                }
                return CLI_SUCCESS;
            }
            else
            {
                CliPrintf (CliHandle, "%-6d", u4Fid);
                PrintMacAddress (SrcMacAddr, au1String);
                CliPrintf (CliHandle, "%-18s", au1String);
                CliPrintf (CliHandle, "%-10s", pi1IfName);
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMipCcmDbTable
            (i4CurrentContextId, (UINT4 *) &i4NextContextId, u4Fid,
             &u4NextFid, SrcMacAddr, &NextSrcMacAddr);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1IsShowAll = ECFM_FALSE;
            }
            u4Fid = u4NextFid;
            ECFM_MEMCPY (SrcMacAddr, NextSrcMacAddr, sizeof (SrcMacAddr));
            b1Entry = ECFM_FALSE;
        }
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }
    CliPrintf (CliHandle, "\r\n");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowMipPreventTbl                        
 *                                                                          
 *     DESCRIPTION      : This function will show the etries in the MIP 
 *                        prevent table.
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4IfIndex - Interface Index
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowMipPreventTbl (tCliHandle CliHandle)
{
    INT1               *pi1IfName = NULL;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    INT4                i4NextIfIndex = 0;
    INT4                i4Level = 0;
    INT4                i4NextLevel = 0;
    INT4                i4VlanIsid = 0;
    INT4                i4NextVlanIsid = 0;
    INT4                i4IfIndex = 0;
    INT4                i4RowStatus = 0;
    pi1IfName = (INT1 *) au1IfName;

    CliPrintf (CliHandle, " Port Id   MDLevel   ");
    CliPrintf (CliHandle, "Service Value\r\n");
    CliPrintf (CliHandle, "---------------------");
    CliPrintf (CliHandle, "-------------\r\n");

    while (nmhGetNextIndexFsMIEcfmDynMipPreventionTable (i4IfIndex,
                                                         &i4NextIfIndex,
                                                         i4Level,
                                                         &i4NextLevel,
                                                         i4VlanIsid,
                                                         &i4NextVlanIsid)
           == SNMP_SUCCESS)
    {
        nmhGetFsMIEcfmDynMipPreventionRowStatus (i4NextIfIndex,
                                                 i4NextLevel,
                                                 i4NextVlanIsid, &i4RowStatus);

        CfaCliGetIfName (i4NextIfIndex, pi1IfName);
        if (i4RowStatus == ACTIVE)
        {
            CliPrintf (CliHandle, " %-10s%-10d%-5d\r\n",
                       pi1IfName, i4NextLevel, i4NextVlanIsid);
        }

        i4IfIndex = i4NextIfIndex;
        i4Level = i4NextLevel;
        i4VlanIsid = i4NextVlanIsid;
    }
    CliPrintf (CliHandle, "\r\n");

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowConfigErrors                                       
 *                                                                          
 *     DESCRIPTION      : This function will show configuration errors 
 *                        of interface and a VLAN
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Command - Type of the command
 *                        pu1Arg1 - arument dependending on the type of command
 *                        pu1Arg2 - arument dependending on the type of command
 *                        u4IfIndex - Interface Index
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliShowConfigErrors (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4Command, UINT1 *pu1Arg1, UINT4 u4IfIndex)
{
    tSNMP_OCTET_STRING_TYPE MaName;
    UINT1              *pu1MaName = NULL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4StkRetMdIndex = ECFM_INIT_VAL;
    UINT4               u4StkRetMaIndex = ECFM_INIT_VAL;
    INT4                i4NextIfIndex = ECFM_INIT_VAL;
    INT4                i4CurrMdLevel = ECFM_INIT_VAL;
    INT4                i4PrevMdLevel = ECFM_INIT_VAL;
    INT4                i4CurrVid = ECFM_INIT_VAL;
    INT4                i4PrevVid = ECFM_INIT_VAL;
    INT4                i4CurrDir = ECFM_INIT_VAL;
    INT4                i4PrevDir = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    UINT1               au1MaTempName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4ErrListVid = ECFM_INIT_VAL;
    INT4                i4NextErrListVid = ECFM_INIT_VAL;
    INT4                i4ErrListIfIndex = ECFM_INIT_VAL;
    INT4                i4IfIndex = ECFM_INIT_VAL;
    INT4                i4NextErrListIfIndex = ECFM_INIT_VAL;
    UINT2               u2LocalPort = ECFM_INIT_VAL;
    UINT2               u2Entries = ECFM_INIT_VAL;
    UINT1               u1ErrListErrorType = ECFM_INIT_VAL;
    UINT1               u1Counter = ECFM_INIT_VAL;
    UINT1               u1Temp = ECFM_INIT_VAL;
    UINT1               u1Error = ECFM_INIT_VAL;
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsidEntry = ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE RetErrorType;

    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);

    pi1IfName = (INT1 *) au1IfName;
    MaName.pu1_OctetList = au1MaTempName;
    MaName.i4_Length = ECFM_INIT_VAL;

    i4CurrentContextId = (INT4) (u4ContextId);
    /* Check if there is any entry related to this context */
    i4RetVal = nmhGetNextIndexFsMIEcfmConfigErrorListTable
        (i4ErrListVid,
         &i4NextErrListVid, i4ErrListIfIndex, &i4NextErrListIfIndex);
    if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (i4NextErrListIfIndex,
                                            (UINT4 *) &i4NextContextId,
                                            &u2LocalPort) == ECFM_VCM_SUCCESS)
    {
        if ((UINT4) (i4NextContextId) != u4ContextId)
        {
            return CLI_SUCCESS;
        }
    }

    i4ErrListVid = i4NextErrListVid;
    i4ErrListIfIndex = i4NextErrListIfIndex;
    CliPrintf (CliHandle, "\r\nConfiguration Errors");
    CliPrintf (CliHandle,
               "\r\n---------------------------------------------\r\n");

    /* Scan and print valid entry according to particular command */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))
    {
        ECFM_MEMSET (&RetErrorType, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetErrorType.pu1_OctetList = &u1ErrListErrorType;
        RetErrorType.i4_Length = 1;
        nmhGetFsMIEcfmConfigErrorListErrorType
            (i4ErrListVid, i4ErrListIfIndex, &RetErrorType);
        i4IfIndex = ECFM_INIT_VAL;
        i4PrevVid = ECFM_INIT_VAL;
        i4PrevMdLevel = ECFM_INIT_VAL;
        i4PrevDir = ECFM_INIT_VAL;
        i4NextIfIndex = ECFM_INIT_VAL;
        i4CurrDir = ECFM_INIT_VAL;
        i4CurrMdLevel = ECFM_INIT_VAL;
        i4CurrVid = ECFM_INIT_VAL;
        while (nmhGetNextIndexFsMIEcfmStackTable (i4IfIndex,
                                                  &i4NextIfIndex, i4PrevVid,
                                                  &i4CurrVid, i4PrevMdLevel,
                                                  &i4CurrMdLevel, i4PrevDir,
                                                  &i4CurrDir) == SNMP_SUCCESS)
        {

            if ((i4ErrListIfIndex == i4NextIfIndex) &&
                (i4ErrListVid == i4CurrVid))
            {
                /* Check if it is required entry based on particulare type 
                 * of command */
                MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                MEMSET (au1MaTempName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                MaName.pu1_OctetList = au1MaTempName;
                MaName.i4_Length = ECFM_INIT_VAL;
                nmhGetFsMIEcfmStackMdIndex (i4NextIfIndex, i4CurrVid,
                                            i4CurrMdLevel, i4CurrDir,
                                            &u4StkRetMdIndex);
                nmhGetFsMIEcfmStackMaIndex (i4NextIfIndex, i4CurrVid,
                                            i4CurrMdLevel, i4CurrDir,
                                            &u4StkRetMaIndex);
                nmhGetFsMIEcfmMaName (i4CurrentContextId, u4StkRetMdIndex,
                                      u4StkRetMaIndex, &MaName);
                nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4StkRetMaIndex,
                                        u4StkRetMaIndex, &i4RetMaFormat);
                EcfmUtilMaNameOctetStrToStr (&MaName, i4RetMaFormat,
                                             au1StrMaName);
                switch (u4Command)
                {
                    case CLI_ECFM_SHOW_CONFIG_ERROR_SER_INTF:
                        pu1MaName = (UINT1 *) pu1Arg1;
                        if ((u4IfIndex == (UINT4) i4ErrListIfIndex) &&
                            (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                        {
                            b1Entry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR_SER:
                        pu1MaName = (UINT1 *) pu1Arg1;
                        if (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)
                        {
                            b1Entry = ECFM_TRUE;
                        }
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR_VLAN_INTF:
                    case CLI_ECFM_SHOW_CONFIG_ERROR_VSI_INTF:
                        i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                        if ((i4VlanId == i4ErrListVid) &&
                            (u4IfIndex == (UINT4) i4ErrListIfIndex))
                        {
                            b1Entry = ECFM_TRUE;
                            b1IsidEntry = ECFM_FALSE;
                        }
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR_VLAN:
                    case CLI_ECFM_SHOW_CONFIG_ERROR_VSI:
                        i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                        if (i4VlanId == i4ErrListVid)

                        {
                            b1Entry = ECFM_TRUE;
                            b1IsidEntry = ECFM_FALSE;
                        }
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR_INTF:
                        if (u4IfIndex == (UINT4) i4ErrListIfIndex)
                        {
                            b1Entry = ECFM_TRUE;
                            b1IsidEntry = ECFM_FALSE;
                        }
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR:
                        b1Entry = ECFM_TRUE;
                        b1IsidEntry = ECFM_FALSE;
                        break;
                    case CLI_ECFM_SHOW_CONFIG_ERROR_ISID_INTF:
                        if ((i4ErrListVid ==
                             (ECFM_ISID_TO_ISID_INTERNAL (*pu1Arg1))) &&
                            (u4IfIndex == (UINT4) i4ErrListIfIndex))
                        {
                            b1Entry = ECFM_TRUE;
                            b1IsidEntry = ECFM_TRUE;
                        }
                        break;

                    case CLI_ECFM_SHOW_CONFIG_ERROR_ISID:
                        if (i4ErrListVid == ECFM_ISID_TO_ISID_INTERNAL
                            (*pu1Arg1))
                        {
                            b1Entry = ECFM_TRUE;
                            b1IsidEntry = ECFM_TRUE;
                        }
                        break;
                    default:
                        break;
                }

                /*  If entry found */
                if (b1Entry == ECFM_TRUE)
                {
                    u2Entries = u2Entries + 1;
                    CfaCliGetIfName ((UINT4) i4ErrListIfIndex, pi1IfName);
                    CliPrintf (CliHandle, "interface : %-7s", pi1IfName);
                    if (b1IsidEntry == ECFM_TRUE)
                    {
                        CliPrintf (CliHandle, "ISID : %d\r\n",
                                   ECFM_ISID_INTERNAL_TO_ISID (i4ErrListVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "VLAN : %d\r\n", i4ErrListVid);
                    }
                    if (RetErrorType.pu1_OctetList[ECFM_INDEX_ZERO] == 0)
                    {
                        CliPrintf (CliHandle, "None\r\n");
                    }
                    else
                    {
                        /* Multiple errors can exist for an Interface
                         * and VLAN 
                         */
                        u1Temp = ECFM_INIT_VAL;
                        for (u1Counter = ECFM_VAL_7; u1Counter > ECFM_VAL_3;
                             u1Counter--)

                        {
                            if (ECFM_GET_U1BIT
                                (RetErrorType.pu1_OctetList[ECFM_INDEX_ZERO],
                                 u1Counter) == ECFM_TRUE)

                            {
                                u1Error = u1Counter - (u1Counter - u1Temp);
                                switch (u1Error)

                                {
                                    case ECFM_CONFIG_ERR_CFM_LEAK:
                                        CliPrintf (CliHandle, "Cfm Leak\r\n");
                                        break;
                                    case ECFM_CONFIG_ERR_CONFLICT_VIDS:
                                        CliPrintf (CliHandle,
                                                   "Conflicting Vids\r\n");
                                        break;
                                    case ECFM_CONFIG_ERR_EXCESS_LEVELS:
                                        CliPrintf (CliHandle,
                                                   "Excessive Levels\r\n");
                                        break;
                                    case ECFM_CONFIG_ERR_OVERLAPPED_LEVELS:
                                        CliPrintf (CliHandle,
                                                   "Overlapped Levels\r\n");
                                        break;
                                    default:
                                        break;
                                }
                            }
                            u1Temp = u1Temp + 1;
                        }
                    }
                    u4PagingStatus =
                        CliPrintf (CliHandle,
                                   "---------------------------------------------\r\n");
                }
            }
            i4PrevVid = i4CurrVid;
            i4PrevMdLevel = i4CurrMdLevel;
            i4PrevDir = i4CurrDir;
            i4IfIndex = i4NextIfIndex;
        }
        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmConfigErrorListTable
            (i4ErrListVid, &i4NextErrListVid,
             i4ErrListIfIndex, &i4NextErrListIfIndex);
        /* Check if entry exist and belongs to required context */
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (i4NextErrListIfIndex,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    &u2LocalPort) ==
                ECFM_VCM_SUCCESS)
            {
                if (i4CurrentContextId != i4NextContextId)

                {
                    b1IsShowAll = ECFM_FALSE;
                }
            }
            i4ErrListVid = i4NextErrListVid;
            i4ErrListIfIndex = i4NextErrListIfIndex;
            b1Entry = ECFM_FALSE;
        }
        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }
    if (u2Entries == 0)

    {
        CliPrintf (CliHandle, "None\r\n\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "\r\n");
    }
    return CLI_SUCCESS;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmCliSelectContextOnMode                       
 *                                                                           
 *    Description         : This function is used to check the Mode of       
 *                          the command and also if it a Config Mode         
 *                          command it will do SelectContext for the         
 *                          Context.                                         
 *                                                                           
 *    Input(s)            : u4Cmd - CLI Command.                             
 *                                                                           
 *    Output(s)           : CliHandle - Contains error messages.             
 *                          pu4ContextId - Context Id.                       
 *                          pu2LocalPort - Local Port Number.                
 *                                                                           
 *    Returns            : ECFM_SUCCESS/ECFM_FAILURE                         
 *                                                                          
 *                                                                           
 *****************************************************************************/
INT4
EcfmCliSelectContextOnMode (tCliHandle CliHandle, UINT4 u4Cmd,
                            UINT4 *pu4Context, UINT2 *pu2LocalPort,
                            BOOL1 * pb1LbLtTskCmd)
{
    UINT4               u4ContextId;
    INT4                i4PortId = 0;
    BOOL1               b1IntfCmd = ECFM_FALSE;
    *pu4Context = ECFM_DEFAULT_CONTEXT;

    /* Get the Context-Id from the pCliContext structure */
    u4ContextId = CLI_GET_CXT_ID ();

    /* Check if the command is a switch mode command */
    if (u4ContextId != ECFM_CLI_INVALID_CONTEXT)

    {

        /* Switch-mode Command */
        *pu4Context = u4ContextId;
    }

    else

    {

        /* This flag (b1IntfCmd) is used only in case of MI. 
         * If the command is a Domain mode command then the context-id won't be
         * ECFM_CLI_INVALID_CONTEXT, So this is an interface mode command.
         * Now by refering this flag we have to get the context-id and 
         * local port number from the IfIndex (CLI_GET_IFINDEX). */
        b1IntfCmd = ECFM_TRUE;
    }
    i4PortId = CLI_GET_IFINDEX ();

    /* In SI both the i4PortId and Localport are same. So no need to call
     * EcfmGetContextInfoFromIfIndex. */
    *pu2LocalPort = (UINT4) i4PortId;
    if (EcfmVcmGetSystemMode (ECFM_PROTOCOL_ID) == VCM_MI_MODE)

    {
        if (b1IntfCmd == ECFM_TRUE)

        {

            /* This is an Interface Mode command
             * Get the context Id from the IfIndex */
            if (i4PortId != -1)

            {
                if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
                    ((UINT2) i4PortId, pu4Context, pu2LocalPort) != VCM_SUCCESS)

                {
                    CliPrintf (CliHandle, "\r%% Interface not mapped to "
                               "any of the context.\r\n ");
                    return ECFM_FAILURE;
                }
            }
        }
    }

    /* Since we are calling SI nmh routine for Configuration commands
     * we have to do SelectContext for Config commands*/
    switch (u4Cmd)

    {
        case CLI_ECFM_LTR_CACHE:
        case CLI_ECFM_LTR_CACHE_SET_HOLDTIME:
        case CLI_ECFM_LTR_CACHE_SET_SIZE:
        case CLI_ECFM_LTR_CACHE_RESET_SIZE:
        case CLI_ECFM_LTR_CACHE_RESET_HOLDTIME:
            if (ECFM_IS_SYSTEM_SHUTDOWN (*pu4Context))

            {
                CliPrintf (CliHandle, "\r%% ECFM is shutdown\r\n ");
                ECFM_CC_RELEASE_CONTEXT ();
                return ECFM_FAILURE;
            }
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (ECFM_LBLT_SELECT_CONTEXT (*pu4Context) != ECFM_SUCCESS)

            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return ECFM_FAILURE;
            }
            *pb1LbLtTskCmd = ECFM_TRUE;
            break;
        default:
            if (ECFM_CC_SELECT_CONTEXT (*pu4Context) != ECFM_SUCCESS)

            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                return ECFM_FAILURE;
            }
            if ((ECFM_IS_SYSTEM_SHUTDOWN (*pu4Context)) &&
                (u4Cmd != CLI_ECFM_SYS_CTRL))

            {
                CliPrintf (CliHandle, "\r%% ECFM is shutdown\r\n ");
                ECFM_CC_RELEASE_CONTEXT ();
                return ECFM_FAILURE;
            }
    }
    return ECFM_SUCCESS;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmCliGetContextForShowCmd                       
 *                                                                           
 *    Description         : This function is called only when the show       
 *                          command is given. It handles 3 different         
 *                          sceneario of show commands.                      
 *                            1. If switch name is given, we have to get     
 *                               the context Id from it.                     
 *                            2. If Interface Index is present, from that    
 *                               we have to get the context Id.              
 *                            3. Else we have to go for each and every       
 *                               context.                                    
 *                          For the above all thing we have to check for     
 *                          the System status of the context.                
 *                                                                           
 *    Input(s)            : u4Cmd            - Command.                      
 *                          pu1Name          - Switch-Name.                 
 *                          u4IfIndex        - Interface Index.              
 *                          u4CurrContext    - Context-Id.                   
 *                                                                           
 *    Output(s)           : CliHandle        - Contains error messages.      
 *                          pu4NextContextId - Context Id.                   
 *                          pu2LocalPort     - Local Port Number.            
 *                                                                           
 *    Returns            : ECFM_SUCCESS/ECFM_FAILURE                         
 *                                                                           
 *                                                                           
 ***************************************************************************/
INT4
EcfmCliGetContextForShowCmd (tCliHandle CliHandle, UINT4 u4Cmd,
                             UINT1 *pu1Name, UINT4 u4IfIndex,
                             UINT4 u4CurrContext, UINT4 *pu4NextContext,
                             UINT2 *pu2LocalPort)
{
    UINT4               u4ContextId;
    UINT4               u4TempContextId;
    UINT1               au1TempContextName[ECFM_SWITCH_ALIAS_LEN];
    *pu2LocalPort = 0;

    /* If Switch-name is given then get the Context-Id from it */
    if ((pu1Name != NULL) && (u4IfIndex != 0))

    {
        if (VcmIsSwitchExist (pu1Name, &u4ContextId) != VCM_TRUE)

        {
            CliPrintf (CliHandle, "Switch %s Does not exist.\r\n", pu1Name);
            return ECFM_FAILURE;
        }
        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
            (u4IfIndex, &u4TempContextId, pu2LocalPort) != VCM_SUCCESS)

        {
            CliPrintf (CliHandle, "\r%% Interface not mapped to "
                       "any of the context.\r\n ");
            return ECFM_FAILURE;
        }
        if (u4TempContextId != u4ContextId)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {
        if (pu1Name != NULL)

        {
            if (VcmIsSwitchExist (pu1Name, &u4ContextId) != VCM_TRUE)

            {
                CliPrintf (CliHandle, "Switch %s Does not exist.\r\n", pu1Name);
                return ECFM_FAILURE;
            }
        }

        /* If IfIndex is given then get the Context-Id from it */
        else if (u4IfIndex != 0)

        {
            if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
                (u4IfIndex, &u4ContextId,  pu2LocalPort) != VCM_SUCCESS)

            {
                CliPrintf (CliHandle, "\r%% Interface not mapped to "
                           "any of the context.\r\n ");
                return ECFM_FAILURE;
            }
        }

        else

        {

            /* Case 1: At first entry for this funtion, If Switch-name is not given, 
               then get the first active Context. For this if we give 
               0xffffffff as current context for EcfmGetNextActiveContext 
               function it will return the First Active context. 
               Case 2: At the Next frequent entries it will as per we want. */
            if (EcfmCcGetNextActiveContext (u4CurrContext, &u4ContextId) !=
                ECFM_SUCCESS)

            {
                return ECFM_FAILURE;
            }
        }
    }

    /* If switch name or interface index is not provided then it will display
       context name and return contextId for all created contexts one at a time,
       otherwise same is done for the specified context */
    do

    {
        u4CurrContext = u4ContextId;

        /* if switch name is not given we have to get the switch-name 
         * from context-id for Display purpose */
        if (!((u4Cmd == CLI_ECFM_DEBUG) || (u4Cmd == CLI_ECFM_NO_DEBUG)))

        {
            if (ECFM_MAX_CONTEXTS > 0)

            {
                ECFM_MEMSET (au1TempContextName, 0, ECFM_SWITCH_ALIAS_LEN);
                if (pu1Name == NULL)

                {
                    EcfmVcmGetAliasName (u4ContextId, au1TempContextName);
                }

                else

                {
                    STRNCPY (au1TempContextName, pu1Name,
                             ECFM_SWITCH_ALIAS_LEN - 1);
                }
                switch (u4Cmd)

                {
                    case CLI_ECFM_LB_DOM_VLAN:
                    case CLI_ECFM_LB_DOM_ISID:
                    case CLI_ECFM_LB_DOM:
                    case CLI_ECFM_LB_LEV_VLAN:
                    case CLI_ECFM_LB_LEV_SER:
                    case CLI_ECFM_LB_LEV_ISID:
                    case CLI_ECFM_LB_DOM_SER:
                    case CLI_ECFM_LB_LEV:
                    case CLI_ECFM_LT_DOMAIN_VLAN:
                    case CLI_ECFM_LT_DOMAIN_ISID:
                    case CLI_ECFM_LT_DOMAIN:
                    case CLI_ECFM_LT_LEVEL_VLAN:
                    case CLI_ECFM_LT_LEVEL_SER:
                    case CLI_ECFM_LT_LEVEL_ISID:
                    case CLI_ECFM_LT_LEVEL:
                    case CLI_ECFM_NO_GBL_DEBUG:
                    case CLI_ECFM_NO_DEBUG:
                    case CLI_ECFM_TST_DOM_ISID:
                    case CLI_ECFM_TST_DOM_VLAN:
                    case CLI_ECFM_TST_DOM_SER:
                    case CLI_ECFM_TST_DOM:
                    case CLI_ECFM_TST_LEV_ISID:
                    case CLI_ECFM_TST_LEV_VLAN:
                    case CLI_ECFM_TST_LEV:
                    case CLI_ECFM_FD_MEP_MPID_LEV_VLAN:
                    case CLI_ECFM_FD_MEP_MPID_DOM_VLAN:
                    case CLI_ECFM_FD_MEP_MPID_DOM_SER:
                    case CLI_ECFM_FD_MEP_MAC_LEV_VLAN:
                    case CLI_ECFM_FD_MEP_MAC_DOM_VLAN:
                    case CLI_ECFM_FD_MEP_MAC_DOM_SER:
                    case CLI_ECFM_FD_MEP_MPID_DOM_ISID:
                    case CLI_ECFM_FD_MEP_MAC_DOM_ISID:
                    case CLI_ECFM_FD_MEP_MPID_LEV_ISID:
                    case CLI_ECFM_FD_MEP_MAC_LEV_ISID:
                    case CLI_ECFM_FD_MEP_MPID_DOM:
                    case CLI_ECFM_FD_MEP_MAC_DOM:
                    case CLI_ECFM_FD_MEP_MPID_LEV:
                    case CLI_ECFM_FD_MEP_MAC_LEV:
                    case CLI_ECFM_FL_MEP_MPID_LEV_VLAN:
                    case CLI_ECFM_FL_MEP_MPID_DOM_VLAN:
                    case CLI_ECFM_FL_MEP_MPID_DOM_SER:
                    case CLI_ECFM_FL_MEP_MAC_LEV_VLAN:
                    case CLI_ECFM_FL_MEP_MAC_DOM_VLAN:
                    case CLI_ECFM_FL_MEP_MAC_DOM_SER:
                    case CLI_ECFM_FL_MEP_MPID_DOM_ISID:
                    case CLI_ECFM_FL_MEP_MAC_DOM_ISID:
                    case CLI_ECFM_FL_MEP_MPID_DOM:
                    case CLI_ECFM_FL_MEP_MAC_DOM:
                    case CLI_ECFM_FL_MEP_MPID_LEV_ISID:
                    case CLI_ECFM_FL_MEP_MAC_LEV_ISID:
                    case CLI_ECFM_FL_MEP_MPID_LEV:
                    case CLI_ECFM_FL_MEP_MAC_LEV:
                    case CLI_ECFM_TH_DOM_SER:
                    case CLI_ECFM_TH_DOM_VLAN:
                    case CLI_ECFM_TH_DOM_ISID:
                    case CLI_ECFM_TH_DOM:
                    case CLI_ECFM_TH_LEV_VLAN:
                    case CLI_ECFM_TH_LEV_ISID:
                    case CLI_ECFM_TH_LEV:
                    case CLI_ECFM_SHOW_SUMMARY:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM_SER:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM_SER:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MPID_LEV:
                    case CLI_ECFM_PROACTIVE_FD_MEP_MAC_LEV:
                    
                    case CLI_ECFM_TH_LEV_VSI:
                    case CLI_ECFM_TH_DOM_VSI:
                    case CLI_ECFM_FL_MEP_MAC_DOM_VSI:

                    case CLI_ECFM_FL_MEP_MAC_LEV_VSI:
                    case CLI_ECFM_FL_MEP_MPID_DOM_VSI:
                    case CLI_ECFM_FL_MEP_MPID_LEV_VSI:
                    case CLI_ECFM_FD_MEP_MAC_DOM_VSI:
                    case CLI_ECFM_FD_MEP_MAC_LEV_VSI:
                    case CLI_ECFM_FD_MEP_MPID_DOM_VSI:
                    case CLI_ECFM_FD_MEP_MPID_LEV_VSI:
                    case CLI_ECFM_LT_LEVEL_VSI:
                    case CLI_ECFM_LT_DOMAIN_VSI:
                    case CLI_ECFM_LB_LEV_VSI:
                    case CLI_ECFM_LB_DOM_VSI:
                        break;
                    case CLI_ECFM_CLR_ERR_DOM:
                    case CLI_ECFM_CLR_ERR_LEV:
                    case CLI_ECFM_CLR_ERR_ALL:
                    case CLI_ECFM_CLR_RMEP_DB_DOM:
                    case CLI_ECFM_CLR_RMEP_DB_LEV:
                    case CLI_ECFM_CLR_RMEP_DB_ALL:
                    case CLI_ECFM_CLR_TRACEROUTE_CACHE:
                    case CLI_ECFM_CLR_MIP_CCM_DB:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VLAN:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VSI:             
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VSI:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_ISID:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VLAN:
                    case CLI_ECFM_CLR_MEP_STATS_ON_INTF_ISID:
                    case CLI_ECFM_CLR_INTF_STATS:
                    case CLI_ECFM_CLR_GLOBAL_STATS:
                    case CLI_ECFM_CLR_FD_BUFFER:
                    case CLI_ECFM_CLR_LBR_CACHE:
                    case CLI_ECFM_CLR_FL_BUFFER:
                    case CLI_ECFM_CLR_ERR_LOG:
                    case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV:
                    case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV_SER:
                        CliPrintf (CliHandle,
                                   "\r\n\rClearing for Switch %s\r\n",
                                   au1TempContextName);
                        break;
                    default:
                        CliPrintf (CliHandle, "\r\n\rSwitch %s\r\n",
                                   au1TempContextName);
                }
            }
        }
        if ((ECFM_IS_SYSTEM_INITIALISED () != ECFM_TRUE) ||
            (ECFM_IS_SYSTEM_STARTED (u4ContextId) != ECFM_TRUE))

        {
            if (!((u4Cmd == CLI_ECFM_DEBUG) || (u4Cmd == CLI_ECFM_NO_DEBUG)))
            {
                CliPrintf (CliHandle, "\r%% ECFM is shutdown\r\n");
            }
            if (pu1Name != NULL)

            {

                /* We have to come out of the loop when the switch is 
                 * shutdown, if the command is for specific switch else
                 * continue the Loop. */
                break;
            }
            continue;
        }
        *pu4NextContext = u4ContextId;
        return ECFM_SUCCESS;
    }
    while (EcfmCcGetNextActiveContext (u4CurrContext, &u4ContextId) ==
           ECFM_SUCCESS);
    return ECFM_FAILURE;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowRunningConfigInterfaceDetails              */
/*                                                                           */
/*     DESCRIPTION      : This function displays interface objects in Ecfm   */
/*                        for show running configuration.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        i4IfIndex - Interface value                        */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
VOID
EcfmShowRunningConfigInterfaceDetails (tCliHandle CliHandle, INT4 i4IfIndex,
                                       UINT1 *pu1Flag)
{
    INT4                i4PortModuleStatus = ECFM_INIT_VAL;
    INT4                i4Y1731PortModuleStatus = ECFM_INIT_VAL;
    INT4                i4PortLLCEncapStatus = ECFM_INIT_VAL;
    INT4                i4MepDirection = ECFM_INIT_VAL;
    INT4                i4MepActive = ECFM_INIT_VAL;
    INT4                i4MipActive = ECFM_INIT_VAL;
    INT4                i4MipIfIndex = ECFM_INIT_VAL;
    INT4                i4MipMdLevel = ECFM_INIT_VAL;
    INT4                i4MipVid = ECFM_INIT_VAL;
    INT4                i4NextMipMdLevel = ECFM_INIT_VAL;
    INT4                i4NextMipVid = ECFM_INIT_VAL;
    INT4                i4RetMipRowStatus = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4MepIfIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIndex = ECFM_INIT_VAL;
    UINT2               u2LocalPortId = ECFM_INIT_VAL;
    UINT2               u2RetPortNum = ECFM_INIT_VAL;
    UINT1               au1NameStr[CFA_MAX_PORT_NAME_LENGTH];
    BOOL1               b1SameContext = ECFM_TRUE;

    ECFM_MEMSET (au1NameStr, ECFM_INIT_VAL, CFA_MAX_PORT_NAME_LENGTH);
    /* Needed this check when called from Cfa */
    if (ECFM_IS_SYSTEM_INITIALISED () != ECFM_TRUE)

    {
        return;
    }
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
        (i4IfIndex, &u4ContextId, &u2LocalPortId) == VCM_FAILURE)

    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return;
    }
    if (ECFM_IS_SYSTEM_STARTED (u4ContextId) != ECFM_TRUE)

    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        return;
    }
    if (nmhValidateIndexInstanceFsMIEcfmPortTable (i4IfIndex) == SNMP_SUCCESS)
    {
        /* Ecfm Port Module Enable */
        nmhGetFsMIEcfmPortModuleStatus (i4IfIndex, &i4PortModuleStatus);
        if (i4PortModuleStatus == (ECFM_ENABLE))
        {
            if (*pu1Flag == ECFM_FALSE)
            {

                EcfmCfaCliConfGetIfName (i4IfIndex, (INT1 *) au1NameStr);
                CliPrintf (CliHandle, "interface %s\r\n", au1NameStr);
                *pu1Flag = ECFM_TRUE;
            }

            CliPrintf (CliHandle, "ethernet cfm enable\r\n");
        }

        /* Y1731 Port Module Status */
        nmhGetFsMIY1731PortOperStatus (i4IfIndex, &i4Y1731PortModuleStatus);
        if (i4Y1731PortModuleStatus == ECFM_ENABLE)
        {
            if (*pu1Flag == ECFM_FALSE)
            {

                EcfmCfaCliConfGetIfName (i4IfIndex, (INT1 *) au1NameStr);
                CliPrintf (CliHandle, "interface %s\r\n", au1NameStr);
                *pu1Flag = ECFM_TRUE;
            }

            CliPrintf (CliHandle, "ethernet cfm y1731 enable\r\n");
        }

        /* LLC Encap Enable */
        nmhGetFsMIEcfmPortLLCEncapStatus (i4IfIndex, &i4PortLLCEncapStatus);
        if (i4PortLLCEncapStatus == ECFM_SNMP_TRUE)

        {
            if (*pu1Flag == ECFM_FALSE)
            {

                EcfmCfaCliConfGetIfName (i4IfIndex, (INT1 *) au1NameStr);
                CliPrintf (CliHandle, "interface %s\r\n", au1NameStr);
                *pu1Flag = ECFM_TRUE;
            }

            CliPrintf (CliHandle, "ethernet cfm llc-encap enable\r\n");
        }

        /*Mep Table */
        u4CurrContextId = u4ContextId;
        b1SameContext = ECFM_TRUE;
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                                    &u4NextContextId, 0,
                                                    &u4MdIndex, 0,
                                                    &u4MaIndex, 0, &u4MepIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }

        /* MepTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                         u4MaIndex, u4MepIndex,
                                         (UINT4 *) &i4RetPriVlanId);
            nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                        u4MaIndex, u4MepIndex, &i4MepDirection);
            nmhGetFsMIEcfmMepActive (u4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIndex, &i4MepActive);
            nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                      u4MepIndex, (INT4 *) &u4MepIfIndex);
            if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
                (u4MepIfIndex, &u4CurrContextId,
                 &u2RetPortNum) != ECFM_VCM_SUCCESS)
            {
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                return;
            }
            nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);
            if (i4RetPriVlanId == 0)

            {
                nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                               u4MaIndex, &i4RetPriVlanId);
            }
            nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                        u4MaIndex, u4MepIndex,
                                        &i4RetMepRowStatus);
            if ((u2LocalPortId == u2RetPortNum)
                && (i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE))

            {
                if (i4MepDirection == ECFM_MP_DIR_DOWN)

                {
                    if (i4RetPriVlanId != 0)

                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                        {
                            if (*pu1Flag == ECFM_FALSE)
                            {

                                EcfmCfaCliConfGetIfName (i4IfIndex,
                                                         (INT1 *) au1NameStr);
                                CliPrintf (CliHandle, "interface %s\r\n",
                                           au1NameStr);
                                *pu1Flag = ECFM_TRUE;
                            }

                            CliPrintf (CliHandle,
                                       "ethernet cfm mep level %u mpid %u"
                                       " service-instance %u", u4RetMdLevel,
                                       u4MepIndex,
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4RetPriVlanId));
                        }
                        else
                        {
                            if (*pu1Flag == ECFM_FALSE)
                            {

                                EcfmCfaCliConfGetIfName (i4IfIndex,
                                                         (INT1 *) au1NameStr);
                                CliPrintf (CliHandle, "interface %s\r\n",
                                           au1NameStr);
                                *pu1Flag = ECFM_TRUE;
                            }
#ifdef VSI_WANTED                        
                            if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                            {
                                CliPrintf (CliHandle,
                                           "ethernet cfm mep level %u mpid %u vsi "
                                           "%u", u4RetMdLevel, u4MepIndex,
                                           i4RetPriVlanId);
                            }
                            else
#endif
                            {
                            CliPrintf (CliHandle,
                                       "ethernet cfm mep level %u mpid %u vlan "
                                       "%u", u4RetMdLevel, u4MepIndex,
                                       i4RetPriVlanId);
                        }
                    }
                    }

                    else

                    {
                        if (*pu1Flag == ECFM_FALSE)
                        {

                            EcfmCfaCliConfGetIfName (i4IfIndex,
                                                     (INT1 *) au1NameStr);
                            CliPrintf (CliHandle, "interface %s\r\n",
                                       au1NameStr);
                            *pu1Flag = ECFM_TRUE;
                        }

                        CliPrintf (CliHandle,
                                   "ethernet cfm mep level %u mpid %u",
                                   u4RetMdLevel, u4MepIndex);
                    }
                }

                else

                {
                    if (i4RetPriVlanId != 0)

                    {
                        if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                        {
                            if (*pu1Flag == ECFM_FALSE)
                            {

                                EcfmCfaCliConfGetIfName (i4IfIndex,
                                                         (INT1 *) au1NameStr);
                                CliPrintf (CliHandle, "interface %s\r\n",
                                           au1NameStr);
                                *pu1Flag = ECFM_TRUE;
                            }

                            CliPrintf (CliHandle,
                                       "ethernet cfm mep level %u inward mpid "
                                       "%u service-instance %u", u4RetMdLevel,
                                       u4MepIndex,
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4RetPriVlanId));
                        }
                        else
                        {
                            if (*pu1Flag == ECFM_FALSE)
                            {

                                EcfmCfaCliConfGetIfName (i4IfIndex,
                                                         (INT1 *) au1NameStr);
                                CliPrintf (CliHandle, "interface %s\r\n",
                                           au1NameStr);
                                *pu1Flag = ECFM_TRUE;
                            }

#ifdef VSI_WANTED                        
                            if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                            {
                                CliPrintf (CliHandle,
                                           "ethernet cfm mep level %u inward mpid %u"
                                           " vsi %u", u4RetMdLevel, u4MepIndex,
                                           i4RetPriVlanId);
                            }
                            else
#endif
                            {
                            CliPrintf (CliHandle,
                                       "ethernet cfm mep level %u inward mpid %u"
                                       " vlan %u", u4RetMdLevel, u4MepIndex,
                                       i4RetPriVlanId);
                        }
                        }

                    }
                    else

                    {
                        if (*pu1Flag == ECFM_FALSE)
                        {

                            EcfmCfaCliConfGetIfName (i4IfIndex,
                                                     (INT1 *) au1NameStr);
                            CliPrintf (CliHandle, "interface %s\r\n",
                                       au1NameStr);
                            *pu1Flag = ECFM_TRUE;
                        }

                        CliPrintf (CliHandle,
                                   "ethernet cfm mep level %u inward mpid %u",
                                   u4RetMdLevel, u4MepIndex);
                    }
                }
                if (i4MepActive == ECFM_SNMP_TRUE)

                {
                    if (*pu1Flag == ECFM_FALSE)
                    {

                        EcfmCfaCliConfGetIfName (i4IfIndex,
                                                 (INT1 *) au1NameStr);
                        CliPrintf (CliHandle, "interface %s\r\n", au1NameStr);
                        *pu1Flag = ECFM_TRUE;
                    }

                    CliPrintf (CliHandle, " active");
                }
                CliPrintf (CliHandle, "\r\n");

                /* Show Mep Details */
                EcfmShowRunningConfigMepDetails (CliHandle, u4CurrContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIndex,
                                                 ECFM_ETH_SHOW_RUNNING_CONFIG);
                CliPrintf (CliHandle, "! \r\n");
            }

            /* move to next Mep */
            i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                                        &u4NextContextId,
                                                        u4MdIndex,
                                                        &u4NextMdIndex,
                                                        u4MaIndex,
                                                        &u4NextMaIndex,
                                                        u4MepIndex,
                                                        &u4NextMepIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                u4MepIndex = u4NextMepIndex;

                /* same contex entry is valid */
                if (u4CurrContextId != u4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }

        /*Mip Table */
        u4CurrContextId = u4ContextId;
        u4NextContextId = ECFM_INIT_VAL;
        b1SameContext = ECFM_TRUE;
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMipTable (i4IfIndex, &i4MipIfIndex, 0,
                                             &i4MipMdLevel, 0, &i4MipVid);
        while (i4RetVal == SNMP_SUCCESS)
        {
            if (i4IfIndex == i4MipIfIndex)
            {
                nmhGetFsMIEcfmMipActive (i4MipIfIndex,
                                         i4MipMdLevel, i4MipVid, &i4MipActive);
                nmhGetFsMIEcfmMipRowStatus (i4MipIfIndex, i4MipMdLevel,
                                            i4MipVid, &i4RetMipRowStatus);
                if (i4RetMipRowStatus == ECFM_ROW_STATUS_ACTIVE)

                {

                    if (ECFM_IS_MEP_ISID_AWARE (i4MipVid))
                    {
                        if (*pu1Flag == ECFM_FALSE)
                        {

                            EcfmCfaCliConfGetIfName (i4IfIndex,
                                                     (INT1 *) au1NameStr);
                            CliPrintf (CliHandle, "interface %s\r\n",
                                       au1NameStr);
                            *pu1Flag = ECFM_TRUE;
                        }

                        CliPrintf (CliHandle, "ethernet cfm mip level %u "
                                   "service-instance %u", i4MipMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4MipVid));
                    }
                    else
                    {
                        if (*pu1Flag == ECFM_FALSE)
                        {

                            EcfmCfaCliConfGetIfName (i4IfIndex,
                                                     (INT1 *) au1NameStr);
                            CliPrintf (CliHandle, "interface %s\r\n",
                                       au1NameStr);
                            *pu1Flag = ECFM_TRUE;
                        }

#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4MipVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle, "ethernet cfm mip level %u "
                                       "vsi %u", i4MipMdLevel, i4MipVid);
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle, "ethernet cfm mip level %u "
                                   "vlan %u", i4MipMdLevel, i4MipVid);
                    }
                    }
                    if (i4MipActive == ECFM_SNMP_TRUE)

                    {
                        if (*pu1Flag == ECFM_FALSE)
                        {

                            EcfmCfaCliConfGetIfName (i4IfIndex,
                                                     (INT1 *) au1NameStr);
                            CliPrintf (CliHandle, "interface %s\r\n",
                                       au1NameStr);
                            *pu1Flag = ECFM_TRUE;
                        }

                        CliPrintf (CliHandle, " active");
                    }
                    CliPrintf (CliHandle, "\r\n");
                }
                i4RetVal = nmhGetNextIndexFsMIEcfmMipTable (i4IfIndex,
                                                            &i4MipIfIndex,
                                                            i4MipMdLevel,
                                                            &i4NextMipMdLevel,
                                                            i4MipVid,
                                                            &i4NextMipVid);
            }
            else
            {
                break;
            }
            i4MipMdLevel = i4NextMipMdLevel;
            i4MipVid = i4NextMipVid;
        }

        /*Mip  Prevent Table */
        u4CurrContextId = (INT4) (u4ContextId);
        u4NextContextId = ECFM_INIT_VAL;
        b1SameContext = ECFM_TRUE;
        i4RetVal =
            nmhGetNextIndexFsMIEcfmDynMipPreventionTable (i4IfIndex,
                                                          &i4MipIfIndex, 0,
                                                          &i4MipMdLevel, 0,
                                                          &i4MipVid);
        while (i4RetVal == SNMP_SUCCESS)
        {
            if (i4IfIndex == i4MipIfIndex)
            {
                nmhGetFsMIEcfmDynMipPreventionRowStatus (i4MipIfIndex,
                                                         i4MipMdLevel,
                                                         i4MipVid,
                                                         &i4RetMipRowStatus);
                if (i4RetMipRowStatus == ECFM_ROW_STATUS_ACTIVE)

                {
                    if (*pu1Flag == ECFM_FALSE)
                    {

                        EcfmCfaCliConfGetIfName (i4IfIndex,
                                                 (INT1 *) au1NameStr);
                        CliPrintf (CliHandle, "interface %s\r\n", au1NameStr);
                        *pu1Flag = ECFM_TRUE;
                    }

                    CliPrintf (CliHandle, "restrict ethernet cfm mip "
                               "dynamic evaluation level %u "
                               "service %u", i4MipMdLevel, i4MipVid);
                    CliPrintf (CliHandle, "\r\n");
                }
                i4RetVal = nmhGetNextIndexFsMIEcfmMipTable (i4IfIndex,
                                                            &i4MipIfIndex,
                                                            i4MipMdLevel,
                                                            &i4NextMipMdLevel,
                                                            i4MipVid,
                                                            &i4NextMipVid);
            }
            else
            {
                break;
            }
            i4MipMdLevel = i4NextMipMdLevel;
            i4MipVid = i4NextMipVid;
        }

    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowRunningConfigMepDetails                    */
/*                                                                           */
/*     DESCRIPTION      : This function displays Mep objects in Ecfm/Y1731   */
/*                        for show running configuration.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrentContextId - Current contextId             */
/*                      : u4MdIndex  -Md Index                               */
/*                      : u4MaIndex  -Ma Index                               */
/*                      : u4MepIndex -Mep Index                              */
/*                      : u1Module   -Module Index                           */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
VOID
EcfmShowRunningConfigMepDetails (tCliHandle CliHandle,
                                 INT4 i4CurrentContextId,
                                 UINT4 u4MdIndex, UINT4 u4MaIndex,
                                 UINT4 u4MepIndex, UINT1 u1Module)
{
    tEcfmMacAddr        au1InMacAddr;
    tEcfmMacAddr        au1AisClintMacAddr;
    tEcfmMacAddr        au1LckClintMacAddr;
    UINT4               u4RetValFsMIY1731MepFrameDelayThreshold = ECFM_INIT_VAL;
    UINT4               u4MepNearEndFrameLossThreshold = ECFM_INIT_VAL;
    UINT4               u4MepFarEndFrameLossThreshold = ECFM_INIT_VAL;
    INT4                i4Mep1DmTransInterval = ECFM_INIT_VAL;
    INT4                i4MepLckInterval = ECFM_INIT_VAL;
    INT4                i4MepLckDelay = ECFM_INIT_VAL;
    INT4                i4MepOutOfService = ECFM_INIT_VAL;
    INT4                i4OffLoadStatus = ECFM_INIT_VAL;
    INT4                i4AisIsMultiCastAddr = (INT4) ECFM_INIT_VAL;
    INT4                i4LckIsMultiCastAddr = (INT4) ECFM_INIT_VAL;
    INT4                i4MepAisOffloadStatus = (INT4) ECFM_INIT_VAL;
    INT4                i4MepLowPriDef = ECFM_INIT_VAL;
    INT4                i4MepLoopbackStatus = ECFM_INIT_VAL;
    INT4                i4MepResetTime = ECFM_INIT_VAL;
    INT4                i4MepAlarmTime = ECFM_INIT_VAL;
    INT4                i4MepCsfRxCapability = ECFM_INIT_VAL;
    UINT4               u4MepLckPeroid = ECFM_INIT_VAL;
    UINT1               u1FieldValue = (UINT1) ECFM_FALSE;
    UINT1               u1TestValue = (UINT1) ECFM_FALSE;
    UINT1               au1String[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1AisString[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1LckString[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1ZeroString[ECFM_CLI_MAC_STRING_LENGTH] =
        { ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48,
        ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48,
        ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58,
        ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_32
    };

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        /* Get Frame Delay Value */
        nmhGetFsMIY1731MepFrameDelayThreshold ((UINT4) i4CurrentContextId,
                                               u4MdIndex, u4MaIndex,
                                               u4MepIndex,
                                               &u4RetValFsMIY1731MepFrameDelayThreshold);
        if (u4RetValFsMIY1731MepFrameDelayThreshold !=
            ECFM_FD_BUFFER_DEF_THRESHOLD)

        {
            CliPrintf (CliHandle, " set frame delay threshold %u\r\n",
                       u4RetValFsMIY1731MepFrameDelayThreshold);
        }

        /* Get DM Interval */
        nmhGetFsMIY1731Mep1DmTransInterval ((UINT4) i4CurrentContextId,
                                            u4MdIndex, u4MaIndex, u4MepIndex,
                                            &i4Mep1DmTransInterval);
        if (i4Mep1DmTransInterval != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, " set one-dm-transaction-interval %u\r\n",
                       i4Mep1DmTransInterval * ECFM_VAL_10);
        }
    }
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        ECFM_MEMSET (au1InMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);

        /* Get CCM Unicast Mac Address */
        nmhGetFsMIY1731MepUnicastCcmMacAddress ((UINT4) i4CurrentContextId,
                                                u4MdIndex, u4MaIndex,
                                                u4MepIndex, &au1InMacAddr);
        PrintMacAddress (au1InMacAddr, au1String);
        if (ECFM_MEMCMP (au1String, au1ZeroString, ECFM_CLI_MAC_STRING_LENGTH)
            != ECFM_INIT_VAL)

        {
            if (!(ECFM_IS_MULTICAST_ADDR (au1InMacAddr)))

            {
                CliPrintf (CliHandle, " set ccm-mac unicast %s\r\n", au1String);
            }
        }
    }
    /* Mep CCMOffloading Status */
    nmhGetFsMIEcfmMepCcmOffload ((UINT4) i4CurrentContextId, u4MdIndex,
                                 u4MaIndex, u4MepIndex, &i4OffLoadStatus);
    if (i4OffLoadStatus == ECFM_CCM_OFFLOAD_ENABLE)

    {
        if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
        {
            CliPrintf (CliHandle, " set ethernet cfm offload enable\r\n");
        }
        else
        {
            CliPrintf (CliHandle, "  set ccm Offload enable\r\n");
            nmhGetFsMIY1731MepAisOffload ((UINT4) i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIndex,
                                          &i4MepAisOffloadStatus);
            if (i4MepAisOffloadStatus == ECFM_MPLSTP_AIS_OFF_ENABLE)
            {
                CliPrintf (CliHandle, "  set ais Offload enable\r\n");
            }
        }
    }
    /* ETH-CSF Capability */
    nmhGetFsMIY1731MepCsfRxCapability ((UINT4) i4CurrentContextId, u4MdIndex,
            u4MaIndex, u4MepIndex, &i4MepCsfRxCapability);
    if (i4MepCsfRxCapability == ECFM_DISABLE)
    {
        CliPrintf (CliHandle, "set csf diable\r\n");
    }
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        ECFM_MEMSET (au1AisClintMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (au1LckClintMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (au1AisString, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);
        ECFM_MEMSET (au1LckString, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);
        nmhGetFsMIY1731MepAisDestIsMulticast ((UINT4) i4CurrentContextId,
                                              u4MdIndex, u4MaIndex, u4MepIndex,
                                              &i4AisIsMultiCastAddr);
        nmhGetFsMIY1731MepLckDestIsMulticast ((UINT4) i4CurrentContextId,
                                              u4MdIndex, u4MaIndex, u4MepIndex,
                                              &i4LckIsMultiCastAddr);
        nmhGetFsMIY1731MepAisClientMacAddress ((UINT4) i4CurrentContextId,
                                               u4MdIndex, u4MaIndex, u4MepIndex,
                                               &au1AisClintMacAddr);
        nmhGetFsMIY1731MepLckClientMacAddress ((UINT4) i4CurrentContextId,
                                               u4MdIndex, u4MaIndex, u4MepIndex,
                                               &au1LckClintMacAddr);
        PrintMacAddress (au1AisClintMacAddr, au1AisString);
        au1AisString[ECFM_INDEX_SEVENTEEN] = '\0';
        if (i4AisIsMultiCastAddr == ECFM_SNMP_FALSE)

        {
            if (ECFM_MEMCMP
                (au1AisString, au1ZeroString,
                 ECFM_CLI_MAC_STRING_LENGTH) != ECFM_INIT_VAL)

            {
                if (!(ECFM_IS_MULTICAST_ADDR (au1AisClintMacAddr)))

                {
                    CliPrintf (CliHandle, " set client-layer-mac ais unicast "
                               "%s", au1AisString);
                    u1FieldValue = ECFM_TRUE;
                }
            }
        }
        PrintMacAddress (au1LckClintMacAddr, au1LckString);
        au1LckString[ECFM_INDEX_SEVENTEEN] = '\0';
        if (i4LckIsMultiCastAddr == ECFM_SNMP_FALSE)

        {
            if (ECFM_MEMCMP
                (au1LckString, au1ZeroString,
                 ECFM_CLI_MAC_STRING_LENGTH) != ECFM_INIT_VAL)

            {
                if (!(ECFM_IS_MULTICAST_ADDR (au1LckClintMacAddr)))

                {
                    if (u1FieldValue == ECFM_TRUE)

                    {
                        CliPrintf (CliHandle, " lck unicast %s\r\n",
                                   au1LckString);
                        u1TestValue = ECFM_TRUE;
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   " set client-layer-mac lck unicast "
                                   "%s\r\n", au1LckString);
                        u1TestValue = ECFM_TRUE;
                    }
                }
            }
        }
        if ((u1TestValue == ECFM_FALSE) && (u1FieldValue == ECFM_TRUE))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        nmhGetFsMIY1731MepFarEndFrameLossThreshold ((UINT4) i4CurrentContextId,
                                                    u4MdIndex, u4MaIndex,
                                                    u4MepIndex,
                                                    &u4MepFarEndFrameLossThreshold);
        nmhGetFsMIY1731MepNearEndFrameLossThreshold ((UINT4) i4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     u4MepIndex,
                                                     &u4MepNearEndFrameLossThreshold);
        if (u4MepNearEndFrameLossThreshold != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, " set frame loss threshold near-end "
                       "%u", u4MepNearEndFrameLossThreshold);
            if (u4MepFarEndFrameLossThreshold != ECFM_INIT_VAL)

            {
                CliPrintf (CliHandle, " far-end %u\r\n",
                           u4MepFarEndFrameLossThreshold);
            }

            else

            {
                CliPrintf (CliHandle, "\r\n");
            }
        }

        else

        {
            if (u4MepFarEndFrameLossThreshold != ECFM_INIT_VAL)

            {
                CliPrintf (CliHandle,
                           " set frame loss threshold far-end %u\r\n",
                           u4MepFarEndFrameLossThreshold);
            }
        }

        /* Reset the u1FieldValue to ECFM_FALSE */
        u1FieldValue = ECFM_FALSE;
        nmhGetFsMIY1731MepOutOfService ((UINT4) i4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIndex,
                                        &i4MepOutOfService);
        nmhGetFsMIY1731MepLckInterval ((UINT4) i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIndex,
                                       &i4MepLckInterval);
        nmhGetFsMIY1731MepLckPeriod ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex, &u4MepLckPeroid);
        nmhGetFsMIY1731MepLckDelay ((UINT4) i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIndex, &i4MepLckDelay);
        if ((i4MepOutOfService != ECFM_SNMP_FALSE)
            || (i4MepLckInterval != ECFM_CC_AIS_LCK_INTERVAL_1_SEC)
            || (i4MepLckDelay != ECFM_CC_LCK_DEFAULT_DELAY)
            || (u4MepLckPeroid != ECFM_INIT_VAL))

        {
            if (i4MepOutOfService != ECFM_SNMP_FALSE)

            {
                CliPrintf (CliHandle, " set out-of-service");
                CliPrintf (CliHandle, " enable");
                u1FieldValue = ECFM_TRUE;
                if (i4MepLckInterval != ECFM_CC_AIS_LCK_INTERVAL_1_SEC)

                {
                    CliPrintf (CliHandle, " interval one-min");
                    u1FieldValue = ECFM_TRUE;
                }
                if (u4MepLckPeroid != ECFM_INIT_VAL)

                {
                    CliPrintf (CliHandle, " period %d", u4MepLckPeroid);
                    u1FieldValue = ECFM_TRUE;
                }
                if (i4MepLckDelay != ECFM_CC_LCK_DEFAULT_DELAY)

                {
                    CliPrintf (CliHandle, " delay %d", i4MepLckDelay);
                    u1FieldValue = ECFM_TRUE;
                }
                if (u1FieldValue == ECFM_TRUE)

                {
                    CliPrintf (CliHandle, "\r\n");
                }
            }
        }
        EcfmPrintDropEnable (CliHandle, i4CurrentContextId, u4MdIndex,
                             u4MaIndex, u4MepIndex);
        /* Lowest priority defect */
        nmhGetFsMIEcfmMepLowPrDef ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, u4MepIndex, &i4MepLowPriDef);

        if (i4MepLowPriDef != ECFM_DEF_MAC_REM_ERR_XCON)
        {
            CliPrintf (CliHandle, " set lowest-priority-defect ");
            if (i4MepLowPriDef == ECFM_DEF_ALL)
            {
                CliPrintf (CliHandle, "all-Defects");
            }
            else if (i4MepLowPriDef == ECFM_DEF_REM_ERR_XCON)
            {
                CliPrintf (CliHandle, "rem-Err-Xcon-Defects");
            }
            else if (i4MepLowPriDef == ECFM_DEF_ERR_XCON)
            {
                CliPrintf (CliHandle, "err-Xcon-Defects");
            }
            else if (i4MepLowPriDef == ECFM_DEF_XCON)
            {
                CliPrintf (CliHandle, "xcon-Defects");
            }
            else
            {
                CliPrintf (CliHandle, "noXcon-Defects");
            }
            CliPrintf (CliHandle, "\r\n");
        }

        /* MEP Loopback Status */
        nmhGetFsMIY1731MepLoopbackStatus ((UINT4) i4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIndex,
                                          &i4MepLoopbackStatus);

        if (i4MepLoopbackStatus == ECFM_SNMP_TRUE)
        {
            CliPrintf (CliHandle, "set ethernet cfm loopback enable\r\n");
        }

        nmhGetFsMIEcfmMepFngResetTime ((UINT4) i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIndex, &i4MepResetTime);
        if (i4MepResetTime != ECFM_FNG_RESET_TIME_MAX)
        {
            CliPrintf (CliHandle, " set alarm reset %d \r\n", i4MepResetTime);
        }
        nmhGetFsMIEcfmMepFngAlarmTime ((UINT4) i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, u4MepIndex, &i4MepAlarmTime);
        if (i4MepAlarmTime != ECFM_FNG_ALARM_TIME_MIN)
        {
            CliPrintf (CliHandle, " set alarm delay %d \r\n", i4MepAlarmTime);
        }

    }
    EcfmPrintServicePriority (CliHandle, i4CurrentContextId, u4MdIndex,
                              u4MaIndex, u4MepIndex, u1Module);
    EcfmPrintCapability (CliHandle, i4CurrentContextId, u4MdIndex,
                         u4MaIndex, u4MepIndex, u1Module);
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmPrintCapability                                */
/*                                                                           */
/*     DESCRIPTION      : This function displays ECFM Capability for show    */
/*                         running configuration Feature.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrentContextId - Current contextId             */
/*                      : u4MdIndex - Md Index                               */
/*                      : u4MaIndex -Ma Index                                */
/*                      : u4MepIndex -Mep Index                              */
/*                      : u1Module - Module Id                               */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmPrintCapability (tCliHandle CliHandle, INT4 i4CurrentContextId,
                     UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepIndex,
                     UINT1 u1Module)
{
    INT4                i4MepLoopbackCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4MepMulticastLbmRecvCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4MepMulticastTstRecvCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4MepTstRecvCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4Mep1DmRecvCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4MepDmrOptionalFields = (INT4) ECFM_INIT_VAL;
    INT4                i4MepAisInterval = (INT4) ECFM_INIT_VAL;
    INT4                i4MepAisCapability = (INT4) ECFM_INIT_VAL;
    INT4                i4MepRdiCapability = (INT4) ECFM_INIT_VAL;
    UINT4               u4MepAisPeriod = (UINT4) ECFM_INIT_VAL;
    UINT4               u4MepRdiPeriod = (UINT4) ECFM_INIT_VAL;
    UINT1               u1FlagFieldValue = (UINT1) ECFM_FALSE;
    UINT1               u1FieldValue = (UINT1) ECFM_FALSE;

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();
    nmhGetFsMIY1731MepLoopbackCapability ((UINT4) i4CurrentContextId,
                                          u4MdIndex, u4MaIndex, u4MepIndex,
                                          &i4MepLoopbackCapability);
    nmhGetFsMIY1731MepMulticastLbmRecvCapability ((UINT4)
                                                  i4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIndex,
                                                  &i4MepMulticastLbmRecvCapability);
    nmhGetFsMIY1731MepTstCapability ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepTstRecvCapability);
    nmhGetFsMIY1731MepMulticastTstRecvCapability ((UINT4)
                                                  i4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIndex,
                                                  &i4MepMulticastTstRecvCapability);
    nmhGetFsMIY1731Mep1DmRecvCapability ((UINT4) i4CurrentContextId,
                                         u4MdIndex, u4MaIndex, u4MepIndex,
                                         &i4Mep1DmRecvCapability);
    nmhGetFsMIY1731MepDmrOptionalFields ((UINT4) i4CurrentContextId,
                                         u4MdIndex, u4MaIndex, u4MepIndex,
                                         &i4MepDmrOptionalFields);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    nmhGetFsMIY1731MepRdiCapability ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepRdiCapability);
    nmhGetFsMIY1731MepAisCapability ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepAisCapability);
    nmhGetFsMIY1731MepAisInterval ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, u4MepIndex, &i4MepAisInterval);
    nmhGetFsMIY1731MepAisPeriod ((UINT4) i4CurrentContextId, u4MdIndex,
                                 u4MaIndex, u4MepIndex, &u4MepAisPeriod);
    nmhGetFsMIY1731MepRdiPeriod ((UINT4) i4CurrentContextId, u4MdIndex,
                                 u4MaIndex, u4MepIndex, &u4MepRdiPeriod);
    if (i4MepLoopbackCapability == ECFM_DISABLE)

    {
        CliPrintf (CliHandle, " set params capability disable ping \r\n");
    }
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        if (i4MepMulticastLbmRecvCapability == ECFM_ENABLE)

        {
            CliPrintf (CliHandle,
                       " set params capability enable multicast-ping\r\n");
        }
        if (i4MepMulticastTstRecvCapability == ECFM_ENABLE)

        {
            CliPrintf (CliHandle,
                       " set params capability enable multicast-test\r\n");
        }
        if (i4MepTstRecvCapability == ECFM_DISABLE)

        {
            CliPrintf (CliHandle, " set params capability disable test\r\n");
        }
        if (i4Mep1DmRecvCapability == ECFM_DISABLE)

        {
            CliPrintf (CliHandle, " set params capability disable"
                       " one-way-frame-delay\r\n");
        }
        if (i4MepDmrOptionalFields == ECFM_SNMP_TRUE)

        {
            CliPrintf (CliHandle, " set params capability enable"
                       " turnaround-delay\r\n");
        }
    }

    /* Reset the u1FieldValue,u1FlagFieldValue to ECFM_FALSE */
    u1FieldValue = ECFM_FALSE;
    u1FlagFieldValue = ECFM_FALSE;
    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        CliPrintf (CliHandle, " ");
    }
    if (i4MepAisCapability == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, " set ais enable");
        if (i4MepAisInterval != ECFM_CC_AIS_LCK_INTERVAL_1_SEC)

        {
            CliPrintf (CliHandle, " interval one-min");
        }
        if (u4MepAisPeriod != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, " period %u", u4MepAisPeriod);
        }
        CliPrintf (CliHandle, "\r\n");
    }
    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        CliPrintf (CliHandle, " ");
    }
    if (i4MepAisCapability == ECFM_DISABLE)

    {
        if (i4MepAisInterval != ECFM_CC_AIS_LCK_INTERVAL_1_SEC)

        {
            CliPrintf (CliHandle, " set ais interval one-min");
            u1FlagFieldValue = ECFM_TRUE;
        }
        if (u4MepAisPeriod != ECFM_INIT_VAL)

        {
            if (u1FlagFieldValue == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " period %u\r\n", u4MepAisPeriod);
            }

            else

            {
                CliPrintf (CliHandle, "  set ais period %u\r\n",
                           u4MepAisPeriod);
            }
            u1FieldValue = ECFM_TRUE;
        }
        if ((u1FlagFieldValue == ECFM_TRUE) && (u1FieldValue == ECFM_FALSE))

        {
            CliPrintf (CliHandle, "\r\n");
        }
    }
    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        CliPrintf (CliHandle, " ");
    }
    if (i4MepRdiCapability == ECFM_DISABLE)

    {
        CliPrintf (CliHandle, " set rdi disable");
        if (u4MepRdiPeriod != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, " period %u", u4MepRdiPeriod);
        }
        CliPrintf (CliHandle, "\r\n");
    }
    if (i4MepRdiCapability == ECFM_ENABLE)

    {
        if (u4MepRdiPeriod != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, " set rdi period %u\r\n", u4MepRdiPeriod);
        }
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmPrintDropEnable                                */
/*                                                                           */
/*     DESCRIPTION      : This function displays Drop Enable for show running*/
/*                        configuration.                                     */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrentContextId - Current contextId             */
/*                      : u4MdIndex - Md Index                               */
/*                      : u4MaIndex -Ma Index                                */
/*                      : u4MepIndex -Mep Index                              */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmPrintDropEnable (tCliHandle CliHandle, INT4 i4CurrentContextId,
                     UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepIndex)
{
    INT4                i4MepCcmDropEnable = ECFM_INIT_VAL;
    INT4                i4MepLmmDropEnable = ECFM_INIT_VAL;
    INT4                i4MepTstDropEnable = ECFM_INIT_VAL;
    INT4                i4MepAisDropEnable = ECFM_INIT_VAL;
    INT4                i4MepLckDropEnable = ECFM_INIT_VAL;
    INT4                i4MepLbmDropEnable = ECFM_INIT_VAL;
    INT4                i4MepLtmDropEnable = ECFM_INIT_VAL;
    INT4                i4MepDmmDropEnable = ECFM_INIT_VAL;
    INT4                i4Mep1DmDropEnable = ECFM_INIT_VAL;
    UINT1               u1FlagValue = ECFM_FALSE;
    nmhGetFsMIY1731MepTransmitLmmDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4MepLmmDropEnable);
    nmhGetFsMIY1731MepCcmDropEnable ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepCcmDropEnable);
    nmhGetFsMIY1731MepAisDropEnable ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepAisDropEnable);
    nmhGetFsMIY1731MepLckDropEnable ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &i4MepLckDropEnable);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();
    nmhGetFsMIY1731MepTransmitLbmDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4MepLbmDropEnable);
    nmhGetFsMIY1731MepTransmitLtmDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4MepLtmDropEnable);
    nmhGetFsMIY1731MepTransmitDmmDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4MepDmmDropEnable);
    nmhGetFsMIY1731MepTransmit1DmDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4Mep1DmDropEnable);
    nmhGetFsMIY1731MepTransmitTstDropEnable ((UINT4) i4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIndex, &i4MepTstDropEnable);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if ((i4MepCcmDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepLtmDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepLbmDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepDmmDropEnable != ECFM_SNMP_FALSE) &&
        (i4Mep1DmDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepLmmDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepTstDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepAisDropEnable != ECFM_SNMP_FALSE) &&
        (i4MepLckDropEnable != ECFM_SNMP_FALSE))

    {
        CliPrintf (CliHandle, " set drop-eligibility enable all\r\n");
    }

    else

    {
        if ((i4MepCcmDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepLtmDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepDmmDropEnable != ECFM_SNMP_FALSE) ||
            (i4Mep1DmDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepLmmDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepTstDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepAisDropEnable != ECFM_SNMP_FALSE) ||
            (i4MepLckDropEnable != ECFM_SNMP_FALSE))

        {
            CliPrintf (CliHandle, " set drop-eligibility enable");
            u1FlagValue = ECFM_TRUE;
        }
        if (i4MepCcmDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " ccm");
        }
        if (i4MepLtmDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " ltm");
        }
        if (i4Mep1DmDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " one-dm");
        }
        if (i4MepDmmDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " dmm");
        }
        if (i4MepLmmDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " lmm");
        }
        if (i4MepTstDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " tst");
        }
        if (i4MepAisDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " ais");
        }
        if (i4MepLckDropEnable != ECFM_SNMP_FALSE)

        {
            CliPrintf (CliHandle, " lck");
        }
        if (u1FlagValue == ECFM_TRUE)

        {
            CliPrintf (CliHandle, "\r\n");
        }
    }
    if (i4MepLbmDropEnable != ECFM_SNMP_TRUE)

    {
        CliPrintf (CliHandle, " set drop-eligibility disable lbm \r\n");
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmPrintServicePriority                           */
/*                                                                           */
/*     DESCRIPTION      : This function Print the service Priority For       */
/*                        for show running configuration.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrentContextId - Current contextId             */
/*                      : u4MdIndex  - Md Index                              */
/*                      : u4MaIndex  -Ma Index                               */
/*                      : u4MepIndex -Mep Index                              */
/*                      : u1Module   - Module Id                             */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmPrintServicePriority (tCliHandle CliHandle, INT4 i4CurrentContextId,
                          UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepIndex,
                          UINT1 u1Module)
{
    INT4                i4MepCcmVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepLbmVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepLtmVlanPriority = ECFM_INIT_VAL;
    INT4                i4Mep1DmVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepDmmVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepLmmVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepTstVlanPriority = ECFM_INIT_VAL;
    INT4                i4MepAisVlanPriority = ECFM_INIT_VAL;
    UINT4               u4MepLckVlanPriority = ECFM_INIT_VAL;
    UINT4               u4MepCcmLtmPriority = ECFM_INIT_VAL;
    INT4                i4Y1731PortOperStatus = ECFM_DISABLE;
    INT4                i4CurrentPriority = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    UNUSED_PARAM (u1Module);

    nmhGetFsMIY1731MepCcmPriority ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, u4MepIndex,
                                   &i4MepCcmVlanPriority);
    nmhGetFsMIY1731MepAisPriority ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, u4MepIndex,
                                   &i4MepAisVlanPriority);
    nmhGetFsMIY1731MepLckPriority ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, u4MepIndex,
                                   &u4MepLckVlanPriority);
    nmhGetFsMIY1731MepTransmitLmmPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4MepLmmVlanPriority);
    nmhGetFsMIEcfmMaPrimaryVlanId ((UINT4) i4CurrentContextId, u4MdIndex,
                                   u4MaIndex, &i4RetPriVlanId);
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        if (nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                      u4MepIndex,
                                      &i4MepIfIndex) != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, " Unable to retrieve the IfIndex "
                       "associated with the MEP-ID %u \r\n", u4MepIndex);
            return;
        }

        if (nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4Y1731PortOperStatus)
            != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, "Unable to retrieve the Port Operational Mode"
                       "for the IfIndex %d \r\n", i4MepIfIndex);
            return;
        }
    }

    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        i4Y1731PortOperStatus = ECFM_ENABLE;
    }
    nmhGetFsMIEcfmMepCcmLtmPriority ((UINT4) i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIndex,
                                     &u4MepCcmLtmPriority);
    ECFM_UNREGISTER_CLI_CC_LOCK ();

    ECFM_REGISTER_CLI_LBLT_LOCK ();
    nmhGetFsMIY1731MepTransmitLbmPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4MepLbmVlanPriority);
    nmhGetFsMIY1731MepTransmitLtmPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4MepLtmVlanPriority);
    nmhGetFsMIY1731MepTransmitTstPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4MepTstVlanPriority);
    nmhGetFsMIY1731MepTransmitDmmPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4MepDmmVlanPriority);
    nmhGetFsMIY1731MepTransmit1DmPriority ((UINT4) i4CurrentContextId,
                                           u4MdIndex, u4MaIndex, u4MepIndex,
                                           &i4Mep1DmVlanPriority);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();

    ECFM_REGISTER_CLI_CC_LOCK ();
    if (i4Y1731PortOperStatus == ECFM_DISABLE)
    {
        i4MepLtmVlanPriority = (INT4) u4MepCcmLtmPriority;
        i4MepCcmVlanPriority = (INT4) u4MepCcmLtmPriority;
    }

    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        i4MepLtmVlanPriority = i4MepTstVlanPriority = i4MepDmmVlanPriority =
            i4Mep1DmVlanPriority = u4MepLckVlanPriority = i4MepLmmVlanPriority =
            ECFM_DEFAULT_VLAN_PRIORITY;
    }

    if ((i4MepLtmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepTstVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepLbmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepDmmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4Mep1DmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepCcmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepAisVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (u4MepLckVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY) ||
        (i4MepLmmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY))

    {
        if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
        {
            if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
            {
                CliPrintf (CliHandle, " set service-instance-priority");
            }
            else
            {
                CliPrintf (CliHandle, " set vlan-priority");
            }
        }
        else
        {
            CliPrintf (CliHandle, "  set phb");
            i4MepLtmVlanPriority = i4MepTstVlanPriority = i4MepDmmVlanPriority =
                i4Mep1DmVlanPriority = u4MepLckVlanPriority =
                i4MepLmmVlanPriority = i4MepLbmVlanPriority;
        }
        i4CurrentPriority = i4MepLtmVlanPriority;
        if ((i4CurrentPriority == i4MepLtmVlanPriority) &&
            (i4CurrentPriority == i4MepTstVlanPriority) &&
            (i4CurrentPriority == i4MepLbmVlanPriority) &&
            (i4CurrentPriority == i4MepDmmVlanPriority) &&
            (i4CurrentPriority == i4Mep1DmVlanPriority) &&
            (i4CurrentPriority == i4MepCcmVlanPriority) &&
            (i4CurrentPriority == i4MepAisVlanPriority) &&
            (i4CurrentPriority == (INT4) u4MepLckVlanPriority) &&
            (i4CurrentPriority == i4MepLmmVlanPriority))

        {
            CliPrintf (CliHandle, " all %u\r\n", i4CurrentPriority);
        }

        else

        {
            if (i4MepCcmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

            {
                CliPrintf (CliHandle, " ccm %u", i4MepCcmVlanPriority);
            }
            if (i4MepLbmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

            {
                CliPrintf (CliHandle, " lbm %u", i4MepLbmVlanPriority);
            }
            if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
            {
                if (i4MepLtmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " ltm %u", i4MepLtmVlanPriority);
                }
                if (i4Mep1DmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " one-dm %u", i4Mep1DmVlanPriority);
                }
                if (i4MepDmmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " dmm %u", i4MepDmmVlanPriority);
                }
                if (i4MepLmmVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " lmm %u", i4MepLmmVlanPriority);
                }
                if (i4MepTstVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " tst %u", i4MepTstVlanPriority);
                }
            }
            if (i4MepAisVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

            {
                CliPrintf (CliHandle, " ais %u", i4MepAisVlanPriority);
            }
            if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
            {
                if (u4MepLckVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)

                {
                    CliPrintf (CliHandle, " lck %d", u4MepLckVlanPriority);
                }
            }
            CliPrintf (CliHandle, "\r\n");
        }
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmMaMepListPrint                                 */
/*                                                                           */
/*     DESCRIPTION      : This function displays MaMepList objects in Ecfm   */
/*                        for show running configuration for a particular    */
/*                        context                                            */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u4MdIndex - Md Index used for MaMepList            */
/*                        u4MaIndex - Ma Index used for MaMepList            */
/*                        u1Module  - Module Id                              */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmMaMepListPrint (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4LocalMdIndex, UINT4 u4LocalMaIndex, UINT1 u1Module)
{
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaMepListRowStatus = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;

    ECFM_MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId, 0,
                                                      &u4MdIndex, 0,
                                                      &u4MaIndex, 0,
                                                      &u4MaMepListIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* MaTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* first check its row status */
        nmhGetFsMIEcfmMaMepListRowStatus (i4CurrContextId, u4MdIndex,
                                          u4MaIndex, u4MaMepListIndex,
                                          &i4RetMaMepListRowStatus);
        if ((i4RetMaMepListRowStatus == ECFM_ROW_STATUS_ACTIVE)
            && (u4MdIndex == u4LocalMdIndex) && (u4MaIndex == u4LocalMaIndex))

        {

            /* Get u4MaIndex's name, primaryvlanid for MA */
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               " mep crosscheck mpid %u service-instance %u"
                               "\r\n", u4MaMepListIndex,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, " mep crosscheck mpid %u vsi %u"
                                   "\r\n", u4MaMepListIndex, i4RetPriVlanId);
                    }
                    else
#endif
                    {
                    CliPrintf (CliHandle, " mep crosscheck mpid %u vlan %u"
                               "\r\n", u4MaMepListIndex, i4RetPriVlanId);
                }
            }
            }

            else

            {
                if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
                {
                    CliPrintf (CliHandle, " mep crosscheck mpid %u "
                               "\r\n", u4MaMepListIndex);
                }
                else
                {
                    EcfmUtilGetMaName ((UINT4) i4CurrContextId, u4MdIndex,
                                       u4MaIndex, au1StrMaName);
                    CliPrintf (CliHandle, " mep crosscheck mpid %u service %s"
                               "\r\n", u4MaMepListIndex, au1StrMaName);
                }
            }
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                          (UINT4 *)
                                                          &i4NextContextId,
                                                          u4MdIndex,
                                                          &u4NextMdIndex,
                                                          u4MaIndex,
                                                          &u4NextMaIndex,
                                                          u4MaMepListIndex,
                                                          &u4NextMaMepListIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MaMepListIndex = u4NextMaMepListIndex;

            /* Check for the same context */
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmMaMepListCount                                 */
/*                                                                           */
/*     DESCRIPTION      : This function returns  MaMepList objects count in  */
/*                        Ecfm for show running configuration.               */
/*                                                                           */
/*     INPUT            : MdIndex - MdIndex for MaMepList object             */
/*                        MaIndex - MaIndex for MaMepList object             */
/*                                                                           */
/*     OUTPUT           : NONE                                               */
/*                                                                           */
/*     RETURNS          : u4Count - MaMepList objects count in ECFM          */
/*****************************************************************************/
PRIVATE UINT4
EcfmMaMepListCount (UINT4 u4ContextId, UINT4 u4LocalMdIndex,
                    UINT4 u4LocalMaIndex)
{
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaMepListRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4Count = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;

    /*MA Mep List */
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId,
                                                      u4LocalMdIndex,
                                                      &u4MdIndex,
                                                      u4LocalMaIndex,
                                                      &u4MaIndex,
                                                      0, &u4MaMepListIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* first check its row status */
        nmhGetFsMIEcfmMaMepListRowStatus (i4CurrContextId, u4MdIndex,
                                          u4MaIndex, u4MaMepListIndex,
                                          &i4RetMaMepListRowStatus);
        if ((i4RetMaMepListRowStatus ==
             ECFM_ROW_STATUS_ACTIVE) && ((UINT4) (i4CurrContextId) ==
                                         u4ContextId) && (u4MdIndex ==
                                                          u4LocalMdIndex)
            && (u4MaIndex == u4LocalMaIndex))

        {

            /* Get u4MaIndex's name, primaryvlanid for MA */
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
            u4Count = u4Count + 1;
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable
            (i4CurrContextId, (UINT4 *) &i4NextContextId, u4MdIndex,
             &u4NextMdIndex, u4MaIndex, &u4NextMaIndex, u4MaMepListIndex,
             &u4NextMaMepListIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MaMepListIndex = u4NextMaMepListIndex;

            /* Check if it has entry for this particular context */
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
    return u4Count;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCcStatusPrint                                  */
/*                                                                           */
/*     DESCRIPTION      : This function displays CC status in Ecfm           */
/*                        for show running configuration for a particular    */
/*                        context.                                           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        MdLevel - Md Level                                 */
/*                        i4Vid - VlanId                                     */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmCcStatusPrint (tCliHandle CliHandle, UINT4 u4ContextId,
                   UINT4 u4MdLevel, INT4 i4Vid)
{
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4MepCciEnabled = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIndex = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                (UINT4 *) &i4NextContextId,
                                                0, &u4MdIndex, 0,
                                                &u4MaIndex, 0, &u4MepIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* MepTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        i4RetPriVlanId = 0;
        u4RetMdLevel = 0;
        i4MepCciEnabled = 0;
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIndex, (UINT4 *) &i4RetPriVlanId);
        nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMepCciEnabled (i4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIndex, &i4MepCciEnabled);
        if (i4RetPriVlanId == 0)

        {
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
        }

        /*Print Vlan for the same PrimaryVlan */
        if ((i4MepCciEnabled == ECFM_SNMP_TRUE) &&
            (u4RetMdLevel == u4MdLevel) && (i4RetPriVlanId != i4Vid))

        {
            if (i4RetPriVlanId != 0)

            {
#ifdef VSI_WANTED                        
                if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                {
                    CliPrintf (CliHandle, "\r\nethernet cfm cc enable level %u "
                               "vsi %u", u4RetMdLevel, i4RetPriVlanId);
                }
                else
#endif
                {
                CliPrintf (CliHandle, "\r\nethernet cfm cc enable level %u "
                           "vlan %u", u4RetMdLevel, i4RetPriVlanId);
            }
            }

            else

            {
                CliPrintf (CliHandle,
                           "\r\nethernet cfm cc enable level %u ",
                           u4RetMdLevel);
            }
        }

        /* move to next Mep */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIndex,
                                                    &u4NextMepIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIndex = u4NextMepIndex;
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmVlanPrint                                    */
/*                                                                           */
/*     DESCRIPTION      : This function displays Vlan in Ecfm                */
/*                        for show running configuration.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        PrimaryVid - Primary Vlan                          */
/*                        u4Vid - VlanId                                     */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmVlanPrint (tCliHandle CliHandle, UINT4 u4ContextId,
               UINT4 u4PrimaryVid, UINT4 u4Vid)
{
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT4               u4VlanVid = ECFM_INIT_VAL;
    UINT4               u4NextVlanVid = ECFM_INIT_VAL;
    UINT4               u4VlanPrimaryVid = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                 (UINT4 *) &i4NextContextId,
                                                 0, (INT4 *) &u4VlanVid);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        nmhGetFsMIEcfmVlanPrimaryVid (i4CurrContextId, u4VlanVid,
                                      (INT4 *) &u4VlanPrimaryVid);
        if ((u4VlanPrimaryVid == u4PrimaryVid) && (u4VlanVid != u4Vid))

        {

            /*Print Vlan under one PrimaryVid */
            CliPrintf (CliHandle, ",%u", u4VlanVid);
        }

        /* move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                     (UINT4 *)
                                                     &i4NextContextId,
                                                     u4VlanVid,
                                                     (INT4 *) &u4NextVlanVid);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4VlanVid = u4NextVlanVid;
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
}

/*****************************************************************************/
/*                                                                           */
/*     FUNCTION NAME    : EcfmGlobalShowRunningConfig                        */
/*                                                                           */
/*     DESCRIPTION      : This function  displays the  ECFM ISS Level        */
/*                        Configuration e.g. OUI Configuration               */
/*                                                                           */
/*     INPUT            : tCliHandle-Handle to the Cli Context               */
/*                                                                           */
/*                                                                           */
/*     OUTPUT           : NONE                                               */
/*                                                                           */
/*                                                                           */
/*     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            */
/*****************************************************************************/
INT4
EcfmGlobalShowRunningConfig (tCliHandle CliHandle)
{
    UINT1               au1OuiVal[ECFM_OUI_LENGTH];
    UINT1               au1OuiStrVal[ECFM_CLI_OUI_STR_LEN];
    tSNMP_OCTET_STRING_TYPE LocalClientOui;
    UINT1               au1OuiStrValLocal[ECFM_CLI_OUI_STR_LEN] =
        { ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48,
        ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48
    };
    ECFM_REGISTER_CLI_CC_LOCK ();
    MEMSET (au1OuiVal, 0, ECFM_OUI_LENGTH);
    MEMSET (&LocalClientOui, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    LocalClientOui.i4_Length = ECFM_OUI_LENGTH;
    LocalClientOui.pu1_OctetList = au1OuiVal;

    /* Get OUI Value & Display if other then Zero */
    nmhGetFsMIEcfmOui (&LocalClientOui);
    ECFM_MEMSET (au1OuiStrVal, 0, ECFM_CLI_OUI_STR_LEN);
    CliOctetToStr (LocalClientOui.pu1_OctetList, LocalClientOui.i4_Length,
                   au1OuiStrVal, ECFM_CLI_OUI_STR_LEN);
    if (ECFM_MEMCMP
        (&au1OuiStrVal, &au1OuiStrValLocal,
         LocalClientOui.i4_Length) != ECFM_INIT_VAL)

    {
        CliPrintf (CliHandle, "set ethernet-cfm oui %s\r\n", au1OuiStrVal);
        CliPrintf (CliHandle, "! \r\n");
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return CLI_SUCCESS;
}


/*****************************************************************************/
/*     FUNCTION NAME    : EcfmEthbnCliShowRunningConfig                      */
/*                                                                           */
/*     DESCRIPTION      : This function displays EthBn objects in Ecfm/Y1731 */
/*                        for show running configuration.                    */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrentContextId - Current contextId             */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
INT4
EcfmEthbnCliShowRunningConfig (tCliHandle CliHandle)
{
    UINT4 u4IfIndex = 0;
    INT4 i4PrevIndex = 0;
    INT4 i4EthBnPortStat = 0;
    INT4 i4EthBnTrapStat = 0;
    UINT1  u1IsPartShowAll = 1;

    ECFM_CC_LOCK ();

    if(nmhGetFirstIndexFsMIY1731EthBnPortTable  ((INT4 *)&u4IfIndex) == SNMP_FAILURE)
    {
        ECFM_CC_UNLOCK ();
        return CLI_FAILURE;
    }

    ECFM_CC_UNLOCK ();

    do
    {

        ECFM_LBLT_LOCK ();

        nmhGetFsMIY1731EthBnPortStatus (u4IfIndex, &i4EthBnPortStat);
        nmhGetFsMIY1731EthBnTrapStatus (u4IfIndex, &i4EthBnTrapStat);

        ECFM_LBLT_UNLOCK ();


        CliPrintf (CliHandle, "interface gigabitethernet 0/%d\r\n", u4IfIndex);
        if (i4EthBnPortStat == ECFM_SNMP_FALSE)
        {
            CliPrintf (CliHandle, "ethbn disable\r\n");
        }
        if (i4EthBnTrapStat == ECFM_SNMP_TRUE)
        {
            CliPrintf (CliHandle, "trap enable \r\n");
        }

        i4PrevIndex = u4IfIndex;

        CliPrintf (CliHandle, "!\r\n");

        ECFM_CC_LOCK ();

        if (nmhGetNextIndexFsMIY1731EthBnPortTable ( i4PrevIndex, (INT4 *)&u4IfIndex) == SNMP_FAILURE)
        {
            u1IsPartShowAll = FALSE;
        }

        ECFM_CC_UNLOCK ();

    }while (u1IsPartShowAll);

    return (CLI_SUCCESS);

}



/*****************************************************************************/
/*                                                                           */
/*     FUNCTION NAME    : EcfmShowRunningConfig                              */
/*                                                                           */
/*     DESCRIPTION      : This function  displays the  ECFM Configuration    */
/*                                                                           */
/*     INPUT            : tCliHandle-Handle to the Cli Context               */
/*                        u4ContextId - Current Context Id                   */
/*                        u4Module - Module Id                               */
/*                                                                           */
/*                                                                           */
/*     OUTPUT           : NONE                                               */
/*                                                                           */
/*                                                                           */
/*     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            */
/*****************************************************************************/
INT4
EcfmShowRunningConfig (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Module)
{
    UINT4               u4SysMode;
    UINT1               au1ContextName[ECFM_SWITCH_ALIAS_LEN];
    INT4                i4SystemControl = 0;

    UNUSED_PARAM (u4Module);
    ECFM_REGISTER_CLI_CC_LOCK ();

    ECFM_MEMSET (au1ContextName, 0, ECFM_SWITCH_ALIAS_LEN);
    EcfmVcmGetAliasName (u4ContextId, au1ContextName);
    nmhGetFsMIEcfmSystemControl (u4ContextId, &i4SystemControl);
    if (u4ContextId == ECFM_DEFAULT_CONTEXT)
    {
        if (i4SystemControl == ECFM_SHUTDOWN)
        {
            CliPrintf (CliHandle, "\rno ethernet cfm start \r\n");
            CliPrintf (CliHandle, "\r!\r\n");
        }
    }
    if (i4SystemControl != ECFM_SHUTDOWN)

    {
        u4SysMode = EcfmVcmGetSystemModeExt (ECFM_PROTOCOL_ID);
        if (u4SysMode == VCM_MI_MODE)
        {
            if (STRLEN (au1ContextName) != 0)
            {
                if (u4ContextId != ECFM_DEFAULT_CONTEXT)
                {
                    CliPrintf (CliHandle, "\rswitch %s \r\n", au1ContextName);
                }
            }
        }
        if (EcfmShowRunningConfigScalars (CliHandle, u4ContextId,
                                          ECFM_ETH_SHOW_RUNNING_CONFIG)
            == CLI_SUCCESS)

        {
            CliPrintf (CliHandle, "! \r\n");

            EcfmShowRunningConfigInterface (CliHandle, u4ContextId);
            if (STRLEN (au1ContextName) != 0)
            {
                if (u4ContextId != ECFM_DEFAULT_CONTEXT)
                {
                    CliPrintf (CliHandle, "\rswitch %s \r\n", au1ContextName);
                }
            }
        }

#ifdef MPLS_WANTED
        if (EcfmShowRunningConfigScalars (CliHandle, u4ContextId,
                                          ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
            == CLI_SUCCESS)
        {
            CliPrintf (CliHandle, "! \r\n");
        }
#endif
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return CLI_SUCCESS;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowRunningConfigScalars                       */
/*                                                                           */
/*     DESCRIPTION      : This function displays scalar objects in ECFM for  */
/*                        show running configuration.                        */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u1Module    - Module Id                            */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : None                                               */
/*                                                                           */
/*****************************************************************************/
INT4
EcfmShowRunningConfigScalars (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT1 u1Module)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4PrevContextId = ECFM_INIT_VAL;
    INT4                i4ModStatus = ECFM_INIT_VAL;
    INT4                i4SystemControl = ECFM_INIT_VAL;
    INT4                i4LtrCacheStatus = ECFM_INIT_VAL;
    INT4                i4MipCcmDbStatus = ECFM_INIT_VAL;
    INT4                i4MipDynamicEvalStatus = ECFM_INIT_VAL;
    INT4                i4MepCrosscheckDelay = ECFM_INIT_VAL;
    INT4                i4DefaultMdDefLevel = ECFM_INIT_VAL;
    INT4                i4DefaultMdDefMhfCreation = ECFM_INIT_VAL;
    INT4                i4DefaultMdDefIdPermission = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4RetMdRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMaMepListRowStatus = ECFM_INIT_VAL;
    INT4                i4ErrorLogStatus = ECFM_INIT_VAL;
    INT4                i4ErrorLogSize = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4FrameDelayBufferSize = ECFM_INIT_VAL;
    INT4                i4FrameLossBufferSize = ECFM_INIT_VAL;
    INT4                i4LbrCacheHoldtime = ECFM_INIT_VAL;
    INT4                i4LtrCacheHoldTime = ECFM_INIT_VAL;
    INT4                i4LbrCacheSize = ECFM_INIT_VAL;
    INT4                i4MipCcmDbSize = ECFM_INIT_VAL;
    INT4                i4MipCcmDbHoldTime = ECFM_INIT_VAL;
    INT4                i4MIY1731MegVlanPriority = (INT4) ECFM_INIT_VAL;
    INT4                i4MIY1731MegDropEnable = (INT4) ECFM_INIT_VAL;
    INT4                i4RetMdLevel = (INT4) ECFM_INIT_VAL;
    INT4                i4MepArchiveHoldTime = ECFM_INIT_VAL;
    INT4                i4MepCciEnabled = ECFM_INIT_VAL;
    INT4                i4MaXChkStatus = ECFM_INIT_VAL;
    INT4                i4LtrCacheSize = ECFM_INIT_VAL;
    INT4                i4OffModuleStatus = 0;
    INT4                i4RetCcRole = 0;
    INT4                i4RetY1731MeCciEnabled = (INT4) ECFM_SNMP_FALSE;
    INT4                i4ClientMEGLevel = (INT4) ECFM_INIT_VAL;
    INT4                i4CfmMdMhfCreation = (INT4) ECFM_INIT_VAL;
    INT4                i4CfmMdMhfIdPermission = (INT4) ECFM_INIT_VAL;
    INT4                i4DefaultMdLevel = ECFM_INIT_VAL;
    INT4                i4RetValLbrCacheStatus = ECFM_INIT_VAL;
    INT4                i4DefaultMdMhfCreation = ECFM_INIT_VAL;
    INT4                i4DefaultMdIdPermission = ECFM_INIT_VAL;
    INT4                i4PrimarySelectorType = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;
    INT4                i4PrevVlanId = ECFM_INIT_VAL;
    UINT4               u4VlanVid = ECFM_INIT_VAL;
    UINT4               u4NextVlanVid = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepCount = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4DefaultMdPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4NextDefaultMdPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4PrevLevel = ECFM_INIT_VAL;
    UINT1               u1Return = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               u1FlagValue = ECFM_FALSE;
    UINT1               au1StrTemp[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               u1MdLevel = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *pu1VlanList = NULL;

    /* Get Ecfm SystemControl */
    nmhGetFsMIEcfmSystemControl (u4ContextId, &i4SystemControl);

    /* Checking SystemControl value other than default value */

    if (u4ContextId != ECFM_DEFAULT_CONTEXT)
    {
        if (i4SystemControl != ECFM_SHUTDOWN)

        {
            CliPrintf (CliHandle, "%s start\r\n", gau1ModuleName[u1Module]);
        }
        else
        {
            return CLI_SUCCESS;
        }
    }
    else
    {
        if (i4SystemControl == ECFM_SHUTDOWN)
        {
            CliPrintf (CliHandle, "no %s start\r\n", gau1ModuleName[u1Module]);
            return CLI_SUCCESS;
        }
    }

    /* Module Status */
    nmhGetFsMIEcfmModuleStatus (u4ContextId, &i4ModStatus);

    /* Checking Module Status value other than default value */
    if (i4ModStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%s enable\r\n", gau1ModuleName[u1Module]);
    }
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        nmhGetFsMIY1731OperStatus (u4ContextId, &i4ModStatus);

        /* Checking Y1731 Module Status value other than default value */
        if (i4ModStatus == ECFM_ENABLE)

        {
            CliPrintf (CliHandle, "%s y1731 enable\r\n",
                       gau1ModuleName[u1Module]);
        }
    }

    /* CCMOffloading Module Status */
    nmhGetFsMIEcfmGlobalCcmOffload (u4ContextId, &i4OffModuleStatus);

    /* Checking Offload Module Status value other than default value */
    if (i4OffModuleStatus == ECFM_CCM_OFFLOAD_ENABLE)

    {
        if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
        {
            CliPrintf (CliHandle, "%s offload\r\n", gau1ModuleName[u1Module]);
        }
        else
        {
            CliPrintf (CliHandle, "%s ccm offload\r\n",
                       gau1ModuleName[u1Module]);
        }
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();
 MEMSET (au1StrTemp, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        /*Ltr Cache Status */
        nmhGetFsMIEcfmLtrCacheStatus (u4ContextId, &i4LtrCacheStatus);
        if (i4LtrCacheStatus == ECFM_ENABLE)
        {
            CliPrintf (CliHandle, "%s traceroute cache\r\n",
                       gau1ModuleName[u1Module]);

        }
        /*Checking Ltr Cache status other than default value */

        /*Ltr Cache Size */
        nmhGetFsMIEcfmLtrCacheSize (u4ContextId, &i4LtrCacheSize);

        /*Checking Ltr Cache Size value other than default value */
        if ((i4LtrCacheSize != ECFM_LTR_CACHE_DEF_SIZE) &&
            (i4LtrCacheSize != ECFM_INIT_VAL))

        {
            CliPrintf (CliHandle, "%s traceroute cache size %u"
                       "\r\n", gau1ModuleName[u1Module], i4LtrCacheSize);
        }

        /*Ltr Cache Hold Time */
        nmhGetFsMIEcfmLtrCacheHoldTime (u4ContextId, &i4LtrCacheHoldTime);

        /*Checking Ltr Cache Hold Time other than default value */
        if (i4LtrCacheHoldTime != ECFM_LTR_CACHE_DEF_HOLD_TIME)

        {
            CliPrintf (CliHandle, "%s traceroute cache hold-time "
                       "%u \r\n", gau1ModuleName[u1Module], i4LtrCacheHoldTime);
        }

        /*Frame Delay Buffer Size */
        nmhGetFsMIY1731FrameDelayBufferSize (u4ContextId,
                                             &i4FrameDelayBufferSize);
        if (i4FrameDelayBufferSize != ECFM_FD_BUFFER_DEF_SIZE)

        {
            CliPrintf (CliHandle, " %s frame delay buffer size "
                       "%u \r\n", gau1ModuleName[u1Module],
                       i4FrameDelayBufferSize);
        }
    }
    nmhGetFsMIY1731LbrCacheStatus (u4ContextId, &i4RetValLbrCacheStatus);
    if (i4RetValLbrCacheStatus == ECFM_DISABLE)
    {
        CliPrintf (CliHandle, "no %s loopback cache \r\n",
                   gau1ModuleName[u1Module]);
    }
    nmhGetFsMIY1731LbrCacheHoldTime (u4ContextId, &i4LbrCacheHoldtime);
    nmhGetFsMIY1731LbrCacheSize (u4ContextId, &i4LbrCacheSize);
    if ((i4LbrCacheSize != ECFM_INIT_VAL) &&
        (i4LbrCacheSize != ECFM_LBR_CACHE_DEF_SIZE))

    {
        CliPrintf (CliHandle, "%s loopback cache size "
                   "%u", gau1ModuleName[u1Module], i4LbrCacheSize);
        if (i4LbrCacheHoldtime != ECFM_LBR_CACHE_DEF_HOLD_TIME)

        {
            CliPrintf (CliHandle, " hold-time " "%u", i4LbrCacheHoldtime);
        }
        CliPrintf (CliHandle, "\r\n");
    }

    else

    {
        if (i4LbrCacheHoldtime != ECFM_LBR_CACHE_DEF_HOLD_TIME)

        {
            CliPrintf (CliHandle, "%s loopback cache hold-time "
                       "%u\r\n", gau1ModuleName[u1Module], i4LbrCacheHoldtime);
        }
    }
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        /*Frame Loss  Buffer Size */
        nmhGetFsMIY1731FrameLossBufferSize (u4ContextId,
                                            &i4FrameLossBufferSize);
        if (i4FrameLossBufferSize != ECFM_FL_BUFFER_DEF_SIZE)

        {
            CliPrintf (CliHandle, "%s frame loss buffer size "
                       "%u \r\n", gau1ModuleName[u1Module],
                       i4FrameLossBufferSize);
        }
        nmhGetFsMIY1731ErrorLogSize (u4ContextId, &i4ErrorLogSize);
        nmhGetFsMIY1731ErrorLogStatus (u4ContextId, &i4ErrorLogStatus);
        if (i4ErrorLogStatus == ECFM_DISABLE)

        {
            CliPrintf (CliHandle, "%s error-log disable ",
                       gau1ModuleName[u1Module]);
            if (i4ErrorLogSize != ECFM_ERROR_LOG_DEF_SIZE)

            {
                CliPrintf (CliHandle, "size " "%u\r\n", i4ErrorLogSize);
            }

            else

            {
                CliPrintf (CliHandle, "\r\n");
            }
        }

        else

        {
            if (i4ErrorLogSize != ECFM_ERROR_LOG_DEF_SIZE)

            {
                CliPrintf (CliHandle, "%s error-log size "
                           "%u\r\n", gau1ModuleName[u1Module], i4ErrorLogSize);
            }
        }

        /*Mip CCM Db Status */
        nmhGetFsMIEcfmMipCcmDbStatus (u4ContextId, &i4MipCcmDbStatus);

        /*Checking if Mip CCM Db Status other than default value */
        if (i4MipCcmDbStatus == ECFM_ENABLE)

        {
            CliPrintf (CliHandle, "%s mip ccm-database\r\n",
                       gau1ModuleName[u1Module]);
        }
        nmhGetFsMIEcfmMipCcmDbSize (u4ContextId, &i4MipCcmDbSize);

        /*Checking if Mip CCM Db Size other than default value */
        if (i4MipCcmDbSize != ECFM_MIP_CCM_DB_DEF_SIZE)

        {
            CliPrintf (CliHandle, "%s mip ccm-database size %u "
                       "\r\n", gau1ModuleName[u1Module], i4MipCcmDbSize);
        }

        /*Mip CCM Db Hold Time */
        nmhGetFsMIEcfmMipCcmDbHoldTime (u4ContextId, &i4MipCcmDbHoldTime);

        /*Checking if Mip CCM Db Hold Time other than default value */
        if ((i4MipCcmDbHoldTime != ECFM_MIP_CCM_DB_DEF_HOLD_TIME) &&
            (i4MipCcmDbHoldTime != ECFM_INIT_VAL))

        {
            CliPrintf (CliHandle,
                       "%s mip ccm-database hold-time %u " "\r\n",
                       gau1ModuleName[u1Module], i4MipCcmDbHoldTime);
        }
        /*Mip Dynamic Evaluation Status */
        nmhGetFsMIEcfmMipDynamicEvaluationStatus (u4ContextId,
                                                  &i4MipDynamicEvalStatus);

        /*Checking if Mip Mip Dynamic Evaluation Status other than default
         * value */
        if (i4MipDynamicEvalStatus == ECFM_SNMP_TRUE)

        {
            CliPrintf (CliHandle, "%s mip dynamic evaluation\r\n",
                       gau1ModuleName[u1Module]);
        }

        /*Mep Cross Check Delay */
        nmhGetFsMIEcfmCrosscheckDelay (u4ContextId, &i4MepCrosscheckDelay);

        /*Checking if Mep Cross Check Delay other than default value */
        if (i4MepCrosscheckDelay != ECFM_INIT_VAL)

        {
            CliPrintf (CliHandle, "%s mep crosscheck start-delay %u "
                       "\r\n", gau1ModuleName[u1Module], i4MepCrosscheckDelay);
        }
    }

    /* Print the Traps Type which are enabledd by user */
    EcfmPrintTrapControl (CliHandle, u4ContextId, u1Module);

    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        /*Default MdDefLevel */
        nmhGetFsMIEcfmDefaultMdDefLevel (u4ContextId, &i4DefaultMdDefLevel);
        nmhGetFsMIEcfmDefaultMdDefMhfCreation (u4ContextId,
                                               &i4DefaultMdDefMhfCreation);
        nmhGetFsMIEcfmDefaultMdDefIdPermission (u4ContextId,
                                                &i4DefaultMdDefIdPermission);

        /* Set Flag Value to False */
        u1FlagValue = ECFM_FALSE;
        if ((i4DefaultMdDefLevel != ECFM_MD_LEVEL_MIN) ||
            ((i4DefaultMdDefMhfCreation != ECFM_MHF_CRITERIA_NONE) &&
             (i4DefaultMdDefMhfCreation != ECFM_INIT_VAL)) ||
            ((i4DefaultMdDefIdPermission != ECFM_SENDER_ID_NONE) &&
             (i4DefaultMdDefIdPermission != ECFM_INIT_VAL)))

        {
            CliPrintf (CliHandle, "ethernet cfm default-domain global");
            u1FlagValue = ECFM_TRUE;
        }
        if (i4DefaultMdDefLevel != ECFM_MD_LEVEL_MIN)

        {
            CliPrintf (CliHandle, " level %u", i4DefaultMdDefLevel);
            u1FlagValue = ECFM_TRUE;
        }

        /*Default MdDefMhfCreation */
        if ((i4DefaultMdDefMhfCreation != ECFM_MHF_CRITERIA_NONE) &&
            (i4DefaultMdDefMhfCreation != ECFM_INIT_VAL))

        {
            CliPrintf (CliHandle, " mip-creation-criteria ");
            switch (i4DefaultMdDefMhfCreation)

            {
                case ECFM_MHF_CRITERIA_DEFAULT:
                    CliPrintf (CliHandle, "%s", "default");
                    break;
                case ECFM_MHF_CRITERIA_EXPLICIT:
                    CliPrintf (CliHandle, "%s", "explicit");
                    break;
                default:
                    break;
            }
            u1FlagValue = ECFM_TRUE;
        }

        /*Default MdDefIdPermission */
        if ((i4DefaultMdDefIdPermission != ECFM_SENDER_ID_NONE) &&
            (i4DefaultMdDefIdPermission != ECFM_INIT_VAL))

        {
            CliPrintf (CliHandle, " sender-id-permission ");
            switch (i4DefaultMdDefIdPermission)

            {
                case ECFM_SENDER_ID_CHASSIS:
                    CliPrintf (CliHandle, "%s", "chassis");
                    break;
                case ECFM_SENDER_ID_MANAGE:
                    CliPrintf (CliHandle, "%s", "manage");
                    break;
                case ECFM_SENDER_ID_CHASSID_MANAGE:
                    CliPrintf (CliHandle, "%s", "chassis-mgt-address");
                    break;
                default:
                    break;
            }
            u1FlagValue = ECFM_TRUE;
        }
        if (u1FlagValue == ECFM_TRUE)

        {
            CliPrintf (CliHandle, "\r\n");
        }
    }

    /*Print Domain, Service and MaMepList Objects */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;
    i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrContextId,
                                               (UINT4 *) &i4NextContextId,
                                               0, &u4MdIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMdRowStatus (i4CurrContextId, u4MdIndex,
                                   &i4RetMdRowStatus);
        u4PrevMdIndex = u4MdIndex;
        i4PrevContextId = i4CurrContextId;

        if (i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE)
        {
            nmhGetFsMIEcfmMdName (i4CurrContextId, u4MdIndex, &RetMdName);
            nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);
            nmhGetFsMIEcfmMdFormat (i4CurrContextId, u4MdIndex, &i4RetMdFormat);

            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);
            if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
            {
                /*Print  Domain for the u4RetMdLevel */
                if (i4RetMdFormat != ECFM_DOMAIN_NAME_TYPE_CHAR_STRING)
                {
                    switch (i4RetMdFormat)
                    {
                        case ECFM_DOMAIN_NAME_TYPE_DNS_LIKE_NAME:
                            CliPrintf (CliHandle,
                                       "%s domain format dns-like-name "
                                       "name %s level %u \r\n",
                                       gau1ModuleName[u1Module],
                                       au1StrMdName, u4RetMdLevel);
                            break;
                        case ECFM_DOMAIN_NAME_TYPE_MAC_ADDR_AND_UINT:
                            CliPrintf (CliHandle,
                                       "%s domain format mac-addr "
                                       "name %s level %u \r\n",
                                       gau1ModuleName[u1Module],
                                       au1StrMdName, u4RetMdLevel);
                            break;
                        case ECFM_DOMAIN_NAME_TYPE_NONE:
                            CliPrintf (CliHandle,
                                       "%s domain format none "
                                       "name %s level %u \r\n",
                                       gau1ModuleName[u1Module],
                                       au1StrMdName, u4RetMdLevel);
                        default:
                            break;
                    }
                }
                else
                {
                    CliPrintf (CliHandle,
                               "%s domain name %s level %u " "\r\n",
                               gau1ModuleName[u1Module], au1StrMdName,
                               u4RetMdLevel);
                }
                nmhGetFsMIEcfmMdMhfCreation (i4CurrContextId, u4MdIndex,
                                             &i4CfmMdMhfCreation);
                nmhGetFsMIEcfmMdMhfIdPermission (i4CurrContextId, u4MdIndex,
                                                 &i4CfmMdMhfIdPermission);
                if ((i4CfmMdMhfIdPermission !=
                     ECFM_SENDER_ID_NONE) && (i4CfmMdMhfIdPermission !=
                                              ECFM_INIT_VAL))

                {
                    CliPrintf (CliHandle, " set sender-id-permission ");
                    switch (i4CfmMdMhfIdPermission)

                    {
                        case ECFM_SENDER_ID_CHASSIS:
                            CliPrintf (CliHandle, "%s", "chassis\r\n");
                            break;
                        case ECFM_SENDER_ID_MANAGE:
                            CliPrintf (CliHandle, "%s", "manage\r\n");
                            break;
                        case ECFM_SENDER_ID_CHASSID_MANAGE:
                            CliPrintf (CliHandle, "%s",
                                       "chassis-mgt-address\r\n");
                            break;
                        default:
                            break;
                    }
                }
                if ((i4CfmMdMhfCreation != ECFM_MHF_CRITERIA_NONE)
                    && (i4CfmMdMhfCreation != ECFM_INIT_VAL))

                {
                    CliPrintf (CliHandle, " set mip-creation-criteria ");
                    switch (i4CfmMdMhfCreation)

                    {
                        case ECFM_MHF_CRITERIA_DEFAULT:
                            CliPrintf (CliHandle, "%s", "default\r\n");
                            break;
                        case ECFM_MHF_CRITERIA_EXPLICIT:
                            CliPrintf (CliHandle, "%s", "explicit\r\n");
                            break;
                        default:
                            break;
                    }
                }
                nmhGetFsMIY1731MegClientMEGLevel (i4CurrContextId, u4MdIndex,
                                                  &i4ClientMEGLevel);
                if (i4ClientMEGLevel != ECFM_MD_LEVEL_NOT_CONFIGURE)
                {
                    CliPrintf (CliHandle, " client-layer-level %u "
                               "\r\n", i4ClientMEGLevel);
                }
            }
            else
            {
                CliPrintf (CliHandle,
                           "%s domain level %u \r\n",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
            nmhGetFsMIEcfmMepArchiveHoldTime (i4CurrContextId, u4MdIndex,
                                              &i4MepArchiveHoldTime);
            if ((i4MepArchiveHoldTime != ECFM_MEP_ARCHIVE_DEF_HOLD_TIME)
                && (i4MepArchiveHoldTime != ECFM_INIT_VAL))

            {
                CliPrintf (CliHandle, " mep archive-hold-time %u "
                           "\r\n", i4MepArchiveHoldTime);
            }

            /*Check MA Mep List objects in this Domain */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable
                (i4CurrContextId, (UINT4 *) &i4NextContextId, 0,
                 &u4MdIndex, 0, &u4MaIndex, 0, &u4MaMepListIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }

            /* MaTable not empty, now scan its each row */
            while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

            {
                ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL,
                             ECFM_MA_NAME_ARRAY_SIZE);
                ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetMaName.pu1_OctetList = au1RetMaName;
                RetMaName.i4_Length = ECFM_INIT_VAL;
                ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL,
                             ECFM_MD_NAME_ARRAY_SIZE);
                ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetMdName.pu1_OctetList = au1RetMdName;
                RetMdName.i4_Length = ECFM_INIT_VAL;
                nmhGetFsMIEcfmMaMepListRowStatus (i4CurrContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MaMepListIndex,
                                                  &i4RetMaMepListRowStatus);

                /* Prints all the Ma and MaMepList object for a domain */
                if ((i4RetMaMepListRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4PrevContextId == i4CurrContextId) &&
                    (u4PrevMdIndex == u4MdIndex) &&
                    (u4MaIndex != u4PrevMaIndex))

                {
                    if (nmhGetNextIndexFsMIEcfmExtMaTable
                        ((UINT4) i4CurrContextId, &u4NextContextId, u4MdIndex,
                         &u4NextMdIndex, u4MaIndex, &u4NextMdIndex, 0,
                         &i4NextSelectorType, 0,
                         &u4NextSelectorOrNone) == SNMP_SUCCESS)
                    {
                        if (((ECFM_IS_SELECTOR_TYPE_MPLS_TP
                              (i4NextSelectorType))
                             && (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG))
                            ||
                            ((ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType)
                              != ECFM_TRUE)
                             && (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)))
                        {
                            /* Print Ma Commands For which Mep Exists  */
                            EcfmMaListPrint (CliHandle, i4CurrContextId,
                                             u4MdIndex, u4MaIndex, u1Module);

                            /* Print  MaMepList for the domain u4MdIndex and
                             * service u4MaIndex */
                            EcfmMaMepListPrint (CliHandle, i4CurrContextId,
                                                u4MdIndex, u4MaIndex, u1Module);
                            if (ECFM_IS_SELECTOR_TYPE_MPLS_TP
                                (i4NextSelectorType))
                            {
                                EcfmMpTpMepListPrint (CliHandle,
                                                      u4ContextId, u4MdIndex,
                                                      u4MaIndex, u1Module);
                            }
                        }
                    }
                    u4PrevMaIndex = u4MaIndex;
                }

                /* Get next index for MaMepList */
                i4RetVal =
                    nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                           (UINT4 *)
                                                           &i4NextContextId,
                                                           u4MdIndex,
                                                           &u4NextMdIndex,
                                                           u4MaIndex,
                                                           &u4NextMaIndex,
                                                           u4MaMepListIndex,
                                                           &u4NextMaMepListIndex);

                /* If valid index found */
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MaMepListIndex = u4NextMaMepListIndex;
                    if (i4CurrContextId != i4NextContextId)

                    {
                        b1SameContext = ECFM_FALSE;
                    }
                }
            }

            /*Scan and Print all the Service for the domain which doesnot
             * have MaMep objects*/
            b1SameContext = ECFM_TRUE;
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId, 0,
                                                       &u4MdIndex, 0,
                                                       &u4MaIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
            while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

            {
                ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL,
                             ECFM_MA_NAME_ARRAY_SIZE);
                ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetMaName.pu1_OctetList = au1RetMaName;
                RetMaName.i4_Length = 0;

                /* Count the MaMepList Entry for particular Domain and 
                 * Association */
                u4MaMepCount =
                    EcfmMaMepListCount (i4CurrContextId, u4MdIndex, u4MaIndex);
                if (u4MaMepCount == 0)

                {
                    nmhGetFsMIEcfmMaRowStatus (i4CurrContextId, u4MdIndex,
                                               u4MaIndex, &i4RetMaRowStatus);
                    if ((i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE)
                        && (i4PrevContextId == i4CurrContextId)
                        && (u4PrevMdIndex == u4MdIndex))

                    {
                        if (nmhGetNextIndexFsMIEcfmExtMaTable
                            ((UINT4) i4CurrContextId, &u4NextContextId,
                             u4MdIndex, &u4NextMdIndex, u4MaIndex,
                             &u4NextMdIndex, 0, &i4NextSelectorType, 0,
                             &u4NextSelectorOrNone) == SNMP_SUCCESS)
                        {
                            if (((ECFM_IS_SELECTOR_TYPE_MPLS_TP
                                  (i4NextSelectorType))
                                 && (u1Module ==
                                     ECFM_MPLSTP_SHOW_RUNNING_CONFIG))
                                ||
                                ((ECFM_IS_SELECTOR_TYPE_MPLS_TP
                                  (i4NextSelectorType) != ECFM_TRUE)
                                 && (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)))
                            {
                                /* Print Ma Commands For which Mep Exists  */
                                EcfmMaListPrint (CliHandle, i4CurrContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u1Module);
                            }
                        }
                    }
                }
                i4RetVal = nmhGetNextIndexFsMIEcfmMaTable
                    (i4CurrContextId, (UINT4 *) &i4NextContextId, u4MdIndex,
                     &u4NextMdIndex, u4MaIndex, &u4NextMaIndex);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    if (i4CurrContextId != i4NextContextId)

                    {
                        b1SameContext = ECFM_FALSE;
                    }
                }
            }
        }
        CliPrintf (CliHandle, "!");
        u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User Presses 'q' at the prompt, so break! */
            break;
        }
        i4CurrContextId = i4PrevContextId;
        u4MdIndex = u4PrevMdIndex;
        i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4PrevMaIndex = ECFM_INIT_VAL;
            if (i4CurrContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }

            else

            {
                b1SameContext = ECFM_TRUE;
            }
        }
    }

    /*Vlan Priority & Drop Enable  */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;

    i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrContextId,
                                               (UINT4 *) &i4NextContextId,
                                               0, &u4MdIndex);
    if (i4RetVal == SNMP_SUCCESS)
    {
        if (i4CurrContextId != i4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }

        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
        {
            ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));

            RetMdName.pu1_OctetList = au1RetMdName;
            RetMdName.i4_Length = 0;

            nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
            nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
            nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetMdLevel);
            nmhGetFsMIY1731MegVlanPriority (i4CurrContextId, u4MdIndex,
                                            &i4MIY1731MegVlanPriority);
            nmhGetFsMIY1731MegDropEnable (i4CurrContextId, u4MdIndex,
                                          &i4MIY1731MegDropEnable);

            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);
            if ((i4MIY1731MegVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)
                || (i4MIY1731MegDropEnable == ECFM_SNMP_TRUE))
            {
                if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
                {
                     if (MEMCMP
                         (au1StrMdName, au1StrTemp,
                          ECFM_MD_NAME_ARRAY_SIZE) != 0)
		     {
			     CliPrintf (CliHandle, "ethernet cfm vlan-param domain %s",
					     au1StrMdName);

			     if (i4MIY1731MegDropEnable == ECFM_SNMP_TRUE)
			     {
				     CliPrintf (CliHandle, " drop-eligibility enable");
			     }

			     if (i4MIY1731MegVlanPriority != ECFM_DEFAULT_VLAN_PRIORITY)
			     {
				     CliPrintf (CliHandle, " vlan-priority %u",
						     i4MIY1731MegVlanPriority);
			     }
		     }
                     else
                     {
                         CliPrintf (CliHandle, "ethernet cfm vlan-param");
                         if (i4MIY1731MegDropEnable == ECFM_SNMP_TRUE)
                         {
                             CliPrintf (CliHandle, " drop-eligibility enable");
                         }

                         if (i4MIY1731MegVlanPriority !=
                             ECFM_DEFAULT_VLAN_PRIORITY)
                         {
                             CliPrintf (CliHandle, " vlan-priority %u",
                                        i4MIY1731MegVlanPriority);
                         }
                     }

                }
                else
                {
                    CliPrintf (CliHandle, "%s phb %u level %u",
                               gau1ModuleName[u1Module],
                               i4MIY1731MegVlanPriority, i4RetMdLevel);
                }
                CliPrintf (CliHandle, "\r\n");
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)
            {
                u4MdIndex = u4NextMdIndex;

                if (i4CurrContextId != i4NextContextId)
                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }

    /* Initialise variables for the next table */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;

    /*Continuity Check Interval */
    i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrContextId,
                                               (UINT4 *) &i4NextContextId,
                                               0, &u4MdIndex, 0, &u4MaIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {
        INT4                i4MaCcmInterval = ECFM_INIT_VAL;

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* MaTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            nmhGetFsMIEcfmMaCcmInterval (i4CurrContextId, u4MdIndex,
                                         u4MaIndex, &i4MaCcmInterval);
            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                           u4MaIndex, &i4RetPriVlanId);
            nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);
            nmhGetFsMIY1731MeCcmApplication (i4CurrContextId, u4MdIndex,
                                             u4MaIndex, &i4RetCcRole);

            nmhGetFsMIY1731MeCciEnabled (i4CurrContextId, u4MdIndex,
                                         u4MaIndex, &i4RetY1731MeCciEnabled);

            if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
            {
                if ((i4PrevVlanId != i4RetPriVlanId)
                    || (u4PrevLevel != u4RetMdLevel))
                {
                    i4PrevVlanId = i4RetPriVlanId;
                    u4PrevLevel = u4RetMdLevel;
                    /*Continuity Check Interval other than default value */
                    EcfmPrintTimerInterval (CliHandle, i4RetCcRole,
                                            i4MaCcmInterval, u4RetMdLevel,
                                            i4RetPriVlanId, u1Module);
                    if (i4RetY1731MeCciEnabled == ECFM_SNMP_TRUE)

                    {

                        CliPrintf (CliHandle,
                                   "%s cc enable level %u"
                                   " service-instance %u\r\n",
                                   gau1ModuleName[u1Module], u4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                    }
                }
            }
            else
            {
                /*Check whether this MdLevel is already traversed */
                u1MdLevel = ECFM_INIT_VAL;
                u1Return = EcfmGetBit (&u1MdLevel);
                if (u1Return == 0)
                {
                    if ((i4PrevVlanId != i4RetPriVlanId)
                        || (u4PrevLevel != u4RetMdLevel))
                    {
                        /*Continuity Check Interval other than default value */
                        EcfmPrintTimerInterval (CliHandle, i4RetCcRole,
                                                i4MaCcmInterval, u4RetMdLevel,
                                                i4RetPriVlanId, u1Module);
                    }
                    if (i4RetY1731MeCciEnabled == ECFM_SNMP_TRUE)

                    {

                        if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
                        {
                            if ((i4PrevVlanId != i4RetPriVlanId)
                                || (u4PrevLevel != u4RetMdLevel))
                            {
                                i4PrevVlanId = i4RetPriVlanId;
                                u4PrevLevel = u4RetMdLevel;
                                if (i4RetPriVlanId == 0)

                                {
                                    CliPrintf (CliHandle,
                                               "ethernet cfm cc enable level %u \r\n",
                                               u4RetMdLevel);
                                }

                                else

                                {
#ifdef VSI_WANTED                        
                                        if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                                        {
                                            CliPrintf (CliHandle,
                                                       "ethernet cfm cc enable level %u vsi "
                                                       "%u", u4RetMdLevel, i4RetPriVlanId);
                                        }
                                        else
#endif
                                        {
                                    CliPrintf (CliHandle,
                                               "ethernet cfm cc enable level %u vlan "
                                                   "%u", u4RetMdLevel, i4RetPriVlanId);
                                        }
                                    CliPrintf (CliHandle, "\r\n");

                                }
                            }
                        }

                        else if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
                        {
                            EcfmUtilGetMaName ((UINT4) i4CurrContextId,
                                               u4MdIndex, u4MaIndex,
                                               au1StrMaName);
                            CliPrintf (CliHandle,
                                       "%s cc enable level %u service "
                                       "%s \r\n", gau1ModuleName[u1Module],
                                       u4RetMdLevel, au1StrMaName);
                            CliPrintf (CliHandle, "!\r\n");
                            i4PrevVlanId = i4RetPriVlanId;
                            u4PrevLevel = u4RetMdLevel;
                        }
                        /*Set MdLevel Array stating it as traversed */
                        ECFM_SET_U1BIT (u1MdLevel, u4RetMdLevel);
                    }
                }
            }

            /* Get next index for Ma Table */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }

    /* Initialise variables for the next table */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;

    /*Continuity Check Interval */
    i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                (UINT4 *) &i4NextContextId,
                                                0, &u4MdIndex, 0,
                                                &u4MaIndex, 0, &u4MepIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /*Continuity Check Status */

        /* MaTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            nmhGetFsMIEcfmMepRowStatus (i4CurrContextId, u4MdIndex,
                                        u4MaIndex, u4MepIndex,
                                        &i4RetMepRowStatus);
            nmhGetFsMIY1731MeCciEnabled (i4CurrContextId, u4MdIndex,
                                         u4MaIndex, &i4RetY1731MeCciEnabled);
            if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE))

            {
                if (i4RetY1731MeCciEnabled == ECFM_SNMP_FALSE)

                {
                    nmhGetFsMIEcfmMepPrimaryVid (i4CurrContextId, u4MdIndex,
                                                 u4MaIndex, u4MepIndex,
                                                 (UINT4 *) &i4RetPriVlanId);
                    nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                             (INT4 *) &u4RetMdLevel);
                    nmhGetFsMIEcfmMepCciEnabled (i4CurrContextId, u4MdIndex,
                                                 u4MaIndex, u4MepIndex,
                                                 &i4MepCciEnabled);
                    if (i4MepCciEnabled == ECFM_SNMP_TRUE)
                    {
                        if (i4RetPriVlanId == 0)

                        {
                            nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           &i4RetPriVlanId);
                        }
                        if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                        {
                            CliPrintf (CliHandle,
                                       "%s cc enable level %u"
                                       " service-instance %u\r\n",
                                       gau1ModuleName[u1Module], u4RetMdLevel,
                                       ECFM_ISID_INTERNAL_TO_ISID
                                       (i4RetPriVlanId));
                        }
                        else
                        {
                            /*Check whether this MdLevel is already traversed */
                            u1MdLevel = ECFM_INIT_VAL;
                            u1Return = EcfmGetBit (&u1MdLevel);
                            if ((i4MepCciEnabled == ECFM_SNMP_TRUE)
                                && (u1Return == 0))
                            {
                                if (i4RetPriVlanId == 0)

                                {
                                    CliPrintf (CliHandle,
                                               "%s cc enable level %u ",
                                               gau1ModuleName[u1Module],
                                               u4RetMdLevel);
                                }

                                else

                                {
#ifdef VSI_WANTED                        
                                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                                    {
                                        CliPrintf (CliHandle,
                                                   "%s cc enable level %u vsi "
                                                   "%u", gau1ModuleName[u1Module],
                                                   u4RetMdLevel, i4RetPriVlanId);
                                    }
                                    else
#endif
                                    {
                                    CliPrintf (CliHandle,
                                               "%s cc enable level %u vlan "
                                               "%u", gau1ModuleName[u1Module],
                                               u4RetMdLevel, i4RetPriVlanId);
                                }
                                }

                                /*Print  CC status if not default for the 
                                 * domain u4RetMdLevel, and vlan
                                 * i4RetPriVlanId*/
                                EcfmCcStatusPrint (CliHandle, i4CurrContextId,
                                                   u4RetMdLevel,
                                                   i4RetPriVlanId);
                                CliPrintf (CliHandle, "\r\n");

                                /*Set MdLevel Array stating it as traversed */
                                ECFM_SET_U1BIT (u1MdLevel, u4RetMdLevel);
                            }
                        }
                    }
                }
            }

            /* move to next Mep */
            i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrContextId,
                                                        (UINT4 *)
                                                        &i4NextContextId,
                                                        u4MdIndex,
                                                        &u4NextMdIndex,
                                                        u4MaIndex,
                                                        &u4NextMaIndex,
                                                        u4MepIndex,
                                                        &u4NextMepIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                u4MepIndex = u4NextMepIndex;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }

    /*Mep Cross Check Functionality */

    /* Initialise variables for the next table */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;
    i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrContextId,
                                               (UINT4 *) &i4NextContextId,
                                               0, &u4MdIndex, 0, &u4MaIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* MaTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            nmhGetFsMIEcfmMaRowStatus (i4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaRowStatus);
            if (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE)

            {
                nmhGetFsMIEcfmMdMdLevel (i4CurrContextId, u4MdIndex,
                                         (INT4 *) &u4RetMdLevel);
                nmhGetFsMIEcfmMaCrosscheckStatus (i4CurrContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  &i4MaXChkStatus);
                nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex,
                                               u4MaIndex, &i4RetPriVlanId);
                if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
                {
                    /*If CrossCheck status other than default */
                    if (i4MaXChkStatus == ECFM_DISABLE)

                    {
                        if (i4RetPriVlanId != 0)

                        {
                            if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                            {
                                CliPrintf (CliHandle, "exit\r\n");
                                CliPrintf (CliHandle,
                                           "ethernet cfm mep crosscheck disable "
                                           "level %u service-instance %u \r\n",
                                           u4RetMdLevel,
                                           ECFM_ISID_INTERNAL_TO_ISID
                                           (i4RetPriVlanId));
                            }
                            else
                            {
                                CliPrintf (CliHandle, "exit\r\n");
#ifdef VSI_WANTED                        
                                if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                                {
                                    CliPrintf (CliHandle,
                                               "ethernet cfm mep crosscheck disable "
                                               "level %u vsi %u \r\n",
                                               u4RetMdLevel, i4RetPriVlanId);
                                }
                                else
#endif
                                {
                                CliPrintf (CliHandle,
                                           "ethernet cfm mep crosscheck disable "
                                           "level %u vlan %u \r\n",
                                           u4RetMdLevel, i4RetPriVlanId);
                            }
                        }
                        }

                        else

                        {
                            CliPrintf (CliHandle, "exit\r\n");
                            CliPrintf (CliHandle,
                                       "ethernet cfm mep crosscheck disable "
                                       "level %u \r\n", u4RetMdLevel);
                        }
                    }
                }
            }

            /* move to next Mep */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }

    /* Initialise variables for the next table */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;

    /*Association of Vlan To a Primary Vlan */
    i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                 (UINT4 *) &i4NextContextId,
                                                 0, (INT4 *) &u4VlanVid);
    pu1VlanList = UtilVlanAllocVlanListSize (sizeof (tVlanListExt));

    if (pu1VlanList == NULL)
    {
        CliPrintf (CliHandle, "\r\n Error in Allocating Memory for "
                   "Vlan List\r\n");
        return CLI_FAILURE;
    }

    ECFM_MEMSET (pu1VlanList, ECFM_INIT_VAL, sizeof (tVlanListExt));
    if (i4RetVal == SNMP_SUCCESS)

    {
        UINT4               u4VlanPrimaryVid = ECFM_INIT_VAL;

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            nmhGetFsMIEcfmVlanPrimaryVid (i4CurrContextId, u4VlanVid,
                                          (INT4 *) &u4VlanPrimaryVid);

            /*Check whether this PrimaryVlanId is already traversed */
            ECFM_IS_LIST_MEMBER (pu1VlanList, (INT2) u4VlanPrimaryVid,
                                 u1Return);

            if (u1Return == ECFM_FALSE)
            {
                CliPrintf (CliHandle, "ethernet cfm associate vlan-id %u",
                           u4VlanVid);

                /*Print  Vlan List for same primary-vid */
                EcfmVlanPrint (CliHandle, i4CurrContextId, u4VlanPrimaryVid,
                               u4VlanVid);
                CliPrintf (CliHandle, " primary-vlan-id %u", u4VlanPrimaryVid);
                CliPrintf (CliHandle, "\r\n");

                /*Set Vlan Array stating it as traversed */
                ECFM_SET_LIST_MEMBER (pu1VlanList, (INT2) u4VlanPrimaryVid);
            }
            i4RetVal = nmhGetNextIndexFsMIEcfmVlanTable (i4CurrContextId,
                                                         (UINT4 *)
                                                         &i4NextContextId,
                                                         u4VlanVid,
                                                         (INT4 *)
                                                         &u4NextVlanVid);
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4VlanVid = u4NextVlanVid;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }
    /* Releasing memory for Vlan List Size */
    UtilVlanReleaseVlanListSize ((UINT1 *) pu1VlanList);

    /* Initialise variables for the next table */
    i4CurrContextId = (INT4) (u4ContextId);
    i4NextContextId = ECFM_INIT_VAL;
    b1SameContext = ECFM_TRUE;
    i4PrimarySelectorType = 0;

    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        /*Default Md Table */
        i4RetVal = nmhGetNextIndexFsMIEcfmExtDefaultMdTable (i4CurrContextId,
                                                             (UINT4 *)
                                                             &i4NextContextId,
                                                             i4PrimarySelectorType,
                                                             &i4PrimarySelectorType,
                                                             0,
                                                             &u4DefaultMdPrimaryVid);
        if (i4RetVal == SNMP_SUCCESS)

        {
            /* Check if it has entry for this particular context */
            if (i4CurrContextId != i4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
            }
        }
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
        {
            /*Default MdLevel */
            nmhGetFsMIEcfmExtDefaultMdLevel (i4CurrContextId,
                                             i4PrimarySelectorType,
                                             u4DefaultMdPrimaryVid,
                                             &i4DefaultMdLevel);
            nmhGetFsMIEcfmExtDefaultMdMhfCreation (i4CurrContextId,
                                                   i4PrimarySelectorType,
                                                   u4DefaultMdPrimaryVid,
                                                   &i4DefaultMdMhfCreation);
            nmhGetFsMIEcfmExtDefaultMdIdPermission (i4CurrContextId,
                                                    i4PrimarySelectorType,
                                                    u4DefaultMdPrimaryVid,
                                                    &i4DefaultMdIdPermission);
            if ((i4DefaultMdLevel != ECFM_DEF_MD_LEVEL_DEF_VAL)
                || (i4DefaultMdMhfCreation != ECFM_MHF_CRITERIA_DEFER)
                || (i4DefaultMdIdPermission != ECFM_SENDER_ID_DEFER))
            {
                CliPrintf (CliHandle, "ethernet cfm default-domain ");

                if (i4PrimarySelectorType == ECFM_SERVICE_SELECTION_VLAN)
                {
#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (u4DefaultMdPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "vsi %u", u4DefaultMdPrimaryVid);
                    }
                    else
#endif
                    {
                    CliPrintf (CliHandle, "vlan %u", u4DefaultMdPrimaryVid);
                }
                }
                else if (i4PrimarySelectorType == ECFM_SERVICE_SELECTION_ISID)
                {
                    CliPrintf (CliHandle,
                               "service-instance %u", u4DefaultMdPrimaryVid);
                }
            }

            if (i4DefaultMdLevel != ECFM_DEF_MD_LEVEL_DEF_VAL)
            {
                CliPrintf (CliHandle, " level %u", i4DefaultMdLevel);
                if ((i4DefaultMdMhfCreation == ECFM_MHF_CRITERIA_DEFER) &&
                    (i4DefaultMdIdPermission == ECFM_SENDER_ID_DEFER))

                {
                    CliPrintf (CliHandle, "\r\n");
                }
            }

            /*Default MdMhfCreation */
            if (i4DefaultMdMhfCreation != ECFM_MHF_CRITERIA_DEFER)
            {
                CliPrintf (CliHandle, " mip-creation-criteria ");
                switch (i4DefaultMdMhfCreation)
                {
                    case ECFM_MHF_CRITERIA_NONE:
                        CliPrintf (CliHandle, "%s", "none");
                        break;
                    case ECFM_MHF_CRITERIA_DEFAULT:
                        CliPrintf (CliHandle, "%s", "default");
                        break;
                    case ECFM_MHF_CRITERIA_EXPLICIT:
                        CliPrintf (CliHandle, "%s", "explicit");
                        break;
                    default:
                        break;
                }
                if (i4DefaultMdIdPermission == ECFM_SENDER_ID_DEFER)
                {
                    CliPrintf (CliHandle, "\r\n");
                }
            }

            /*Default MdIdPermission */
            if (i4DefaultMdIdPermission != ECFM_SENDER_ID_DEFER)
            {
                CliPrintf (CliHandle, " sender-id-permission ");
                switch (i4DefaultMdIdPermission)
                {
                    case ECFM_SENDER_ID_NONE:
                        CliPrintf (CliHandle, "%s", "none");
                        break;
                    case ECFM_SENDER_ID_CHASSIS:
                        CliPrintf (CliHandle, "%s", "chassis");
                        break;
                    case ECFM_SENDER_ID_MANAGE:
                        CliPrintf (CliHandle, "%s", "manage");
                        break;
                    case ECFM_SENDER_ID_CHASSID_MANAGE:
                        CliPrintf (CliHandle, "%s", "chassis-mgt-address");
                        break;
                    default:
                        break;
                }
                CliPrintf (CliHandle, "\r\n");
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmExtDefaultMdTable
                (i4CurrContextId,
                 (UINT4 *) &i4NextContextId, i4PrimarySelectorType,
                 &i4PrimarySelectorType, u4DefaultMdPrimaryVid,
                 &u4NextDefaultMdPrimaryVid);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)
            {
                u4DefaultMdPrimaryVid = u4NextDefaultMdPrimaryVid;
                if (i4CurrContextId != i4NextContextId)
                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }

    return CLI_SUCCESS;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmMaListPrint                                    */
/*                                                                           */
/*     DESCRIPTION      : This function Print the Ma Created by User         */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4CurrContextId - Current Context Id               */
/*                      : u4MdIndex - MD Index                               */
/*                      : u4MaIndex - MA Index                               */
/*                        u1Module    - Module Id                            */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmMaListPrint (tCliHandle CliHandle, UINT4 i4CurrContextId,
                 UINT4 u4MdIndex, UINT4 u4MaIndex, UINT1 u1Module)
{
    INT4                i4RetMaFormat = (INT1) ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = (INT1) ECFM_INIT_VAL;
    INT4                i4EcfmMaMhfCreation = (INT1) ECFM_INIT_VAL;
    INT4                i4RetIdPermission = (INT1) ECFM_INIT_VAL;
    UINT1               au1RetMegIdCodeIcc[ECFM_CARRIER_CODE_ARRAY_SIZE];
    UINT1               au1RetMegIdCodeUmc[ECFM_UMC_CODE_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1ServiceType[ECFM_CARRIER_CODE_ARRAY_SIZE];
    tSNMP_OCTET_STRING_TYPE RetMegIdCodeIcc;
    tSNMP_OCTET_STRING_TYPE RetMegIdCodeUmc;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tEcfmCcMaInfo      *pMaNode = NULL;

    /* Get u4MaIndex's name, primaryvlanid for MA */
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = ECFM_INIT_VAL;

    i4RetMaFormat = ECFM_INIT_VAL;

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;
    ECFM_MEMSET (au1RetMegIdCodeIcc, ECFM_INIT_VAL,
                 ECFM_CARRIER_CODE_ARRAY_SIZE);
    ECFM_MEMSET (&RetMegIdCodeIcc, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMegIdCodeIcc.pu1_OctetList = au1RetMegIdCodeIcc;
    RetMegIdCodeIcc.i4_Length = 0;
    ECFM_MEMSET (au1RetMegIdCodeUmc, ECFM_INIT_VAL,
                 ECFM_CARRIER_CODE_ARRAY_SIZE);
    ECFM_MEMSET (&RetMegIdCodeUmc, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMegIdCodeUmc.pu1_OctetList = au1RetMegIdCodeUmc;
    RetMegIdCodeUmc.i4_Length = 0;

    nmhGetFsMIEcfmMaName (i4CurrContextId, u4MdIndex, u4MaIndex, &RetMaName);
    nmhGetFsMIEcfmMdName (i4CurrContextId, u4MdIndex, &RetMdName);
    nmhGetFsMIEcfmMdFormat (i4CurrContextId, u4MdIndex, &i4RetMdFormat);
    nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrContextId, u4MdIndex, u4MaIndex,
                                   &i4RetPriVlanId);
    nmhGetFsMIEcfmMaFormat (i4CurrContextId, u4MdIndex, u4MaIndex,
                            &i4RetMaFormat);
    nmhGetFsMIY1731MeMegIdIcc (i4CurrContextId, u4MdIndex, u4MaIndex,
                               &RetMegIdCodeIcc);
    nmhGetFsMIY1731MeMegIdUmc (i4CurrContextId, u4MdIndex, u4MaIndex,
                               &RetMegIdCodeUmc);

    if (ECFM_CC_SELECT_CONTEXT (i4CurrContextId) != ECFM_SUCCESS)
    {
        return;
    }

    pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);

    if (pMaNode == NULL)
    {
        ECFM_CC_RELEASE_CONTEXT ();
        return;
    }

    ECFM_MEMSET (au1ServiceType, ECFM_INIT_VAL, ECFM_CARRIER_CODE_ARRAY_SIZE);
    ECFM_CC_RELEASE_CONTEXT ();
    if (pMaNode->u1SelectorType == ECFM_SERVICE_SELECTION_LSP)
    {
        ECFM_MEMCPY (au1ServiceType, "lsp", sizeof ("lsp"));
    }
    else if (pMaNode->u1SelectorType == ECFM_SERVICE_SELECTION_PW)
    {
        ECFM_MEMCPY (au1ServiceType, "pw", sizeof ("pw"));
    }
    MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
    EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

    MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
    if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        CliPrintf (CliHandle, " service name %s service-type %s icc %s umc %s ",
                   au1StrMaName, au1ServiceType,
                   RetMegIdCodeIcc.pu1_OctetList,
                   RetMegIdCodeUmc.pu1_OctetList);
        CliPrintf (CliHandle, "\r\n");
        return;
    }

    if (i4RetPriVlanId != 0)
    {
        switch (i4RetMaFormat)
        {
            case ECFM_ASSOC_NAME_PRIMARY_VID:
                CliPrintf (CliHandle, " service format primary-vid name");
                break;

            case ECFM_ASSOC_NAME_UNSIGNED_INT_16:
                CliPrintf (CliHandle, " service format unsigned-int16 name");
                break;

            case ECFM_ASSOC_NAME_RFC2865_VPN_ID:
                CliPrintf (CliHandle, " service format rfc2865-vpn-id name");
                break;

            case ECFM_ASSOC_NAME_CHAR_STRING:
            case ECFM_ASSOC_NAME_ICC:
                CliPrintf (CliHandle, " service name");
            default:
                break;
        }

        CliPrintf (CliHandle, " %s", au1StrMaName);
        /* If ICC and UMC is not equal to Zero then print the value.
         */
        if ((RetMegIdCodeIcc.i4_Length != ECFM_INIT_VAL) ||
            (RetMegIdCodeUmc.i4_Length != ECFM_INIT_VAL))
        {
            CliPrintf (CliHandle, " icc %s", RetMegIdCodeIcc.pu1_OctetList);
            CliPrintf (CliHandle, " umc %s", RetMegIdCodeUmc.pu1_OctetList);
        }
        if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
        {
            CliPrintf (CliHandle, " service-instance %d",
                       ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
        }
        else
        {
#ifdef VSI_WANTED                        
            if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, " vsi %d", i4RetPriVlanId);
                if (pMaNode->u2OamVlanId != ECFM_INVALID_RANGE_VLAN_ID)
                {
                    CliPrintf (CliHandle, " oam-vlan %d", pMaNode->u2OamVlanId);
                }
            }
            else
#endif
            {
            CliPrintf (CliHandle, " vlan %d", i4RetPriVlanId);
        }
    }
    }
    else
    {
        switch (i4RetMaFormat)
        {
            case ECFM_ASSOC_NAME_UNSIGNED_INT_16:
                CliPrintf (CliHandle, " service format unsigned-int16"
                           " name %s", au1StrMaName);
                break;

            case ECFM_ASSOC_NAME_RFC2865_VPN_ID:
                CliPrintf (CliHandle, " service format rfc2865-vpn-id"
                           " name %s", au1StrMaName);
                break;

            case ECFM_ASSOC_NAME_CHAR_STRING:
            case ECFM_ASSOC_NAME_ICC:
                CliPrintf (CliHandle, " service name %s", au1StrMaName);
                break;

            default:
                break;
        }

        /* If ICC and UMC is not equal to Zero then print the value.
         */
        if ((RetMegIdCodeIcc.i4_Length != ECFM_INIT_VAL) ||
            (RetMegIdCodeUmc.i4_Length != ECFM_INIT_VAL))
        {
            CliPrintf (CliHandle, " icc %s", RetMegIdCodeIcc.pu1_OctetList);
            CliPrintf (CliHandle, " umc %s", RetMegIdCodeUmc.pu1_OctetList);
        }
    }
    nmhGetFsMIEcfmMaMhfCreation (i4CurrContextId, u4MdIndex, u4MaIndex,
                                 &i4EcfmMaMhfCreation);
    nmhGetFsMIEcfmMaIdPermission (i4CurrContextId, u4MdIndex, u4MaIndex,
                                  &i4RetIdPermission);
    if ((i4EcfmMaMhfCreation !=
         ECFM_MHF_CRITERIA_DEFER) || (i4RetIdPermission !=
                                      ECFM_SENDER_ID_DEFER))

    {
        switch (i4EcfmMaMhfCreation)

        {
            case ECFM_MHF_CRITERIA_NONE:
                CliPrintf (CliHandle, " mip-creation-criteria none");
                break;
            case ECFM_MHF_CRITERIA_DEFAULT:
                CliPrintf (CliHandle, " mip-creation-criteria default");
                break;
            case ECFM_MHF_CRITERIA_EXPLICIT:
                CliPrintf (CliHandle, " mip-creation-criteria explicit");
                break;
            default:
                break;
        }

        /*Default MdIdPermission */
        if (i4RetIdPermission != ECFM_SENDER_ID_DEFER)

        {
            CliPrintf (CliHandle, " sender-id-permission ");
            switch (i4RetIdPermission)

            {
                case ECFM_SENDER_ID_NONE:
                    CliPrintf (CliHandle, "%s", "none");
                    break;
                case ECFM_SENDER_ID_CHASSIS:
                    CliPrintf (CliHandle, "%s", "chassis");
                    break;
                case ECFM_SENDER_ID_MANAGE:
                    CliPrintf (CliHandle, "%s", "manage");
                    break;
                case ECFM_SENDER_ID_CHASSID_MANAGE:
                    CliPrintf (CliHandle, "%s", "chassis-mgt-address");
                    break;
                default:
                    break;
            }
        }
    }
    CliPrintf (CliHandle, "\r\n");
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmPrintTrapControl                               */
/*                                                                           */
/*     DESCRIPTION      : This function Print the Types of Enabled           */
/*                        value is diffrent then default value               */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4RetCcRole - Current CC Role                      */
/*                        u1Module    - Module Id                            */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmPrintTrapControl (tCliHandle CliHandle, UINT4 u4ContextId, UINT1 u1Module)
{
    UINT1               u1TrapOption = 0;
    UINT1               au1Y1731TrapOption[ECFM_INDEX_TWO] = { 0 };
    UINT1               u1CurY1731TrapOptionLsb = (UINT1) ECFM_INIT_VAL;
    UINT1               u1CurTrapOption = (UINT1) ECFM_INIT_VAL;
    UINT1               u1CurY1731TrapOptionMsb = (UINT1) ECFM_INIT_VAL;
    UINT1               u1FlagValue = (UINT1) ECFM_FALSE;
    tSNMP_OCTET_STRING_TYPE EcfmTrapOption;
    tSNMP_OCTET_STRING_TYPE Y1731TrapOption;
    ECFM_MEMSET (&EcfmTrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (au1Y1731TrapOption));
    EcfmTrapOption.pu1_OctetList = &u1TrapOption;
    EcfmTrapOption.i4_Length = 1;
    Y1731TrapOption.pu1_OctetList = au1Y1731TrapOption;
    Y1731TrapOption.i4_Length = 1;
    nmhGetFsMIEcfmTrapControl (u4ContextId, &EcfmTrapOption);
    nmhGetFsMIY1731TrapControl (u4ContextId, &Y1731TrapOption);
    u1CurTrapOption = EcfmTrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionLsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionMsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ONE];

    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        u1Module = ECFM_INIT_VAL;
    }
    else if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        u1Module = ECFM_INDEX_ONE;
    }
    if (ECFM_CLI_ALL_CCM_TRAP_ENABLED
        (u1CurTrapOption, u1CurY1731TrapOptionMsb,
         u1CurY1731TrapOptionLsb) == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "snmp-server enable traps %s all\r\n",
                   gau1ModuleName[u1Module]);
    }

    else

    {
        if ((u1CurTrapOption != ECFM_INIT_VAL) ||
            (u1CurY1731TrapOptionMsb != ECFM_INIT_VAL) ||
            (u1CurY1731TrapOptionLsb != ECFM_INIT_VAL))

        {
            CliPrintf (CliHandle, "snmp-server enable traps %s ",
                       gau1ModuleName[u1Module]);
        }
        if ((ECFM_CLI_RDI_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
            || (Y1731_CLI_RDI_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionLsb)))

        {
            CliPrintf (CliHandle, " rdi-ccm");

            u1FlagValue = ECFM_TRUE;
        }
        if (ECFM_CLI_MAC_STATUS_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " mac-status");
            u1FlagValue = ECFM_TRUE;
        }
        if (ECFM_CLI_REMOTE_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " mep-missing");
            u1FlagValue = ECFM_TRUE;
        }
        if (ECFM_CLI_ERR_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " errored-ccm");
            u1FlagValue = ECFM_TRUE;
        }
        if (ECFM_CLI_XCONN_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " cross-connect");
            u1FlagValue = ECFM_TRUE;
        }
        if (Y1731_CLI_LOC_TRAP_ENABLED (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " loss-of-continuity");
            u1FlagValue = ECFM_TRUE;
        }
        if (Y1731_CLI_UNEXPECTED_PERIOD_TRAP_ENABLED
            (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " unexpected-period");
            u1FlagValue = ECFM_TRUE;
        }
        if (Y1731_CLI_UNEXPECTED_MEP_TRAP_ENABLED (u1CurY1731TrapOptionLsb)
            == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " unexpected-mep");
            u1FlagValue = ECFM_TRUE;
        }
        if (Y1731_CLI_MIS_MERGE_TRAP_ENABLED (u1CurY1731TrapOptionMsb) ==
            ECFM_TRUE)

        {
            CliPrintf (CliHandle, " mis-merge");
            u1FlagValue = ECFM_TRUE;
        }
        if (Y1731_CLI_UNEXPECTED_MEG_LEVEL_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

        {
            CliPrintf (CliHandle, " unexpected-level");
            u1FlagValue = ECFM_TRUE;
        }
        if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
        {
            if (Y1731_CLI_LOCAL_LINK_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " local-link-failure");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_INTERNAL_HW_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " hardware-failure");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_INTERNAL_SW_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " software-failure");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_FRAME_LOSS_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
                ECFM_TRUE)

            {
                CliPrintf (CliHandle, " frame-loss");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_FRAME_DELAY_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
                ECFM_TRUE)

            {
                CliPrintf (CliHandle, " frame-delay");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_TST_RCVD_WITH_ERROR_TRAP_ENABLED
                (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " bit-error");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_AIS_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
                == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " ais-condition");
                u1FlagValue = ECFM_TRUE;
            }
            if (Y1731_CLI_LCK_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
                == ECFM_TRUE)

            {
                CliPrintf (CliHandle, " lck-condition");
                u1FlagValue = ECFM_TRUE;
            }
        }
        if (u1FlagValue == ECFM_TRUE)

        {
            CliPrintf (CliHandle, "\r\n");
        }
            }
        }

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmPrintTimerInterval                             */
/*                                                                           */
/*     DESCRIPTION      : This function Print the CCI Interval If Configred  */
/*                        value is diffrent then default value               */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : i4RetCcRole - Current CC Role                      */
/*                      : i4MaCcmInterval - Current CCM Interval             */
/*                      : u4RetMdLevel - Current MD Level                    */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmPrintTimerInterval (tCliHandle CliHandle, INT4 i4RetCcRole,
                        INT4 i4MaCcmInterval, UINT4 u4RetMdLevel,
                        INT4 i4RetPriVlanId, UINT4 u1Module)
{
    if (u1Module == ECFM_ETH_SHOW_RUNNING_CONFIG)
    {
        u1Module = ECFM_INIT_VAL;
    }
    else if (u1Module == ECFM_MPLSTP_SHOW_RUNNING_CONFIG)
    {
        u1Module = ECFM_INDEX_ONE;
    }
    if (i4RetCcRole == ECFM_CC_ROLE_FM)

    {
        if (i4MaCcmInterval != ECFM_CCM_INTERVAL_1_S)

        {
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u service-instance %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "%s cc level %u vsi %u ",
                                   gau1ModuleName[u1Module], u4RetMdLevel,
                                   i4RetPriVlanId);
                    }
                    else
#endif
                    {
                    CliPrintf (CliHandle, "%s cc level %u vlan %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               i4RetPriVlanId);
                }
            }
            }

            else

            {
                CliPrintf (CliHandle, "%s cc level %u ",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
            switch (i4MaCcmInterval)

            {
                case ECFM_CCM_INTERVAL_300Hz:
                    CliPrintf (CliHandle, "interval three-hundred-hertz ");
                    break;
                case ECFM_CCM_INTERVAL_10_Ms:
                    CliPrintf (CliHandle, "interval ten-ms ");
                    break;
                case ECFM_CCM_INTERVAL_100_Ms:
                    CliPrintf (CliHandle, "interval hundred-ms ");
                    break;
                case ECFM_CCM_INTERVAL_10_S:
                    CliPrintf (CliHandle, "interval ten-sec ");
                    break;
                case ECFM_CCM_INTERVAL_1_MIN:
                    CliPrintf (CliHandle, "interval one-min ");
                    break;
                case ECFM_CCM_INTERVAL_10_MIN:
                    CliPrintf (CliHandle, "interval ten-min ");
                    break;
                default:
                    break;
            }
            CliPrintf (CliHandle, "\r\n");
        }
    }
    if (i4RetCcRole == ECFM_CC_ROLE_PM)

    {
        if (i4MaCcmInterval != ECFM_CCM_INTERVAL_100_Ms)

        {
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u service-instance %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "%s cc level %u vsi %u ",
                                   gau1ModuleName[u1Module], u4RetMdLevel,
                                   i4RetPriVlanId);
                    }
                    else
#endif
                    {
                    CliPrintf (CliHandle, "%s cc level %u vlan %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               i4RetPriVlanId);
                }
            }
            }

            else

            {
                CliPrintf (CliHandle, "%s cc level %u ",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
            switch (i4MaCcmInterval)

            {
                case ECFM_CCM_INTERVAL_300Hz:
                    CliPrintf (CliHandle, "interval three-hundred-hertz ");
                    break;
                case ECFM_CCM_INTERVAL_10_Ms:
                    CliPrintf (CliHandle, "interval ten-ms ");
                    break;
                case ECFM_CCM_INTERVAL_1_S:
                    CliPrintf (CliHandle, "interval one-sec ");
                    break;
                case ECFM_CCM_INTERVAL_10_S:
                    CliPrintf (CliHandle, "interval ten-sec ");
                    break;
                case ECFM_CCM_INTERVAL_1_MIN:
                    CliPrintf (CliHandle, "interval one-min ");
                    break;
                case ECFM_CCM_INTERVAL_10_MIN:
                    CliPrintf (CliHandle, "interval ten-min ");
                    break;
                default:
                    break;
            }
            CliPrintf (CliHandle, "role performance-monitoring\r\n");
        }

        else

        {
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u service-instance %u "
                               "role performance-monitoring\r\n",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u vlan %u "
                               "role performance-monitoring\r\n",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               i4RetPriVlanId);
                }
            }

            else

            {
                CliPrintf (CliHandle,
                           "%s cc level %u performance-monitoring\r\n",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
        }
    }
    if (i4RetCcRole == ECFM_CC_ROLE_PS)

    {
        if (i4MaCcmInterval != ECFM_CCM_INTERVAL_300Hz)

        {
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u service-instance %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
#ifdef VSI_WANTED                        
                    if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "%s cc level %u vsi %u ",
                                   gau1ModuleName[u1Module], u4RetMdLevel,
                                   i4RetPriVlanId);
                    }
                    else
#endif
                    {
                    CliPrintf (CliHandle, "%s cc level %u vlan %u ",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               i4RetPriVlanId);
                }
            }
            }

            else

            {
                CliPrintf (CliHandle, "%s cc level %u ",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
            switch (i4MaCcmInterval)

            {
                case ECFM_CCM_INTERVAL_10_Ms:
                    CliPrintf (CliHandle, "interval ten-ms ");
                    break;
                case ECFM_CCM_INTERVAL_100_Ms:
                    CliPrintf (CliHandle, "interval hundred-ms ");
                    break;
                case ECFM_CCM_INTERVAL_1_S:
                    CliPrintf (CliHandle, "interval one-sec ");
                    break;
                case ECFM_CCM_INTERVAL_10_S:
                    CliPrintf (CliHandle, "interval ten-sec ");
                    break;
                case ECFM_CCM_INTERVAL_1_MIN:
                    CliPrintf (CliHandle, "interval one-min ");
                    break;
                case ECFM_CCM_INTERVAL_10_MIN:
                    CliPrintf (CliHandle, "interval ten-min ");
                    break;
                default:
                    break;
            }
            CliPrintf (CliHandle, "role protection-switching\r\n");
        }

        else

        {
            if (i4RetPriVlanId != 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPriVlanId))
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u service-instance %u"
                               " role protection-switching\r\n",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPriVlanId));
                }
                else
                {
                    CliPrintf (CliHandle,
                               "%s cc level %u vlan %u role"
                               " protection-switching\r\n",
                               gau1ModuleName[u1Module], u4RetMdLevel,
                               i4RetPriVlanId);
                }

            }

            else

            {
                CliPrintf (CliHandle,
                           "%s cc level %u role protection-switching\r\n",
                           gau1ModuleName[u1Module], u4RetMdLevel);
            }
        }
    }
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowRunningConfigInterface                     */
/*                                                                           */
/*     DESCRIPTION      : This function scans the interface table for  ECFM  */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                      : u4ContextId - Current context Id                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
VOID
EcfmShowRunningConfigInterface (tCliHandle CliHandle, UINT4 u4ContextId)
{
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT1               u1Flag = ECFM_FALSE;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NxtIfIndex = ECFM_INIT_VAL;
    UINT4               u4IfIndex = ECFM_INIT_VAL;
    UINT4               u4PreIfIndex = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT2               u2LocalPort = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
#ifdef ICCH_WANTED
    UINT4               u4IcchIfIndex = 0;
#endif

    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmPortTable (0, (INT4 *) &u4IfIndex);

#ifdef ICCH_WANTED
    IcchGetIcclIfIndex (&u4IcchIfIndex);
#endif

    while (i4RetVal == SNMP_SUCCESS)
    {
        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4IfIndex,
                                                (UINT4 *) &i4NextContextId,
                                                &u2LocalPort) !=
            ECFM_VCM_SUCCESS)
        {
            return;
        }
        /* Check if it has entry for this particular context */
        if ((i4CurrContextId != i4NextContextId)
#ifdef ICCH_WANTED
            || (u4IfIndex == u4IcchIfIndex)
#endif
            )

        {
            b1SameContext = ECFM_FALSE;
            u4PreIfIndex = u4IfIndex;
            i4RetVal =
                nmhGetNextIndexFsMIEcfmPortTable (u4PreIfIndex,
                                                  (INT4 *) &u4IfIndex);
            continue;
        }
        else
        {
            b1SameContext = ECFM_TRUE;
            break;
        }
    }
    while (i4RetVal == SNMP_SUCCESS)

    {
        if (b1SameContext == ECFM_TRUE)
        {
            /*Get the Interface name for specified IfIndex */
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            u1Flag = ECFM_FALSE;
            EcfmShowRunningConfigInterfaceDetails (CliHandle, (INT4) u4IfIndex,
                                                   &u1Flag);
            ECFM_REGISTER_CLI_CC_LOCK ();
            CliPrintf (CliHandle, "!");
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
            if (u4PagingStatus == CLI_FAILURE)
            {

                /* User Presses 'q' at the prompt, so break! */
                break;
            }
        }
        i4RetVal =
            nmhGetNextIndexFsMIEcfmPortTable (u4IfIndex,
                                              (INT4 *) &u4NxtIfIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4NxtIfIndex,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    &u2LocalPort) ==
                ECFM_VCM_SUCCESS)
            {
                u4IfIndex = u4NxtIfIndex;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                else
                {
                    b1SameContext = ECFM_TRUE;
                }

            }
        }
    }
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliShowGlobalInfo                              */
/*                                                                           */
/*     DESCRIPTION      : This function displays global information in ECFM  */
/*                                                                           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : None                                               */
/*                                                                           */
/*****************************************************************************/
INT4
EcfmCliShowGlobalInfo (tCliHandle CliHandle, UINT4 u4ContextId)
{
    tSNMP_OCTET_STRING_TYPE TrapOption;
    tSNMP_OCTET_STRING_TYPE Y1731TrapOption;
    INT4                i4ModStatus = ECFM_INIT_VAL;
    INT4                i4OperStatus = ECFM_INIT_VAL;
    INT4                i4OffLoadStatus = ECFM_INIT_VAL;
    INT4                i4SystemControl = ECFM_INIT_VAL;
    INT4                i4LtrCacheStatus = ECFM_INIT_VAL;
    INT4                i4LbrCacheStatus = ECFM_INIT_VAL;
    INT4                i4ErrorLogStatus = ECFM_INIT_VAL;
    INT4                i4MipCcmDbStatus = ECFM_INIT_VAL;
    INT4                i4MipDynamicEvalStatus = ECFM_INIT_VAL;
    INT4                i4MepCrosscheckDelay = ECFM_INIT_VAL;
    INT4                i4MipCcmDbSize = ECFM_INIT_VAL;
    INT4                i4MipCcmDbHoldTime = ECFM_INIT_VAL;
    INT4                i4LtrCacheSize = ECFM_INIT_VAL;
    INT4                i4LtrCacheHoldTime = ECFM_INIT_VAL;
    INT4                i4ErrorLogSize = ECFM_INIT_VAL;
    INT4                i4LbrCacheSize = ECFM_INIT_VAL;
    INT4                i4LbrCacheHoldTime = ECFM_INIT_VAL;
    INT4                i4FrameLossBufferSize = ECFM_INIT_VAL;
    INT4                i4FrameDelayBufferSize = ECFM_INIT_VAL;
    INT4                i4McLagMepShutStatus = ECFM_INIT_VAL;
    UINT4               u4McLagMepFaultHoldTime = ECFM_INIT_VAL; 
    UINT1               u1TrapOption = ECFM_INIT_VAL;
    UINT1               au1Y1731TrapOption[ECFM_ARRAY_SIZE_2] = { 0 };
    UINT1               u1CurTrapOption = ECFM_INIT_VAL;
    UINT1               u1CurY1731TrapOptionMsb = ECFM_INIT_VAL;
    UINT1               u1CurY1731TrapOptionLsb = ECFM_INIT_VAL;

    /* SystemControl */
    nmhGetFsMIEcfmSystemControl (u4ContextId, &i4SystemControl);

    /* Checking SystemControl value other than default value */
    if (i4SystemControl == ECFM_SHUTDOWN)

    {
        CliPrintf (CliHandle, "ECFM Status : Shutdown.\r\n");
        return CLI_SUCCESS;
    }

    /* Module Status ECFM */
    nmhGetFsMIEcfmModuleStatus (u4ContextId, &i4ModStatus);
    if (i4ModStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "\r\nECFM Status       : Started, Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "\r\nECFM Status       : Started, Disabled");
    }

    /* Module Status :Y1731 */
    nmhGetFsMIY1731OperStatus (u4ContextId, &i4OperStatus);
    if (i4OperStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "\r\nY1731 Status      : Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "\r\nY1731 Status      : Disabled");
    }

    /* Off-Load Status */
    nmhGetFsMIEcfmGlobalCcmOffload (u4ContextId, &i4OffLoadStatus);
    if (i4OffLoadStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "\r\nOffLoad Status    : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "\r\nOffLoad Status    : Disabled\r\n");
    }
    CliPrintf (CliHandle, "\r\n");

    /*Mip Dynamic Evaluation Status */
    nmhGetFsMIEcfmMipDynamicEvaluationStatus (u4ContextId,
                                              &i4MipDynamicEvalStatus);
    if (i4MipDynamicEvalStatus == ECFM_SNMP_TRUE)

    {
        CliPrintf (CliHandle, "MIP Creation Dynamic Evaluation : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle,
                   "MIP Creation Dynamic Evaluation : Disabled \r\n");
    }

    /*Mep Cross Check Delay */
    nmhGetFsMIEcfmCrosscheckDelay (u4ContextId, &i4MepCrosscheckDelay);
    CliPrintf (CliHandle, "Cross-Check Delay               : %u\r\n",
               i4MepCrosscheckDelay);

    /* Mip CCM Db */
    nmhGetFsMIEcfmMipCcmDbStatus (u4ContextId, &i4MipCcmDbStatus);
    CliPrintf (CliHandle, "\r\nMIP CCM Database\r\n");
    CliPrintf (CliHandle, "----------------\r\n");
    if (i4MipCcmDbStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "Status    : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "Status    : Disabled\r\n");
    }

    /* Display MIP CCM Db parameters */

    /* Checking Mip CCM Db Size */
    nmhGetFsMIEcfmMipCcmDbSize (u4ContextId, &i4MipCcmDbSize);
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4MipCcmDbSize);

    /* Mip CCM Db Hold Time */
    nmhGetFsMIEcfmMipCcmDbHoldTime (u4ContextId, &i4MipCcmDbHoldTime);
    CliPrintf (CliHandle, "Hold-time : %u hours\r\n", i4MipCcmDbHoldTime);
    CliPrintf (CliHandle, "\r\n");

    /*Traceroute Cache */
    CliPrintf (CliHandle, "Traceroute Cache");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "----------------\r\n");
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /*LTR Cache */
    nmhGetFsMIEcfmLtrCacheStatus (u4ContextId, &i4LtrCacheStatus);

    /*Ltr Cache Size */
    nmhGetFsMIEcfmLtrCacheSize (u4ContextId, &i4LtrCacheSize);

    /*Ltr Cache Hold Time */
    nmhGetFsMIEcfmLtrCacheHoldTime (u4ContextId, &i4LtrCacheHoldTime);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    /* Display LTR related parameters  */
    if (i4LtrCacheStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "Status    : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "Status    : Disabled\r\n");
    }
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4LtrCacheSize);

    /*Checking Ltr Cache Hold Time other than default value */
    CliPrintf (CliHandle, "Hold-time : %u minutes\r\n", i4LtrCacheHoldTime);
    CliPrintf (CliHandle, "\r\n");

    /* Display Error Log related parameters if it is enabled */
    nmhGetFsMIY1731ErrorLogStatus (u4ContextId, &i4ErrorLogStatus);
    CliPrintf (CliHandle, "Error Log");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "---------\r\n");
    if (i4ErrorLogStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "Status    : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "Status    : Disabled\r\n");
    }

    /*Ltr Cache Size */
    nmhGetFsMIY1731ErrorLogSize (u4ContextId, &i4ErrorLogSize);
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4ErrorLogSize);
    CliPrintf (CliHandle, "\r\n");
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /*LBR Chache */
    CliPrintf (CliHandle, "LoopBack Replies (LBR) Cache");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "----------------------------\r\n");

    /*LBR Cache */
    nmhGetFsMIY1731LbrCacheStatus (u4ContextId, &i4LbrCacheStatus);
    if (i4LbrCacheStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "Status    : Enabled\r\n");
    }
    else
    {
        CliPrintf (CliHandle, "Status    : Disabled\r\n");
    }

    /*Lbr Cache Size */
    nmhGetFsMIY1731LbrCacheSize (u4ContextId, &i4LbrCacheSize);
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4LbrCacheSize);

    /*Lbr Cache Hold Time */
    nmhGetFsMIY1731LbrCacheHoldTime (u4ContextId, &i4LbrCacheHoldTime);

    /*Checking Lcr Cache Hold Time other than default value */
    CliPrintf (CliHandle, "Hold-time : %u minutes\r\n", i4LbrCacheHoldTime);
    CliPrintf (CliHandle, "\r\n");
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    /*Frame Loss Buffer */
    CliPrintf (CliHandle, "Frame Loss Buffer");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "-----------------\r\n");

    /*Frame Loss Buffer Size */
    nmhGetFsMIY1731FrameLossBufferSize (u4ContextId, &i4FrameLossBufferSize);
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4FrameLossBufferSize);
    CliPrintf (CliHandle, "\r\n");

    /*Frame Delay Buffer */
    CliPrintf (CliHandle, "Frame Delay Buffer");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "------------------\r\n");
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /*Frame Delay Buffer Size */
    nmhGetFsMIY1731FrameDelayBufferSize (u4ContextId, &i4FrameDelayBufferSize);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    CliPrintf (CliHandle, "Size      : %u entries\r\n", i4FrameDelayBufferSize);
    CliPrintf (CliHandle, "\r\n");

    /*Trap Option ECFM */
    ECFM_MEMSET (&TrapOption, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    TrapOption.pu1_OctetList = &u1TrapOption;
    TrapOption.i4_Length = 1;
    if (nmhGetFsMIEcfmTrapControl (u4ContextId, &TrapOption) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /*Trap Option Y1731 */
    ECFM_MEMSET (&Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (au1Y1731TrapOption));
    Y1731TrapOption.pu1_OctetList = au1Y1731TrapOption;
    Y1731TrapOption.i4_Length = 0;
    if (nmhGetFsMIY1731TrapControl (u4ContextId, &Y1731TrapOption) ==
        SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    CliPrintf (CliHandle, "Enabled Traps");
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "-------------\r\n");
    u1CurTrapOption = TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionLsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionMsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ONE];
    if ((u1CurTrapOption == 0) &&
        (u1CurY1731TrapOptionMsb == 0) && (u1CurY1731TrapOptionLsb == 0))

    {
        CliPrintf (CliHandle, "None\r\n");
    }

    else

    {
        UINT1               u1TempChar = ECFM_INIT_VAL;    /* For displaying the traps */

        /*ECFM TRAPS */
        /* Cross-connect defect */
        if (ECFM_CLI_XCONN_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "cross-connect");
        }

        /* Error CCM defect */
        if (ECFM_CLI_ERR_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "errored-ccm");
        }

        /* Remote CCM defect */
        if (ECFM_CLI_REMOTE_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "mep-missing");
        }

        /* Mac Status defect */
        if (ECFM_CLI_MAC_STATUS_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "mac-status");
        }

        /* Rdi defect */
        if ((ECFM_CLI_RDI_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
            || (Y1731_CLI_RDI_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionLsb)))

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "rdi condition");
        }

        /*ECFM Y1731 TRAPS */
        /* Lock Condition */
        if (Y1731_CLI_LCK_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
            == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "lck condition");
        }

        /* Ais Condition */
        if (Y1731_CLI_AIS_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
            == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "ais condition");
        }

        /* Internal Software Failure */
        if (Y1731_CLI_INTERNAL_SW_FAILURE_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "internal s/w failure");
        }

        /* Internal Hardware Failure */
        if (Y1731_CLI_INTERNAL_HW_FAILURE_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "internal h/w failure");
        }

        /*Local Link Failure  */
        if (Y1731_CLI_LOCAL_LINK_FAILURE_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "local-link failure");
        }

        /* Unexpected Meg Level */
        if (Y1731_CLI_UNEXPECTED_MEG_LEVEL_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "unexpected meg level");
        }

        /* Mis Merge */
        if (Y1731_CLI_MIS_MERGE_TRAP_ENABLED (u1CurY1731TrapOptionMsb) ==
            ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "mismerge");
        }

        /* Unexpected Mep */
        if (Y1731_CLI_UNEXPECTED_MEP_TRAP_ENABLED (u1CurY1731TrapOptionLsb)
            == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "unexpected mep");
        }

        /*Unexpected Period  */
        if (Y1731_CLI_UNEXPECTED_PERIOD_TRAP_ENABLED
            (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "unexpected period");
        }

        /* Loss of Continuity */
        if (Y1731_CLI_LOC_TRAP_ENABLED (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "loss of continuity");
        }

        /*Frame Delay  */
        if (Y1731_CLI_FRAME_DELAY_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
            ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "delay exceeded");
        }

        /* Frame Loss */
        if (Y1731_CLI_FRAME_LOSS_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
            ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "loss exceeded");
        }

        /* Tst Received With Error */
        if (Y1731_CLI_TST_RCVD_WITH_ERROR_TRAP_ENABLED
            (u1CurY1731TrapOptionLsb) == ECFM_TRUE)

        {
            if (u1TempChar >= 1)

            {
                CliPrintf (CliHandle, ", ");
            }
            if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
                (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

            {
                CliPrintf (CliHandle, "\r\n");
            }
            u1TempChar = u1TempChar + ECFM_INCR_VAL;
            CliPrintf (CliHandle, "bit-error");
        }
    }
    nmhGetFsMIEcfmMcLagStandbyMepShut (u4ContextId, &i4McLagMepShutStatus);
    nmhGetFsMIEcfmMcLagMepFaultHoldTime (u4ContextId, &u4McLagMepFaultHoldTime);
    if (i4McLagMepShutStatus == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "\n%-30s: %-10s", "Standby McLag Mep Shutdown",
                              "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "\n%-30s: %-10s", "Standby McLag Mep Shutdown",
                              "Disabled");
    }
        CliPrintf (CliHandle, "\n%-30s: %d %-10s", "Fault Propagation HoldTime",
                              u4McLagMepFaultHoldTime, "second");
    CliPrintf (CliHandle, "\r\n");
    return CLI_SUCCESS;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowPortDetail                                 */
/*                                                                           */
/*     DESCRIPTION      : This function displays information related to port */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u4IfIndex - Interface Index of the Port            */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmShowPortDetail (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4IfIndex)
{
    INT4                i4PortModuleStatus = ECFM_INIT_VAL;
    INT4                i4PortY1731Status = ECFM_INIT_VAL;
    INT4                i4PortLLCEncapStatus = ECFM_INIT_VAL;
    UINT4               u4MepCount = ECFM_INIT_VAL;
    UINT4               u4MipCount = ECFM_INIT_VAL;
    UINT2               u2Temp = ECFM_INIT_VAL;

    CliPrintf (CliHandle, "\r\n");
    for (u2Temp = 0; u2Temp < ECFM_VAL_30; u2Temp++)

    {
        CliPrintf (CliHandle, "-");
    }

    /*Module Status */
    nmhGetFsMIEcfmPortModuleStatus ((INT4) u4IfIndex, &i4PortModuleStatus);
    if (i4PortModuleStatus == (ECFM_ENABLE))

    {
        CliPrintf (CliHandle, "\r\nECFM Status       : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "\r\nECFM Status       : Disabled\r\n");
    }

    /*Y.1731 Module Status */
    nmhGetFsMIY1731PortOperStatus (u4IfIndex, &i4PortY1731Status);
    if (i4PortY1731Status == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "Y1731 Status      : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "Y1731 Status      : Disabled\r\n");
    }

    /*LLC encapsulation status */
    nmhGetFsMIEcfmPortLLCEncapStatus ((INT4) u4IfIndex, &i4PortLLCEncapStatus);
    if (i4PortLLCEncapStatus == ECFM_SNMP_TRUE)

    {
        CliPrintf (CliHandle, "LLC Encapsulation : Enabled\r\n");
    }

    else

    {
        CliPrintf (CliHandle, "LLC Encapsulation : Disabled\r\n");
    }

    EcfmGetNoOfMPsAtPort (u4ContextId, u4IfIndex, &u4MepCount, &u4MipCount);
    CliPrintf (CliHandle, "MEPs Configured   : %u \r\n", u4MepCount);
    CliPrintf (CliHandle, "MIPs Configured   : %u ", u4MipCount);
    CliPrintf (CliHandle, "\r\n");
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowPortInfo                                   */
/*                                                                           */
/*     DESCRIPTION      : This function shows port related information       */
/*                        specific to the ECFM.                              */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u4Command - Command identifier                     */
/*                        u4ReqPortNum - Port Number                         */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            */
/*****************************************************************************/
INT4
EcfmShowPortInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                  UINT4 u4Command, UINT4 u4ReqPortNum)
{
    INT1               *pi1IfName = NULL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextPortNum = ECFM_INIT_VAL;
    UINT4               u4PreIfIndex = ECFM_INIT_VAL;
    UINT4               u4PortNum = ECFM_INIT_VAL;
    UINT2               u2LocalPort = ECFM_INIT_VAL;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    BOOL1               b1SameContext = ECFM_TRUE;
    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;

    /* For a required port in a context */
    if (u4Command == CLI_ECFM_SHOW_PORT)

    {
        if (nmhValidateIndexInstanceFsMIEcfmPortTable
            ((INT4) u4ReqPortNum) == SNMP_FAILURE)

        {
            return CLI_SUCCESS;
        }
        EcfmShowPortDetail (CliHandle, u4ContextId, u4ReqPortNum);
        CliPrintf (CliHandle, "\r\n");
        return CLI_SUCCESS;
    }

    /* For all the Ports in required context */
    i4CurrContextId = (INT4) (u4ContextId);
    i4RetVal = nmhGetNextIndexFsMIEcfmPortTable (0, (INT4 *) &u4PortNum);
    while (i4RetVal == SNMP_SUCCESS)

    {
        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4PortNum,
                                                (UINT4 *) &i4NextContextId,
                                                &u2LocalPort) ==
            ECFM_VCM_SUCCESS)
        {
            /* Check if it has entry for this particular context */
            if (i4CurrContextId != i4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
                u4PreIfIndex = u4PortNum;
                i4RetVal =
                    nmhGetNextIndexFsMIEcfmPortTable (u4PreIfIndex,
                                                      (INT4 *) &u4PortNum);
                continue;
            }
            else
            {
                b1SameContext = ECFM_TRUE;
                break;
            }
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        CfaCliGetIfName (u4PortNum, pi1IfName);
        CliPrintf (CliHandle, "\r\ninterface %s", pi1IfName);

        /* Display port's information */
        EcfmShowPortDetail (CliHandle, u4ContextId, u4PortNum);
        CliPrintf (CliHandle, "\r\n");
        i4RetVal =
            nmhGetNextIndexFsMIEcfmPortTable (u4PortNum,
                                              (INT4 *) &u4NextPortNum);
        if (ECFM_GET_CONTEXT_INFO_FROM_IFINDEX
            (u4NextPortNum, (UINT4 *) &i4NextContextId,
              &u2LocalPort) == ECFM_VCM_SUCCESS)
        {
            /* Check if entry is for required context */
            if (i4RetVal == SNMP_SUCCESS)

            {
                u4PortNum = u4NextPortNum;
                if (i4CurrContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
    }
    return CLI_SUCCESS;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmShowDefaultDomain                              */
/*                                                                           */
/*     DESCRIPTION      : This function displays DefaultDomain objects in    */
/*                        ECFM                                               */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : None                                               */
/*                                                                           */
/*****************************************************************************/
INT4
EcfmShowDefaultDomain (tCliHandle CliHandle, UINT4 u4ContextId)
{
    INT4                i4DefaultMdLevel = ECFM_INIT_VAL;
    INT4                i4DefaultMdMhfCreation = ECFM_INIT_VAL;
    INT4                i4DefaultMdIdPermission = ECFM_INIT_VAL;
    INT4                i4NextDefaultMdPrimaryVid = ECFM_INIT_VAL;
    INT4                i4DefaultMdPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT2               u2Temp = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;

    /*Default MdDefLevel */
    nmhGetFsMIEcfmDefaultMdDefLevel (u4ContextId, &i4DefaultMdLevel);
    nmhGetFsMIEcfmDefaultMdDefMhfCreation (u4ContextId,
                                           &i4DefaultMdMhfCreation);
    nmhGetFsMIEcfmDefaultMdDefIdPermission (u4ContextId,
                                            &i4DefaultMdIdPermission);
    CliPrintf (CliHandle, "\r\nDefault-domain parameters");
    CliPrintf (CliHandle, "\r\n");
    for (u2Temp = 0; u2Temp < ECFM_VAL_26; u2Temp++)

    {
        CliPrintf (CliHandle, "-");
    }
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "\r\nLevel                 : %d", i4DefaultMdLevel);

    /*Default MdDefMhfCreation */
    CliPrintf (CliHandle, "\r\nMIP Creation Criteria : ");
    switch (i4DefaultMdMhfCreation)

    {
        case ECFM_MHF_CRITERIA_NONE:
            CliPrintf (CliHandle, "%s", "none");
            break;
        case ECFM_MHF_CRITERIA_DEFAULT:
            CliPrintf (CliHandle, "%s", "default");
            break;
        case ECFM_MHF_CRITERIA_EXPLICIT:
            CliPrintf (CliHandle, "%s", "explicit");
            break;
        default:
            break;
    }

    /*Default MdDefIdPermission */
    CliPrintf (CliHandle, "\r\nSenderId Permission   : ");
    switch (i4DefaultMdIdPermission)

    {
        case ECFM_SENDER_ID_NONE:
            CliPrintf (CliHandle, "%s", "none");
            break;
        case ECFM_SENDER_ID_CHASSIS:
            CliPrintf (CliHandle, "%s", "chassis");
            break;
        case ECFM_SENDER_ID_MANAGE:
            CliPrintf (CliHandle, "%s", "manage");
            break;
        case ECFM_SENDER_ID_CHASSID_MANAGE:
            CliPrintf (CliHandle, "%s", "chassis-manage");
            break;
        default:
            break;
    }
    CliPrintf (CliHandle, "\r\n");
    u4CurrContextId = u4ContextId;

    /*Default Md Table */
    i4RetVal =
        nmhGetNextIndexFsMIEcfmDefaultMdTable (u4CurrContextId,
                                               &u4NextContextId, 0,
                                               (INT4 *) &i4DefaultMdPrimaryVid);
    if (i4RetVal == SNMP_SUCCESS)

    {
        INT4                i4DefaultMdStatus = ECFM_SNMP_FALSE;

        /* Check if it has entry for this particular context */
        if (u4CurrContextId != u4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            i4DefaultMdLevel = ECFM_INIT_VAL;
            i4DefaultMdStatus = ECFM_INIT_VAL;
            i4DefaultMdMhfCreation = ECFM_INIT_VAL;
            i4DefaultMdIdPermission = ECFM_INIT_VAL;

            /*Default MdLevel */
            i4RetVal = nmhGetFsMIEcfmDefaultMdLevel (u4CurrContextId,
                                                     i4DefaultMdPrimaryVid,
                                                     &i4DefaultMdLevel);
            i4RetVal = nmhGetFsMIEcfmDefaultMdStatus (u4CurrContextId,
                                                      i4DefaultMdPrimaryVid,
                                                      &i4DefaultMdStatus);
            i4RetVal = nmhGetFsMIEcfmDefaultMdMhfCreation (u4CurrContextId,
                                                           i4DefaultMdPrimaryVid,
                                                           &i4DefaultMdMhfCreation);
            i4RetVal = nmhGetFsMIEcfmDefaultMdIdPermission
                (u4CurrContextId, i4DefaultMdPrimaryVid,
                 &i4DefaultMdIdPermission);
            if ((i4RetVal != SNMP_FAILURE))
            {
                if ((i4DefaultMdLevel !=
                     ECFM_DEF_MD_LEVEL_DEF_VAL) || (i4DefaultMdStatus !=
                                                    ECFM_SNMP_TRUE)
                    || (i4DefaultMdMhfCreation !=
                        ECFM_MHF_CRITERIA_DEFER)
                    || (i4DefaultMdIdPermission != ECFM_SENDER_ID_DEFER))

                {
                    if (b1Entry == ECFM_FALSE)

                    {
                        CliPrintf (CliHandle, "\r\n");
                        for (u2Temp = 0; u2Temp < ECFM_CLI_MAX_LINE_LENGTH;
                             u2Temp++)

                        {
                            CliPrintf (CliHandle, "-");
                        }
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4DefaultMdPrimaryVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r\n%-5s%-5s%-6s%-26s%-13s%-14s",
                                       "Vsi", "Isid", "Level", "Status",
                                       "MIP-Creation criteria",
                                       "  SenderId Permission");
                        }
                        else
#endif
                        {
                        CliPrintf (CliHandle,
                                   "\r\n%-5s%-5s%-6s%-26s%-13s%-14s",
                                   "Vlan", "Isid", "Level", "Status",
                                   "MIP-Creation criteria",
                                   "  SenderId Permission");
                        }
                        CliPrintf (CliHandle, "\r\n");
                        for (u2Temp = 0; u2Temp < ECFM_CLI_MAX_LINE_LENGTH;
                             u2Temp++)

                        {
                            CliPrintf (CliHandle, "-");
                        }
                        CliPrintf (CliHandle, "\r\n");
                    }
                    b1Entry = ECFM_TRUE;
                    if (ECFM_IS_MEP_ISID_AWARE (i4DefaultMdPrimaryVid))
                    {
                        CliPrintf (CliHandle, "-    ");
                        CliPrintf (CliHandle, "%-5u",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4DefaultMdPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-5u", i4DefaultMdPrimaryVid);
                        CliPrintf (CliHandle, "-    ");
                    }
                    CliPrintf (CliHandle, "%-6d", i4DefaultMdLevel);

                    /* MD status */
                    if (i4DefaultMdStatus != ECFM_SNMP_TRUE)

                    {
                        CliPrintf (CliHandle, "%-26s", "MA with Up-MEP exists");
                    }

                    else

                    {
                        CliPrintf (CliHandle, "%-26s",
                                   "No MA with Up-MEP exists");
                    }

                    /*Default MdMhfCreation */
                    switch (i4DefaultMdMhfCreation)

                    {
                        case ECFM_MHF_CRITERIA_NONE:
                            CliPrintf (CliHandle, "%-23s", "none");
                            break;
                        case ECFM_MHF_CRITERIA_DEFAULT:
                            CliPrintf (CliHandle, "%-23s", "default");
                            break;
                        case ECFM_MHF_CRITERIA_EXPLICIT:
                            CliPrintf (CliHandle, "%-23s", "explicit");
                            break;
                        case ECFM_MHF_CRITERIA_DEFER:
                            CliPrintf (CliHandle, "%-23s", "defer");
                            break;
                        default:
                            break;
                    }

                    /*Default MdIdPermission */
                    switch (i4DefaultMdIdPermission)

                    {
                        case ECFM_SENDER_ID_NONE:
                            CliPrintf (CliHandle, "%-14s", "none");
                            break;
                        case ECFM_SENDER_ID_CHASSIS:
                            CliPrintf (CliHandle, "%-14s", "chassis");
                            break;
                        case ECFM_SENDER_ID_MANAGE:
                            CliPrintf (CliHandle, "%-14s", "manage");
                            break;
                        case ECFM_SENDER_ID_CHASSID_MANAGE:
                            CliPrintf (CliHandle, "%-14s", "chassis-mgt");
                            break;
                        case ECFM_SENDER_ID_DEFER:
                            CliPrintf (CliHandle, "%-14s", "defer");
                            break;
                        default:
                            break;
                    }
                    CliPrintf (CliHandle, "\r\n");
                }
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmDefaultMdTable
                (u4CurrContextId,
                 (UINT4 *) &u4NextContextId, i4DefaultMdPrimaryVid,
                 &i4NextDefaultMdPrimaryVid);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)

            {
                i4DefaultMdPrimaryVid = i4NextDefaultMdPrimaryVid;
                if (u4CurrContextId != u4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
            }
        }
        CliPrintf (CliHandle, "\r\n");
    }
    return CLI_SUCCESS;
}

/* Y.1731 : Commands Implementation
 * */
/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetY1731Status                               
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable Y.1731 globally on 
 *                        a device.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID
 *                        u4Command   - Command ID                    
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetY1731Status (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Command)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Status = ECFM_INIT_VAL;

    /* Setting the Y1731 operational status according to the input command */
    if (u4Command == CLI_ECFM_ENABLE_Y1731)

    {
        i4Status = ECFM_ENABLE;
    }

    else

    {
        i4Status = ECFM_DISABLE;
    }

    /* Test if status can be set or not */
    if (nmhTestv2FsMIY1731OperStatus
        (&u4ErrorCode, u4ContextId, i4Status) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then set the status */
    if (nmhSetFsMIY1731OperStatus (u4ContextId, i4Status) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetFDBufferSize                               
 *                                                                          
 *     DESCRIPTION      : This function will set/reset the size of the 
 *                        Frame Delay Buffer.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command ID 
 *                        pu1Arg1     - Value to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetFDBufferSize (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Size = ECFM_INIT_VAL;

    /* Setting the Frame Delay Buffer size according to the input command */
    if (u4Command == CLI_ECFM_SET_FD_BUFFER_SIZE)

    {
        i4Size = *(INT4 *) (VOID *) pu1Arg1;
    }

    else

    {
        i4Size = ECFM_FD_BUFFER_DEF_SIZE;
    }
    if (nmhTestv2FsMIY1731FrameDelayBufferSize
        (&u4ErrorCode, u4ContextId, i4Size) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the size */
    if (nmhSetFsMIY1731FrameDelayBufferSize (u4ContextId, i4Size) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetLbrCacheParams
 *                                                                          
 *     DESCRIPTION      : This function will set Loopback Cache Size and/or
 *                        Hold-Time parameters.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command ID
 *                        pu1Arg1     - Argument acc. to command type
 *                        pu1Arg2     - Argument acc. to command type
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetLbrCacheParams (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4Command, UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Size = ECFM_INIT_VAL;
    INT4                i4HoldTime = ECFM_INIT_VAL;

    /* Setting the LBR Cache size/hold-time according to the input command */
    switch (u4Command)

    {
        case CLI_ECFM_SET_LBRCACHE_SIZE_HOLDTIME:
            i4Size = *(INT4 *) (VOID *) pu1Arg1;
            i4HoldTime = *(INT4 *) (VOID *) pu1Arg2;
            break;
        case CLI_ECFM_SET_LBRCACHE_SIZE:
            i4Size = *(INT4 *) (VOID *) pu1Arg1;
            break;
        case CLI_ECFM_SET_LBRCACHE_HOLDTIME:
            i4HoldTime = *(INT4 *) (VOID *) pu1Arg1;
            break;
        case CLI_ECFM_RESET_LBRCACHE_SIZE_HOLDTIME:
            i4Size = ECFM_LBR_CACHE_DEF_SIZE;
            i4HoldTime = ECFM_LBR_CACHE_DEF_HOLD_TIME;
            break;
        case CLI_ECFM_RESET_LBRCACHE_SIZE:
            i4Size = ECFM_LBR_CACHE_DEF_SIZE;
            break;
        case CLI_ECFM_RESET_LBRCACHE_HOLDTIME:
            i4HoldTime = ECFM_LBR_CACHE_DEF_HOLD_TIME;
            break;
        default:
            break;
    }
    if (i4Size != 0)

    {

        /* Test if the size can be set or not */
        if (nmhTestv2FsMIY1731LbrCacheSize
            (&u4ErrorCode, u4ContextId, i4Size) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then set the size */
        if (nmhSetFsMIY1731LbrCacheSize (u4ContextId, i4Size) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    if (i4HoldTime != 0)

    {

        /* Test if the hold-time can be set or not */
        if (nmhTestv2FsMIY1731LbrCacheHoldTime
            (&u4ErrorCode, u4ContextId, i4HoldTime) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then set the hold-time */
        if (nmhSetFsMIY1731LbrCacheHoldTime (u4ContextId, i4HoldTime) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetErrLogParams
 *                                                                          
 *     DESCRIPTION      : This function will enable or disable the Error logging 
 *                        and also sets the size of the error log table.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command ID
 *                        pu1Arg1     - Size to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetErrLogParams (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Status = ECFM_INIT_VAL;
    INT4                i4Size = ECFM_INIT_VAL;

    /* Setting the Error Log status/size according to the input command */
    switch (u4Command)

    {
        case CLI_ECFM_SET_ERR_LOG_SIZE:
            i4Status = ECFM_ENABLE;
            i4Size = *(INT4 *) (VOID *) pu1Arg1;
            break;
        case CLI_ECFM_ENABLE_ERR_LOG:
            i4Status = ECFM_ENABLE;
            break;
        case CLI_ECFM_DISABLE_ERR_LOG:
            i4Status = ECFM_DISABLE;
            break;
        case CLI_ECFM_DISABLE_ERR_LOG_SET_SIZE:
            i4Status = ECFM_DISABLE;
            i4Size = *(INT4 *) (VOID *) pu1Arg1;
            break;
        default:
            break;
    }
    if (i4Status != 0)

    {

        /* Test if the status can be set or not */
        if (nmhTestv2FsMIY1731ErrorLogStatus
            (&u4ErrorCode, u4ContextId, i4Status) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then Set the status */
        if (nmhSetFsMIY1731ErrorLogStatus (u4ContextId, i4Status) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    if (i4Size != 0)

    {

        /* Test if the size can be set or not */
        if (nmhTestv2FsMIY1731ErrorLogSize
            (&u4ErrorCode, u4ContextId, i4Size) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then Set the size */
        if (nmhSetFsMIY1731ErrorLogSize (u4ContextId, i4Size) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetCcRole
 *                                                                          
 *     DESCRIPTION      : This function will set CC role for all MAs on a 
 *                        particular Mdlevel.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4CurrContextId - ContextId
 *                        u4Type        - Type of command  
 *                        au1MdLevel    - array of Levels  
 *                        u2NoOfMdLevels- No of levels in au1MdLevel         
 *                        au1VlanId     - array of VlanIds
 *                        i4CcRole      - CC Role
 *                        pu1MaName     - MA name
 *                        pu1MdName     - MD name
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetCcRole (tCliHandle CliHandle,
                  UINT4 u4CurrContextId, UINT4 u4Type,
                  UINT1 au1MdLevel[], UINT2 u2NoOfMdLevels,
                  UINT1 au1VlanId[], UINT1 *pu1ArgIsid, INT4 i4CcRole,
                  UINT1 *pu1MaName, UINT1 *pu1MdName)
{
    tVlanId             VlanId;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaFormat = SNMP_SUCCESS;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    BOOL1               ab1LevelSerEntry[ECFM_MD_LEVEL_MAX + 1] =
        { ECFM_FALSE };
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    u4ContextId = u4CurrContextId;

    /* Check the Y.1731 Status */
    if (ECFM_IS_Y1731_DISABLED (u4ContextId))
    {
        CLI_SET_ERR (CLI_ECFM_Y1731_DISABLED_ERR);
        ECFM_CC_TRC (ECFM_MGMT_TRC | ECFM_ALL_FAILURE_TRC,
                     "\tEcfmCliSetCcRole:Y1731 is disabled on port\n");
        return CLI_FAILURE;
    }

    i4RetVal =
        nmhGetNextIndexFsMIY1731MeTable (u4ContextId, &u4NextContextId,
                                         0, &u4MdIndex, 0, &u4MaIndex);
    if (i4RetVal == SNMP_SUCCESS)

    {
        if (u4ContextId != u4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    else

    {
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* The following block of code will be called in PBB Architecture */
    if (pu1ArgIsid != NULL)
    {
        /* Scan MA table for this MD level */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
        {
            /* Check if this entry is having this Md Level */
            nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);
            nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
            RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
            nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);

            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                    ((pu1MdName == NULL) ||
                     (STRCMP (au1StrMdName, pu1MdName) == 0)))
                {
                    if ((u4Type == CLI_ECFM_LEV_ISID_SET_CC_ROLE) ||
                        (u4Type == CLI_ECFM_LEV_ISID_SET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_LEV_ISID_RESET_CC_ROLE) ||
                        (u4Type == CLI_ECFM_LEV_ISID_RESET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_SET_CC_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_SET_CC_INT_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_RESET_CC_ROLE) ||
                        (u4Type == CLI_ECFM_DOM_ISID_RESET_CC_INT_ROLE))
                    {
                        u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
                        nmhGetFsMIEcfmMaPrimaryVlanId
                            (u4ContextId, u4MdIndex, u4MaIndex,
                             &i4RetPrimaryVid);
                        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex,
                                              u4MaIndex, &RetMaName);
                        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex,
                                                u4MaIndex, &i4RetMaFormat);

                        MEMSET (au1StrMaName, ECFM_INIT_VAL,
                                ECFM_MA_NAME_ARRAY_SIZE);
                        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                                     au1StrMaName);
                        if (((UINT4) i4RetPrimaryVid ==
                             ECFM_ISID_TO_ISID_INTERNAL (u4Isid)) &&
                            (pu1MaName == NULL ||
                             ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                        {
                            b1EntryFound = ECFM_TRUE;

                            /* Setting CC Role */
                            EcfmSetCcRole
                                (CliHandle,
                                 u4ContextId, u4MdIndex, u4MaIndex, i4CcRole);

                            if ((pu1MaName != NULL) &&
                                (u2NoOfMdLevels == ECFM_VAL_1))
                            {
                                return CLI_SUCCESS;
                            }
                        }
                    }
                    break;
                }
            }
            /* Move to next MA */
            i4RetVal =
                nmhGetNextIndexFsMIY1731MeTable (u4ContextId,
                                                 &u4NextContextId,
                                                 u4MdIndex, &u4NextMdIndex,
                                                 u4MaIndex, &u4NextMaIndex);
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (u4ContextId != u4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4ContextId = u4NextContextId;
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
            }
        }
        if (b1EntryFound != ECFM_TRUE)
        {
            u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
            for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
                 u1LevelCounter++)
            {
                CliPrintf (CliHandle,
                           "\r%% CC Role cannot be configured at level %d, isid %u\r\n",
                           au1MdLevel[u1LevelCounter], u4Isid);
            }
        }
        return CLI_SUCCESS;
    }
    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
        ab1LevelSerEntry[u1LevelCounter] = ECFM_FALSE;
    }
    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        /* Copying the vlan list into 2-D array at the specified index (i.e.
         * level), this will be further used to display the level and vlan 
         * for which cc status is not set */
        ECFM_MEMCPY (apu1LevelVlanList[au1MdLevel[u1LevelCounter]],
                     au1VlanId, sizeof (tVlanListExt));
        /* Copying the level list into a variable at the specified index (i.e.
         * level), this will be further used to display the level for unware
         * vlan entries */
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }

    /* Scan MA table for this MD level */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Check if this entry is having this Md Level */
        nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)

        {

            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                b1EntryFound = ECFM_FALSE;
                nmhGetFsMIEcfmMaPrimaryVlanId
                    (u4ContextId, u4MdIndex, u4MaIndex, &i4RetPrimaryVid);
                nmhGetFsMIEcfmMaName (u4ContextId,
                                      u4MdIndex, u4MaIndex, &RetMaName);
                nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex,
                                        u4MaIndex, &i4RetMaFormat);
                MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                EcfmUtilMaNameOctetStrToStr (&RetMaName,
                                             i4RetMaFormat, au1StrMaName);
                if (((u4Type == CLI_ECFM_LEV_SER_SET_CC_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_SET_CC_INT_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_RESET_CC_ROLE) ||
                     (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT_ROLE)) &&
                    ((pu1MaName != NULL) &&
                     (STRCMP (au1StrMaName, pu1MaName)) == 0))

                {
                    b1EntryFound = ECFM_TRUE;
                    ab1LevelSerEntry[u4RetMdLevel] = ECFM_TRUE;

                    /* Setting CC Role */
                    EcfmSetCcRole (CliHandle,
                                   u4ContextId, u4MdIndex, u4MaIndex, i4CcRole);
                }
                else if ((u4Type != CLI_ECFM_LEV_UNAWARE_SET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_RESET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_SET_CC_INT_ROLE) &&
                         (u4Type != CLI_ECFM_LEV_UNAWARE_RESET_CC_INT_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_RESET_CC_ROLE) &&
                         (u4Type != CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE)
                         && (u4Type != CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE))
                {

                    /* Entry found with this Mdlevel */
                    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                         u4ByteIndex++)

                    {
                        if (au1VlanId[u4ByteIndex] == 0)

                        {
                            continue;
                        }
                        u2VlanFlag = au1VlanId[u4ByteIndex];
                        for (u4BitIndex = 0;
                             ((u4BitIndex < BITS_PER_BYTE)
                              &&
                              (EcfmUtilQueryBitListTable
                               (u2VlanFlag, u4BitIndex) != 0)); u4BitIndex++)
                        {
                            VlanId =
                                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                         EcfmUtilQueryBitListTable (u2VlanFlag,
                                                                    u4BitIndex));

                            if (((UINT2) i4RetPrimaryVid == VlanId)
                                && (pu1MaName == NULL
                                    || ECFM_STRCMP (au1StrMaName, pu1MaName)
                                    == 0))

                            {
                                b1EntryFound = ECFM_TRUE;
                                ECFM_RESET_LIST_MEMBER
                                    (apu1LevelVlanList
                                     [au1MdLevel
                                      [u1LevelCounter]], i4RetPrimaryVid);

                                /* Setting CC Role */
                                EcfmSetCcRole (CliHandle,
                                               u4ContextId,
                                               u4MdIndex, u4MaIndex, i4CcRole);

                                if ((pu1MaName != NULL) &&
                                    (u2NoOfMdLevels == ECFM_VAL_1))
                                {
                                    /* Releasing memory for Vlan List Size */
                                    for (u1LevelCounter = 0; u1LevelCounter
                                         < ECFM_MD_LEVEL_MAX + 1;
                                         u1LevelCounter++)
                                    {
                                        UtilVlanReleaseVlanListSize
                                            (apu1LevelVlanList[u1LevelCounter]);
                                    }
                                    return CLI_SUCCESS;
                                }
                                break;
                            }
                        }
                        if (b1EntryFound)

                        {
                            break;
                        }
                    }
                    break;
                }
                else if (((UINT2) i4RetPrimaryVid == 0) &&
                         ((pu1MaName == NULL) ||
                          ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1EntryFound = ECFM_TRUE;
                    ECFM_CLEAR_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);

                    /* Setting CC Role */
                    EcfmSetCcRole (CliHandle, u4ContextId, u4MdIndex,
                                   u4MaIndex, i4CcRole);

                    if ((pu1MaName != NULL) && (u2NoOfMdLevels == ECFM_VAL_1))
                    {
                        /* Releasing memory for Vlan List Size */
                        for (u1LevelCounter = 0; u1LevelCounter
                             < ECFM_MD_LEVEL_MAX + 1; u1LevelCounter++)
                        {
                            UtilVlanReleaseVlanListSize
                                (apu1LevelVlanList[u1LevelCounter]);
                        }
                        return CLI_SUCCESS;
                    }
                    break;
                }
            }
        }

        /* Move to next MA */
        i4RetVal =
            nmhGetNextIndexFsMIY1731MeTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4ContextId = u4NextContextId;
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }

    /* Loop that will display the level and vlan for which cc role is not set */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)

    {
        if ((u4Type == CLI_ECFM_LEV_UNAWARE_SET_CC_ROLE) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_RESET_CC_ROLE) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_SET_CC_INT_ROLE) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_RESET_CC_INT_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_SET_CC_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_RESET_CC_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_SET_CC_INT_ROLE) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_RESET_CC_INT_ROLE))

        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% CC role - NO UNAWARE MEP found at level %d\r\n",
                           u1Level);
            }
            else
            {
                break;
            }
        }
        else if (((u4Type == CLI_ECFM_LEV_SER_SET_CC_ROLE) ||
                  (u4Type == CLI_ECFM_LEV_SER_SET_CC_INT_ROLE) ||
                  (u4Type == CLI_ECFM_LEV_SER_RESET_CC_ROLE) ||
                  (u4Type == CLI_ECFM_LEV_SER_RESET_CC_INT_ROLE)) &&
                 (b1EntryFound == ECFM_FALSE))
        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                if (ab1LevelSerEntry[u1Level] == ECFM_FALSE)
                {
                    CliPrintf (CliHandle,
                               "\r%% No MEP found with service name %s at level %d\r\n",
                               pu1MaName, u1Level);
                }
            }
            else
            {
                break;
            }
        }
        else

        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)

            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] == 0)

                {
                    continue;
                }
                u2VlanFlag = apu1LevelVlanList[u1LevelCounter][u4ByteIndex];
                if ((u4BitIndex < BITS_PER_BYTE) &&
                    (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) != 0))
                {
                    VlanId =
                        (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                 EcfmUtilQueryBitListTable (u2VlanFlag,
                                                            u4BitIndex));

                    CliPrintf (CliHandle,
                               "\r%% CC role - No Mep found at level %d, vlan %d\r\n",
                               u1LevelCounter, VlanId);
                }
            }
        }
    }
    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmSetCcRole                               
 *                                                                          
 *     DESCRIPTION      : This function will set CC Role value for a 
 *                        particular Ma
 *                                                                          
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4ContextId  - Context ID
 *                        u4MdIndex    - mdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        i4CcRole     - Cc Role
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
PRIVATE INT4
EcfmSetCcRole (tCliHandle CliHandle, UINT4 u4ContextId,
               UINT4 u4MdIndex, UINT4 u4MaIndex, INT4 i4CcRole)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* First change RowStatus to NOT_IN_SERVICE  */
    if (nmhTestv2FsMIY1731MeRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    /* Set the CC Role */
    do

    {
        if (nmhTestv2FsMIY1731MeCcmApplication
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             i4CcRole) == SNMP_FAILURE)

        {
            break;
        }
        if (nmhSetFsMIY1731MeCcmApplication
            (u4ContextId, u4MdIndex, u4MaIndex, i4CcRole) == SNMP_FAILURE)

        {
            break;
        }
    }
    while (0);

    /* After setting CC Role, change RowStatus to Active */
    if (nmhTestv2FsMIY1731MeRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MeRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetFDThreshold
 *                                                                          
 *     DESCRIPTION      : This function will set Frame Delay threshold value.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Value - Threshold value to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetFDThreshold (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Value)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Getting MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    do

    {

        /* Test if Threshold can be set or not */
        if (nmhTestv2FsMIY1731MepFrameDelayThreshold
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, u4Value) == SNMP_FAILURE)

        {
            break;
        }

        /* Then Set the Threshold value */
        if (nmhSetFsMIY1731MepFrameDelayThreshold
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
             u4Value) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            break;
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearStatistics                                       
 *                                                                          
 *     DESCRIPTION      : This function will clear all ECFM and Y.1731 
 *                        global, interface and MEP statistics.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId   - Context Identifier
 *                        u4Type        - Type of command
 *                        u4Level       - Level of MEP
 *                        pu1Arg1       - 
 *                        pu1Arg2       - Argument acc. to the command 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliClearStatistics (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4Command, UINT4 u4IfIndex,
                        UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    INT4                i4ReturnStatus = CLI_FAILURE;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4NextIfIndex = ECFM_INIT_VAL;
    INT4                i4PreIfIndex = ECFM_INIT_VAL;
    UINT2               u2LocalPort = ECFM_INIT_VAL;
    UINT4               u4NextIfIndex = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;

    /* Validate context */
    if (nmhValidateIndexInstanceFsMIEcfmContextTable
        (u4ContextId) != SNMP_SUCCESS)

    {
        CliPrintf (CliHandle, "\r\n Context %d not validated", u4ContextId);
        return CLI_FAILURE;
    }

    /* Clearing statistics depending on the input */
    switch (u4Command)

    {
        case CLI_ECFM_CLR_ALL_STATS:
            i4ReturnStatus =
                EcfmClearMepStats (CliHandle, u4ContextId, u4Command,
                                   ECFM_INIT_VAL, NULL, NULL,
                                   ECFM_SERVICE_SELECTION_VLAN);
            i4ReturnStatus =
                EcfmClearCtxorPortStats (CliHandle, u4ContextId, u4NextIfIndex);

            i4CurrContextId = (INT4) (u4ContextId);
            i4NextIfIndex = (INT4) u4NextIfIndex;
            i4RetVal = nmhGetNextIndexFsMIEcfmPortTable (0, &i4NextIfIndex);
            while (i4RetVal == SNMP_SUCCESS)

            {
                u4NextIfIndex = (UINT4) i4NextIfIndex;
                i4RetVal = ECFM_GET_CONTEXT_INFO_FROM_IFINDEX (u4NextIfIndex,
                                                               (UINT4 *)
                                                               &i4NextContextId,
                                                               &u2LocalPort);
                if (i4NextContextId != i4CurrContextId)
                {
                    i4PreIfIndex = i4NextIfIndex;
                    i4RetVal = nmhGetNextIndexFsMIEcfmPortTable (i4PreIfIndex,
                                                                 &i4NextIfIndex);

                    continue;
                }

                /* Display a port specifice MEP parameters (statistics) */
                u4NextIfIndex = (UINT4) i4NextIfIndex;
                EcfmClearCtxorPortStats (CliHandle, u4ContextId, u4NextIfIndex);
                if (ECFM_MAX_CONTEXTS > 1)
                {
                    u4PagingStatus = (UINT4) CliPrintf (CliHandle, "\r\n");
                }
                if (u4PagingStatus == CLI_FAILURE)
                {
                    return CLI_SUCCESS;
                }
                /* Get the next index */
                i4PreIfIndex = i4NextIfIndex;
                i4RetVal = nmhGetNextIndexFsMIEcfmPortTable (i4PreIfIndex,
                                                             &i4NextIfIndex);
            }

            break;

        case CLI_ECFM_CLR_GLOBAL_STATS:
            i4ReturnStatus = EcfmClearGlobalStats (CliHandle, u4ContextId);
            /* Clear Context Stats by calling EcfmClearCtxorPortStats with
             * IfIndex as ZERO.
             */
            i4ReturnStatus =
                EcfmClearCtxorPortStats (CliHandle, u4ContextId, ECFM_INIT_VAL);
            break;
        case CLI_ECFM_CLR_INTF_STATS:
            i4ReturnStatus =
                EcfmClearCtxorPortStats (CliHandle, u4ContextId, u4IfIndex);
            break;
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_SER:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VLAN:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VSI:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_SER:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VLAN:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VSI:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_SER:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VLAN:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VSI:
        case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV:
        case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_DOM_SER:
            i4ReturnStatus =
                EcfmClearMepStats (CliHandle, u4ContextId, u4Command,
                                   u4IfIndex, pu1Arg1, pu1Arg2,
                                   ECFM_SERVICE_SELECTION_VLAN);
            break;
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_ISID:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_ISID:
        case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_ISID:
            i4ReturnStatus =
                EcfmClearMepStats (CliHandle, u4ContextId, u4Command,
                                   u4IfIndex, pu1Arg1, pu1Arg2,
                                   ECFM_SERVICE_SELECTION_ISID);
            break;
        case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV_SER:
            i4ReturnStatus =
                EcfmClearMepStats (CliHandle, u4ContextId, u4Command,
                                   u4IfIndex, pu1Arg1, pu1Arg2,
                                   ECFM_SERVICE_SELECTION_LSP);
            break;
        default:
            break;
    }
    return i4ReturnStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmClearGlobalStats                                       
 *                                                                          
 *     DESCRIPTION      : This function will clear all ECFM and Y.1731 
 *                        global statistics.
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId   - Context Identifier
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
PRIVATE INT4
EcfmClearGlobalStats (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Clear all the counters at this context */
    if (nmhTestv2FsMIEcfmMemoryFailureCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmBufferFailureCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmUpCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmDownCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmNoDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmRdiDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmMacStatusDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmRemoteCcmDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmErrorCcmDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhTestv2FsMIEcfmXconDftCount
        (&u4ErrorCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

/* Then clear the counters */
    if (nmhSetFsMIEcfmMemoryFailureCount (u4ContextId, ECFM_INIT_VAL) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmBufferFailureCount (u4ContextId, ECFM_INIT_VAL) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmUpCount (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmDownCount (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmNoDftCount (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmRdiDftCount (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmMacStatusDftCount (u4ContextId, ECFM_INIT_VAL) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmRemoteCcmDftCount (u4ContextId, ECFM_INIT_VAL) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmErrorCcmDftCount (u4ContextId, ECFM_INIT_VAL) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmXconDftCount (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmClearCtxorPortStats                                       
 *                                                                          
 *     DESCRIPTION      : This function will clear all ECFM and Y.1731 
 *                        port statistics as well as the statistics on the
 *                        context (if the u4IfIndex is equal to zero).
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId   - Context Identifier
 *                        u4IfIndex     - Interface Index
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
PRIVATE INT4
EcfmClearCtxorPortStats (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4IfIndex)
{
    INT4                i4RetVal = CLI_SUCCESS;
    UINT4               u4ErrCode = ECFM_INIT_VAL;

    if (u4IfIndex != ECFM_INIT_VAL)
    {
        /* Clear all the counters at this interface */
        /* First Test if the counters can be cleared or not */
        if (nmhTestv2FsMIY1731PortLmmOut
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortLmrOut
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortLmmIn
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortLmrIn
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortAisOut
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortAisIn
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortLckOut
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731PortLckIn
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortTxCfmPduCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortTxCcmCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortTxFailedCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortRxCfmPduCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortRxCcmCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortRxBadCfmPduCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortFrwdCfmPduCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmPortDsrdCfmPduCount
            (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLmmOut (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLmrOut (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLmmIn (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLmrIn (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortAisOut (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortAisIn (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLckOut (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731PortLckIn (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortTxCfmPduCount (u4IfIndex, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortTxCcmCount (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortTxFailedCount (u4IfIndex, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortRxCfmPduCount (u4IfIndex, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortRxCcmCount (u4IfIndex, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortRxBadCfmPduCount
            (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortFrwdCfmPduCount
            (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmPortDsrdCfmPduCount
            (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then clear the counters */
        /* LBLT task specific port stats */
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();

        do

        {
            if (nmhTestv2FsMIEcfmPortTxLbmCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortTxLbrCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortTxLtmCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortTxLtrCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortRxLbmCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortRxLbrCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortRxLtmCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIEcfmPortRxLtrCount
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortTstOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortTstIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortDmmOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortDmmIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortDmrOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortDmrIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731Port1DmOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731Port1DmIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortApsOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortApsIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortMccOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortMccIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortVsmOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortVsmIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortVsrOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortVsrIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortCsfIn (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)
            {
                i4RetVal= CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortExmOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortExmIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortExrOut
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhTestv2FsMIY1731PortExrIn
                (&u4ErrCode, u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }

            /* Then clear the counters */
            if (nmhSetFsMIEcfmPortTxLbmCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmPortTxLbrCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmPortTxLtmCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmPortTxLtrCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIY1731PortTstOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortTstIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortDmmOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortDmmIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortDmrOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortDmrIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731Port1DmOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731Port1DmIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortApsOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortApsIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortMccOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortMccIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortVsmOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortVsmIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortVsrOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortVsrIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortCsfIn (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;

            }
            if (nmhSetFsMIY1731PortExmOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortExmIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortExrOut (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731PortExrIn (u4IfIndex, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmPortRxLbmCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmPortRxLbrCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmPortRxLtmCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmPortRxLtrCount
                (u4IfIndex, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
        }
        while (0);
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    else
    {
        /* Clear all the counters in the specified context context */
        /* First Test if the counters can be cleared or not */
        if (nmhTestv2FsMIY1731LmmOut
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731LmrOut
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731LmmIn
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731LmrIn
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731AisOut
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731AisIn
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731LckOut
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIY1731LckIn
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmTxCfmPduCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmTxCcmCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmTxFailedCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmRxCfmPduCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmRxCcmCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmRxBadCfmPduCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmFrwdCfmPduCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhTestv2FsMIEcfmDsrdCfmPduCount
            (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LmmOut (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LmrOut (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LmmIn (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LmrIn (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731AisOut (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731AisIn (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LckOut (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731LckIn (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmTxCfmPduCount (u4ContextId, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmTxCcmCount (u4ContextId, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmTxFailedCount (u4ContextId, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmRxCfmPduCount (u4ContextId, ECFM_INIT_VAL)
            == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmRxCcmCount (u4ContextId, ECFM_INIT_VAL) ==
            SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmRxBadCfmPduCount
            (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmFrwdCfmPduCount
            (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmDsrdCfmPduCount
            (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Then clear the counters, LBLT task specific LBLT stats */
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();

        do

        {
            if (nmhTestv2FsMIEcfmTxLbmCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmTxLbrCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmTxLtmCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmTxLtrCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmRxLbmCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmRxLbrCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmRxLtmCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIEcfmRxLtrCount
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731TstOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731TstIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731DmmOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731DmmIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731DmrOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731DmrIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY17311DmOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY17311DmIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ApsOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ApsIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731MccOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731MccIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731VsmOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731VsmIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731VsrOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731VsrIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731CsfIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ExmOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ExmIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ExrOut
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhTestv2FsMIY1731ExrIn
                (&u4ErrCode, u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }

            /* Then clear the counters */
            if (nmhSetFsMIEcfmTxLbmCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmTxLbrCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmTxLtmCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIEcfmTxLtrCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIY1731TstOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIY1731TstIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
            if (nmhSetFsMIY1731DmmOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731DmmIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731DmrOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731DmrIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY17311DmOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY17311DmIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ApsOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ApsIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731MccOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731MccIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731VsmOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731VsmIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731VsrOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731VsrIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731CsfIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ExmOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ExmIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ExrOut (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIY1731ExrIn (u4ContextId, ECFM_INIT_VAL) ==
                SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmRxLbmCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmRxLbrCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmRxLtmCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
            if (nmhSetFsMIEcfmRxLtrCount
                (u4ContextId, ECFM_INIT_VAL) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetVal = CLI_FAILURE;
                break;
            }
        }
        while (0);
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    return i4RetVal;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmClearMepStats                           
 *                                                                          
 *     DESCRIPTION      : This function will clear MEP related statistics. 
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context  Identifier 
 *                        u4Command   - Type of the command
 *                        u4IfIndex   - Interface Index
 *                        pu1Arg1     - Argument depending upon 
 *                                      type of the command
 *                        pu1Arg2     - Argument depending upon 
 *                                      type of the command
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
PRIVATE INT4
EcfmClearMepStats (tCliHandle CliHandle, UINT4 u4ContextId,
                   UINT4 u4Command, UINT4 u4IfIndex,
                   UINT1 *pu1Arg1, UINT1 *pu1Arg2, INT4 i4SelectorType)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE MdName;
    tEcfmCcMepInfo     *pMepNode = NULL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMepVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaVlanId = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4ReturnStatus = CLI_FAILURE;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1MdTempName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsidEntry = ECFM_FALSE;
    BOOL1               b1FindSelectorType = ECFM_TRUE;
    BOOL1               b1MplstpMep = ECFM_FALSE;

    u4CurrContextId = u4ContextId;

    i4RetVal =
        nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                         &u4NextContextId, 0,
                                         &u4MdIndex, 0, &u4MaIndex, 0,
                                         &u4MepIdentifier);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Entry is for this particular context */
        if (u4CurrContextId != u4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        if (u4NextContextId != u4ContextId)

        {
            return CLI_SUCCESS;
        }
    }

    /* MEP related statistics */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        i4MepIfIndex = ECFM_INIT_VAL;
        i4RetMepVlanId = ECFM_INIT_VAL;
        i4RetMaVlanId = ECFM_INIT_VAL;
        u4RetMdLevel = ECFM_INIT_VAL;
        u4MdLevel = ECFM_INIT_VAL;
        i4VlanId = ECFM_INIT_VAL;

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&MdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1MdTempName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;
        MdName.pu1_OctetList = au1MdTempName;
        MdName.i4_Length = ECFM_INIT_VAL;

        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4MepIfIndex);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetMepVlanId);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaVlanId);
        nmhGetFsMIEcfmMaName (u4CurrContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4CurrContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMdName (u4CurrContextId, u4MdIndex, &MdName);
        nmhGetFsMIEcfmMdFormat (u4CurrContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&MdName, i4RetMdFormat, au1StrMdName);

        if (b1FindSelectorType)
        {
            nmhGetNextIndexFsMIEcfmExtMaTable (u4CurrContextId,
                                               &u4NextContextId,
                                               u4MdIndex,
                                               &u4NextMdIndex,
                                               u4MaIndex,
                                               &u4NextMdIndex,
                                               0,
                                               &i4NextSelectorType,
                                               0, &u4NextSelectorOrNone);

            if ((i4NextSelectorType == ECFM_SERVICE_SELECTION_LSP) ||
                (i4NextSelectorType == ECFM_SERVICE_SELECTION_PW))
            {
                b1MplstpMep = ECFM_TRUE;
            }
            else
            {
                b1MplstpMep = ECFM_FALSE;
            }
        }
        if (ECFM_IS_MEP_ISID_AWARE (i4RetMaVlanId))
        {
            i4SelectorType = (INT4) ECFM_SERVICE_SELECTION_ISID;
        }
        /* Valid entry depending upon command */
        switch (u4Command)

        {
            case CLI_ECFM_CLR_ALL_STATS:

                if ((u4IfIndex == ECFM_INIT_VAL) && (pu1Arg1 == NULL)
                    && (pu1Arg2 == NULL))
                {
                    /* To clear the global statistics using context id */
                    i4ReturnStatus =
                        EcfmClearGlobalStats (CliHandle, u4CurrContextId);
                    if (i4ReturnStatus == CLI_FAILURE)
                    {
                        printf ("Error in clearing the counters");
                    }
                    /* To clear the port specific counters in particular context */
                    i4ReturnStatus =
                        EcfmClearCtxorPortStats (CliHandle, u4CurrContextId,
                                                 ECFM_INIT_VAL);
                    if (i4ReturnStatus == CLI_FAILURE)
                    {
                        printf ("Error in clearing the counters");
                    }
                    /* To clear the port specific counters in the parituclar port
                     * To do this port number is needed. so port number is get from
                     * pMepNode (which getting from global structure using u4MdIndex,
                     * u4MaIndex, u4MepIdentifier). */

                    ECFM_MEMSET (gpEcfmCcMepNode, ECFM_INIT_VAL,
                                 ECFM_CC_MEP_INFO_SIZE);
                    gpEcfmCcMepNode->u4ContextId = u4CurrContextId;
                    gpEcfmCcMepNode->u4MdIndex = u4MdIndex;
                    gpEcfmCcMepNode->u4MaIndex = u4MaIndex;
                    gpEcfmCcMepNode->u2MepId = (UINT2) u4MepIdentifier;

                    /* Get Mep Entry */
                    pMepNode =
                        (tEcfmCcMepInfo *) RBTreeGet (ECFM_CC_MEP_TABLE,
                                                      gpEcfmCcMepNode);

                    if (pMepNode != NULL)
                    {
                        i4ReturnStatus =
                            EcfmClearCtxorPortStats (CliHandle, u4CurrContextId,
                                                     pMepNode->u4PortNum);
                        if (i4ReturnStatus == CLI_FAILURE)
                        {
                            printf ("Error in clearing the counters");
                        }
                    }

                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM:
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV:
                MEMCPY (&u4MdLevel, pu1Arg1, sizeof (UINT4));
                if (((UINT4) (u4RetMdLevel) == u4MdLevel) &&
                    (ECFM_STRLEN (au1StrMdName) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_SER:
                if (b1MplstpMep == ECFM_FALSE)
                {
                    if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                        (ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                else
                {
                    if (ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL)
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_ISID:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VLAN:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_VSI:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                if (b1MplstpMep == ECFM_FALSE)
                {
                    if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                        ((i4VlanId == i4RetMepVlanId) ||
                         (i4VlanId == i4RetMaVlanId)))

                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                else
                {
                    if (i4VlanId == i4RetMaVlanId)
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_ISID:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VLAN:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_VSI:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_ISID:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VLAN:
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_VSI:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel) &&
                    ((i4VlanId == i4RetMepVlanId) ||
                     (i4VlanId == i4RetMaVlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_DOM_SER:
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_CLR_MEP_STATS_ON_INTF_LEV_SER:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4IfIndex == (UINT4) i4MepIfIndex) &&
                    (u4MdLevel == u4RetMdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_DOM_SER:
                if ((ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0) &&
                    (ECFM_STRLEN (au1StrMdName) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_MPLS_CLR_MEP_STATS_ON_LEV_SER:
                MEMCPY (&u4MdLevel, pu1Arg1, sizeof (UINT4));
                if (((UINT4) (u4RetMdLevel) == u4MdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0) &&
                    (ECFM_STRLEN (au1StrMdName) == ECFM_INIT_VAL))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Required MEP is found */
        if (b1Entry == ECFM_TRUE)

        {
            if (i4SelectorType == ECFM_SERVICE_SELECTION_ISID)
            {
                b1IsidEntry = ECFM_TRUE;
            }
            /* For clearing MEP statitics, there is no need to
             * make MEP inactive(Triggering state Machine).
             * So MEP Table is accessed without making ROWSTATUS:Not in service.
             * This has been treated as special case for handling clear statistics.*/
            do

            {
                if (b1IsidEntry == ECFM_TRUE)
                {
                    if (nmhTestv2FsMIEcfmExtMepCcmSequenceErrors
                        (&u4ErrCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhTestv2FsMIEcfmExtMepCciSentCcms
                        (&u4ErrCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIEcfmExtMepCcmSequenceErrors
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIEcfmExtMepCciSentCcms
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }

                }
                else
                {
                    if (nmhTestv2FsMIEcfmMepCcmSequenceErrors
                        (&u4ErrCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhTestv2FsMIEcfmMepCciSentCcms
                        (&u4ErrCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIEcfmMepCcmSequenceErrors
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIEcfmMepCciSentCcms
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                }
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();

                do

                {
                    if (b1IsidEntry == ECFM_TRUE)
                    {
                        if (nmhTestv2FsMIEcfmExtMepLbrIn
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmExtMepLbrInOutOfOrder
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmExtMepLbrBadMsdu
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmExtMepUnexpLtrIn
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmExtMepLbrOut
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }

                    }
                    else
                    {
                        if (nmhTestv2FsMIEcfmMepLbrIn
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmMepLbrInOutOfOrder
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmMepLbrBadMsdu
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmMepUnexpLtrIn
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhTestv2FsMIEcfmMepLbrOut
                            (&u4ErrCode, u4CurrContextId, u4MdIndex,
                             u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                    }
                    if (nmhTestv2FsMIY1731MepBitErroredLbrIn
                        (&u4ErrCode, u4CurrContextId, u4MdIndex,
                         u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhTestv2FsMIY1731MepBitErroredTstIn
                        (&u4ErrCode, u4CurrContextId, u4MdIndex,
                         u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhTestv2FsMIY1731MepValidTstIn
                        (&u4ErrCode, u4CurrContextId, u4MdIndex,
                         u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhTestv2FsMIY1731MepTstOut
                        (&u4ErrCode, u4CurrContextId, u4MdIndex,
                         u4MaIndex, u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }

                    /* Then clear the counters */

                    if (b1IsidEntry == ECFM_TRUE)
                    {
                        if (nmhSetFsMIEcfmExtMepLbrIn
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmExtMepLbrInOutOfOrder
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmExtMepLbrBadMsdu
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmExtMepUnexpLtrIn
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmExtMepLbrOut
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                    }
                    else
                    {
                        if (nmhSetFsMIEcfmMepLbrIn
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmMepLbrInOutOfOrder
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmMepLbrBadMsdu
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmMepUnexpLtrIn
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                        if (nmhSetFsMIEcfmMepLbrOut
                            (u4CurrContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, 0) == SNMP_FAILURE)

                        {
                            break;
                        }
                    }
                    if (nmhSetFsMIY1731MepBitErroredLbrIn
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIY1731MepBitErroredTstIn
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIY1731MepValidTstIn
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                    if (nmhSetFsMIY1731MepTstOut
                        (u4CurrContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, 0) == SNMP_FAILURE)

                    {
                        break;
                    }
                }
                while (0);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
            }
            while (0);
        }

        /* Move to next MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if ((u4NextMaIndex != u4MaIndex) || (u4NextMdIndex != u4MdIndex))
        {
            b1FindSelectorType = ECFM_TRUE;
        }
        if (u4NextMdIndex != u4MdIndex)
        {
            b1FindSelectorType = ECFM_TRUE;
        }

        b1Entry = ECFM_FALSE;

        /* MEP entry is for the required context */
        if (u4CurrContextId != u4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    return CLI_FAILURE;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearFDBuffer
 *                                                                          
 *     DESCRIPTION      : This function will clear the contents of 
 *                        Frame delay buffer.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context ID 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliClearFDBuffer (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrCode = ECFM_INIT_VAL;

    /* Test if Frame delay buffer can be cleared or not */
    if (nmhTestv2FsMIY1731FrameDelayBufferClear
        (&u4ErrCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then clear it */
    if (nmhSetFsMIY1731FrameDelayBufferClear
        (u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}
/****************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliClearProFDBuffer
 *
 *     DESCRIPTION      : This function will clear the contents of
 *                        Proactive Frame delay buffer.
 *
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context ID
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *****************************************************************************/
INT4
EcfmCliClearProFDBuffer (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrCode = ECFM_INIT_VAL;

    /* Test if Frame delay buffer can be cleared or not */
    if (nmhTestv2FsMIY1731FrameDelayBufferClear
        (&u4ErrCode, u4ContextId, ECFM_PROACTIVE_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then clear it */
    if (nmhSetFsMIY1731FrameDelayBufferClear
        (u4ContextId, ECFM_PROACTIVE_TRUE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}
/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearLbrCache
 *                                                                          
 *     DESCRIPTION      : This function will clear the contents of LBR cache.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context ID 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliClearLbrCache (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrCode = ECFM_INIT_VAL;

    /* Test if Lbr cache can be cleared or not */
    if (nmhTestv2FsMIY1731LbrCacheClear
        (&u4ErrCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then clear it */
    if (nmhSetFsMIY1731LbrCacheClear (u4ContextId, ECFM_SNMP_TRUE) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowLocalMepInfo
 *                                                                          
 *     DESCRIPTION      : This function will display the informations regarding
 *                        the MEPs.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id
 *                        u4Type - Type of command
 *                        pu1Arg1 -  
 *                        pu1Arg2 - 
 *                        pu1Arg3 - 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowLocalMepInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT4 u4Type, UINT1 *pu1Arg1,
                         UINT1 *pu1Arg2, UINT1 *pu1Arg3)
{
    tEcfmMacAddr        MacAddr;
    tEcfmMacAddr        RetMacAddr;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT1              *pu1MdName = NULL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4Isid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4MepDirection = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Flag = ECFM_FALSE;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1              *pu1MaName = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
#ifdef DISS_WANTED
    tEcfmCcMepInfo     *pMepInfo = NULL;
#endif

    u4CurrentContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        b1ShowAll = ECFM_FALSE;
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    ECFM_MEMSET (MacAddr, ECFM_DEF_MAC_ADDR, ECFM_MAC_ADDR_LENGTH);

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll == ECFM_TRUE))

    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;

        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepMacAddress (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier, &RetMacAddr);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4MepDirection);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Type)
        {
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_SER:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MaName = (UINT1 *) pu1Arg3;
                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_SER:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_SER:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_SER:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                pu1MaName = (UINT1 *) pu1Arg3;

                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0) &&
                    (u4MdLevel == (UINT4) (i4RetMdLevel)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;

                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_VSI:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_ISID:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                i4Isid = *(INT4 *) (VOID *) pu1Arg3;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);
                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {
                    if ((u4MepIdentifier == u4MepId) &&
                        (STRCMP (au1StrMdName, pu1MdName)
                         == 0) && ((i4RetPrimaryVid == i4VlanId)
                                   || (i4RetMaPrimaryVid == i4VlanId)))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_DOM_UNAWARE:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((u4MepIdentifier == u4MepId) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_UNAWARE:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                if ((u4MepIdentifier == u4MepId) && (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_VLAN:
            case CLI_ECFM_SHOW_MEP_MPID_ON_VSI:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((u4MepIdentifier == u4MepId) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_ISID:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                i4Isid = *(INT4 *) (VOID *) pu1Arg2;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);
                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {
                    if ((u4MepIdentifier == u4MepId) &&
                        ((i4RetPrimaryVid == i4VlanId) ||
                         (i4RetMaPrimaryVid == i4VlanId)))

                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_VSI:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((u4MepIdentifier == u4MepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_ISID:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4Isid = *(INT4 *) (VOID *) pu1Arg3;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);
                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {
                    if ((u4MepIdentifier == u4MepId) &&
                        ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                        ((i4RetPrimaryVid == i4VlanId) ||
                         (i4RetMaPrimaryVid == i4VlanId)))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV_UNAWARE:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4MepIdentifier == u4MepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID_ON_LEV:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((u4MepIdentifier == u4MepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MPID:
                /* Get Input parameters according to type of the command */
                u4MepId = *(UINT4 *) (VOID *) pu1Arg1;
                if (u4MepIdentifier == u4MepId)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    &&
                    (ECFM_MEMCMP
                     (RetMdName.pu1_OctetList, pu1MdName,
                      RetMdName.i4_Length) == 0))

                    if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) ==
                         0) && (STRCMP (au1StrMdName, pu1MdName) == 0))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;

                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_ISID:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                i4Isid = *(INT4 *) (VOID *) pu1Arg3;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);

                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {

                    if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) ==
                         0) && (STRCMP (au1StrMdName, pu1MdName) == 0)
                        && ((i4RetPrimaryVid == i4VlanId)
                            || (i4RetMaPrimaryVid == i4VlanId)))

                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_DOM_UNAWARE:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                pu1MdName = (UINT1 *) pu1Arg2;
                if ((MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_UNAWARE:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_VSI:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg3;
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && ((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && ((i4RetPrimaryVid == i4VlanId)
                        || (i4RetMaPrimaryVid == i4VlanId)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_ISID:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                i4Isid = *(INT4 *) (VOID *) pu1Arg2;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);
                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {
                    if ((ECFM_MEMCMP
                         (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                        && ((i4RetPrimaryVid == i4VlanId)
                            || (i4RetMaPrimaryVid == i4VlanId)))

                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_ISID:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                i4Isid = *(INT4 *) (VOID *) pu1Arg2;
                i4VlanId = ECFM_ISID_TO_ISID_INTERNAL (i4Isid);
                if (ECFM_IS_MEP_ISID_AWARE (i4VlanId))
                {
                    if ((ECFM_MEMCMP
                         (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                        && ((UINT4) (i4RetMdLevel) == u4MdLevel)
                        && ((i4RetPrimaryVid == i4VlanId)
                            || (i4RetMaPrimaryVid == i4VlanId)))
                    {
                        b1Entry = ECFM_TRUE;
                    }
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV_UNAWARE:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && ((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && (i4RetMaPrimaryVid == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC_ON_LEV:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg2;
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)
                    && ((UINT4) (i4RetMdLevel) == u4MdLevel))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_SHOW_MEP_MAC:
                /* Get Input parameters according to type of the command */
                StrToMac ((UINT1 *) pu1Arg1, MacAddr);
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            default:
                break;
        }
        if (b1Entry == ECFM_TRUE)

        {
            b1Flag = ECFM_TRUE;
            CliPrintf (CliHandle,
                       "\r\n-----------------------------------------------------------");
            if (i4RetPrimaryVid == 0)

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetMaPrimaryVid))
                {
                    i4Isid = ECFM_ISID_INTERNAL_TO_ISID (i4RetMaPrimaryVid);
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {

                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-4d Dir: Up", u4MepIdentifier,
                                   i4RetMdLevel, i4Isid);
                    }

                    else

                    {

                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID: "
                                   "%-4d Dir: Down", u4MepIdentifier,
                                   i4RetMdLevel, i4Isid);

                    }
                }
                else
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {
#ifdef VSI_WANTED                        
                        if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                       "%-4d Dir: Up", u4MepIdentifier,
                                       i4RetMdLevel, i4RetMaPrimaryVid);
                        }
                        else
#endif
                        {
                            CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                   "%-4d Dir: Up", u4MepIdentifier,
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    }
                    else

                    {
                        if (i4RetMaPrimaryVid != 0)

                        {
#ifdef VSI_WANTED                        
                            if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                            {
                                CliPrintf (CliHandle,
                                           "\r\nMPID: %-4d MdLevel: %-4d VSI: "
                                           "%-4d Dir: Down", u4MepIdentifier,
                                           i4RetMdLevel, i4RetMaPrimaryVid);
                            }
                            else
#endif
                            {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VLAN: "
                                       "%-4d Dir: Down", u4MepIdentifier,
                                       i4RetMdLevel, i4RetMaPrimaryVid);
                        }
                        }
                        else

                        {
                            CliPrintf (CliHandle,
                                       "\r\nMPID: %-4d MdLevel: %-4d VLAN:: "
                                       "%-4s Dir: Down", u4MepIdentifier,
                                       i4RetMdLevel, "-");
                        }
                    }

                }

            }

            else

            {
                if (ECFM_IS_MEP_ISID_AWARE (i4RetPrimaryVid))
                {
                    i4Isid = ECFM_ISID_INTERNAL_TO_ISID (i4RetPrimaryVid);
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID:: "
                                   "%-4d", u4MepIdentifier, i4RetMdLevel,
                                   i4Isid);
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d ISID:: "
                                   "%-4d Dir: Down", u4MepIdentifier,
                                   i4RetMdLevel, i4Isid);
                    }
                }
                else
                {
                    if (i4MepDirection == ECFM_MP_DIR_UP)

                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN:: "
                                   "%-4d", u4MepIdentifier, i4RetMdLevel,
                                   i4RetPrimaryVid);
                    }

                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r\nMPID: %-4d MdLevel: %-4d VLAN:: "
                                   "%-4d Dir: Down", u4MepIdentifier,
                                   i4RetMdLevel, i4RetPrimaryVid);
                    }

                }
            }
            CliPrintf (CliHandle,
                       "\r\n-----------------------------------------------------------\n");

#ifdef DISS_WANTED
        /* Get MEP from Global RBTree with received MdIndex, MaIndex, u2MepId */
        pMepInfo = EcfmCcUtilGetMepEntryFrmGlob(u4MdIndex, u4MaIndex,
                                                          u4MepIdentifier);
        if (pMepInfo != NULL)
        {
            /* HW MEP-ID of the configured Local mep */
            CliPrintf (CliHandle, "\r\n%-37s", "HW MEP-ID");
            CliPrintf (CliHandle, "%-3s", ":");
            CliPrintf (CliHandle, "%d\r\n", pMepInfo->u4HwMepId);
        }
#endif

            /* Routine called to display MEP Info */
            EcfmDisplayMepInfo (CliHandle, u4CurrentContextId,
                                u4MdIndex, u4MaIndex, u4MepIdentifier);
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                    (UINT4 *)
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrentContextId != u4NextContextId)

            {
                b1ShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            b1Entry = ECFM_FALSE;
        }
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }

    if (b1Flag == ECFM_FALSE)
    {
        CliPrintf (CliHandle,
                   "%% Given MEP information is not available in the MEP Database\r\n");
    }

    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayMepInfo
 *                                                                          
 *     DESCRIPTION      : This function will display the informations regarding
 *                        the MEPs.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id
 *                        u4MdIndex   - Md Index of the MEP
 *                        u4MaIndex   - Ma Index of the MEP
 *                        u4MepId     - MEPID of the MEP
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayMepInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepId)
{
    tSNMP_OCTET_STRING_TYPE ErrorCcmRcvd;
    tSNMP_OCTET_STRING_TYPE XconCcmRcvd;
    tEcfmMacAddr        au1AisClintMacAddr;
    tEcfmMacAddr        au1LckClintMacAddr;
    tEcfmMacAddr        au1InMacAddr;
    INT4                i4RetValues = ECFM_INIT_VAL;
    INT4                i4RetConditionValues = ECFM_INIT_VAL;
    INT4                i4RetClientMegLevel = ECFM_INIT_VAL;
    INT4                i4RetOffLoadStatus = ECFM_INIT_VAL;
    INT4                i4RetPriority = ECFM_INIT_VAL;
    INT4                i4RetInterval = ECFM_INIT_VAL;
    INT4                i4RetDropEnable = ECFM_INIT_VAL;
    INT4                i4RetDelay = ECFM_INIT_VAL;
    INT4                i4HighestPriDefect = ECFM_INIT_VAL;
    INT4                i4FngState = ECFM_INIT_VAL;
    INT4                i4MepCcmDropEnable = ECFM_INIT_VAL;
    INT4                i4MepCcmVlanPriority = ECFM_INIT_VAL;
    UINT4               u4RetThreshold = ECFM_INIT_VAL;
    UINT4               u4RetPeriod = ECFM_INIT_VAL;
    UINT4               u4RetLckPriority = ECFM_INIT_VAL;
    UINT1               au1ErrorCcmRcvd[ECFM_MAX_CCM_PDU_SIZE];
    UINT1               au1XconCcmRcvd[ECFM_MAX_CCM_PDU_SIZE];
    UINT1               u1Index = ECFM_INIT_VAL;
    UINT1               au1AisString[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1LckString[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1String[ECFM_CLI_MAC_STRING_LENGTH];
    UINT1               au1ZeroString[ECFM_CLI_MAC_STRING_LENGTH] =
        { ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48,
        ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48,
        ECFM_VAL_48, ECFM_VAL_58, ECFM_VAL_48, ECFM_VAL_48, ECFM_VAL_58,
        ECFM_VAL_48, ECFM_VAL_48, ECFM_NULL_CHAR
    };
    ECFM_MEMSET (au1AisClintMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (au1LckClintMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (au1InMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
    ECFM_MEMSET (au1AisString, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);
    ECFM_MEMSET (au1LckString, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);
    ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAC_STRING_LENGTH);

    ECFM_MEMSET (au1ErrorCcmRcvd, ECFM_INIT_VAL, ECFM_MAX_CCM_PDU_SIZE);
    ECFM_MEMSET (au1XconCcmRcvd, ECFM_INIT_VAL, ECFM_MAX_CCM_PDU_SIZE);

    ECFM_MEMSET (&ErrorCcmRcvd, ECFM_INIT_VAL, sizeof
                 (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&XconCcmRcvd, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    ErrorCcmRcvd.pu1_OctetList = au1ErrorCcmRcvd;
    XconCcmRcvd.pu1_OctetList = au1XconCcmRcvd;
    ErrorCcmRcvd.i4_Length = 0;
    XconCcmRcvd.i4_Length = 0;

    nmhGetFsMIEcfmMepErrorCcmLastFailure (u4ContextId,
                                          u4MdIndex, u4MaIndex,
                                          u4MepId, &ErrorCcmRcvd);

    nmhGetFsMIEcfmMepXconCcmLastFailure (u4ContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepId, &XconCcmRcvd);
    nmhGetFsMIY1731MegClientMEGLevel (u4ContextId, u4MdIndex,
                                      (INT4 *) &i4RetClientMegLevel);
    CliPrintf (CliHandle, "\r\n%-37s", "Client MEG Level");
    CliPrintf (CliHandle, "%-3s", ":");
    if (i4RetClientMegLevel == ECFM_MD_LEVEL_NOT_CONFIGURE)

    {
        CliPrintf (CliHandle, "%-18s", "Not Configured");
    }

    else

    {
        CliPrintf (CliHandle, "%-18d", i4RetClientMegLevel);
    }

    /*Status of MepCcmOffload */
    nmhGetFsMIEcfmMepCcmOffload (u4ContextId, u4MdIndex, u4MaIndex,
                                 u4MepId, (INT4 *) &i4RetOffLoadStatus);
    CliPrintf (CliHandle, "\r\n%-37s", "Off-Load Status");
    CliPrintf (CliHandle, "%-3s", ":");
    if (i4RetOffLoadStatus == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n");

    /*Out Of Service */
    CliPrintf (CliHandle, "\r\nOut-Of-Service (LCK)\r\n");
    CliPrintf (CliHandle, "--------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Status");
    CliPrintf (CliHandle, "%-3s", ":");
    nmhGetFsMIY1731MepOutOfService (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-18s", "Locked");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Un-Locked(In-Service)");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "Condition");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetConditionValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepLckCondition (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, &i4RetConditionValues);
    if (i4RetConditionValues == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-18s", "Exist");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Does not exist");
    }
    if (i4RetValues == ECFM_TRUE)

    {
        nmhGetFsMIY1731MepLckInterval (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &i4RetInterval);
        nmhGetFsMIY1731MepLckPeriod (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &u4RetPeriod);
        nmhGetFsMIY1731MepLckPriority (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &u4RetLckPriority);
        nmhGetFsMIY1731MepLckDropEnable (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepId, &i4RetDropEnable);
        nmhGetFsMIY1731MepLckDelay (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, &i4RetDelay);
        nmhGetFsMIY1731MepLckClientMacAddress (u4ContextId, u4MdIndex,
                                               u4MaIndex, u4MepId,
                                               &au1LckClintMacAddr);

        PrintMacAddress (au1LckClintMacAddr, au1LckString);
        au1LckString[ECFM_INDEX_SEVENTEEN] = '\0';

        if (ECFM_MEMCMP
            (au1LckString, au1ZeroString,
             ECFM_CLI_MAC_STRING_LENGTH) != ECFM_INIT_VAL)
        {
            if (!(ECFM_IS_MULTICAST_ADDR (au1LckClintMacAddr)))
            {
                CliPrintf (CliHandle, "\r\n%-37s", "LCK Unicast Address");
                CliPrintf (CliHandle, "%-3s", ":");
                CliPrintf (CliHandle, "%s", au1LckString);
            }
        }
        CliPrintf (CliHandle, "\r\n%-37s", "Period");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%d seconds", u4RetPeriod);

        CliPrintf (CliHandle, "\r\n%-37s", "Drop-Eligibility");
        CliPrintf (CliHandle, "%-3s", ":");
        if (i4RetDropEnable == 1)

        {
            CliPrintf (CliHandle, "%s", "Enabled");
        }

        else

        {
            CliPrintf (CliHandle, "%s", "Disabled");
        }
        CliPrintf (CliHandle, "\r\n%-37s", "VLAN-Priority");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%-18d", u4RetLckPriority);
        CliPrintf (CliHandle, "\r\n%-37s", "Interval");
        CliPrintf (CliHandle, "%-3s", ":");
        if (i4RetInterval == ECFM_CC_AIS_LCK_INTERVAL_1_SEC)

        {
            CliPrintf (CliHandle, "%s", "1 second");
        }

        else

        {
            CliPrintf (CliHandle, "%s", "1 minute");
        }
        CliPrintf (CliHandle, "\r\n%-37s", "Delay");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%d milliseconds", i4RetDelay *
                   ECFM_NUM_OF_TICKS_IN_A_MSEC);
    }

    /* RDI */
    CliPrintf (CliHandle, "\r\n\nRemote Defect Indication (RDI)\r\n");
    CliPrintf (CliHandle, "------------------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepRdiCapability (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    if (i4RetValues == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Period");
        CliPrintf (CliHandle, "%-3s", ":");
        i4RetValues = ECFM_INIT_VAL;
        nmhGetFsMIY1731MepRdiPeriod (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, (UINT4 *) &i4RetValues);
        CliPrintf (CliHandle, "%d seconds", i4RetValues);
    }
    /*Continuity Check Message */

    CliPrintf (CliHandle, "\r\n\nContinuity Check Message(CCM) \r\n");
    CliPrintf (CliHandle, "-----------------------------------");

    nmhGetFsMIY1731MepCcmDropEnable (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &i4MepCcmDropEnable);
    nmhGetFsMIY1731MepCcmPriority (u4ContextId, u4MdIndex, u4MaIndex,
                                   u4MepId, &i4MepCcmVlanPriority);
    /* Get CCM Unicast Mac Address */
    nmhGetFsMIY1731MepUnicastCcmMacAddress (u4ContextId, u4MdIndex, u4MaIndex,
                                            u4MepId, &au1InMacAddr);

    CliPrintf (CliHandle, "\r\n%-37s", "CCM Drop Eligibility");
    CliPrintf (CliHandle, "%-3s", ":");

    if (i4MepCcmDropEnable != ECFM_SNMP_FALSE)
    {
        CliPrintf (CliHandle, "%s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "CCM Vlan Priority");
    CliPrintf (CliHandle, "%-3s", ":");
    CliPrintf (CliHandle, "%d", i4MepCcmVlanPriority);

    PrintMacAddress (au1InMacAddr, au1String);
    au1String[ECFM_INDEX_SEVENTEEN] = '\0';
    if (ECFM_MEMCMP (au1String, au1ZeroString, ECFM_CLI_MAC_STRING_LENGTH)
        != ECFM_INIT_VAL)
    {
        if (!(ECFM_IS_MULTICAST_ADDR (au1InMacAddr)))
        {
            CliPrintf (CliHandle, "\r\n%-37s", "CCM Unicast Mac Address");
            CliPrintf (CliHandle, "%-3s", ":");
            CliPrintf (CliHandle, "%s", au1String);
        }
    }

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /* LBM */
    CliPrintf (CliHandle, "\r\n\nLoopback (LB)\r\n");
    CliPrintf (CliHandle, "-------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepLoopbackCapability (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "Multicast LBM Reception Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepMulticastLbmRecvCapability (u4ContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }

    /* TST */
    CliPrintf (CliHandle, "\r\n\nTest Signal (TST)\r\n");
    CliPrintf (CliHandle, "-----------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Multicast TST Reception Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepMulticastTstRecvCapability (u4ContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "TST Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepTstCapability (u4ContextId, u4MdIndex,
                                     u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    /*AIS Details */
    CliPrintf (CliHandle, "\r\n\nAlarm Indication Signal (AIS)\r\n");
    CliPrintf (CliHandle, "-----------------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepAisCapability (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "Condition");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetConditionValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepAisCondition (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, &i4RetConditionValues);
    if (i4RetConditionValues == ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-18s", "Exist");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Does not exist");
    }

    /* If Ais Capability is enabled then show the details */
    if (i4RetValues == ECFM_ENABLE)

    {
        nmhGetFsMIY1731MepAisInterval (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &i4RetInterval);
        nmhGetFsMIY1731MepAisPeriod (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &u4RetPeriod);
        nmhGetFsMIY1731MepAisPriority (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &i4RetPriority);
        nmhGetFsMIY1731MepAisDropEnable (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepId, &i4RetDropEnable);
        nmhGetFsMIY1731MepAisClientMacAddress (u4ContextId, u4MdIndex,
                                               u4MaIndex, u4MepId,
                                               &au1AisClintMacAddr);
        PrintMacAddress (au1AisClintMacAddr, au1AisString);
        au1AisString[ECFM_INDEX_SEVENTEEN] = '\0';

        if (ECFM_MEMCMP
            (au1AisString, au1ZeroString,
             ECFM_CLI_MAC_STRING_LENGTH) != ECFM_INIT_VAL)
        {
            if (!(ECFM_IS_MULTICAST_ADDR (au1AisClintMacAddr)))

            {
                CliPrintf (CliHandle, "\r\n%-37s", "AIS Unicast Address");
                CliPrintf (CliHandle, "%-3s", ":");
                CliPrintf (CliHandle, "%s", au1AisString);
            }
        }
        CliPrintf (CliHandle, "\r\n%-37s", "Period");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%d seconds", u4RetPeriod);

        CliPrintf (CliHandle, "\r\n%-37s", "Drop-Eligibility");
        CliPrintf (CliHandle, "%-3s", ":");
        if (i4RetDropEnable == 1)

        {
            CliPrintf (CliHandle, "%s", "Enabled");
        }

        else

        {
            CliPrintf (CliHandle, "%s", "Disabled");
        }
        CliPrintf (CliHandle, "\r\n%-37s", "VLAN-Priority");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%-18d", i4RetPriority);
        CliPrintf (CliHandle, "\r\n%-37s", "Interval");
        CliPrintf (CliHandle, "%-3s", ":");
        if (i4RetInterval == ECFM_CC_AIS_LCK_INTERVAL_1_SEC)

        {
            CliPrintf (CliHandle, "%s", "1 seconds");
        }

        else

        {
            CliPrintf (CliHandle, "%s", "1 minute");
        }
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    /*Frame Delay Measurement */
    CliPrintf (CliHandle, "\r\n\nDelay Measurement (DM)\r\n");
    CliPrintf (CliHandle, "----------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "One-Way DM Reception Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731Mep1DmRecvCapability (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "One-Way DM Transaction Interval");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731Mep1DmTransInterval (u4ContextId, u4MdIndex,
                                        u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == 0)

    {
        CliPrintf (CliHandle, "%-5s", "Not Configured");
    }

    else

    {
        CliPrintf (CliHandle, "%d", i4RetValues * ECFM_NUM_OF_TICKS_IN_A_MSEC);
        CliPrintf (CliHandle, " milliseconds");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "Dmr Optional Fields");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepDmrOptionalFields (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)

    {
        CliPrintf (CliHandle, "%-18s", "Included");
    }

    else

    {
        CliPrintf (CliHandle, "%-18s", "Not Included");
    }
    CliPrintf (CliHandle, "\r\n%-37s", "Delay Threshold");
    CliPrintf (CliHandle, "%-3s", ":");
    u4RetThreshold = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepFrameDelayThreshold (u4ContextId, u4MdIndex,
                                           u4MaIndex, u4MepId, &u4RetThreshold);
    if (u4RetThreshold != 0)

    {
        CliPrintf (CliHandle, "%u microseconds", u4RetThreshold);
    }

    else

    {
        CliPrintf (CliHandle, "%-5s", "Not Configured");
    }
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    /*Frame Loss Measurement */
    CliPrintf (CliHandle, "\r\n\nFrame Loss Measurement (LM)\r\n");
    CliPrintf (CliHandle, "----------------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Near-End Loss Threshold");
    CliPrintf (CliHandle, "%-3s", ":");
    u4RetThreshold = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepNearEndFrameLossThreshold (u4ContextId, u4MdIndex,
                                                 u4MaIndex, u4MepId,
                                                 &u4RetThreshold);
    CliPrintf (CliHandle, "%-18u", u4RetThreshold);
    CliPrintf (CliHandle, "\r\n%-37s", "Far-End Loss Threshold");
    CliPrintf (CliHandle, "%-3s", ":");
    u4RetThreshold = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepFarEndFrameLossThreshold (u4ContextId, u4MdIndex,
                                                u4MaIndex, u4MepId,
                                                &u4RetThreshold);
    CliPrintf (CliHandle, "%-18u", u4RetThreshold);
    CliPrintf (CliHandle, "\r\n");

    CliPrintf (CliHandle, "\r\nError Or Cross Connect PDU Received \r\n");
    CliPrintf (CliHandle, "-----------------------------------");
    if (ErrorCcmRcvd.i4_Length != 0)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last Error CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":");
        for (u1Index = 1; u1Index <= ErrorCcmRcvd.i4_Length; u1Index++)
        {
            if (u1Index <= ECFM_MAX_CCM_PDU_SIZE)
            {
                CliPrintf (CliHandle, " %02x", au1ErrorCcmRcvd[u1Index - 1]);
                if ((u1Index != 0) && (!(u1Index % 13)))
                {
                    CliPrintf (CliHandle, "\n");
                    CliPrintf (CliHandle, "%-39s", " ");
                }
            }
        }
    }
    else
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last Error CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":  None");
    }
    if (XconCcmRcvd.i4_Length != 0)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last XCON  CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":");
        for (u1Index = 1; u1Index <= XconCcmRcvd.i4_Length; u1Index++)
        {
            if (u1Index <= ECFM_MAX_CCM_PDU_SIZE)
            {
                CliPrintf (CliHandle, " %02x", au1XconCcmRcvd[u1Index - 1]);
                if ((u1Index != 0) && (!(u1Index % 13)))
                {
                    CliPrintf (CliHandle, "\n");
                    CliPrintf (CliHandle, "%-39s", " ");
                }
            }
        }
    }
    else
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last XCON  CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":  None");
    }
    CliPrintf (CliHandle, "\r\n");
    CliPrintf (CliHandle, "\r\nFault Notification Status \r\n");
    CliPrintf (CliHandle, "-----------------------------------");

    nmhGetFsMIEcfmMepFngState (u4ContextId, u4MdIndex,
                               u4MaIndex, u4MepId, &i4FngState);

    CliPrintf (CliHandle, "\r\n%-37s", "State Machine State");
    switch (i4FngState)
    {
        case ECFM_MEP_FNG_RESET:
            CliPrintf (CliHandle, "%-2s", ":  RESET");
            break;
        case ECFM_MEP_FNG_DEFECT:
            CliPrintf (CliHandle, "%-2s", ":  DEFECT");
            break;
        case ECFM_MEP_FNG_REPORT_DEFECT:
            CliPrintf (CliHandle, "%-2s", ":  REPORT DEFECT");
            break;
        case ECFM_MEP_FNG_DEFECT_REPORTED:
            CliPrintf (CliHandle, "%-2s", ":  DEFECT REPORTED");
            break;
        case ECFM_MEP_FNG_DEFECT_CLEARING:
            CliPrintf (CliHandle, "%-2s", ":  DEFECT CLEARING");
            break;
        default:
            CliPrintf (CliHandle, "%-2s", ":  RESET");
            break;
    }

    nmhGetFsMIEcfmMepHighestPrDefect (u4ContextId, u4MdIndex,
                                      u4MaIndex, u4MepId, &i4HighestPriDefect);
    CliPrintf (CliHandle, "\r\n%-37s", "Highest Priority Defect Present");

    switch (i4HighestPriDefect)
    {
        case ECFM_DEF_RDI_CCM:
            CliPrintf (CliHandle, "%-2s", ":  RDI DEFECT");
            break;
        case ECFM_DEF_MAC_STS:
            CliPrintf (CliHandle, "%-2s", ":  MAC STATUS DEFECT");
            break;
        case ECFM_DEF_REMOTE_CCM:
            CliPrintf (CliHandle, "%-2s", ":  REMOTE CCM DEFECT");
            break;
        case ECFM_DEF_ERROR_CCM:
            CliPrintf (CliHandle, "%-2s", ":  ERROR CCM DEFECT");
            break;
        case ECFM_DEF_XCON_CCM:
            CliPrintf (CliHandle, "%-2s", ":  XCONN DEFECT");
            break;
        default:
            CliPrintf (CliHandle, "%-2s", ":  NO DEFECT");
            break;
    }
    CliPrintf (CliHandle, "\r\n");
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();
	/*CSF Details */
	CliPrintf (CliHandle, "\r\n\n Client Signal Fault Detection (CSF)\r\n");
	CliPrintf (CliHandle, "------------------------------------------");
	CliPrintf (CliHandle, "\r\n%-37s", "Capability");
	CliPrintf (CliHandle, "%-3s", ":");
	i4RetValues = ECFM_INIT_VAL;
	nmhGetFsMIY1731MepCsfRxCapability (u4ContextId, u4MdIndex, u4MaIndex,
			u4MepId, &i4RetValues);
	if (i4RetValues == ECFM_ENABLE)
	{
		CliPrintf (CliHandle, "%-18s", "Enabled");
	}
	else
	{
		CliPrintf (CliHandle, "%-18s", "Disabled");
	}
    i4RetInterval = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepCsfRxInterval(u4ContextId, u4MdIndex,
			u4MaIndex, u4MepId, &i4RetInterval);

	CliPrintf (CliHandle, "\r\n%-37s", "Interval");
	CliPrintf (CliHandle, "%-3s", ":");

	if (i4RetInterval == ECFM_CC_CSF_INTERVAL_1_SEC)
	{
		CliPrintf (CliHandle, "%s", "1 seconds");
	}
	else
	{
		CliPrintf (CliHandle, "%s", "1 minute");
	}

	i4RetValues = ECFM_INIT_VAL;
	nmhGetFsMIY1731MepCsfRxDefectType(u4ContextId, u4MdIndex, u4MaIndex, u4MepId, &i4RetInterval); 

	CliPrintf (CliHandle, "\r\n%-37s", "CSF Defect Type");
	CliPrintf (CliHandle, "%-3s", ":");
	switch(i4RetInterval)
    {
        case ECFM_CSF_NODEFECT_STATE:
            CliPrintf (CliHandle, "%s", "NO DEFECT");
            break;
		case ECFM_CSF_LOS_STATE:
				CliPrintf (CliHandle, "%s", "LOS");
				break;
		case ECFM_CSF_FDI_STATE:
				CliPrintf (CliHandle, "%s", "FDI");
				break;
		case ECFM_CSF_RDI_STATE:
				CliPrintf (CliHandle, "%s", "RDI");
				break;
		case ECFM_CSF_DCI_STATE:
				CliPrintf (CliHandle, "%s", "DCI");
				break;
		default:
			return;
	}
    CliPrintf (CliHandle, "\r\n");
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFDBuffer
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Delay buffer.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4PortId    - Port on which MEP is present
 *                        u4Command   - Command Identifier
 *                        u4DelayType  - Measurement Type of Frame Delay
 *                        b1Brief     - Whether user wants brief info
 *                        or detailed 
 *                        pu1PeerMacAddr - Mac Address of the MEP with which
 *                        Frame Loss is calculated
 *                        pu1Arg1    - 
 *                        pu1Arg2    - 
 *                        Level or Vlan of the MEP which has initiated
 *                        Frame Delay measurement depending on the input command
 *                        pu1MdName  -  Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowFDBuffer (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4PortId, UINT4 u4Command,
                     INT4 i4DelayType, BOOL1 b1Brief,
                     UINT1 *pu1PeerMacAddr, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                     UINT1 *pu1MdName)
{
    tEcfmMacAddr        RetMacAddr = { 0 };
    tEcfmMacAddr        MacAddr = { 0 };
    UINT4               u4SavedMdIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SavedContextId = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevTransId = ECFM_INIT_VAL;
    UINT4               u4PrevSeqNum = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    INT4                i4RetPortNum = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetDelayType = ECFM_INIT_VAL;
    BOOL1               b1Flag = ECFM_FALSE;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    u4CurrentContextId = u4ContextId;
    while ((nmhGetNextIndexFsMIY1731FdTable
            (u4CurrentContextId, &u4NextContextId, u4PrevMdIndex,
             &u4MdIndex, u4PrevMaIndex, &u4MaIndex, u4PrevMepIdentifier,
             &u4MepIdentifier, u4PrevTransId, &u4TransId, u4PrevSeqNum,
             &u4SeqNum) == SNMP_SUCCESS)
           && (u4CurrentContextId == u4NextContextId)
           && (b1ShowAll == ECFM_TRUE))

    {

        /* Compare the entry indices with saved one for skipping the entries if
         * already showed for a MEP */
        if ((u4SavedContextId == u4NextContextId) &&
            (u4SavedMdIndex == u4MdIndex) &&
            (u4SavedMaIndex == u4MaIndex) &&
            (u4SavedMepIdentifier == u4MepIdentifier))

        {
            u4PrevMdIndex = u4MdIndex;
            u4PrevMaIndex = u4MaIndex;
            u4PrevMepIdentifier = u4MepIdentifier;
            u4PrevTransId = u4TransId;
            u4PrevSeqNum = u4SeqNum;
            b1Entry = ECFM_FALSE;
            continue;
        }
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetPortNum = ECFM_INIT_VAL;
        u4MdLevel = ECFM_INIT_VAL;
        i4VlanId = ECFM_INIT_VAL;
        i4RetDelayType = ECFM_INIT_VAL;

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;

        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetPortNum);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        nmhGetFsMIY1731FdPeerMepMacAddress (u4CurrentContextId,
                                            u4MdIndex, u4MaIndex,
                                            u4MepIdentifier, u4TransId,
                                            u4SeqNum, &RetMacAddr);
        nmhGetFsMIY1731FdMeasurementType (u4CurrentContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4TransId, u4SeqNum, &i4RetDelayType);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        if (pu1PeerMacAddr != NULL)

        {
            StrToMac ((UINT1 *) pu1PeerMacAddr, MacAddr);
        }

        /* Search for MEP satisfying the input conditions */
        switch (u4Command)

        {
            case CLI_ECFM_SHOW_FD_INTF:
                if ((i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_INTF_UNAWARE:
                if ((i4RetPortNum == (INT4) u4PortId) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_INTF_SER:
                if ((i4RetPortNum == (INT4) u4PortId) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_INTF_ISID:
            case CLI_ECFM_SHOW_FD_INTF_VLAN:
      
            case CLI_ECFM_SHOW_FD_INTF_VSI:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg1);
                if ((i4RetPortNum == (INT4) u4PortId) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD:
                if (((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_UNAWARE:
                if ((i4RetMaPrimaryVid == 0) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV_INTF:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_INTF:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV_INTF_UNAWARE:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_INTF_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (i4RetMaPrimaryVid == 0) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV_INTF_ISID:
            case CLI_ECFM_SHOW_FD_LEV_INTF_VLAN:
            case CLI_ECFM_SHOW_FD_LEV_INTF_VSI:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_INTF_ISID:
            case CLI_ECFM_SHOW_FD_DOM_INTF_VLAN:
            case CLI_ECFM_SHOW_FD_DOM_INTF_VSI:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_INTF_SER:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                    (i4RetPortNum == (INT4) u4PortId) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV_UNAWARE:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_ISID:
            case CLI_ECFM_SHOW_FD_VLAN:
            case CLI_ECFM_SHOW_FD_VSI:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg1);
                if (((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_SER:
                if ((ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_LEV_ISID:
            case CLI_ECFM_SHOW_FD_LEV_VLAN:
            case CLI_ECFM_SHOW_FD_LEV_VSI:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_ISID:
            case CLI_ECFM_SHOW_FD_DOM_VLAN:
            case CLI_ECFM_SHOW_FD_DOM_VSI:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FD_DOM_SER:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4RetDelayType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* If the entry is found */
        if (b1Entry == ECFM_TRUE)

        {
            u4SavedContextId = u4CurrentContextId;
            u4SavedMdIndex = u4MdIndex;
            u4SavedMaIndex = u4MaIndex;
            u4SavedMepIdentifier = u4MepIdentifier;
            EcfmDisplayFDEntries (CliHandle, u4CurrentContextId,
                                  u4MdIndex, u4MaIndex, u4MepIdentifier,
                                  b1Brief, pu1PeerMacAddr);
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to Next entry */
        u4PrevMdIndex = u4MdIndex;
        u4PrevMaIndex = u4MaIndex;
        u4PrevMepIdentifier = u4MepIdentifier;
        u4PrevTransId = u4TransId;
        u4PrevSeqNum = u4SeqNum;
        b1Entry = ECFM_FALSE;
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }

    UNUSED_PARAM(b1Flag);
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowProactiveFDBuffer
 *
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Delay buffer.
 *
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4PortId    - Port on which MEP is present
 *                        u4Command   - Command Identifier
 *                        u4DelayType  - Measurement Type of Frame Delay
 *                        b1Brief     - Whether user wants brief info
 *                        or detailed
 *                        pu1PeerMacAddr - Mac Address of the MEP with which
 *                        Frame Loss is calculated
 *                        pu1Arg1    -
 *                        pu1Arg2    -
 *                        Level or Vlan of the MEP which has initiated
 *                        Frame Delay measurement depending on the input command
 *                        pu1MdName  -  Md Name
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
EcfmCliShowProactiveFDBuffer (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4PortId, UINT4 u4Command,
                              INT4 i4DelayType, UINT4 u4TstId,
                              UINT1 *pu1PeerMacAddr, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                              UINT1 *pu1MdName)
{
    tEcfmMacAddr        RetMacAddr = { 0 };
    tEcfmMacAddr        MacAddr = { 0 };
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevTestId = ECFM_INIT_VAL;
    UINT4               i4PrevDmType = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TestId = ECFM_INIT_VAL;
    INT4                i4DmType = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    INT4                i4RetPortNum = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4DmSent = ECFM_INIT_VAL;
    UINT4               u4DmRcvd = ECFM_INIT_VAL;
    UINT4               u4DmUnAck = ECFM_INIT_VAL;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1ProDmAvg[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1ProDmMin[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1ProDmMax[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT1                *pi1IfName = NULL;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE ProDmAvg;
    tSNMP_OCTET_STRING_TYPE ProDmMin;
    tSNMP_OCTET_STRING_TYPE ProDmMax;

    UNUSED_PARAM(u4PortId);
    UNUSED_PARAM(u4TstId);
    u4CurrentContextId = u4ContextId;
    while ((nmhGetNextIndexFsMIY1731ProactiveFdStatsTable
            (u4CurrentContextId, &u4NextContextId, u4PrevMdIndex,
             &u4MdIndex, u4PrevMaIndex, &u4MaIndex, u4PrevMepIdentifier,
             &u4MepIdentifier, u4PrevRMepIdentifier, &u4RMepIdentifier, u4PrevTestId, (INT4 *)&u4TestId, i4PrevDmType,
             &i4DmType) == SNMP_SUCCESS)
           && (u4CurrentContextId == u4NextContextId)
           && (b1ShowAll == ECFM_TRUE))

    {
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetPortNum = ECFM_INIT_VAL;
        u4MdLevel = ECFM_INIT_VAL;
        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;
        MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
        pi1IfName = (INT1 *) au1IfName;

        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetPortNum);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        /* nmhGetFsMIY1731FdPeerMepMacAddress (u4CurrentContextId,
           u4MdIndex, u4MaIndex,
           u4MepIdentifier, u4TransId,
           u4SeqNum, &RetMacAddr);
           nmhGetFsMIY1731FdMeasurementType (u4CurrentContextId, u4MdIndex,
           u4MaIndex, u4MepIdentifier,
           u4TransId, u4SeqNum, &i4RetDelayType);*/
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        CfaCliGetIfName ((UINT4) i4RetPortNum, pi1IfName);
        CliPrintf (CliHandle, "\r\nInterface : %-7s ", pi1IfName);
        CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepIdentifier);
        CliPrintf (CliHandle, "\r\nRMEP-ID   : %d", u4RMepIdentifier);
        CliPrintf (CliHandle, "\r\nLevel     : %d\n", i4RetMdLevel);
        if (pu1PeerMacAddr != NULL)

        {
            StrToMac ((UINT1 *) pu1PeerMacAddr, MacAddr);
        }

        /* Search for MEP satisfying the input conditions */
        switch (u4Command)

        {
            case CLI_ECFM_SHOW_PRO_FD:
                if (((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4DmType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_PRO_FD_LEV:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4DmType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_PRO_FD_DOM:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4DmType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_PRO_FD_SER:
                if ((ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4DmType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_PRO_FD_DOM_SER:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                    ((i4DelayType == 0) ||
                     ((i4DelayType != 0) &&
                      (i4DelayType == i4DmType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }
        /* If the entry is found */
        if (b1Entry == ECFM_TRUE)

        {
             nmhGetFsMIY1731ProactiveFdStatsDmOut (u4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4RMepIdentifier,
                                                  u4TestId, i4DmType,
                                                  &u4DmSent);
             CliPrintf (CliHandle, "\r\npackets sent = %d,", u4DmSent);

             nmhGetFsMIY1731ProactiveFdStatsDmIn (u4CurrentContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4RMepIdentifier,
                                                  u4TestId, i4DmType,
                                                  &u4DmRcvd);
             CliPrintf (CliHandle, " packets Rcvd = %d,", u4DmRcvd);

             nmhGetFsMIY1731ProactiveFdUnAck(u4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIdentifier, u4RMepIdentifier,
                                             u4TestId, i4DmType,
                                             &u4DmUnAck);
             CliPrintf (CliHandle, " packets UnAck = %d \r\n", u4DmUnAck);

 
             CliPrintf (CliHandle,"\r\nNear End Statistics ");
             CliPrintf (CliHandle,"\r\n-------------------");

             ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmAvg.pu1_OctetList =  au1ProDmAvg;
             ProDmAvg.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndDelayAverage (u4CurrentContextId,
                                                                 u4MdIndex, u4MaIndex,
                                                                 u4MepIdentifier, u4RMepIdentifier,
                                                                 u4TestId,
                                                                 i4DmType,
                                                                 &ProDmAvg);


             ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMin.pu1_OctetList =  au1ProDmMin;
             ProDmMin.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndDelayMin (u4CurrentContextId,
                                                             u4MdIndex, u4MaIndex,
                                                             u4MepIdentifier, u4RMepIdentifier,
                                                             u4TestId,
                                                             i4DmType,
                                                             &ProDmMin);

             ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMax.pu1_OctetList =  au1ProDmMax;
             ProDmMax.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndDelayMax (u4CurrentContextId,
                                                             u4MdIndex, u4MaIndex,
                                                             u4MepIdentifier, u4RMepIdentifier,
                                                             u4TestId,
                                                             i4DmType,
                                                             &ProDmMax);
             CliPrintf (CliHandle, "\r\nFrame Dealy min/max/avg = %.5sms/%.5sms/%.5sms",
                        ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);


             ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmAvg.pu1_OctetList =  au1ProDmAvg;
             ProDmAvg.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndFDVAverage (u4CurrentContextId,
                                                               u4MdIndex, u4MaIndex,
                                                               u4MepIdentifier, u4RMepIdentifier,
                                                               u4TestId,
                                                               i4DmType,
                                                               &ProDmAvg);
             ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMin.pu1_OctetList =  au1ProDmMin;
             ProDmMin.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndFDVMin (u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier, u4RMepIdentifier,
                                                           u4TestId,
                                                           i4DmType,
                                                           &ProDmMin);
             ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMax.pu1_OctetList =  au1ProDmMax;
             ProDmMax.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndFDVMax (u4CurrentContextId,
                                                           u4MdIndex, u4MaIndex,
                                                           u4MepIdentifier, u4RMepIdentifier,
                                                           u4TestId,
                                                           i4DmType,
                                                           &ProDmMax);
             CliPrintf (CliHandle, "\r\nFrame Dealy Variation min/max/avg = %.5sms/%.5sms/%.5sms",
                        ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);

             ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmAvg.pu1_OctetList =  au1ProDmAvg;
             ProDmAvg.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndIFDVAverage (u4CurrentContextId,
                                                                u4MdIndex, u4MaIndex,
                                                                u4MepIdentifier, u4RMepIdentifier,
                                                                u4TestId,
                                                                i4DmType,
                                                                &ProDmAvg);


             ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMin.pu1_OctetList =  au1ProDmMin;
             ProDmMin.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndIFDVMin (u4CurrentContextId,
                                                            u4MdIndex, u4MaIndex,
                                                            u4MepIdentifier, u4RMepIdentifier,
                                                            u4TestId,
                                                            i4DmType,
                                                            &ProDmMin);
             ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                          sizeof (tSNMP_OCTET_STRING_TYPE));
             ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                          ECFM_MD_NAME_ARRAY_SIZE);
             ProDmMax.pu1_OctetList =  au1ProDmMax;
             ProDmMax.i4_Length = ECFM_INIT_VAL;
             nmhGetFsMIY1731ProactiveFdStatsNearEndIFDVMax (u4CurrentContextId,
                                                            u4MdIndex, u4MaIndex,
                                                            u4MepIdentifier, u4RMepIdentifier,
                                                            u4TestId,
                                                            i4DmType,
                                                            &ProDmMax);
             CliPrintf (CliHandle, "\r\nInter Frame Dealy Variation min/max/avg = %.5sms/%.5sms/%.5sms\n",
                        ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);


             if (i4DmType == ECFM_LBLT_DM_TYPE_DMM)
             { 
                 CliPrintf (CliHandle,"\r\nFar End Statistics ");
                 CliPrintf (CliHandle,"\r\n------------------");

                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndDelayAverage (u4CurrentContextId,
                                                                    u4MdIndex, u4MaIndex,
                                                                    u4MepIdentifier, u4RMepIdentifier,
                                                                    u4TestId,
                                                                    i4DmType,
                                                                    &ProDmAvg);


                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndDelayMin (u4CurrentContextId,
                                                                u4MdIndex, u4MaIndex,
                                                                u4MepIdentifier, u4RMepIdentifier,
                                                                u4TestId,
                                                                i4DmType,
                                                                &ProDmMin);

                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndDelayMax (u4CurrentContextId,
                                                                u4MdIndex, u4MaIndex,
                                                                u4MepIdentifier, u4RMepIdentifier,
                                                                u4TestId,
                                                                i4DmType,
                                                                &ProDmMax);
                 CliPrintf (CliHandle, "\r\nFrame Dealy min/max/avg = %.5sms/%.5sms/%.5sms",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);


                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndFDVAverage (u4CurrentContextId,
                                                                  u4MdIndex, u4MaIndex,
                                                                  u4MepIdentifier, u4RMepIdentifier,
                                                                  u4TestId,
                                                                  i4DmType,
                                                                  &ProDmAvg);
                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndFDVMin (u4CurrentContextId,
                                                              u4MdIndex, u4MaIndex,
                                                              u4MepIdentifier, u4RMepIdentifier,
                                                              u4TestId,
                                                              i4DmType,
                                                              &ProDmMin);
                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndFDVMax (u4CurrentContextId,
                                                              u4MdIndex, u4MaIndex,
                                                              u4MepIdentifier, u4RMepIdentifier,
                                                              u4TestId,
                                                              i4DmType,
                                                              &ProDmMax);
                 CliPrintf (CliHandle, "\r\nFrame Dealy Variation min/max/avg = %.5sms/%.5sms/%.5sms",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);

                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndIFDVAverage (u4CurrentContextId,
                                                                   u4MdIndex, u4MaIndex,
                                                                   u4MepIdentifier, u4RMepIdentifier,
                                                                   u4TestId,
                                                                   i4DmType,
                                                                   &ProDmAvg);


                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndIFDVMin (u4CurrentContextId,
                                                               u4MdIndex, u4MaIndex,
                                                               u4MepIdentifier, u4RMepIdentifier,
                                                               u4TestId,
                                                               i4DmType,
                                                               &ProDmMin);
                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsFarEndIFDVMax (u4CurrentContextId,
                                                               u4MdIndex, u4MaIndex,
                                                               u4MepIdentifier, u4RMepIdentifier,
                                                               u4TestId,
                                                               i4DmType,
                                                               &ProDmMax);
                 CliPrintf (CliHandle, "\r\nInter Frame Dealy Variation min/max/avg = %.5sms/%.5sms/%.5sms\n",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);

                 CliPrintf (CliHandle,"\r\nRound Trip Statistics ");
                 CliPrintf (CliHandle,"\r\n---------------------");

                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirDelayAverage (u4CurrentContextId,
                                                                   u4MdIndex, u4MaIndex,
                                                                   u4MepIdentifier, u4RMepIdentifier,
                                                                   u4TestId,
                                                                   i4DmType,
                                                                   &ProDmAvg);


                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirDelayMin (u4CurrentContextId,
                                                               u4MdIndex, u4MaIndex,
                                                               u4MepIdentifier, u4RMepIdentifier,
                                                               u4TestId,
                                                               i4DmType,
                                                               &ProDmMin);

                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirDelayMax (u4CurrentContextId,
                                                               u4MdIndex, u4MaIndex,
                                                               u4MepIdentifier, u4RMepIdentifier,
                                                               u4TestId,
                                                               i4DmType,
                                                               &ProDmMax);
                 CliPrintf (CliHandle, "\r\nFrame Dealy min/max/avg = %.5sms/%.5sms/%.5sms",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);


                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirFDVAverage (u4CurrentContextId,
                                                                 u4MdIndex, u4MaIndex,
                                                                 u4MepIdentifier, u4RMepIdentifier,
                                                                 u4TestId,
                                                                 i4DmType,
                                                                 &ProDmAvg);
                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirFDVMin (u4CurrentContextId,
                                                             u4MdIndex, u4MaIndex,
                                                             u4MepIdentifier, u4RMepIdentifier,
                                                             u4TestId,
                                                             i4DmType,
                                                             &ProDmMin);
                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirFDVMax (u4CurrentContextId,
                                                             u4MdIndex, u4MaIndex,
                                                             u4MepIdentifier, u4RMepIdentifier,
                                                             u4TestId,
                                                             i4DmType,
                                                             &ProDmMax);
                 CliPrintf (CliHandle, "\r\nFrame Dealy Variation min/max/avg = %.5sms/%.5sms/%.5sms",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);

                 ECFM_MEMSET (&ProDmAvg, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmAvg, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmAvg.pu1_OctetList =  au1ProDmAvg;
                 ProDmAvg.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirIFDVAverage (u4CurrentContextId,
                                                                  u4MdIndex, u4MaIndex,
                                                                  u4MepIdentifier, u4RMepIdentifier,
                                                                  u4TestId,
                                                                  i4DmType,
                                                                  &ProDmAvg);


                 ECFM_MEMSET (&ProDmMin, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMin, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMin.pu1_OctetList =  au1ProDmMin;
                 ProDmMin.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirIFDVMin (u4CurrentContextId,
                                                              u4MdIndex, u4MaIndex,
                                                              u4MepIdentifier, u4RMepIdentifier,
                                                              u4TestId,
                                                              i4DmType,
                                                              &ProDmMin);
                 ECFM_MEMSET (&ProDmMax, ECFM_INIT_VAL,
                              sizeof (tSNMP_OCTET_STRING_TYPE));
                 ECFM_MEMSET (&au1ProDmMax, ECFM_INIT_VAL,
                              ECFM_MD_NAME_ARRAY_SIZE);
                 ProDmMax.pu1_OctetList =  au1ProDmMax;
                 ProDmMax.i4_Length = ECFM_INIT_VAL;
                 nmhGetFsMIY1731ProactiveFdStatsBiDirIFDVMax (u4CurrentContextId,
                                                              u4MdIndex, u4MaIndex,
                                                              u4MepIdentifier, u4RMepIdentifier,
                                                              u4TestId,
                                                              i4DmType,
                                                              &ProDmMax);
                 CliPrintf (CliHandle, "\r\nInter Frame Dealy Variation min/max/avg = %.5s ms/%.5s ms/%.5s ms\n",
                            ProDmMin.pu1_OctetList, ProDmMax.pu1_OctetList, ProDmAvg.pu1_OctetList);
             }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to Next entry */
        u4PrevMdIndex = u4MdIndex;
        u4PrevMaIndex = u4MaIndex;
        u4PrevMepIdentifier = u4MepIdentifier;
        u4PrevRMepIdentifier = u4RMepIdentifier;
        u4PrevTestId = u4TestId;
        i4PrevDmType = i4DmType;
        b1Entry = ECFM_FALSE;
        if (u4PagingStatus == CLI_FAILURE)

        {
            /* User pressed 'q' at more prompt, no more print required,
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }
    return CLI_SUCCESS;
}
/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayFDEntries
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Delay buffer.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *                        b1Brief - True then show brief info else detail info
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                          
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayFDEntries (tCliHandle CliHandle, UINT4 u4ConId,
                      UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId, BOOL1 b1Brief,
                      UINT1 *pu1PeerMacAddr)
{
    time_t              ltime;
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    tSNMP_OCTET_STRING_TYPE RetDelay;
    tSNMP_OCTET_STRING_TYPE RetMinDelay;
    tSNMP_OCTET_STRING_TYPE RetMaxDelay;
    tSNMP_OCTET_STRING_TYPE RetAvgDelay;
    tSNMP_OCTET_STRING_TYPE RetIFDVDelay;
    tSNMP_OCTET_STRING_TYPE RetFDVDelay;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4DmSent = ECFM_INIT_VAL;
    UINT4               u4DmrRcvd = ECFM_INIT_VAL;
    UINT4               u4RetMeasurementTime = ECFM_INIT_VAL;
    UINT4               u4DelayInSec = ECFM_INIT_VAL;
    UINT4               u4DelayInNanoSec = ECFM_INIT_VAL;
    UINT4               u4TempFDSeqNum = ECFM_INIT_VAL;
    UINT4               u4Entries = ECFM_INIT_VAL;
    UINT4               u4DelayInNanoSecFDV;
    UINT4               u4DelayInNanoSecIFDV;
    UINT4               u4DelayInNanoSecNearEnd;
    UINT4               u4DelayInNanoSecFarEnd;
    UINT4               u4DelayInNanoSecMinDelay;
    UINT4               u4DelayInNanoSecAvgDelay;
    UINT4               u4DelayInNanoSecMaxDelay;
    INT1               *pi1IfName = NULL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4RetLevel = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_FAILURE;
    INT4                i4RetDmType = ECFM_INIT_VAL;
    INT4                i4RetDmBufferSize = ECFM_INIT_VAL;
    FLT4                f4DelayInMs = 0.0;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1RetDelay[ECFM_ARRAY_SIZE_8] = { ECFM_INIT_VAL };
    UINT1               au1DelayMin[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1DelayMax[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1DelayAvg[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1IFDVAvg[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1FDVAvg[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1DelayValue[ECFM_ARRAY_SIZE_32] = { ECFM_INIT_VAL };
    UINT1               au1Date[ECFM_ARRAY_SIZE_64] = { ECFM_INIT_VAL };
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1PrintStats = ECFM_FALSE;
    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    tSNMP_OCTET_STRING_TYPE     RetFarEndDelayValue;
    tEcfmLbLtFrmDelayBuff       *pFdNode = NULL;
    unsigned char               FarEndDelayVal[ECFM_ARRAY_SIZE_8] =
                                    { ECFM_INIT_VAL };
    UINT1               au1FarEndDelayVal[ECFM_ARRAY_SIZE_8] = { ECFM_INIT_VAL };


    tSNMP_OCTET_STRING_TYPE     RetFarEndDelayVariation;
    unsigned char               FarEndDelayVar[ECFM_ARRAY_SIZE_8] =
                                    { ECFM_INIT_VAL };
    UINT1               au1FarEndDelayVar[ECFM_ARRAY_SIZE_8] = { ECFM_INIT_VAL };


    tSNMP_OCTET_STRING_TYPE     RetNearEndDelayValue;
    unsigned char               NearEndDelayVal[ECFM_ARRAY_SIZE_8] =
                                    { ECFM_INIT_VAL };
    UINT1               au1NearEndDelayVal[ECFM_ARRAY_SIZE_8] = { ECFM_INIT_VAL };


    tSNMP_OCTET_STRING_TYPE     RetNearEndDelayVariation;
    unsigned char               NearEndDelayVar[ECFM_ARRAY_SIZE_8] =
                                    { ECFM_INIT_VAL };
    UINT1               au1NearEndDelayVar[ECFM_ARRAY_SIZE_8] = { ECFM_INIT_VAL };


    MEMSET (FarEndDelayVal, ECFM_INIT_VAL, sizeof (FarEndDelayVal));
    MEMSET (&RetFarEndDelayValue, ECFM_INIT_VAL, sizeof (RetFarEndDelayValue));

    MEMSET (FarEndDelayVar, ECFM_INIT_VAL, sizeof (FarEndDelayVar));
    MEMSET (&RetFarEndDelayVariation, ECFM_INIT_VAL, sizeof (RetFarEndDelayVariation));

    MEMSET (NearEndDelayVal, ECFM_INIT_VAL, sizeof (NearEndDelayVal));
    MEMSET (&RetNearEndDelayValue, ECFM_INIT_VAL, sizeof (RetNearEndDelayValue));

    MEMSET (NearEndDelayVar, ECFM_INIT_VAL, sizeof (NearEndDelayVar));
    MEMSET (&RetNearEndDelayVariation, ECFM_INIT_VAL, sizeof (RetNearEndDelayVariation));

    nmhGetFsMIEcfmMepPrimaryVid (u4ConId, u4MdId, u4MaId, u4MepId,
                                 (UINT4 *) &i4RetPrimaryVid);
    nmhGetFsMIEcfmMaPrimaryVlanId (u4ConId, u4MdId, u4MaId, &i4RetMaPrimaryVid);
    nmhGetFsMIEcfmMepIfIndex (u4ConId, u4MdId, u4MaId, u4MepId, &i4RetIfIndex);
    nmhGetFsMIEcfmMdMdLevel (u4ConId, u4MdId, &i4RetLevel);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();
    if (nmhGetFsMIY1731FrameDelayBufferSize
        (u4ConId, &i4RetDmBufferSize) != SNMP_FAILURE)

    {
        CliPrintf (CliHandle,
                   "\r\n DM Buffer maximum size configured : %d \r\n",
                   i4RetDmBufferSize);
    }
    CfaCliGetIfName ((UINT4) i4RetIfIndex, pi1IfName);
    CliPrintf (CliHandle, "\r\nInterface : %-7s ", pi1IfName);
    CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepId);
    CliPrintf (CliHandle, "\r\nLevel     : %d", i4RetLevel);
    if (i4RetPrimaryVid != 0)
    {
#ifdef VSI_WANTED                        
        if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
        {
            CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetPrimaryVid);
        }
        else if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#else
		if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#endif
        {

            CliPrintf (CliHandle, "\r\nVLAN-ID   : %d \r", i4RetPrimaryVid);
        }
        else
        {

            CliPrintf (CliHandle, "\r\nVLAN-ID   : - \r");
        }
    }
    else
    {
#ifdef VSI_WANTED                        
        if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
        {
            CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetMaPrimaryVid);
        }
        else if ((i4RetMaPrimaryVid != 0)
            && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#else
        if ((i4RetMaPrimaryVid != 0)
            && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#endif

        {
            CliPrintf (CliHandle, "\r\nVLAN-ID   : %d \r", i4RetMaPrimaryVid);
        }

        else

        {
            CliPrintf (CliHandle, "\r\nVLAN-ID   : - \r");
        }
    }

    /*For ISID */
    if (i4RetPrimaryVid != 0)
    {
        if (i4RetPrimaryVid > ECFM_INTERNAL_ISID_MIN)
        {

            CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                       ECFM_ISID_INTERNAL_TO_ISID (i4RetPrimaryVid));
        }
        else
        {

            CliPrintf (CliHandle, "\r\nISID      : - \r\n");
        }
    }
    else
    {
        if ((i4RetMaPrimaryVid != 0)
            && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))

        {
            CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                       ECFM_ISID_INTERNAL_TO_ISID (i4RetMaPrimaryVid));
        }
        else
        {
            CliPrintf (CliHandle, "\r\nISID      : - \r\n");
        }
    }

    /* Show the brief info */
    if (b1Brief != ECFM_TRUE)

    {
        u4MdIndex = u4MdId;
        u4MaIndex = u4MaId;
        u4MepIdentifier = u4MepId;
        u4ContextId = u4ConId;

        /* Check for FD entry for a MEP */
        i4RetVal =
            nmhGetNextIndexFsMIY1731FdTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier, 0,
                                             &u4TransId, 0, &u4SeqNum);
        if (i4RetVal == SNMP_SUCCESS)

        {

            /* Entry is for this particular MEP */
            if ((u4ContextId != u4NextContextId) &&
                (u4MdIndex != u4NextMdIndex) &&
                (u4MaIndex != u4NextMaIndex) &&
                (u4MepIdentifier != u4NextMepIdentifier))

            {
                b1SameContext = ECFM_FALSE;
            }
        }
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

        {
            if (b1Header == ECFM_TRUE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                nmhGetFsMIEcfmMepMacAddress (u4ConId, u4MdId, u4MaId,
                                             u4MepId, &RetMacAddr);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                nmhGetFsMIY1731FdMeasurementType (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, u4SeqNum,
                                                  &i4RetDmType);
                PrintMacAddress (RetMacAddr, au1String);
                au1String[ECFM_INDEX_SEVENTEEN] = '\0';
                if (i4RetDmType == ECFM_LBLT_DM_TYPE_1DM)

                {
                    CliPrintf (CliHandle,
                               "\r\n--- %s one-way frame delay statistics ---\r\n",
                               au1String);
                }

                else

                {
                    CliPrintf (CliHandle,
                               "\r\n--- %s two-way frame delay statistics ---\r\n",
                               au1String);
                }
                b1Header = ECFM_FALSE;
            }

            /* Move to next entry */
            i4RetVal =
                nmhGetNextIndexFsMIY1731FdTable (u4ContextId,
                                                 &u4NextContextId,
                                                 u4MdIndex,
                                                 &u4NextMdIndex,
                                                 u4MaIndex,
                                                 &u4NextMaIndex,
                                                 u4MepIdentifier,
                                                 &u4NextMepIdentifier,
                                                 u4TransId,
                                                 &u4NextTransId,
                                                 u4SeqNum, &u4NextSeqNum);
            if ((u4ContextId == u4NextContextId)
                && (u4MdIndex == u4NextMdIndex)
                && (u4MaIndex == u4NextMaIndex)
                && (u4MepIdentifier == u4NextMepIdentifier))

            {
                if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

                {
                    b1PrintStats = ECFM_TRUE;
                }
            }

            else

            {
                b1SameContext = ECFM_FALSE;
                b1PrintStats = ECFM_TRUE;
            }
            if (b1PrintStats == ECFM_TRUE)

            {
                nmhGetFsMIY1731FdMeasurementTimeStamp (u4ConId, u4MdId,
                                                       u4MaId, u4MepId,
                                                       u4TransId,
                                                       u4SeqNum,
                                                       &u4RetMeasurementTime);
                u4TempFDSeqNum = u4SeqNum;

                /*Check if the Received Time Stamp is zero or not and 
                 * if it is zero get the last non zero value*/
                while (u4RetMeasurementTime == ECFM_INIT_VAL)

                {
                    if (u4TempFDSeqNum == ECFM_INIT_VAL)

                    {
                        break;
                    }
                    nmhGetFsMIY1731FdMeasurementTimeStamp (u4ConId,
                                                           u4MdId,
                                                           u4MaId,
                                                           u4MepId,
                                                           u4TransId,
                                                           u4TempFDSeqNum,
                                                           &u4RetMeasurementTime);
                    u4TempFDSeqNum = u4TempFDSeqNum - 1;
                }
                if (u4RetMeasurementTime == ECFM_INIT_VAL)

                {
                    CliPrintf (CliHandle, "timestamp = NA,");
                }

                else

                {
                    ECFM_MEMSET (au1Date, ECFM_INIT_VAL, sizeof (au1Date));
                    ltime = (INT4) u4RetMeasurementTime;
                    /* ctime() function converts the time value pointed to by time to local time 
                     * in the form of a character string. The string result that is produced by 
                     * ctime() contains exactly 26 characters and has the format 
                     * "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n". Because of this new line character, 
                     * mep Id and defect type are coming in the next line. To avoid this 
                     * subtracting the string length by 1.*/

                    MEMCPY (au1Date, ctime (&ltime),
                            (STRLEN (ctime (&ltime)) - ECFM_VAL_1));
                    CliPrintf (CliHandle, "timestamp = %s,", au1Date);
                }
                if (i4RetDmType == ECFM_LBLT_DM_TYPE_DMM)

                {
                    u4DmSent = ECFM_INIT_VAL;
                    nmhGetFsMIY1731FdStatsDmmOut (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4DmSent);
                    CliPrintf (CliHandle, " packets sent = %d,", u4DmSent);
                }
                u4DmrRcvd = ECFM_INIT_VAL;
                nmhGetFsMIY1731FdStatsDmrIn (u4ConId, u4MdId, u4MaId,
                                             u4MepId, u4TransId, &u4DmrRcvd);
                CliPrintf (CliHandle, " packets received = %d,\r\n", u4DmrRcvd);
                
		if (ECFM_LBLT_SELECT_CONTEXT (u4ContextId) == ECFM_SUCCESS)

		{
			pFdNode = EcfmSnmpLwGetFrmDelayTransEntry (u4MdId, u4MaId,
					u4MepId, u4TransId);
		}

                if (pFdNode != NULL)
                {
                    RetFarEndDelayValue.pu1_OctetList = FarEndDelayVal;
                    RetFarEndDelayValue.i4_Length = 0;

                    EcfmSnmpLwGetDmTransactionStats (pFdNode, NULL, NULL, NULL, NULL,NULL, NULL,
                                                    &RetFarEndDelayValue, NULL, NULL, NULL);

                    ECFM_GET_4BYTE (u4DelayInSec, RetFarEndDelayValue.pu1_OctetList);
                    ECFM_GET_4BYTE (u4DelayInNanoSec, RetFarEndDelayValue.pu1_OctetList);
                    f4DelayInMs = (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                        (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                    SPRINTF ((CHR1 *) au1FarEndDelayVal, "%f", f4DelayInMs);
                    u4DelayInNanoSecFarEnd = u4DelayInNanoSec;
                    au1FarEndDelayVal[ECFM_INDEX_FIVE] = 'm';
                    au1FarEndDelayVal[ECFM_INDEX_SIX] = 's';
                    au1FarEndDelayVal[ECFM_INDEX_SEVEN] = '\0';
                    u4DelayInSec = ECFM_INIT_VAL;
                    u4DelayInNanoSec = ECFM_INIT_VAL;
                    f4DelayInMs = 0.0;

                    RetFarEndDelayVariation.pu1_OctetList = FarEndDelayVar;
                    RetFarEndDelayVariation.i4_Length = 0;

                    EcfmSnmpLwGetDmTransactionStats (pFdNode, NULL, NULL, NULL, NULL,NULL, NULL,
                                                    NULL, &RetFarEndDelayVariation, NULL, NULL);

                    ECFM_GET_4BYTE (u4DelayInSec, RetFarEndDelayVariation.pu1_OctetList);
                    ECFM_GET_4BYTE (u4DelayInNanoSec, RetFarEndDelayVariation.pu1_OctetList);
                    f4DelayInMs = (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                        (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                    SPRINTF ((CHR1 *) au1FarEndDelayVar, "%f", f4DelayInMs);
                    u4DelayInNanoSecFarEnd = u4DelayInNanoSec;
                    au1FarEndDelayVar[ECFM_INDEX_FIVE] = 'm';
                    au1FarEndDelayVar[ECFM_INDEX_SIX] = 's';
                    au1FarEndDelayVar[ECFM_INDEX_SEVEN] = '\0';
                    u4DelayInSec = ECFM_INIT_VAL;
                    u4DelayInNanoSec = ECFM_INIT_VAL;
                    f4DelayInMs = 0.0;

                    RetNearEndDelayValue.pu1_OctetList = NearEndDelayVal;
                    RetNearEndDelayValue.i4_Length = 0;

                    EcfmSnmpLwGetDmTransactionStats (pFdNode, NULL, NULL, NULL, NULL,NULL, NULL,
                                                    NULL, NULL, &RetNearEndDelayValue, NULL);

                    ECFM_GET_4BYTE (u4DelayInSec, RetNearEndDelayValue.pu1_OctetList);
                    ECFM_GET_4BYTE (u4DelayInNanoSec, RetNearEndDelayValue.pu1_OctetList);
                    f4DelayInMs = (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                        (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                    SPRINTF ((CHR1 *) au1NearEndDelayVal, "%f", f4DelayInMs);
                    u4DelayInNanoSecNearEnd = u4DelayInNanoSec;
                    au1NearEndDelayVal[ECFM_INDEX_FIVE] = 'm';
                    au1NearEndDelayVal[ECFM_INDEX_SIX] = 's';
                    au1NearEndDelayVal[ECFM_INDEX_SEVEN] = '\0';
                    u4DelayInSec = ECFM_INIT_VAL;
                    u4DelayInNanoSec = ECFM_INIT_VAL;
                    f4DelayInMs = 0.0;

                    RetNearEndDelayVariation.pu1_OctetList = NearEndDelayVar;
                    RetNearEndDelayVariation.i4_Length = 0;

                    EcfmSnmpLwGetDmTransactionStats (pFdNode, NULL, NULL, NULL, NULL,NULL, NULL,
                                                    NULL, NULL, NULL, &RetNearEndDelayVariation);

                    ECFM_GET_4BYTE (u4DelayInSec, RetNearEndDelayVariation.pu1_OctetList);
                    ECFM_GET_4BYTE (u4DelayInNanoSec, RetNearEndDelayVariation.pu1_OctetList);
                    f4DelayInMs = (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                        (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                    SPRINTF ((CHR1 *) au1NearEndDelayVar, "%f", f4DelayInMs);
                    u4DelayInNanoSecNearEnd = u4DelayInNanoSec;
                    au1NearEndDelayVar[ECFM_INDEX_FIVE] = 'm';
                    au1NearEndDelayVar[ECFM_INDEX_SIX] = 's';
                    au1NearEndDelayVar[ECFM_INDEX_SEVEN] = '\0';
                    u4DelayInSec = ECFM_INIT_VAL;
                    u4DelayInNanoSec = ECFM_INIT_VAL;
                    f4DelayInMs = 0.0;

                    CliPrintf (CliHandle,
                            "Far End delay value/Variation/Variation in ns = %s/%s/%dns,\r\n",
                            au1FarEndDelayVal, au1FarEndDelayVar,u4DelayInNanoSecFarEnd);

                    CliPrintf (CliHandle,
                            "Near End delay value/Variation/Variation in ns = %s/%s/%dns,\r\n",
                            au1NearEndDelayVal, au1NearEndDelayVar,u4DelayInNanoSecNearEnd);
                }
		ECFM_LBLT_RELEASE_CONTEXT ();
                /* Get the Min,Avg and Max Delay Value */
                ECFM_MEMSET (au1DelayMin, ECFM_INIT_VAL, sizeof (au1DelayMin));
                ECFM_MEMSET (au1DelayMax, ECFM_INIT_VAL, sizeof (au1DelayMax));
                ECFM_MEMSET (au1DelayAvg, ECFM_INIT_VAL, sizeof (au1DelayAvg));
                ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, sizeof (au1RetDelay));
                ECFM_MEMSET (&RetMinDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetMaxDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetAvgDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetMinDelay.pu1_OctetList = au1RetDelay;
                RetMinDelay.i4_Length = 0;
                RetAvgDelay.pu1_OctetList = au1RetDelay;
                RetAvgDelay.i4_Length = 0;
                RetMaxDelay.pu1_OctetList = au1RetDelay;
                RetMaxDelay.i4_Length = 0;
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayMin (u4ConId, u4MdId, u4MaId,
                                                u4MepId, u4TransId,
                                                &RetMinDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetMinDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetMinDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayMin, "%f", f4DelayInMs);
                u4DelayInNanoSecMinDelay = u4DelayInNanoSec;
                au1DelayMin[ECFM_INDEX_FIVE] = 'm';
                au1DelayMin[ECFM_INDEX_SIX] = 's';
                au1DelayMin[ECFM_INDEX_SEVEN] = '\0';
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayAverage (u4ConId, u4MdId,
                                                    u4MaId, u4MepId,
                                                    u4TransId, &RetAvgDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetAvgDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetAvgDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayAvg, "%f", f4DelayInMs);
                u4DelayInNanoSecAvgDelay = u4DelayInNanoSec;
                au1DelayAvg[ECFM_INDEX_FIVE] = 'm';
                au1DelayAvg[ECFM_INDEX_SIX] = 's';
                au1DelayAvg[ECFM_INDEX_SEVEN] = '\0';
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayMax (u4ConId, u4MdId, u4MaId,
                                                u4MepId, u4TransId,
                                                &RetMaxDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetMaxDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetMaxDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayMax, "%f", f4DelayInMs);
                u4DelayInNanoSecMaxDelay = u4DelayInNanoSec;
                au1DelayMax[ECFM_INDEX_FIVE] = 'm';
                au1DelayMax[ECFM_INDEX_SIX] = 's';
                au1DelayMax[ECFM_INDEX_SEVEN] = '\0';
                CliPrintf (CliHandle,
                           "delay min/avg/max/delay in ms min/av/max = %s/%s/%s/%dns/%dns/%dns,\r\n",
                           au1DelayMin, au1DelayAvg, au1DelayMax,u4DelayInNanoSecMinDelay,u4DelayInNanoSecAvgDelay,u4DelayInNanoSecMaxDelay);

                /* Get the Avg IFDV and FDV Value */
                ECFM_MEMSET (au1IFDVAvg, ECFM_INIT_VAL, sizeof (au1IFDVAvg));
                ECFM_MEMSET (au1FDVAvg, ECFM_INIT_VAL, sizeof (au1FDVAvg));
                ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, ECFM_VAL_8);
                ECFM_MEMSET (&RetIFDVDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetFDVDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetIFDVDelay.pu1_OctetList = au1RetDelay;
                RetIFDVDelay.i4_Length = 0;
                RetFDVDelay.pu1_OctetList = au1RetDelay;
                RetFDVDelay.i4_Length = 0;
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsIFDVAverage (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId, &RetIFDVDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetIFDVDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetIFDVDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1IFDVAvg, "%f", f4DelayInMs);
                u4DelayInNanoSecIFDV = u4DelayInNanoSec;
                au1IFDVAvg[ECFM_INDEX_FIVE] = 'm';
                au1IFDVAvg[ECFM_INDEX_SIX] = 's';
                au1IFDVAvg[ECFM_INDEX_SEVEN] = '\0';
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsFDVAverage (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &RetFDVDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetFDVDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetFDVDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1FDVAvg, "%f", f4DelayInMs);
                u4DelayInNanoSecFDV = u4DelayInNanoSec;
                au1FDVAvg[ECFM_INDEX_FIVE] = 'm';
                au1FDVAvg[ECFM_INDEX_SIX] = 's';
                au1FDVAvg[ECFM_INDEX_SEVEN] = '\0';
                CliPrintf (CliHandle,
                           "variation avg IFDV/FDV = %s/%s In Nanoseconds =%dns/%dns\r\n",
                           au1IFDVAvg, au1FDVAvg,u4DelayInNanoSecIFDV,u4DelayInNanoSecFDV);
                b1Header = ECFM_TRUE;
                b1PrintStats = ECFM_FALSE;
            }
            u4TransId = u4NextTransId;
            u4SeqNum = u4NextSeqNum;
            b1PrintStats = ECFM_FALSE;
        }
    }

    /* Show the detailed info */
    else

    {
        u4MdIndex = u4MdId;
        u4MaIndex = u4MaId;
        u4MepIdentifier = u4MepId;
        u4ContextId = u4ConId;

        /* Check for FD entry for a MEP */
        i4RetVal =
            nmhGetNextIndexFsMIY1731FdTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier, 0,
                                             &u4TransId, 0, &u4SeqNum);
        if (i4RetVal == SNMP_SUCCESS)

        {

            /* Entry is for this particular MEP */
            if ((u4ContextId != u4NextContextId) &&
                (u4MdIndex != u4NextMdIndex) &&
                (u4MaIndex != u4NextMaIndex) &&
                (u4MepIdentifier != u4NextMepIdentifier))

            {
                b1SameContext = ECFM_FALSE;
            }
        }
        if (pu1PeerMacAddr != NULL)
        {
            ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            StrToMac ((UINT1 *) pu1PeerMacAddr, MacAddr);
        }

        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE) &&
               (u4Entries < ECFM_FD_BUFFER_SIZE_MAX))

        {
            /* Get Peer Mac Address */
            ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            nmhGetFsMIY1731FdPeerMepMacAddress (u4ContextId, u4MdIndex,
                                                u4MaIndex,
                                                u4MepIdentifier,
                                                u4TransId, u4SeqNum,
                                                &RetMacAddr);

            if ((pu1PeerMacAddr != NULL)
                && (ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) !=
                    0))
            {
                /* Move to next entry */
                i4RetVal =
                    nmhGetNextIndexFsMIY1731FdTable (u4ContextId,
                                                     &u4NextContextId,
                                                     u4MdIndex, &u4NextMdIndex,
                                                     u4MaIndex, &u4NextMaIndex,
                                                     u4MepIdentifier,
                                                     &u4NextMepIdentifier,
                                                     u4TransId, &u4NextTransId,
                                                     u4SeqNum, &u4NextSeqNum);

                if ((u4ContextId != u4NextContextId)
                    && (u4MdIndex != u4NextMdIndex)
                    && (u4MaIndex != u4NextMaIndex)
                    && (u4MepIdentifier != u4NextMepIdentifier))

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4TransId = u4NextTransId;
                u4SeqNum = u4NextSeqNum;
                continue;
            }

            if (b1Header == ECFM_TRUE)

            {
                CliPrintf (CliHandle, "\r\n%-20s%-15s%-11s%-11s\r\n",
                           "peer mac-address", "frame-delay", "IFDV", "FDV");
                CliPrintf (CliHandle, "%-20s%-15s%-11s%-11s\r\n",
                           "-----------------", "-----------", "----", "---");
                b1Header = ECFM_FALSE;
            }

            PrintMacAddress (RetMacAddr, au1String);
            CliPrintf (CliHandle, "%-20s", au1String);

            /* Get the Delay Value */
            ECFM_MEMSET (au1DelayValue, ECFM_INIT_VAL, sizeof (au1DelayValue));
            ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, sizeof (au1RetDelay));
            ECFM_MEMSET (&RetDelay, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetDelay.pu1_OctetList = au1RetDelay;
            RetDelay.i4_Length = 0;
            u4DelayInSec = ECFM_INIT_VAL;
            u4DelayInNanoSec = ECFM_INIT_VAL;
            f4DelayInMs = 0.0;
            nmhGetFsMIY1731FdDelayValue (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4TransId, u4SeqNum, &RetDelay);
            ECFM_GET_4BYTE (u4DelayInSec, RetDelay.pu1_OctetList);
            ECFM_GET_4BYTE (u4DelayInNanoSec, RetDelay.pu1_OctetList);
            f4DelayInMs =
                (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
            SPRINTF ((CHR1 *) au1DelayValue, "%f", f4DelayInMs);
            au1DelayValue[ECFM_INDEX_FIVE] = 'm';
            au1DelayValue[ECFM_INDEX_SIX] = 's';
            au1DelayValue[ECFM_INDEX_SEVEN] = '\0';
            CliPrintf (CliHandle, "%-11s", au1DelayValue);
            CliPrintf (CliHandle, "%4s", " ");

            /* Get the IFDV Value */
            ECFM_MEMSET (au1DelayValue, ECFM_INIT_VAL, sizeof (au1DelayValue));
            ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, sizeof (au1RetDelay));
            ECFM_MEMSET (&RetIFDVDelay, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetIFDVDelay.pu1_OctetList = au1RetDelay;
            RetIFDVDelay.i4_Length = 0;
            u4DelayInSec = ECFM_INIT_VAL;
            u4DelayInNanoSec = ECFM_INIT_VAL;
            f4DelayInMs = 0.0;
            nmhGetFsMIY1731FdIFDV (u4ContextId, u4MdIndex, u4MaIndex,
                                   u4MepIdentifier, u4TransId, u4SeqNum,
                                   &RetIFDVDelay);
            ECFM_GET_4BYTE (u4DelayInSec, RetIFDVDelay.pu1_OctetList);
            ECFM_GET_4BYTE (u4DelayInNanoSec, RetIFDVDelay.pu1_OctetList);
            f4DelayInMs =
                (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
            SPRINTF ((CHR1 *) au1DelayValue, "%f", f4DelayInMs);
            au1DelayValue[ECFM_INDEX_FIVE] = 'm';
            au1DelayValue[ECFM_INDEX_SIX] = 's';
            au1DelayValue[ECFM_INDEX_SEVEN] = '\0';
            CliPrintf (CliHandle, "%-11s", au1DelayValue);

            /* Get the FDV Value */
            ECFM_MEMSET (au1DelayValue, ECFM_INIT_VAL, sizeof (au1DelayValue));
            ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, sizeof (au1RetDelay));
            ECFM_MEMSET (&RetFDVDelay, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetFDVDelay.pu1_OctetList = au1RetDelay;
            RetFDVDelay.i4_Length = 0;
            u4DelayInSec = ECFM_INIT_VAL;
            u4DelayInNanoSec = ECFM_INIT_VAL;
            f4DelayInMs = 0.0;
            nmhGetFsMIY1731FdFDV (u4ContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, u4TransId, u4SeqNum,
                                  &RetFDVDelay);
            ECFM_GET_4BYTE (u4DelayInSec, RetFDVDelay.pu1_OctetList);
            ECFM_GET_4BYTE (u4DelayInNanoSec, RetFDVDelay.pu1_OctetList);
            f4DelayInMs =
                (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
            SPRINTF ((CHR1 *) au1DelayValue, "%f", f4DelayInMs);
            au1DelayValue[ECFM_INDEX_FIVE] = 'm';
            au1DelayValue[ECFM_INDEX_SIX] = 's';
            au1DelayValue[ECFM_INDEX_SEVEN] = '\0';
            CliPrintf (CliHandle, "%-11s\r\n", au1DelayValue);

            /* Move to next entry */
            i4RetVal =
                nmhGetNextIndexFsMIY1731FdTable (u4ContextId,
                                                 &u4NextContextId,
                                                 u4MdIndex,
                                                 &u4NextMdIndex,
                                                 u4MaIndex,
                                                 &u4NextMaIndex,
                                                 u4MepIdentifier,
                                                 &u4NextMepIdentifier,
                                                 u4TransId,
                                                 &u4NextTransId,
                                                 u4SeqNum, &u4NextSeqNum);
            if ((u4ContextId == u4NextContextId)
                && (u4MdIndex == u4NextMdIndex)
                && (u4MaIndex == u4NextMaIndex)
                && (u4MepIdentifier == u4NextMepIdentifier))

            {
                if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

                {
                    b1PrintStats = ECFM_TRUE;
                }
            }

            else

            {
                b1SameContext = ECFM_FALSE;
                b1PrintStats = ECFM_TRUE;
            }
            u4Entries++;
            if (u4Entries == ECFM_FD_BUFFER_SIZE_MAX)
            {
                b1PrintStats = ECFM_TRUE;
            }
            if (b1PrintStats == ECFM_TRUE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                nmhGetFsMIEcfmMepMacAddress (u4ConId, u4MdId, u4MaId,
                                             u4MepId, &RetMacAddr);
                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                nmhGetFsMIY1731FdMeasurementType (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, u4SeqNum,
                                                  &i4RetDmType);
                PrintMacAddress (RetMacAddr, au1String);
                au1String[ECFM_INDEX_SEVENTEEN] = '\0';
                if (i4RetDmType == ECFM_LBLT_DM_TYPE_1DM)

                {
                    CliPrintf (CliHandle,
                               "\r\n--- %s one-way frame delay statistics ---\r\n",
                               au1String);
                }

                else

                {
                    CliPrintf (CliHandle,
                               "\r\n--- %s two-way frame delay statistics ---\r\n",
                               au1String);
                }
                b1Header = ECFM_FALSE;
                nmhGetFsMIY1731FdMeasurementTimeStamp (u4ConId, u4MdId,
                                                       u4MaId, u4MepId,
                                                       u4TransId,
                                                       u4SeqNum,
                                                       &u4RetMeasurementTime);
                u4TempFDSeqNum = u4SeqNum;

                /*Check if the Received Time Stamp is zero or not and 
                 * if it is zero get the last non zero value*/
                while (u4RetMeasurementTime == ECFM_INIT_VAL)

                {
                    if (u4TempFDSeqNum == ECFM_INIT_VAL)

                    {
                        break;
                    }
                    nmhGetFsMIY1731FdMeasurementTimeStamp (u4ConId,
                                                           u4MdId,
                                                           u4MaId,
                                                           u4MepId,
                                                           u4TransId,
                                                           u4TempFDSeqNum,
                                                           &u4RetMeasurementTime);
                    u4TempFDSeqNum = u4TempFDSeqNum - 1;
                }
                if (u4RetMeasurementTime == ECFM_INIT_VAL)

                {
                    CliPrintf (CliHandle, "timestamp = NA,");
                }

                else

                {
                    ECFM_MEMSET (au1Date, ECFM_INIT_VAL, sizeof (au1Date));
                    /* ctime() function converts the time value pointed to by time to local time
                     * in the form of a character string. The string result that is produced by
                     * ctime() contains exactly 26 characters and has the format
                     * "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n". Because of this new line character,
                     * mep Id and defect type are coming in the next line. To avoid this
                     * subtracting the string length by 1.*/
                    ltime = (INT4) u4RetMeasurementTime;
                    MEMCPY (au1Date, ctime (&ltime),
                            (STRLEN (ctime (&ltime)) - ECFM_VAL_1));

                    CliPrintf (CliHandle, "timestamp = %s,", au1Date);
                }
                if (i4RetDmType == ECFM_LBLT_DM_TYPE_DMM)

                {
                    u4DmSent = ECFM_INIT_VAL;
                    nmhGetFsMIY1731FdStatsDmmOut (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4DmSent);
                    CliPrintf (CliHandle, " packets sent = %d,", u4DmSent);
                }
                u4DmrRcvd = ECFM_INIT_VAL;
                nmhGetFsMIY1731FdStatsDmrIn (u4ConId, u4MdId, u4MaId,
                                             u4MepId, u4TransId, &u4DmrRcvd);
                CliPrintf (CliHandle, " packets received = %d,\r\n", u4DmrRcvd);

                /* Get the Min,Avg and Max Delay Value */
                ECFM_MEMSET (au1DelayMin, ECFM_INIT_VAL, sizeof (au1DelayMin));
                ECFM_MEMSET (au1DelayMax, ECFM_INIT_VAL, sizeof (au1DelayMax));
                ECFM_MEMSET (au1DelayAvg, ECFM_INIT_VAL, sizeof (au1DelayAvg));
                ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, 8);
                ECFM_MEMSET (&RetMinDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetMaxDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetAvgDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetMinDelay.pu1_OctetList = au1RetDelay;
                RetMinDelay.i4_Length = 0;
                RetAvgDelay.pu1_OctetList = au1RetDelay;
                RetAvgDelay.i4_Length = 0;
                RetMaxDelay.pu1_OctetList = au1RetDelay;
                RetMaxDelay.i4_Length = 0;
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayMin (u4ConId, u4MdId, u4MaId,
                                                u4MepId, u4TransId,
                                                &RetMinDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetMinDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetMinDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayMin, "%f", f4DelayInMs);
                au1DelayMin[ECFM_INDEX_FIVE] = 'm';
                au1DelayMin[ECFM_INDEX_SIX] = 's';
                au1DelayMin[ECFM_INDEX_SEVEN] = '\0';
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayAverage (u4ConId, u4MdId,
                                                    u4MaId, u4MepId,
                                                    u4TransId, &RetAvgDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetAvgDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetAvgDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayAvg, "%f", f4DelayInMs);
                au1DelayAvg[ECFM_INDEX_FIVE] = 'm';
                au1DelayAvg[ECFM_INDEX_SIX] = 's';
                au1DelayAvg[ECFM_INDEX_SEVEN] = '\0';
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsDelayMax (u4ConId, u4MdId, u4MaId,
                                                u4MepId, u4TransId,
                                                &RetMaxDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetMaxDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetMaxDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1DelayMax, "%f", f4DelayInMs);
                au1DelayMax[ECFM_INDEX_FIVE] = 'm';
                au1DelayMax[ECFM_INDEX_SIX] = 's';
                au1DelayMax[ECFM_INDEX_SEVEN] = '\0';
                CliPrintf (CliHandle,
                           "delay min/avg/max = %s/%s/%s,\r\n",
                           au1DelayMin, au1DelayAvg, au1DelayMax);

                /* Get the Avg IFDV and FDV Value */
                ECFM_MEMSET (au1IFDVAvg, ECFM_INIT_VAL, sizeof (au1IFDVAvg));
                ECFM_MEMSET (au1FDVAvg, ECFM_INIT_VAL, sizeof (au1FDVAvg));
                ECFM_MEMSET (au1RetDelay, ECFM_INIT_VAL, sizeof (au1RetDelay));
                ECFM_MEMSET (&RetIFDVDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                ECFM_MEMSET (&RetFDVDelay, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                RetIFDVDelay.pu1_OctetList = au1RetDelay;
                RetIFDVDelay.i4_Length = 0;
                RetFDVDelay.pu1_OctetList = au1RetDelay;
                RetFDVDelay.i4_Length = 0;
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsIFDVAverage (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId, &RetIFDVDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetIFDVDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetIFDVDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1IFDVAvg, "%f", f4DelayInMs);
                au1IFDVAvg[ECFM_INDEX_FIVE] = 'm';
                au1IFDVAvg[ECFM_INDEX_SIX] = 's';
                au1IFDVAvg[ECFM_INDEX_SEVEN] = '\0';
                u4DelayInSec = ECFM_INIT_VAL;
                u4DelayInNanoSec = ECFM_INIT_VAL;
                f4DelayInMs = 0.0;
                nmhGetFsMIY1731FdStatsFDVAverage (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &RetFDVDelay);
                ECFM_GET_4BYTE (u4DelayInSec, RetFDVDelay.pu1_OctetList);
                ECFM_GET_4BYTE (u4DelayInNanoSec, RetFDVDelay.pu1_OctetList);
                f4DelayInMs =
                    (((FLT4) u4DelayInSec) * ECFM_NUM_OF_MSEC_IN_A_SEC) +
                    (((FLT4) u4DelayInNanoSec) / ECFM_NUM_OF_USEC_IN_A_SEC);
                SPRINTF ((CHR1 *) au1FDVAvg, "%f", f4DelayInMs);
                au1FDVAvg[ECFM_INDEX_FIVE] = 'm';
                au1FDVAvg[ECFM_INDEX_SIX] = 's';
                au1FDVAvg[ECFM_INDEX_SEVEN] = '\0';
                CliPrintf (CliHandle,
                           "variation avg IFDV/FDV = %s/%s\r\n",
                           au1IFDVAvg, au1FDVAvg);
                b1Header = ECFM_TRUE;
                b1PrintStats = ECFM_FALSE;
            }
            u4TransId = u4NextTransId;
            u4SeqNum = u4NextSeqNum;
            b1PrintStats = ECFM_FALSE;
        }
    }
    return;
}

/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowLbrCache
 *                                                                          
 *     DESCRIPTION      : This function will display the contents of the LBR
 *                        cache.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Command   - Command Type
 *                        pu1Arg1 -  
 *                        pu1Arg2 - 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        pu1MdName   - MD name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowLbrCache (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4Command, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                     UINT1 *pu1MdName)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SavedMdIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevTransId = ECFM_INIT_VAL;
    UINT4               u4PrevSeqNum = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4SavedContextId = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Brief = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    i4CurrentContextId = (INT4) u4ContextId;

    while ((nmhGetNextIndexFsMIY1731LbmTable (i4CurrentContextId,
                                              (UINT4 *)
                                              &i4NextContextId,
                                              u4PrevMdIndex, &u4MdIndex,
                                              u4PrevMaIndex, &u4MaIndex,
                                              u4PrevMepIdentifier,
                                              &u4MepIdentifier,
                                              u4PrevTransId, &u4TransId,
                                              u4PrevSeqNum,
                                              &u4SeqNum) ==
            SNMP_SUCCESS) && (i4CurrentContextId == i4NextContextId)
           && (b1ShowAll == ECFM_TRUE))

    {

        /* Compare the entry indices with saved one, Means one LBM entry is
         * already showed for a MEP */
        if ((i4SavedContextId == i4NextContextId) &&
            (u4SavedMdIndex == u4MdIndex) &&
            (u4SavedMaIndex == u4MaIndex) &&
            (u4SavedMepIdentifier == u4MepIdentifier))

        {

            /* skip this entry, as a LBM is already shown with this MEP entry */
            u4PrevMdIndex = u4MdIndex;
            u4PrevMaIndex = u4MaIndex;
            u4PrevMepIdentifier = u4MepIdentifier;
            u4PrevTransId = u4TransId;
            u4PrevSeqNum = u4SeqNum;
            b1Entry = ECFM_FALSE;
            continue;
        }
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();

        ECFM_MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));

        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;

        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_UNAWARE:
                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && (i4RetMaPrimaryVid == 0))

                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_SER:
                /* Get Input parameters according to type of the command */
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL))
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM_ISID:
                /* Get Input parameters according to type of the command */
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_ISID:

                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))

                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV:
                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((UINT4) (i4RetMdLevel) == u4MdLevel)

                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_DOM:
                if (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_ISID:
                /* Get Input parameters according to type of the command */
                i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetPrimaryVid == i4VlanId) ||
                    (i4RetMaPrimaryVid == i4VlanId))
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_SER:
                /* Get Input parameters according to type of the command */
                if (ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL)
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_UNAWARE:
                /* Get Input parameters according to type of the command */
                if (i4RetMaPrimaryVid == 0)
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_SER:
                MEMCPY (&u4MdLevel, pu1Arg1, sizeof (UINT4));
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF_ON_LEV_SER:
                MEMCPY (&u4MdLevel, pu1Arg1, sizeof (UINT4));
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == 0))
                {
                    b1Brief = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_BRIEF:

                /* Get Input parameters according to type of the command */
                b1Brief = ECFM_TRUE;
                b1Entry = ECFM_TRUE;
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_UNAWARE:
                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && (i4RetMaPrimaryVid == 0))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_ISID:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM_SER:
                /* Get Input parameters according to type of the command */
                if ((ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_ISID:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV_VSI:
                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)))
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_LEV:
                /* Get Input parameters according to type of the command */
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((UINT4) (i4RetMdLevel) == u4MdLevel)
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_DOM:
                /* Get Input parameters according to type of the command */
                if (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_VLAN:
            case CLI_ECFM_SHOW_LBRCACHE_ON_VSI:
            case CLI_ECFM_SHOW_LBRCACHE_ON_ISID:
                /* Get Input parameters according to type of the command */
                i4VlanId = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetPrimaryVid == i4VlanId) ||
                    (i4RetMaPrimaryVid == i4VlanId))

                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_SER:
                /* Get Input parameters according to type of the command */
                if (ECFM_STRCMP (au1StrMaName, pu1Arg1) == ECFM_INIT_VAL)
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE_ON_UNAWARE:
                /* Get Input parameters according to type of the command */
                if (i4RetMaPrimaryVid == 0)
                {
                    b1Brief = ECFM_FALSE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_LBRCACHE:
                /* Get Input parameters according to type of the command */
                b1Brief = ECFM_FALSE;
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            i4SavedContextId = i4CurrentContextId;
            u4SavedMdIndex = u4MdIndex;
            u4SavedMaIndex = u4MaIndex;
            u4SavedMepIdentifier = u4MepIdentifier;

            if (b1Brief == ECFM_TRUE)
            {
                EcfmDisplayLbrCacheBrief (CliHandle, i4CurrentContextId,
                                          u4MdIndex, u4MaIndex,
                                          u4MepIdentifier, ECFM_TRUE);
            }
            else
            {
                EcfmDisplayLbrCache (CliHandle, i4CurrentContextId,
                                     u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, ECFM_TRUE);
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to Next entry */
        u4PrevMdIndex = u4MdIndex;
        u4PrevMaIndex = u4MaIndex;
        u4PrevMepIdentifier = u4MepIdentifier;
        u4PrevTransId = u4TransId;
        u4PrevSeqNum = u4SeqNum;
        b1Entry = ECFM_FALSE;
        if (u4PagingStatus == CLI_FAILURE)

        {
            b1ShowAll = ECFM_FALSE;
        }
    }
    CliPrintf (CliHandle, "\n");
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayLbrCacheBrief
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the LBR
 *                        cache.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *                        b1MepHeader - Header to be show or not
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayLbrCacheBrief (tCliHandle CliHandle, UINT4 u4ConId,
                          UINT4 u4MdId, UINT4 u4MaId,
                          UINT4 u4MepId, BOOL1 b1MepHeader)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4UnexpLbrIn = ECFM_INIT_VAL;
    UINT4               u4DupMsg = ECFM_INIT_VAL;
    UINT4               u4BadMsg = ECFM_INIT_VAL;
    UINT4               u4ChksumErr = ECFM_INIT_VAL;
    UINT4               u4LbrRcvd = ECFM_INIT_VAL;
    UINT4               u4LbmSent = ECFM_INIT_VAL;
    UINT4               u4RetIfIndex = ECFM_INIT_VAL;
    UINT4               u4AvgLbrsPerResponder = ECFM_INIT_VAL;
    UINT4               u4TotalResponders = ECFM_INIT_VAL;
    UINT4               u4ExpLbrs = ECFM_INIT_VAL;
    UINT4               u4LbrsLost = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT4               u4RetMepId = ECFM_INIT_VAL;
    UINT4               u4RetNodeId = ECFM_INIT_VAL;
    UINT4               u4RetIfNum = ECFM_INIT_VAL;
    UINT4               u4RetTtl = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4MinTime = ECFM_INIT_VAL;
    INT4                i4MaxTime = ECFM_INIT_VAL;
    INT4                i4AvgTime = ECFM_INIT_VAL;
    INT4                i4RetLevel = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetDestType = ECFM_INIT_VAL;
    FLT4                f4PercentageLoss = 0.0;
    UINT2               u2TotalRMeps = ECFM_INIT_VAL;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1PrintStats = ECFM_FALSE;
    UINT1               au1PercentageLoss[ECFM_ARRAY_SIZE_32] = { 0 };
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetIcc[ECFM_CARRIER_CODE_ARRAY_SIZE] = { 0 };
    tEcfmMacAddr        RetMacAddr;
    tSNMP_OCTET_STRING_TYPE RetIcc;

    RetIcc.pu1_OctetList = au1RetIcc;
    RetIcc.i4_Length = 0;
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);

    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;
    u4ContextId = u4ConId;
    u4MdIndex = u4MdId;
    u4MaIndex = u4MaId;
    u4MepIdentifier = u4MepId;
    i4RetVal =
        nmhGetNextIndexFsMIY1731LbmTable (u4ContextId, &u4NextContextId,
                                          u4MdIndex, &u4NextMdIndex,
                                          u4MaIndex, &u4NextMaIndex,
                                          u4MepIdentifier,
                                          &u4NextMepIdentifier, 0,
                                          &u4TransId, 0, &u4SeqNum);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Entry is for this particular MEP */
        if ((u4ContextId != u4NextContextId) &&
            (u4MdIndex != u4NextMdIndex) &&
            (u4MaIndex != u4NextMaIndex) &&
            (u4MepIdentifier != u4NextMepIdentifier))

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* Scan LBR Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4UnexpLbrIn = ECFM_INIT_VAL;
        u4DupMsg = ECFM_INIT_VAL;
        u4BadMsg = ECFM_INIT_VAL;
        u4ChksumErr = ECFM_INIT_VAL;
        u4LbrRcvd = ECFM_INIT_VAL;
        u4LbmSent = ECFM_INIT_VAL;
        u4AvgLbrsPerResponder = ECFM_INIT_VAL;
        u4TotalResponders = ECFM_INIT_VAL;
        u4LbrsLost = ECFM_INIT_VAL;
        u4ExpLbrs = ECFM_INIT_VAL;
        i4MinTime = ECFM_INIT_VAL;
        i4MaxTime = ECFM_INIT_VAL;
        i4AvgTime = ECFM_INIT_VAL;
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetLevel = ECFM_INIT_VAL;
        u4RetIfIndex = ECFM_INIT_VAL;

        if (b1MepHeader == ECFM_TRUE)
        {
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();

            nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         (UINT4 *) &i4RetPrimaryVid);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex,
                                           u4MaIndex, &i4RetMaPrimaryVid);
            nmhGetFsMIEcfmMepIfIndex (u4ContextId, u4MdIndex, u4MaIndex,
                                      u4MepIdentifier, (INT4 *) &u4RetIfIndex);
            nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetLevel);
            nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            CfaCliGetIfName (u4RetIfIndex, pi1IfName);

            nmhGetNextIndexFsMIEcfmExtMaTable (u4ContextId, &u4NextContextId,
                                               u4MdIndex, &u4NextMdIndex,
                                               u4MaIndex, &u4NextMaIndex,
                                               ECFM_VAL_0, &i4NextSelectorType,
                                               ECFM_VAL_0,
                                               &u4NextSelectorOrNone);

            if (ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\nMEP-ID       : %d", u4MepIdentifier);
                CliPrintf (CliHandle, "\r\nService Name : %s", au1StrMaName);
                CliPrintf (CliHandle, "\r\nLevel        : %d", i4RetLevel);
            }
            else
            {
                CliPrintf (CliHandle, "\r\nInterface : %s ", pi1IfName);
                CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepIdentifier);
                CliPrintf (CliHandle, "\r\nLevel     : %d", i4RetLevel);

                if (i4RetPrimaryVid != 0)
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetPrimaryVid);
                    }
                    else if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#else
                    if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#endif
                    {

                        CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                                   i4RetPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                    }
                }
                else
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#else
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#endif
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                                   i4RetMaPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                    }
                }

                if (i4RetPrimaryVid != 0)
                {
                    if (i4RetPrimaryVid > ECFM_INTERNAL_ISID_MIN)
                    {

                        CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetPrimaryVid));
                    }
                    else
                    {

                        CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                    }
                }
                else
                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                    }
                }
            }
            b1MepHeader = ECFM_FALSE;
        }

        if (b1Header == ECFM_TRUE)
        {
            if (ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\nping statistics with \r\n");
                /* Sent MEP Id or MIP Information to be printed */
                nmhGetFsMIY1731LbmDestType (u4ContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            u4TransId, u4SeqNum,
                                            &i4RetDestType);
                if (i4RetDestType == ECFM_TX_DEST_TYPE_MEPID)
                {
                    nmhGetFsMIY1731LbmDestMepId (u4ContextId, u4MdIndex,
                                                 u4MaIndex, u4MepIdentifier,
                                                 u4TransId, u4SeqNum,
                                                 &u4RetMepId);
                    CliPrintf (CliHandle, "\r\n MepId = %d", u4RetMepId);
                }
                else if (i4RetDestType == ECFM_TX_DEST_TYPE_MIPID)
                {
                    ECFM_MEMSET (au1RetIcc, ECFM_INIT_VAL,
                                 ECFM_CARRIER_CODE_ARRAY_SIZE);
                    nmhGetFsMIY1731LbmIcc (u4ContextId, u4MdIndex,
                                           u4MaIndex, u4MepIdentifier,
                                           u4TransId, u4SeqNum, &RetIcc);
                    MEMCPY (au1RetIcc, RetIcc.pu1_OctetList, RetIcc.i4_Length);
                    nmhGetFsMIY1731LbmNodeId (u4ContextId, u4MdIndex,
                                              u4MaIndex, u4MepIdentifier,
                                              u4TransId, u4SeqNum,
                                              &u4RetNodeId);
                    nmhGetFsMIY1731LbmIfNum (u4ContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             u4TransId, u4SeqNum, &u4RetIfNum);
                    CliPrintf (CliHandle, "\r\n MIP Info: ICC: %s  NodeId: %u "
                               "IfNum: %u\r\n", au1RetIcc,
                               u4RetNodeId, u4RetIfNum);
                }
                nmhGetFsMIY1731LbmTTL (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier,
                                       u4TransId, u4SeqNum, &u4RetTtl);
                CliPrintf (CliHandle, "\r\n TTL = %d", u4RetTtl);
            }
            else
            {
                ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                nmhGetFsMIY1731LbmTargetMacAddress (u4ContextId, u4MdIndex,
                                                    u4MaIndex,
                                                    u4MepIdentifier,
                                                    u4TransId, u4SeqNum,
                                                    &RetMacAddr);
                PrintMacAddress (RetMacAddr, au1String);
                nmhGetFsMIY1731LbmDestType (u4ContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            u4TransId, u4SeqNum,
                                            &i4RetDestType);
                if (i4RetDestType == ECFM_TX_DEST_TYPE_MEPID)
                {
                    nmhGetFsMIY1731LbmDestMepId (u4ContextId, u4MdIndex,
                                                 u4MaIndex, u4MepIdentifier,
                                                 u4TransId, u4SeqNum,
                                                 &u4RetMepId);

                    CliPrintf (CliHandle,
                               "\r\nping statistics with %s RMepId %u",
                               au1String, u4RetMepId);
                }
                else
                {

                    CliPrintf (CliHandle, "\r\nping statistics with %s ",
                               au1String);
                }
            }
            b1Header = ECFM_FALSE;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731LbmTable (u4ContextId,
                                              &u4NextContextId,
                                              u4MdIndex, &u4NextMdIndex,
                                              u4MaIndex, &u4NextMaIndex,
                                              u4MepIdentifier,
                                              &u4NextMepIdentifier,
                                              u4TransId, &u4NextTransId,
                                              u4SeqNum, &u4NextSeqNum);
        if ((u4ContextId == u4NextContextId)
            && (u4MdIndex == u4NextMdIndex)
            && (u4MaIndex == u4NextMaIndex)
            && (u4MepIdentifier == u4NextMepIdentifier))

        {
            if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

            {
                b1PrintStats = ECFM_TRUE;
            }
        }

        else

        {
            b1SameContext = ECFM_FALSE;
            b1PrintStats = ECFM_TRUE;
        }
        if (b1PrintStats == ECFM_TRUE)

        {
            nmhGetFsMIY1731LbStatsLbmOut (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4TransId, &u4LbmSent);
            EcfmGetInvalidLbrsCount (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     &u4UnexpLbrIn, &u4DupMsg);
            EcfmGetErroredLbrsCount (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     &u4ChksumErr, &u4BadMsg);
            nmhGetFsMIY1731LbStatsLbrIn (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4TransId, &u4LbrRcvd);
            nmhGetFsMIY1731LbStatsLbrTimeMin (u4ContextId, u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              u4TransId, &i4MinTime);
            nmhGetFsMIY1731LbStatsLbrTimeMax (u4ContextId, u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              u4TransId, &i4MaxTime);
            nmhGetFsMIY1731LbStatsLbrTimeAverage (u4ContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier,
                                                  u4TransId, &i4AvgTime);
            nmhGetFsMIY1731LbStatsAvgLbrsPerResponder (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       u4TransId,
                                                       &u4AvgLbrsPerResponder);
            nmhGetFsMIY1731LbStatsTotalResponders (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   u4TransId,
                                                   &u4TotalResponders);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            u2TotalRMeps =
                EcfmGetNumOfRMeps (u4ContextId, u4MdIndex, u4MaIndex,
                                   u4MepIdentifier);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (ECFM_IS_MULTICAST_ADDR (RetMacAddr) == ECFM_TRUE)

            {
                u4ExpLbrs = u2TotalRMeps * u4LbmSent;
                u4LbrsLost = u4ExpLbrs - u4LbrRcvd;
                if (u4ExpLbrs != 0)

                {
                    f4PercentageLoss =
                        ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) / u4ExpLbrs);
                }
            }

            else

            {
                if(u4LbmSent != 0)
                {
                u4LbrsLost = u4LbmSent - u4LbrRcvd;
                f4PercentageLoss =
                    ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) / u4LbmSent);
            }
            }
            CliPrintf (CliHandle, "\r\npackets sent = %d,", u4LbmSent);
            CliPrintf (CliHandle, " packets received = %d,", u4LbrRcvd);
            SPRINTF ((CHR1 *) au1PercentageLoss, "%f", f4PercentageLoss);
            au1PercentageLoss[ECFM_INDEX_FIVE] = '%';
            au1PercentageLoss[ECFM_INDEX_SIX] = '\0';
            CliPrintf (CliHandle, " packets lost  = %d (%s loss), \r\n",
                       u4LbrsLost, au1PercentageLoss);
            CliPrintf (CliHandle, "unexpected received = %d,", u4UnexpLbrIn);
            CliPrintf (CliHandle, " checksum errors = %d,", u4ChksumErr);
            CliPrintf (CliHandle, " bad messages received = %d,", u4BadMsg);
            CliPrintf (CliHandle, "\r\nduplicate received = %d,", u4DupMsg);
            CliPrintf (CliHandle, " responders = %d,", u4TotalResponders);
            CliPrintf (CliHandle,
                       " average packets per responder = %d,",
                       u4AvgLbrsPerResponder);
            CliPrintf (CliHandle,
                       "\r\nrtt min/avg/max = %d/%d/%d ms\r\n",
                       i4MinTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                       i4AvgTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                       i4MaxTime * ECFM_NUM_OF_TICKS_IN_A_MSEC);
            b1Header = ECFM_TRUE;
            b1PrintStats = ECFM_FALSE;
        }
        u4TransId = u4NextTransId;
        u4SeqNum = u4NextSeqNum;
        b1PrintStats = ECFM_FALSE;
    }
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayLbrCache
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the LBR
 *                        cache.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *                        b1MepHeader - Header to be show or not
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayLbrCache (tCliHandle CliHandle, UINT4 u4ConId,
                     UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId,
                     BOOL1 b1MepHeader)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4RcvOrder = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    UINT4               u4NextRcvOrder = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4UnexpLbrIn = ECFM_INIT_VAL;
    UINT4               u4DupMsg = ECFM_INIT_VAL;
    UINT4               u4BadMsg = ECFM_INIT_VAL;
    UINT4               u4ChksumErr = ECFM_INIT_VAL;
    UINT4               u4LbrRcvd = ECFM_INIT_VAL;
    UINT4               u4BytesSent = ECFM_INIT_VAL;
    UINT4               u4LbmSent = ECFM_INIT_VAL;
    UINT4               u4RetIfIndex = ECFM_INIT_VAL;
    UINT4               u4AvgLbrsPerResponder = ECFM_INIT_VAL;
    UINT4               u4TotalResponders = ECFM_INIT_VAL;
    UINT4               u4ExpLbrs = ECFM_INIT_VAL;
    UINT4               u4LbrsLost = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT4               u4RetNodeId = ECFM_INIT_VAL;
    UINT4               u4RetIfNum = ECFM_INIT_VAL;
    UINT4               u4RetMepId = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RcvTime = ECFM_INIT_VAL;
    INT4                i4MinTime = ECFM_INIT_VAL;
    INT4                i4MaxTime = ECFM_INIT_VAL;
    INT4                i4AvgTime = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetLbrErrType = ECFM_INIT_VAL;
    INT4                i4RetLbrCacheSize = ECFM_INIT_VAL;
    INT4                i4RetLevel = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;
    INT4                i4RetDestType = ECFM_INIT_VAL;
    FLT4                f4PercentageLoss = 0.0;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1PrintStats = ECFM_FALSE;
    UINT2               u2TotalRMeps = ECFM_INIT_VAL;
    UINT1               au1PercentageLoss[ECFM_ARRAY_SIZE_32] = { 0 };
    UINT1               au1RcvTime[ECFM_ARRAY_SIZE_32] = { 0 };
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetIcc[ECFM_CARRIER_CODE_ARRAY_SIZE] = { 0 };
    UINT1               u1Temp = ECFM_INIT_VAL;
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        RetTargetMacAddr;
    tSNMP_OCTET_STRING_TYPE RetIcc;

    RetIcc.pu1_OctetList = au1RetIcc;
    RetIcc.i4_Length = 0;
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;
    u4ContextId = u4ConId;
    u4MdIndex = u4MdId;
    u4MaIndex = u4MaId;
    u4MepIdentifier = u4MepId;

    i4RetVal =
        nmhGetNextIndexFsMIY1731LbrTable (u4ContextId, &u4NextContextId,
                                          u4MdIndex, &u4NextMdIndex,
                                          u4MaIndex, &u4NextMaIndex,
                                          u4MepIdentifier,
                                          &u4NextMepIdentifier, 0,
                                          &u4TransId, 0, &u4SeqNum, 0,
                                          &u4RcvOrder);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Entry is for this particular MEP */
        if ((u4ContextId != u4NextContextId) &&
            (u4MdIndex != u4NextMdIndex) &&
            (u4MaIndex != u4NextMaIndex) &&
            (u4MepIdentifier != u4NextMepIdentifier))

        {
            b1SameContext = ECFM_FALSE;
        }
        else
        {
            if (nmhGetFsMIY1731LbrCacheSize (u4ContextId, &i4RetLbrCacheSize)
                != SNMP_FAILURE)
            {
                CliPrintf (CliHandle,
                           "\r\n LBR cache configured maximum size : "
                           "%d entries \r\n", i4RetLbrCacheSize);
            }
        }
    }

    /* Scan LBR Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        u4UnexpLbrIn = ECFM_INIT_VAL;
        u4DupMsg = ECFM_INIT_VAL;
        u4BadMsg = ECFM_INIT_VAL;
        u4ChksumErr = ECFM_INIT_VAL;
        u4LbrRcvd = ECFM_INIT_VAL;
        u4BytesSent = ECFM_INIT_VAL;
        u4LbmSent = ECFM_INIT_VAL;
        u4ExpLbrs = ECFM_INIT_VAL;
        u4LbrsLost = ECFM_INIT_VAL;
        u4AvgLbrsPerResponder = ECFM_INIT_VAL;
        u4TotalResponders = ECFM_INIT_VAL;
        i4RcvTime = ECFM_INIT_VAL;
        i4MinTime = ECFM_INIT_VAL;
        i4MaxTime = ECFM_INIT_VAL;
        i4AvgTime = ECFM_INIT_VAL;
        u4RetIfIndex = ECFM_INIT_VAL;
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetLevel = ECFM_INIT_VAL;
        u1Temp = ECFM_INIT_VAL;

        if (b1MepHeader == ECFM_TRUE)
        {
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         (UINT4 *) &i4RetPrimaryVid);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex,
                                           u4MaIndex, &i4RetMaPrimaryVid);
            nmhGetFsMIEcfmMepIfIndex (u4ContextId, u4MdIndex, u4MaIndex,
                                      u4MepIdentifier, (INT4 *) &u4RetIfIndex);
            nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetLevel);
            nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            CfaCliGetIfName (u4RetIfIndex, pi1IfName);

            nmhGetNextIndexFsMIEcfmExtMaTable (u4ContextId, &u4NextContextId,
                                               u4MdIndex, &u4NextMdIndex,
                                               u4MaIndex, &u4NextMaIndex,
                                               ECFM_VAL_0, &i4NextSelectorType,
                                               ECFM_VAL_0,
                                               &u4NextSelectorOrNone);

            if (ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\nMEP-ID : %d Service Name : %s "
                           "Level : %d", u4MepIdentifier, au1StrMaName,
                           i4RetLevel);
            }
            else
            {
                CliPrintf (CliHandle, "\r\nInterface : %s ", pi1IfName);
                CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepIdentifier);
                CliPrintf (CliHandle, "\r\nLevel     : %d", i4RetLevel);
                if (i4RetPrimaryVid != 0)
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetPrimaryVid);
                    }
                    else if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#else
                    if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#endif
                    {

                        CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                                   i4RetPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                    }

                }
                else
                {
#ifdef VSI_WANTED
                    if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#else
						if ((i4RetMaPrimaryVid != 0)
								&& (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#endif
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                                   i4RetMaPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                    }
                }

                if (i4RetPrimaryVid != 0)
                {

                    if (i4RetPrimaryVid > ECFM_INTERNAL_ISID_MIN)
                    {

                        CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                    }

                }
                else
                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));
                    }
                    else
                    {
                        CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                    }
                }
                b1MepHeader = ECFM_FALSE;
            }
        }

        if (b1Header == ECFM_TRUE)
        {
            nmhGetFsMIY1731LbrDestType (u4ContextId, u4MdIndex, u4MaIndex,
                                        u4MepIdentifier, u4TransId,
                                        u4SeqNum, u4RcvOrder, &i4RetDestType);
            nmhGetFsMIY1731LbrDestMepId (u4ContextId, u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4TransId,
                                         u4SeqNum, u4RcvOrder, &u4RetMepId);
            if (ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType) == ECFM_TRUE)
            {
                /* Get the MEP/MIP info from Lbm Table and print */
                CliPrintf (CliHandle, "\r\nping statistics with MEP/MIP\r\n");
                if (i4RetDestType == ECFM_TX_DEST_TYPE_MEPID)
                {
                    CliPrintf (CliHandle, "\r\n%-6s%-18s%-10s%-18s%-10s\r\n",
                               "RMEP-ID ", " bytes received",
                               " seq no", " time to receive", " error type");
                }
                else
                {
                    CliPrintf (CliHandle, "\r\n%-20s%-18s%-10s%-18s%-10s\r\n",
                               "ICC:  NodeId:  IfNum ", " bytes received",
                               " seq no", " time to receive", " error type");
                }
                CliPrintf (CliHandle, "%-6s%-18s%-10s%-18s%-10s\r\n",
                           "-------", " --------------",
                           " ------", " ---------------", " ----------");
                /* Get the MEP/MIP info from Lbm Table and print */
            }
            else
            {
                ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                nmhGetFsMIY1731LbmTargetMacAddress (u4ContextId, u4MdIndex,
                                                    u4MaIndex,
                                                    u4MepIdentifier,
                                                    u4TransId, u4SeqNum,
                                                    &RetMacAddr);
                PrintMacAddress (RetMacAddr, au1String);
                CliPrintf (CliHandle, "\r\nping statistics with %s", au1String);
                CliPrintf (CliHandle, "\r\n%-20s%-18s%-10s%-18s%-10s\r\n",
                           "source mac-address", " bytes received",
                           " seq no", " time to receive", " error type");
                CliPrintf (CliHandle, "%-20s%-18s%-10s%-18s%-10s\r\n",
                           "------------------", " --------------",
                           " ------", " ---------------", " ----------");
            }
            b1Header = ECFM_FALSE;
        }

        if (ECFM_IS_SELECTOR_TYPE_MPLS_TP (i4NextSelectorType) == ECFM_TRUE)
        {
            /* Print MEP/MIP Info and align the column */
            if (i4RetDestType == ECFM_TX_DEST_TYPE_MEPID)
            {
                CliPrintf (CliHandle, "%-20d", u4RetMepId);
            }
            if (i4RetDestType == ECFM_TX_DEST_TYPE_MIPID)
            {
                ECFM_MEMSET (au1RetIcc, ECFM_INIT_VAL,
                             ECFM_CARRIER_CODE_ARRAY_SIZE);
                nmhGetFsMIY1731LbrICC (u4ContextId, u4MdIndex, u4MaIndex,
                                       u4MepIdentifier, u4TransId,
                                       u4SeqNum, u4RcvOrder, &RetIcc);
                MEMCPY (au1RetIcc, RetIcc.pu1_OctetList, RetIcc.i4_Length);
                CliPrintf (CliHandle, "%-8s", au1RetIcc);
                nmhGetFsMIY1731LbrNodeId (u4ContextId, u4MdIndex, u4MaIndex,
                                          u4MepIdentifier, u4TransId,
                                          u4SeqNum, u4RcvOrder, &u4RetNodeId);
                CliPrintf (CliHandle, "%s-5d", u4RetNodeId);
                nmhGetFsMIY1731LbrIfNum (u4ContextId, u4MdIndex, u4MaIndex,
                                         u4MepIdentifier, u4TransId,
                                         u4SeqNum, u4RcvOrder, &u4RetIfNum);
                CliPrintf (CliHandle, "%s-5d", u4RetIfNum);
            }
        }
        else
        {
            ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            nmhGetFsMIY1731LbrResponderMacAddress
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4TransId, u4SeqNum, u4RcvOrder, &RetMacAddr);
            PrintMacAddress (RetMacAddr, au1String);
            CliPrintf (CliHandle, "%-21s", au1String);
        }
        nmhGetFsMIY1731LbmBytesSent (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     u4SeqNum, &u4BytesSent);
        CliPrintf (CliHandle, "%-18d", u4BytesSent);
        CliPrintf (CliHandle, "%-10d", u4SeqNum);
        ECFM_MEMSET (au1RcvTime, ECFM_INIT_VAL, sizeof (au1RcvTime));
        nmhGetFsMIY1731LbrReceiveTime (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepIdentifier,
                                       u4TransId, u4SeqNum, u4RcvOrder,
                                       &i4RcvTime);
        SPRINTF ((CHR1 *) au1RcvTime, "%d",
                 i4RcvTime * ECFM_NUM_OF_TICKS_IN_A_MSEC);
        while (au1RcvTime[u1Temp++] != '\0');
        u1Temp--;
        au1RcvTime[u1Temp++] = 'm';
        au1RcvTime[u1Temp++] = 's';
        au1RcvTime[u1Temp] = '\0';

        CliPrintf (CliHandle, "%-18s", au1RcvTime);
        nmhGetFsMIY1731LbrErrorType (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     u4SeqNum, u4RcvOrder, &i4RetLbrErrType);
        if (i4RetLbrErrType == ECFM_LBLT_LBR_WITH_BIT_ERR)

        {
            CliPrintf (CliHandle, "%-10s\r\n", "crc32 check");
        }

        else if (i4RetLbrErrType == ECFM_LBLT_LBR_WITH_BAD_MSDU)

        {
            CliPrintf (CliHandle, "%-10s\r\n", "bad msdu");
        }

        else

        {
            CliPrintf (CliHandle, "%-10s\r\n", "none");
        }
        ECFM_MEMSET (RetTargetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        nmhGetFsMIY1731LbmTargetMacAddress (u4ContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            u4TransId, u4SeqNum,
                                            &RetTargetMacAddr);

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731LbrTable (u4ContextId,
                                              &u4NextContextId,
                                              u4MdIndex, &u4NextMdIndex,
                                              u4MaIndex, &u4NextMaIndex,
                                              u4MepIdentifier,
                                              &u4NextMepIdentifier,
                                              u4TransId, &u4NextTransId,
                                              u4SeqNum, &u4NextSeqNum,
                                              u4RcvOrder, &u4NextRcvOrder);
        if ((u4ContextId == u4NextContextId)
            && (u4MdIndex == u4NextMdIndex)
            && (u4MaIndex == u4NextMaIndex)
            && (u4MepIdentifier == u4NextMepIdentifier))

        {
            if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

            {
                b1PrintStats = ECFM_TRUE;
            }
        }

        else

        {
            b1SameContext = ECFM_FALSE;
            b1PrintStats = ECFM_TRUE;
        }
        if (b1PrintStats == ECFM_TRUE)

        {
            nmhGetFsMIY1731LbStatsLbmOut (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4TransId, &u4LbmSent);
            EcfmGetInvalidLbrsCount (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     &u4UnexpLbrIn, &u4DupMsg);
            EcfmGetErroredLbrsCount (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     &u4ChksumErr, &u4BadMsg);
            nmhGetFsMIY1731LbStatsLbrIn (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4TransId, &u4LbrRcvd);
            nmhGetFsMIY1731LbStatsLbrTimeMin (u4ContextId, u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              u4TransId, &i4MinTime);
            nmhGetFsMIY1731LbStatsLbrTimeMax (u4ContextId, u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              u4TransId, &i4MaxTime);
            nmhGetFsMIY1731LbStatsLbrTimeAverage (u4ContextId,
                                                  u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier,
                                                  u4TransId, &i4AvgTime);
            nmhGetFsMIY1731LbStatsAvgLbrsPerResponder (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       u4TransId,
                                                       &u4AvgLbrsPerResponder);
            nmhGetFsMIY1731LbStatsTotalResponders (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   u4TransId,
                                                   &u4TotalResponders);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            u2TotalRMeps =
                EcfmGetNumOfRMeps (u4ContextId, u4MdIndex, u4MaIndex,
                                   u4MepIdentifier);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (ECFM_IS_MULTICAST_ADDR (RetTargetMacAddr) == ECFM_TRUE)

            {
                u4ExpLbrs = u2TotalRMeps * u4LbmSent;
                u4LbrsLost = u4ExpLbrs - u4LbrRcvd;
                if (u4ExpLbrs != 0)

                {
                    f4PercentageLoss =
                        ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) / u4ExpLbrs);
                }
            }

            else

            {
                if(u4LbmSent != 0)
                {
                u4LbrsLost = u4LbmSent - u4LbrRcvd;
                f4PercentageLoss =
                    ((FLT4) (u4LbrsLost * ECFM_100_PERCENT) / u4LbmSent);
            }
            }
            CliPrintf (CliHandle, "\r\npackets sent = %d,", u4LbmSent);
            CliPrintf (CliHandle, " packets received = %d,", u4LbrRcvd);
            SPRINTF ((CHR1 *) au1PercentageLoss, "%f", f4PercentageLoss);
            au1PercentageLoss[ECFM_INDEX_FIVE] = '%';
            au1PercentageLoss[ECFM_INDEX_SIX] = '\0';
            CliPrintf (CliHandle, " packets lost  = %d (%s loss), \r\n",
                       u4LbrsLost, au1PercentageLoss);
            CliPrintf (CliHandle, "unexpected received = %d,", u4UnexpLbrIn);
            CliPrintf (CliHandle, " checksum errors = %d,", u4ChksumErr);
            CliPrintf (CliHandle, " bad messages received = %d,", u4BadMsg);
            CliPrintf (CliHandle, "\r\nduplicate received = %d,", u4DupMsg);
            CliPrintf (CliHandle, " responders = %d,", u4TotalResponders);
            CliPrintf (CliHandle,
                       " average packets per responder = %d,",
                       u4AvgLbrsPerResponder);
            CliPrintf (CliHandle,
                       "\r\nrtt min/avg/max = %d/%d/%d ms\r\n",
                       i4MinTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                       i4AvgTime * ECFM_NUM_OF_TICKS_IN_A_MSEC,
                       i4MaxTime * ECFM_NUM_OF_TICKS_IN_A_MSEC);
            b1Header = ECFM_TRUE;
            b1PrintStats = ECFM_FALSE;
        }
        u4TransId = u4NextTransId;
        u4SeqNum = u4NextSeqNum;
        u4RcvOrder = u4NextRcvOrder;
        b1PrintStats = ECFM_FALSE;
    }
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetInvalidLbrsCount
 *                                                                               
 *     DESCRIPTION      : This routine will get the number of duplicate and
 *                        unexpected LBRs received.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmGetInvalidLbrsCount (UINT4 u4CurrConId, UINT4 u4CurrMdId,
                         UINT4 u4CurrMaId, UINT4 u4CurrMepId,
                         UINT4 u4CurrTransId, UINT4 *pu4UnexpLbrs,
                         UINT4 *pu4DupLbrs)
{
    UINT4               u4UnexpLbrsCount = ECFM_INIT_VAL;
    UINT4               u4DupLbrsCount = ECFM_INIT_VAL;
    UINT4               u4UnexpLbrs = ECFM_INIT_VAL;
    UINT4               u4DupLbrs = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    BOOL1               b1SameEntry = ECFM_TRUE;
    u4ContextId = u4CurrConId;
    i4RetVal =
        nmhGetNextIndexFsMIY1731LbmTable (u4ContextId, &u4NextContextId,
                                          u4MdIndex, &u4NextMdIndex,
                                          u4MaIndex, &u4NextMaIndex,
                                          u4MepIdentifier,
                                          &u4NextMepIdentifier,
                                          u4TransId, &u4NextTransId, 0,
                                          &u4SeqNum);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Searching for same context */
        if (u4CurrConId != u4NextContextId)

        {

            /* Not found */
            return;
        }
    }

    /* Same MEP transaction found */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameEntry == ECFM_TRUE))

    {
        if ((u4CurrConId == u4ContextId) &&
            (u4CurrMdId == u4MdIndex) &&
            (u4CurrMaId == u4MaIndex) &&
            (u4CurrMepId == u4MepIdentifier) && (u4CurrTransId == u4TransId))

        {
            u4UnexpLbrs = ECFM_INIT_VAL;
            u4DupLbrs = ECFM_INIT_VAL;
            nmhGetFsMIY1731LbmUnexptedLbrIn (u4ContextId, u4MdIndex,
                                             u4MaIndex, u4MepIdentifier,
                                             u4TransId, u4SeqNum, &u4UnexpLbrs);
            nmhGetFsMIY1731LbmDuplicatedLbrIn (u4ContextId, u4MdIndex,
                                               u4MaIndex,
                                               u4MepIdentifier,
                                               u4TransId, u4SeqNum, &u4DupLbrs);
            u4UnexpLbrsCount = u4UnexpLbrsCount + u4UnexpLbrs;
            u4DupLbrsCount = u4DupLbrsCount + u4DupLbrs;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731LbmTable (u4ContextId,
                                              &u4NextContextId,
                                              u4MdIndex, &u4NextMdIndex,
                                              u4MaIndex, &u4NextMaIndex,
                                              u4MepIdentifier,
                                              &u4NextMepIdentifier,
                                              u4TransId, &u4NextTransId,
                                              u4SeqNum, &u4NextSeqNum);
        u4ContextId = u4NextContextId;
        u4MdIndex = u4NextMdIndex;
        u4MaIndex = u4NextMaIndex;
        u4MepIdentifier = u4NextMepIdentifier;
        u4TransId = u4NextTransId;
        u4SeqNum = u4NextSeqNum;
    }
    *pu4UnexpLbrs = u4UnexpLbrsCount;
    *pu4DupLbrs = u4DupLbrsCount;
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetErroredLbrsCount
 *                                                                               
 *     DESCRIPTION      : This routine will get the number of bad and
 *                        bit errored LBRs received.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmGetErroredLbrsCount (UINT4 u4CurrConId, UINT4 u4CurrMdId,
                         UINT4 u4CurrMaId, UINT4 u4CurrMepId,
                         UINT4 u4CurrTransId, UINT4 *pu4ChksumErr,
                         UINT4 *pu4BadMsg)
{
    UINT4               u4BadMsgCount = ECFM_INIT_VAL;
    UINT4               u4ChksumErrCount = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNum = ECFM_INIT_VAL;
    UINT4               u4RcvOrder = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4NextSeqNum = ECFM_INIT_VAL;
    UINT4               u4NextRcvOrder = ECFM_INIT_VAL;
    INT4                i4LbrErrType = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    u4ContextId = u4CurrConId;
    u4MdIndex = u4CurrMdId;
    u4MaIndex = u4CurrMaId;
    u4MepIdentifier = u4CurrMepId;
    u4TransId = u4CurrTransId;
    i4RetVal =
        nmhGetNextIndexFsMIY1731LbrTable (u4ContextId, &u4NextContextId,
                                          u4MdIndex, &u4NextMdIndex,
                                          u4MaIndex, &u4NextMaIndex,
                                          u4MepIdentifier,
                                          &u4NextMepIdentifier,
                                          u4TransId, &u4NextTransId, 0,
                                          &u4SeqNum, 0, &u4RcvOrder);
    if (i4RetVal == SNMP_SUCCESS)

    {
        if (u4ContextId != u4NextContextId)

        {

            /* Entry is for the context */
            return;
        }
    }
    while (i4RetVal == SNMP_SUCCESS)

    {
        if ((u4CurrConId == u4ContextId) &&
            (u4CurrMdId == u4MdIndex) &&
            (u4CurrMaId == u4MaIndex) &&
            (u4CurrMepId == u4MepIdentifier) && (u4CurrTransId == u4TransId))

        {
            nmhGetFsMIY1731LbrErrorType (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         u4TransId, u4SeqNum,
                                         u4RcvOrder, &i4LbrErrType);

            /* Bad Msdu */
            if (i4LbrErrType == ECFM_LBLT_LBR_WITH_BAD_MSDU)

            {
                u4BadMsgCount = u4BadMsgCount + 1;
            }

            /* Checksum error */
            if (i4LbrErrType == ECFM_LBLT_LBR_WITH_BIT_ERR)

            {
                u4ChksumErrCount = u4ChksumErrCount + 1;
            }
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731LbrTable (u4ContextId,
                                              &u4NextContextId,
                                              u4MdIndex, &u4NextMdIndex,
                                              u4MaIndex, &u4NextMaIndex,
                                              u4MepIdentifier,
                                              &u4NextMepIdentifier,
                                              u4TransId, &u4NextTransId,
                                              u4SeqNum, &u4NextSeqNum,
                                              u4RcvOrder, &u4NextRcvOrder);
        u4ContextId = u4NextContextId;
        u4MdIndex = u4NextMdIndex;
        u4MaIndex = u4NextMaIndex;
        u4MepIdentifier = u4NextMepIdentifier;
        u4TransId = u4NextTransId;
        u4SeqNum = u4NextSeqNum;
        u4RcvOrder = u4NextRcvOrder;
    }
    *pu4ChksumErr = u4ChksumErrCount;
    *pu4BadMsg = u4BadMsgCount;
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliInitDelayMeasurement
 *                                                                          
 *     DESCRIPTION      : This function will initiate the delay calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4DelayType - Type of Delay measurement
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4, pu1Arg5, pu1Arg6
 *                        arguments can contain different parameters according
 *                        to particular command.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliInitDelayMeasurement (tCliHandle CliHandle,
                             UINT4 u4ContextId, UINT4 u4Command,
                             INT4 i4DelayType, INT4 i4Dir,
                             UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                             UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                             UINT1 *pu1Arg5, UINT1 *pu1Arg6, UINT4 u4IfIndex,
                             UINT1 *pu1MdName, UINT1 *patternSize, UINT4 *dataPattern)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsDestMpId = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;
    BOOL1               b2Err = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex,
         0, &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_FD_MEP_MPID_DOM_SER:
            case CLI_ECFM_FD_MEP_MPID_DOM_ISID:
            case CLI_ECFM_FD_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MPID_DOM_VSI:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FD_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FD_MEP_MPID_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MPID_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) && ((i4Dir == 0)
                                                    || ((i4Dir != 0)
                                                        && (i4Dir ==
                                                            i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MPID_DOM:
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_LEV_ISID:
            case CLI_ECFM_FD_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_FD_MEP_MAC_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_DOM_ISID:
            case CLI_ECFM_FD_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MAC_DOM_VSI:
            case CLI_ECFM_FD_MEP_MAC_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Start the Delay Measurement */
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (EcfmConfigDMParams
                (CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, b1IsDestMpId, i4DelayType, pu1Arg3,
                 pu1Arg4, pu1Arg5, pu1Arg6, &b1Err, &b2Err, patternSize, dataPattern) == ECFM_FAILURE)

            {
                if (b2Err == ECFM_TRUE)
                {
                    CLI_SET_ERR (CLI_ECFM_DM_IN_PROGRESS_ERR);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if ((u4IfIndex != 0) && (i4Dir != 0))
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                    }
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();

                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                            (UINT4 *)
                                                            &i4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                        ECFM_REGISTER_CLI_CC_LOCK ();
                    }
                    return CLI_FAILURE;
                }

                if (i4CurrentContextId != i4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                b1IsDestMpId = ECFM_FALSE;
                b1Err = ECFM_FALSE;
                continue;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
        b1IsDestMpId = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliStopDelayMeasurement
 *                                                                          
 *     DESCRIPTION      : This function will initiate the delay calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4DelayType - Type of Delay measurement
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2,
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliStopDelayMeasurement (tCliHandle CliHandle,
                             UINT4 u4ContextId, UINT4 u4Command,
                             INT4 i4Dir, UINT1 *pu1Arg1,
                             UINT1 *pu1Arg2, UINT4 u4IfIndex, UINT1 *pu1MdName)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex,
         0, &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_FD_MEP_MAC_DOM_ISID:
            case CLI_ECFM_FD_MEP_MAC_DOM_SER:
            case CLI_ECFM_FD_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MAC_DOM_VSI: 
            case CLI_ECFM_FD_MEP_MPID_DOM_VSI:
            case CLI_ECFM_FD_MEP_MPID_DOM_SER:
            case CLI_ECFM_FD_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FD_MEP_MPID_DOM_ISID:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FD_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FD_MEP_MPID_LEV_VSI: 
            case CLI_ECFM_FD_MEP_MAC_LEV_VSI:
            case CLI_ECFM_FD_MEP_MAC_LEV_ISID:
            case CLI_ECFM_FD_MEP_MAC_LEV_VLAN:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_LEV:
            case CLI_ECFM_FD_MEP_MPID_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FD_MEP_MAC_DOM:
            case CLI_ECFM_FD_MEP_MPID_DOM:
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Stop the Delay Measurement */
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* Test if the transaction can be stop  */
            if (nmhTestv2FsMIY1731MepTransmitDmStatus
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            /* Then set the transaction */
            if (nmhSetFsMIY1731MepTransmitDmStatus
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliInitProactiveDM
 *
 *     DESCRIPTION      : This function will initiate the delay calculations.
 *
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4DelayType - Type of Delay measurement
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4, pu1Arg5, pu1Arg6
 *                        arguments can contain different parameters according
 *                        to particular command.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
EcfmCliInitProactiveDM (tCliHandle CliHandle,
                             UINT4 u4ContextId, UINT4 u4Command,
                             INT4 i4DelayType, INT4 i4Dir,
                             UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                             UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                             UINT1 *pu1Arg5, UINT1 *pu1Arg6, UINT4 u4IfIndex,
                             UINT1 *pu1MdName, UINT1 *patternSize, UINT4 *dataPattern)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsDestMpId = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;
    BOOL1               b2Err = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    i4CurrentContextId = (INT4) (u4ContextId);

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex,
         0, &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                        (i4MdLevel == i4RetMdLevel)&& ((i4Dir == 0)
                            || ((i4Dir != 0)
                                && (i4Dir ==
                                    i4RetDir)))
                        && ((u4IfIndex == 0)
                            || ((u4IfIndex != 0)
                                && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM:
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                        (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL)
                        && ((i4Dir == 0)
                            || ((i4Dir != 0)
                                && (i4Dir ==
                                    i4RetDir)))
                        && ((u4IfIndex == 0)
                            || ((u4IfIndex != 0)
                                && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
           case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MAC_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }
        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Start the Delay Measurement */
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (EcfmConfigProactiveDMParams
                (CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, b1IsDestMpId, i4DelayType, pu1Arg3,
                 pu1Arg4, pu1Arg5, pu1Arg6, &b1Err, &b2Err, patternSize, dataPattern) == ECFM_FAILURE)

            {
                if (b2Err == ECFM_TRUE)
                {
                    CLI_SET_ERR (CLI_ECFM_DM_IN_PROGRESS_ERR);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                if ((u4IfIndex != 0) && (i4Dir != 0))
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                    }
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();

                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                            (UINT4 *)
                                                            &i4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_DM_INITIATION_ERR);
                        /*ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                        ECFM_REGISTER_CLI_CC_LOCK ();*/
                    }
                    return CLI_FAILURE;
                }

                if (i4CurrentContextId != i4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                b1IsDestMpId = ECFM_FALSE;
                b1Err = ECFM_FALSE;
                continue;
            }
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
        b1IsDestMpId = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}
/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigDMParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for
 *                        Delay Measurement.
 *                                                                          
 *     INPUT            : CliHandle       - CliContext ID
 *                        u4MdIndex       - MdIndex                     
 *                        u4MaIndex       - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        b1IsDestMpId    - Destination MepId or Mac Address
 *                        i4DelayType     - Type of the DM to initiate
 *                        pu1Arg1         -
 *                        pu1Arg2         -
 *                        pu1Arg3         -
 *                        pu1Arg4         - Arguments acc. to the command                        
 *                                                                        
 *     OUTPUT           : b1Err - Indicates an Error from Test routine
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigDMParams (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4MdIndex, UINT4 u4MaIndex,
                    UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                    INT4 i4DelayType, UINT1 *pu1Arg1,
                    UINT1 *pu1Arg2, UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                    BOOL1 * pb1Err, BOOL1 * pb2Err, UINT1 *patternSize, UINT4 *dataPattern)
{
    tEcfmMacAddr        DestMacAddr;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4DestMpId = ECFM_INIT_VAL;
    INT4                i4DmInterval = ECFM_INIT_VAL;
    INT4                i4DmMsgs = ECFM_INIT_VAL;
    INT4                i4DmDeadline = ECFM_INIT_VAL;
    INT4                i4DmStatus = -1;
    UINT4               u4PatternSize = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE DataTlv;

    ECFM_MEMSET (ECFM_LBLT_PDU, ECFM_INIT_VAL, ECFM_MAX_JUMBO_PDU_SIZE); 
    ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
    DataTlv.i4_Length = 0;

    /* Set MepId or Dest Mac Address depending on the input */
    if (b1IsDestMpId == ECFM_TRUE)

    {
        if (nmhGetFsMIY1731MepTransmitDmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &i4DmStatus) != SNMP_FAILURE)
        {
            if (i4DmStatus == ECFM_TX_STATUS_NOT_READY)
            {
                *pb2Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
        }
        if (nmhTestv2FsMIY1731MepTransmitDmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitDmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set MepId of the destination */
        u4DestMpId = *(UINT4 *) (VOID *) pu1Arg1;
        if (nmhTestv2FsMIY1731MepTransmitDmDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitDmDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {
        ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        StrToMac (pu1Arg1, DestMacAddr);
        if (nmhTestv2FsMIY1731MepTransmitDmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitDmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set destination address */
        if (nmhTestv2FsMIY1731MepTransmitDmDestMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, DestMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitDmDestMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             DestMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Test Delay Measurement Type before setting */
    if (nmhTestv2FsMIY1731MepTransmitDmType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4DelayType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Number of Observations required for delay mesurement 
     * before setting */
    if (pu1Arg2 != NULL)

    {
        i4DmMsgs = *(INT4 *) (VOID *) pu1Arg2;
    }

    else

    {
        i4DmMsgs = 0;
    }
    if (nmhTestv2FsMIY1731MepTransmitDmMessages
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4DmMsgs) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Interval before setting */
    if (pu1Arg3 != NULL)

    {
        i4DmInterval = (*(INT4 *) (VOID *) pu1Arg3) / ECFM_VAL_10;
    }

    else

    {
        i4DmInterval = ECFM_DM_INTERVAL_DEF_VAL;
    }
    if (nmhTestv2FsMIY1731MepTransmitDmInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4DmInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test DeadLine Time before setting */
    if (pu1Arg4 != NULL)

    {
        i4DmDeadline = *(INT4 *) (VOID *) pu1Arg4;
    }

    else

    {
        i4DmDeadline = 0;
    }
    if (nmhTestv2FsMIY1731MepTransmitDmDeadline
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4DmDeadline) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Initiate Delay Measurment */
    if (nmhTestv2FsMIY1731MepTransmitDmStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if ((patternSize != NULL) && (dataPattern != NULL))
    {
        u4PatternSize = *(UINT4 *) (VOID *) patternSize;
        /* Data TLV */
        if (nmhTestv2FsMIY1731MepTransmitDmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_LBLT_DM_WITH_DATA_TLV) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        DataTlv.i4_Length = ECFM_STRLEN (dataPattern);
        DataTlv.pu1_OctetList = (UINT1*)dataPattern;
        if (nmhTestv2FsMIY1731MepTransmitDmDataPattern
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

        if (nmhTestv2FsMIY1731MepTransmitDmDataPatternSize
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4PatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    else 
    {
        if (nmhTestv2FsMIY1731MepTransmitDmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_LBLT_DM_WITHOUT_TLV) == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

    }
    if (nmhSetFsMIY1731MepTransmitDmType
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4DelayType) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (pu1Arg2 != NULL)

    {
        if (nmhSetFsMIY1731MepTransmitDmMessages
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             i4DmMsgs) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    if (nmhSetFsMIY1731MepTransmitDmInterval
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4DmInterval) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (pu1Arg4 != NULL)

    {
        if (nmhSetFsMIY1731MepTransmitDmDeadline
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             i4DmDeadline) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    if (nmhSetFsMIY1731MepTransmitDmStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if ((patternSize != NULL) && (dataPattern != NULL))
    {
        if (nmhSetFsMIY1731MepTransmitDmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_LBLT_DM_WITH_DATA_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitDmDataPattern
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepTransmitDmDataPatternSize
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4PatternSize) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }
    else
    {
        if (nmhSetFsMIY1731MepTransmitDmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_LBLT_DM_WITHOUT_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    
    }

    CliPrintf (CliHandle, " ");
    return ECFM_SUCCESS;
}
/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmConfigProactiveDMParams
 *
 *     DESCRIPTION      : This function will set the MIB fields required for
 *                        Delay Measurement.
 *
 *     INPUT            : CliHandle       - CliContext ID
 *                        u4MdIndex       - MdIndex
 *                        u4MaIndex       - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        b1IsDestMpId    - Destination MepId or Mac Address
 *                        i4DelayType     - Type of the DM to initiate
 *                        pu1Arg1         -
 *                        pu1Arg2         -
 *                        pu1Arg3         -
 *                        pu1Arg4         - Arguments acc. to the command
 *
 *     OUTPUT           : b1Err - Indicates an Error from Test routine
 *
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE
 *
 ******************************************************************************/
PRIVATE INT4
EcfmConfigProactiveDMParams (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4MdIndex, UINT4 u4MaIndex,
                    UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                    INT4 i4DelayType,  UINT1 *pu1Arg1,
                    UINT1 *pu1Arg2, UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                    BOOL1 * pb1Err, BOOL1 * pb2Err, UINT1 *patternSize, UINT4 *dataPattern)
{
    tEcfmMacAddr        DestMacAddr;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4DestMpId = ECFM_INIT_VAL;
    INT4                i4DmInterval = ECFM_INIT_VAL;
    INT4                i4DmStatus = -1;
    INT4                i4TestId =  *(INT4 *) (VOID *)pu1Arg2;
    UINT4               u4PatternSize = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE DataTlv;
    tSNMP_OCTET_STRING_TYPE TestName;

    ECFM_MEMSET (ECFM_LBLT_PDU, ECFM_INIT_VAL, ECFM_MAX_JUMBO_PDU_SIZE);
    ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
    DataTlv.i4_Length = 0;

    ECFM_MEMSET (&TestName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    TestName.pu1_OctetList = ECFM_LBLT_PDU;
    TestName.i4_Length = 0;
    if(b1IsDestMpId != ECFM_TRUE)
    {
        ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        StrToMac (pu1Arg1, DestMacAddr);

        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();

        EcfmCcUtilGetRMepIdFromMacAddr (u4ContextId,u4MdIndex,u4MaIndex, (UINT2)u4MepIdentifier,
                                        DestMacAddr, &u4DestMpId);

        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
    }
    else 
    {
        u4DestMpId = *(UINT4 *) (VOID *) pu1Arg1;;
    }

    if (nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4DestMpId, i4TestId, 
                                               ECFM_ROW_STATUS_CREATE_AND_GO ) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }


    /* Set MepId or Dest Mac Address depending on the input */
    if (b1IsDestMpId == ECFM_TRUE)

    {
        if (nmhGetFsMIY1731MepProactiveDmStatus (u4ContextId, u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4DestMpId, i4TestId, 
                                                 &i4DmStatus) != SNMP_FAILURE)
        {
            if (i4DmStatus == ECFM_TX_STATUS_NOT_READY)
            {
                *pb2Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
        }
        if (nmhTestv2FsMIY1731MepProactiveDmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepProactiveDmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set MepId of the destination */
        if (nmhTestv2FsMIY1731MepProactiveDmDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, u4DestMpId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepProactiveDmDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, u4DestMpId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else
    {
        ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        StrToMac (pu1Arg1, DestMacAddr);
        if (nmhTestv2FsMIY1731MepProactiveDmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepProactiveDmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, ECFM_SNMP_FALSE) == SNMP_FAILURE)


        {
            return ECFM_FAILURE;
        }

        /* Set destination address */
        if (nmhTestv2FsMIY1731MepProactiveDmDestMacAddr
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, DestMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepProactiveDmDestMacAddr
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, DestMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /*Set Test name*/
    if(pu1Arg4 !=NULL) 
    {
        TestName.i4_Length = ECFM_STRLEN (pu1Arg4);
        TestName.pu1_OctetList = ECFM_LBLT_PDU;
        ECFM_STRCPY (TestName.pu1_OctetList, pu1Arg4);

        if (nmhTestv2FsMIY1731MepProactiveDmTestname
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, &TestName) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY); 
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepProactiveDmTestname
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, &TestName) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

    }

    /* Test Delay Measurement Type before setting */
    if (nmhTestv2FsMIY1731MepProactiveDmType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4DestMpId, i4TestId, i4DelayType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4DestMpId, i4TestId,
                                               ECFM_ROW_STATUS_DESTROY);
        return ECFM_FAILURE;
    }

    /* Test Interval before setting */
    if (pu1Arg3 != NULL)

    {
        i4DmInterval = (*(INT4 *) (VOID *) pu1Arg3) / ECFM_VAL_10;
    }

    else

    {
        i4DmInterval = ECFM_DM_INTERVAL_DEF_VAL;
    }
    if (nmhTestv2FsMIY1731MepProactiveDmInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4DestMpId, i4TestId, i4DmInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4DestMpId, i4TestId,
                                               ECFM_ROW_STATUS_DESTROY);
        return ECFM_FAILURE;
    }


    /* Initiate Delay Measurment */
    if (nmhTestv2FsMIY1731MepProactiveDmStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4DestMpId, i4TestId, ECFM_TX_PROACTIVE_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4DestMpId, i4TestId,
                                               ECFM_ROW_STATUS_DESTROY);
        return ECFM_FAILURE;
    }

    
    if ((patternSize != NULL) && (dataPattern != NULL))
    {
            u4PatternSize = *(UINT4 *) (VOID *) patternSize;
            /* Data TLV */
            if (nmhTestv2FsMIY1731MepProactiveDmTlvType
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4DestMpId, i4TestId,
                 ECFM_LBLT_DM_WITH_DATA_TLV) == SNMP_FAILURE)
            {
                nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                      u4MepIdentifier, u4DestMpId, i4TestId,
                                                      ECFM_ROW_STATUS_DESTROY);
                return ECFM_FAILURE;
            }
            if(i4DelayType == ECFM_LBLT_DM_TYPE_DMM)
            {
                DataTlv.i4_Length = ECFM_STRLEN (dataPattern);
                DataTlv.pu1_OctetList = (UINT1*)dataPattern;
                if (nmhTestv2FsMIY1731MepProactiveDmmDataPattern
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4DestMpId, i4TestId, &DataTlv) == SNMP_FAILURE)

                {
                    nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
                    return ECFM_FAILURE;
                }

                if (nmhTestv2FsMIY1731MepProactiveDmmDataPatternSize
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4DestMpId, i4TestId, u4PatternSize) == SNMP_FAILURE)

                {
                    nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY);
                    return ECFM_FAILURE;
                }
            }
            else if (i4DelayType == ECFM_LBLT_DM_TYPE_1DM)
            {
                DataTlv.i4_Length = ECFM_STRLEN (dataPattern);
                DataTlv.pu1_OctetList = (UINT1*)dataPattern;
                if (nmhTestv2FsMIY1731MepProactive1DmDataPattern
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4DestMpId, i4TestId, &DataTlv) == SNMP_FAILURE)

                {
                    nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY );
                    return ECFM_FAILURE;
                }

                if (nmhTestv2FsMIY1731MepProactive1DmDataPatternSize
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, u4DestMpId, i4TestId, u4PatternSize) == SNMP_FAILURE)

                {
                    nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY );
                    return ECFM_FAILURE;
                }        
            }
    }
    else
    {
        if (nmhTestv2FsMIY1731MepProactiveDmTlvType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId, i4TestId, 
             ECFM_LBLT_DM_WITHOUT_TLV) == SNMP_FAILURE)
        {
            nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                                  u4MepIdentifier, u4DestMpId, i4TestId,
                                                  ECFM_ROW_STATUS_DESTROY );
            return ECFM_FAILURE;
        }

    }



    if (nmhSetFsMIY1731MepProactiveDmType
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         u4DestMpId, i4TestId, i4DelayType) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepProactiveDmInterval
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         u4DestMpId, i4TestId, i4DmInterval) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepProactiveDmStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         u4DestMpId, i4TestId, ECFM_TX_PROACTIVE_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if ((patternSize != NULL) && (dataPattern != NULL))
    {
        if (nmhSetFsMIY1731MepProactiveDmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, ECFM_LBLT_DM_WITH_DATA_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        if (i4DelayType == ECFM_LBLT_DM_TYPE_DMM)
        {
            if (nmhSetFsMIY1731MepProactiveDmmDataPattern
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4DestMpId, i4TestId, &DataTlv) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            if (nmhSetFsMIY1731MepProactiveDmmDataPatternSize
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4DestMpId, i4TestId, u4PatternSize) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }
        else if (i4DelayType == ECFM_LBLT_DM_TYPE_1DM)
        {
            if (nmhSetFsMIY1731MepProactive1DmDataPattern
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4DestMpId, i4TestId, &DataTlv) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }

            if (nmhSetFsMIY1731MepProactive1DmDataPatternSize
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4DestMpId, i4TestId, u4PatternSize) == SNMP_FAILURE)

            {
                return ECFM_FAILURE;
            }
        }

    }
    else
    {
        if (nmhSetFsMIY1731MepProactiveDmTlvType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId, i4TestId, ECFM_LBLT_DM_WITHOUT_TLV) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

    }
    CliPrintf (CliHandle, " ");
    return ECFM_SUCCESS;
}


/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliStopProactiveDM
 *
 *     DESCRIPTION      : This function will initiate the delay calculations.
 *
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4DelayType - Type of Delay measurement
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2,
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
EcfmCliStopProactiveDM (tCliHandle CliHandle,
                             UINT4 u4ContextId, UINT4 u4Command,
                             INT4 i4Dir, UINT1 *pu1Arg1,
                             UINT1 *pu1Arg2, UINT4 u4IfIndex, UINT1 *pu1MdName,
                             UINT1 *pu1Arg3, UINT1 *pu1Arg4)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4TestId = ECFM_INIT_VAL;
    INT4                i4RetStatus = ECFM_INIT_VAL;                
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsDestMpId = ECFM_TRUE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    i4CurrentContextId = (INT4) (u4ContextId);
    i4TestId= *pu1Arg4;


    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex,
         0, &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        nmhGetFsMIEcfmMepPrimaryVid (i4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (i4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (i4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM_SER:
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM_SER:
                if (u4Command == CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM_SER)
                {
                    b1IsDestMpId = ECFM_FALSE;
                }
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MAC_LEV:
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_LEV:
                if (u4Command == CLI_ECFM_PROACTIVE_FD_MEP_MAC_LEV)
                {
                    b1IsDestMpId = ECFM_FALSE;
                }
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM:
            case CLI_ECFM_PROACTIVE_FD_MEP_MPID_DOM:
                if (u4Command == CLI_ECFM_PROACTIVE_FD_MEP_MAC_DOM)
                {
                    b1IsDestMpId = ECFM_FALSE;
                }
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == ECFM_INIT_VAL)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {
            if (b1IsDestMpId == ECFM_TRUE)
            {
                 u4RMepIdentifier = *(UINT4 *) (VOID *)pu1Arg3;
            }
            else
            {
                ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                StrToMac (pu1Arg3, MacAddr);

                i4RetStatus = 
                       EcfmCcUtilGetRMepIdFromMacAddr (u4ContextId, u4MdIndex, u4MaIndex, 
                             (UINT2)u4MepIdentifier, MacAddr, &u4RMepIdentifier);

                if (i4RetStatus != ECFM_SUCCESS)
                {
                    CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
                    return ECFM_FAILURE;
                }
            }

            /* Stop the Delay Measurement */
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* Test if the transaction can be stop  */
            if (nmhTestv2FsMIY1731MepProactiveDmStatus
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, u4RMepIdentifier, i4TestId,
                 ECFM_TX_PROACTIVE_STATUS_STOP) == SNMP_FAILURE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }
            if (nmhTestv2FsMIY1731MepProactiveDmRowStatus(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4RMepIdentifier, i4TestId,
                                               ECFM_ROW_STATUS_DESTROY ) == SNMP_FAILURE)
            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            /* Then set the transaction */
            if (nmhSetFsMIY1731MepProactiveDmStatus
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 u4RMepIdentifier, i4TestId, ECFM_TX_PROACTIVE_STATUS_STOP) == SNMP_FAILURE)

            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }
            if (nmhSetFsMIY1731MepProactiveDmRowStatus(u4ContextId, u4MdIndex, u4MaIndex,
                                               u4MepIdentifier, u4RMepIdentifier, i4TestId,
                                               ECFM_ROW_STATUS_DESTROY ) == SNMP_FAILURE)
            {
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_SUCCESS;
            }

            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}


/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : VepEcfmGetMepConfigPrompt
 *
 *     DESCRIPTION      : This function returns the MEP-prompt to be displayed.
 *
 *     INPUT            : pi1ModeName - Mode to be configured.
 *
 *     OUTPUT           : pi1DispStr  - Prompt to be displayed.
 *
 *     RETURNS          : ECFM_TRUE or ECFM_FALSE
 *
 *******************************************************************************/
INT1
VepEcfmGetMepConfigPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4Len = STRLEN (CLI_MEP_MODE);
    if ((!pi1DispStr) || (!pi1ModeName))

    {
        return ECFM_FALSE;
    }
    if (STRNCMP (pi1ModeName, CLI_MEP_MODE, u4Len) != 0)

    {
        return ECFM_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;

    /*
     * No need to take lock here, since it is taken by
     * Cli in cli_process_ecfm_config_cmd.
     */
    STRCPY (pi1DispStr, "(config-vep-ether-mep)#");
    return ECFM_TRUE;
}
/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmGetMepConfigPrompt 
 *                                                                           
 *     DESCRIPTION      : This function returns the MEP-prompt to be displayed.                
 *                                                                           
 *     INPUT            : pi1ModeName - Mode to be configured.               
 *                                                                           
 *     OUTPUT           : pi1DispStr  - Prompt to be displayed.              
 *                                                                           
 *     RETURNS          : ECFM_TRUE or ECFM_FALSE                                      
 *                                                                           
 *******************************************************************************/
INT1
EcfmGetMepConfigPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4Len = STRLEN (CLI_MEP_MODE);
    if ((!pi1DispStr) || (!pi1ModeName))

    {
        return ECFM_FALSE;
    }
    if (STRNCMP (pi1ModeName, CLI_MEP_MODE, u4Len) != 0)

    {
        return ECFM_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;

    /* 
     * No need to take lock here, since it is taken by
     * Cli in cli_process_ecfm_config_cmd.
     */
    STRCPY (pi1DispStr, "(config-ether-mep)#");
    return ECFM_TRUE;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmTpOamGetMepConfigPrompt
 *
 *     DESCRIPTION      : This function returns the MEP-prompt to be displayed.
 *
 *     INPUT            : pi1ModeName - Mode to be configured.
 *
 *     OUTPUT           : pi1DispStr  - Prompt to be displayed.
 *
 *     RETURNS          : ECFM_TRUE or ECFM_FALSE
 *
 *******************************************************************************/
INT1
EcfmTpOamGetMepConfigPrompt (INT1 *pi1ModeName, INT1 *pi1DispStr)
{
    UINT4               u4Len = STRLEN (CLI_MEP_MPLS_MODE);
    if ((!pi1DispStr) || (!pi1ModeName))

    {
        return ECFM_FALSE;
    }
    if (STRNCMP (pi1ModeName, CLI_MEP_MPLS_MODE, u4Len) != 0)

    {
        return ECFM_FALSE;
    }
    pi1ModeName = pi1ModeName + u4Len;

    /*
     * No need to take lock here, since it is taken by
     * Cli in cli_process_ecfm_config_cmd.

     */
    STRCPY (pi1DispStr, "(config-mpls-mep)#");
    return ECFM_TRUE;
}


/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMepCsfCapability
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable various 
 *                        MEP's CSF capabilities.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Values to be set 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMepCsfCapability (tCliHandle CliHandle, UINT4 u4ContextId,
                           UINT4 u4Command)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Capability = ECFM_INIT_VAL;

    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check whether to enable or disable the capabilities */
    if (u4Command == CLI_ECFM_DISABLE_CSF_CAP)

    {
        i4Capability = ECFM_DISABLE;
    }
    if (u4Command == CLI_ECFM_ENABLE_CSF_CAP)

    {
        i4Capability = ECFM_ENABLE;
    }
    if (nmhTestv2FsMIY1731MepCsfRxCapability(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId, i4Capability) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepCsfRxCapability (u4ContextId, u4MdIndex, u4MaIndex, u4MepId, i4Capability)==SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}
/******************************************************************************
 * 
*     FUNCTION NAME    : EcfmCliSetMepRdiCapability
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable various 
 *                        MEP's capabilities.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Flag      - Values to be set 
 *                        pu1Arg1     - Rdi period to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMepRdiCapability (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4RdiPeriod = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Capability = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;

    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check whether to enable or disable the capabilities */
    if (u4Command == CLI_ECFM_DISABLE_RDI_CAP)

    {
        i4Capability = ECFM_DISABLE;
    }
    if (u4Command == CLI_ECFM_ENABLE_RDI_CAP)

    {
        i4Capability = ECFM_ENABLE;
    }
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    do

    {

        /* Setting RDI capability and period  */
        /* Test if Rdi capability can be set or not */
        if ((u4Command == CLI_ECFM_DISABLE_RDI_CAP)
            || (u4Command == CLI_ECFM_ENABLE_RDI_CAP))

        {
            if (nmhTestv2FsMIY1731MepRdiCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if RDI period can be set or not */
        if (pu1Arg1 != NULL)
        {
            u4RdiPeriod = *(UINT4 *) (VOID *) pu1Arg1;
            if (nmhTestv2FsMIY1731MepRdiPeriod
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, u4RdiPeriod) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Then set the capability */
        if ((u4Command == CLI_ECFM_DISABLE_RDI_CAP)
            || (u4Command == CLI_ECFM_ENABLE_RDI_CAP))

        {
            if (nmhSetFsMIY1731MepRdiCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Then set the period */
        if (pu1Arg1 != NULL)
        {
            u4RdiPeriod = *(UINT4 *) (VOID *) pu1Arg1;
            if (nmhSetFsMIY1731MepRdiPeriod
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 u4RdiPeriod) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMepAisCapability 
 *                                                                          
 *     DESCRIPTION      : This function sets the Mep Ais Capability 
 *                        and its related parameters (interval and period).     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command Type
 *                        u4interval  - Ais interval to be set
 *                        pu1AisPeriod- Ais period to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMepAisCapability (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Command, UINT4 u4interval,
                            UINT1 *pu1AisPeriod)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4AisPeriod = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4EnableAis = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check whether to enable or disable the capabilities */
    /* If user wants to enable Ais operations */
    if (u4Command == CLI_ECFM_ENABLE_AIS_CAP)

    {
        i4EnableAis = ECFM_SNMP_TRUE;
    }

    /* If user wants to disable Ais operations */
    else if (u4Command == CLI_ECFM_DISABLE_AIS_CAP)

    {
        i4EnableAis = ECFM_SNMP_FALSE;
    }

    do
    {
        /* Setting AIS capability, AIS interval and period  */
        if ((u4Command == CLI_ECFM_ENABLE_AIS_CAP)
            || (u4Command == CLI_ECFM_DISABLE_AIS_CAP))
        {

            /* Test if AIS capability can be set or not */
            if (nmhTestv2FsMIY1731MepAisCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, i4EnableAis) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if interval and period can be set or not */
        if (u4interval != 0)
        {
            if (nmhTestv2FsMIY1731MepAisInterval
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4interval) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        if (pu1AisPeriod != NULL)
        {
            u4AisPeriod = *(UINT4 *) (VOID *) pu1AisPeriod;
            if (nmhTestv2FsMIY1731MepAisPeriod
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4AisPeriod) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        if ((u4Command == CLI_ECFM_ENABLE_AIS_CAP)
            || (u4Command == CLI_ECFM_DISABLE_AIS_CAP))
        {

            /* Then set the capability */
            if (nmhSetFsMIY1731MepAisCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 i4EnableAis) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* After test, set the interval, period */
        if (u4interval != 0)
        {
            /* Then set the interval */
            if (nmhSetFsMIY1731MepAisInterval
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4interval) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        if (pu1AisPeriod != NULL)
        {
            u4AisPeriod = *(UINT4 *) (VOID *) pu1AisPeriod;
            /* Then set the capability */
            if (nmhSetFsMIY1731MepAisPeriod
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4AisPeriod) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliSetMepCapability
 *
 *     DESCRIPTION      : This function will enable or disable the
 *                        various capabilities on MEP's 
 *
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID
 *                        u4Flag      - Values to be set 
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *****************************************************************************/
INT4
EcfmCliSetMepCapability (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Flag)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Capability = ECFM_INIT_VAL;
    INT4                i4SendDmOptFields = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;

    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check whether to enable or disable the capabilities */
    if ((u4Flag & CLI_ECFM_DISABLE_CAP) == CLI_ECFM_DISABLE_CAP)
    {
        i4Capability = ECFM_DISABLE;
    }
    else if ((u4Flag & CLI_ECFM_ENABLE_CAP) == CLI_ECFM_ENABLE_CAP)
    {
        i4Capability = ECFM_ENABLE;
    }

    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    do
    {
        /* Test if ping capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_PING_CAP) == CLI_ECFM_SET_PING_CAP)
        {
            if (nmhTestv2FsMIY1731MepLoopbackCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if multicast LBM reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_MCAST_PING_RX_CAP) ==
            CLI_ECFM_SET_MCAST_PING_RX_CAP)
        {
            if (nmhTestv2FsMIY1731MepMulticastLbmRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if 1DM reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_1WAY_FD_RX_CAP) ==
            CLI_ECFM_SET_1WAY_FD_RX_CAP)
        {
            if (nmhTestv2FsMIY1731Mep1DmRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if multicast test reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_MCAST_TST_RX_CAP) ==
            CLI_ECFM_SET_MCAST_TST_RX_CAP)
        {
            if (nmhTestv2FsMIY1731MepMulticastTstRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if test capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_TST_RX_CAP) == CLI_ECFM_SET_TST_RX_CAP)
        {
            if (nmhTestv2FsMIY1731MepTstCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if optional fields in DMR capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP) ==
            CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP)
        {
            if (i4Capability == ECFM_ENABLE)
            {
                i4SendDmOptFields = ECFM_SNMP_TRUE;
            }
            else
            {
                i4SendDmOptFields = ECFM_SNMP_FALSE;
            }

            if (nmhTestv2FsMIY1731MepDmrOptionalFields
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SendDmOptFields) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Now set the loopback capability */
        if ((u4Flag & CLI_ECFM_SET_PING_CAP) == CLI_ECFM_SET_PING_CAP)
        {
            if (nmhSetFsMIY1731MepLoopbackCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the multicast loopback reception capability */
        if ((u4Flag & CLI_ECFM_SET_MCAST_PING_RX_CAP) ==
            CLI_ECFM_SET_MCAST_PING_RX_CAP)
        {
            if (nmhSetFsMIY1731MepMulticastLbmRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the 1DM reception capability */
        if ((u4Flag & CLI_ECFM_SET_1WAY_FD_RX_CAP) ==
            CLI_ECFM_SET_1WAY_FD_RX_CAP)
        {
            if (nmhSetFsMIY1731Mep1DmRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the multicast TST reception capability */
        if ((u4Flag & CLI_ECFM_SET_MCAST_TST_RX_CAP) ==
            CLI_ECFM_SET_MCAST_TST_RX_CAP)
        {
            if (nmhSetFsMIY1731MepMulticastTstRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the TST reception capability */
        if ((u4Flag & CLI_ECFM_SET_TST_RX_CAP) == CLI_ECFM_SET_TST_RX_CAP)
        {
            if (nmhSetFsMIY1731MepTstCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the DMR optional fields */
        if ((u4Flag & CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP) ==
            CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP)
        {
            if (nmhSetFsMIY1731MepDmrOptionalFields
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SendDmOptFields) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);

    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    return i4RetStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearErrorLog
 *                                                                          
 *     DESCRIPTION      : This function will clear error log.
 *                                                                               
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4ContextId  - Context Identtifier
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ****************************************************************************/
INT4
EcfmCliClearErrorLog (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    /* Test if Error Log can be clear or not */
    if (nmhTestv2FsMIY1731ErrorLogClear
        (&u4ErrorCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then clear it */
    if (nmhSetFsMIY1731ErrorLogClear (u4ContextId, ECFM_SNMP_TRUE) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}
/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliDisClearEthBnCount                          */
/*                                                                           */
/*     DESCRIPTION      : This function clears All ethbn counters            */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4IfIndex - Interface index                        */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/

INT4
EcfmCliClearAllEthBnCount (tCliHandle CliHandle, UINT4 u4IfIndex)
{
	INT4   i4RetVal = SNMP_FAILURE;
	UINT4  u4CurrIfIdx = 0;

	/*  The CC_LOCK  is taken from the calling CLI function . The below function needs to be executed in the CC_LOCK */

	i4RetVal = nmhGetFirstIndexFsMIY1731EthBnPortTable ((INT4 *)&u4IfIndex);
	if (i4RetVal == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	do
	{
		ECFM_UNREGISTER_CLI_CC_LOCK ();
		ECFM_REGISTER_CLI_LBLT_LOCK ();

		i4RetVal = EcfmCliClearEthBnCount (CliHandle, u4IfIndex);

		ECFM_UNREGISTER_CLI_LBLT_LOCK ();
		ECFM_REGISTER_CLI_CC_LOCK ();


		if (i4RetVal == CLI_FAILURE)
		{
			return (CLI_FAILURE);
		}

	u4CurrIfIdx = u4IfIndex;

	i4RetVal = nmhGetNextIndexFsMIY1731EthBnPortTable (u4CurrIfIdx, (INT4 *)&u4IfIndex);

    }while (i4RetVal == SNMP_SUCCESS);

	return (CLI_SUCCESS);

}

/****************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliClearEthBnCount
 *
 *     DESCRIPTION      : This function will clear ethbn counters.
 *
 *     INPUT            : CliHandle    - CliContext ID
 *                        u4ContextId  - Context Identtifier
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ****************************************************************************/
INT4
EcfmCliClearEthBnCount (tCliHandle CliHandle, UINT4 u4IfIndex)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4BnClearStat = 0;

    if (nmhTestv2FsMIY1731EthBnClearStats
        (&u4ErrorCode, (INT4) u4IfIndex, ECFM_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731EthBnClearStats ((INT4) u4IfIndex, ECFM_TRUE) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    UNUSED_PARAM(i4BnClearStat);
    return CLI_SUCCESS;
}
/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetMultipleMepsCapability
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable various 
 *                        MEP's capabilities at the provided Level and Vlan.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Type      - Command Type
 *                        au1MdLevel  - MdLevel 
 *                        u2NoOfMdLevels - No. of Levels
 *                        au1VlanId   - Vlan Id
 *                        u4FlagVal   - Capability to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetMultipleMepsCapability (tCliHandle CliHandle,
                                  UINT4 u4CurrContextId,
                                  UINT4 u4Type, UINT1 au1MdLevel[],
                                  UINT2 u2NoOfMdLevels,
                                  UINT1 au1VlanId[], UINT4 u4FlagVal,
                                  UINT1 *pu1MaName, UINT1 *pu1MdName)
{
    tVlanId             VlanId;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT4               u4BitIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMepPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4RetMaFormat = SNMP_FAILURE;
    UINT2               u2VlanFlag = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1EntryFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = 0;

    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
    }
    u4ContextId = u4CurrContextId;
    i4RetVal =
        nmhGetNextIndexFsMIEcfmMepTable (u4ContextId, &u4NextContextId,
                                         0, &u4MdIndex, 0, &u4MaIndex,
                                         0, &u4MepId);
    if (i4RetVal == SNMP_SUCCESS)
    {
        if (u4ContextId != u4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }
    else
    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
        }
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        /* Copying the vlan list into 2-D array at the specified index (i.e.
         * level), this will be further used to display the level and vlan 
         * for which cc status is not set */
        ECFM_MEMCPY (apu1LevelVlanList[au1MdLevel[u1LevelCounter]],
                     au1VlanId, sizeof (tVlanListExt));
        /* Copying the level list into a variable at the specified index (i.e.
         * level), this will be further used to display the level for unware
         * vlan entries */
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }
    /* Scan MEP table for this MD level and Vlan ID */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {

            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                b1EntryFound = ECFM_FALSE;
                i4RetPrimaryVid = ECFM_INIT_VAL;
                nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex,
                                               u4MaIndex, &i4RetPrimaryVid);
                nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex,
                                      &RetMaName);
                nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                        &i4RetMaFormat);
                MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                             au1StrMaName);

                if ((u4Type != CLI_ECFM_SET_DOM_UNAWARE_MEP_CAPABILITY_IN_MA) &&
                    (u4Type != CLI_ECFM_SET_LEV_UNAWARE_MEP_CAPABILITY_IN_MA))
                {
                    for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                         u4ByteIndex++)
                    {
                        if (au1VlanId[u4ByteIndex] == 0)
                        {
                            continue;
                        }
                        u2VlanFlag = au1VlanId[u4ByteIndex];

                        for (u4BitIndex = 0;
                             ((u4BitIndex < BITS_PER_BYTE)
                              &&
                              (EcfmUtilQueryBitListTable
                               (u2VlanFlag, u4BitIndex) != 0)); u4BitIndex++)
                        {
                            VlanId =
                                (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                         EcfmUtilQueryBitListTable (u2VlanFlag,
                                                                    u4BitIndex));
                            nmhGetFsMIEcfmMepPrimaryVid
                                (u4ContextId, u4MdIndex,
                                 u4MaIndex, u4MepId,
                                 (UINT4 *) &i4RetMepPrimaryVid);
                            if ((((UINT2) i4RetPrimaryVid == VlanId)
                                 || ((UINT2) i4RetMepPrimaryVid == VlanId)) &&
                                (pu1MaName == NULL ||
                                 ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                            {
                                b1EntryFound = ECFM_TRUE;

                                /* Reset the entry for which MEP entry is
                                 * found */
                                ECFM_RESET_LIST_MEMBER
                                    (apu1LevelVlanList
                                     [au1MdLevel
                                      [u1LevelCounter]], i4RetPrimaryVid);

                                /* Setting Capabilities */
                                EcfmSetMepCapability (CliHandle,
                                                      u4ContextId,
                                                      u4MdIndex,
                                                      u4MaIndex,
                                                      u4MepId, u4FlagVal);
                                break;
                            }
                        }

                        if (b1EntryFound)
                        {
                            break;
                        }
                    }
                    break;
                }
                else if ((UINT2) i4RetPrimaryVid == 0)
                {

                    if ((pu1MaName == NULL) ||
                        (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                    {
                        b1EntryFound = ECFM_TRUE;
                        ECFM_CLEAR_U1BIT (u1LevelList,
                                          au1MdLevel[u1LevelCounter]);

                        /* Setting Capabilities */
                        EcfmSetMepCapability (CliHandle, u4ContextId,
                                              u4MdIndex, u4MaIndex, u4MepId,
                                              u4FlagVal);
                        break;
                    }
                    else
                    {

                        CliPrintf (CliHandle, "\r\n Service not"
                                   "configured at specified level\r\n");
                    }

                }
            }
        }

        /* Move to next MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepId, &u4NextMepId);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepId = u4NextMepId;
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }

    /* Loop that will display the level and vlan for which MEP capability is not set */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)

    {
        if (u4Type == CLI_ECFM_SET_DOM_UNAWARE_MEP_CAPABILITY_IN_MA ||
            u4Type == CLI_ECFM_SET_LEV_UNAWARE_MEP_CAPABILITY_IN_MA)
        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% MEP capability cannot be configured at level %d\r\n",
                           u1Level);
            }
            else
            {
                break;
            }
        }
        else
        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)

            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] == 0)
                {
                    continue;
                }
                u2VlanFlag = apu1LevelVlanList[u1LevelCounter][u4ByteIndex];

                if ((u4BitIndex < BITS_PER_BYTE)
                    && (EcfmUtilQueryBitListTable (u2VlanFlag, u4BitIndex) !=
                        0))
                {
                    VlanId =
                        (UINT2) ((u4ByteIndex * BITS_PER_BYTE) +
                                 EcfmUtilQueryBitListTable (u2VlanFlag,
                                                            u4BitIndex));

                    CliPrintf (CliHandle,
                               "\r%% MEP capability cannot be configured at level %d, vlan %d\r\n",
                               u1LevelCounter, VlanId);
                }
            }
        }
    }
    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
    }
    return CLI_SUCCESS;
}

INT4
EcfmCliSetMultipleMepsIsidCapability (tCliHandle CliHandle,
                                      UINT4 u4CurrContextId,
                                      UINT4 u4Type, UINT1 au1MdLevel[],
                                      UINT2 u2NoOfMdLevels,
                                      UINT1 *pu1ArgIsid, UINT4 u4FlagVal,
                                      UINT1 *pu1MaName)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMepPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    tSNMP_OCTET_STRING_TYPE RetMaName;
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    u4ContextId = u4CurrContextId;
    i4RetVal =
        nmhGetNextIndexFsMIEcfmMepTable (u4ContextId, &u4NextContextId,
                                         0, &u4MdIndex, 0, &u4MaIndex,
                                         0, &u4MepId);
    if (i4RetVal == SNMP_SUCCESS)
    {
        if (u4ContextId != u4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }
    else
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {
            if (u4RetMdLevel == au1MdLevel[u1LevelCounter])
            {
                b1EntryFound = ECFM_FALSE;
                i4RetPrimaryVid = ECFM_INIT_VAL;
                nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex,
                                               u4MaIndex, &i4RetPrimaryVid);
                nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex,
                                      &RetMaName);
                nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                        &i4RetMaFormat);

                MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
                EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                             au1StrMaName);

                if ((u4Type != CLI_ECFM_SET_DOM_UNAWARE_MEP_CAPABILITY_IN_MA)
                    && (u4Type != CLI_ECFM_SET_LEV_UNAWARE_MEP_CAPABILITY_IN_MA))
                {
                    u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
                    nmhGetFsMIEcfmMepPrimaryVid
                        (u4ContextId, u4MdIndex,
                         u4MaIndex, u4MepId, (UINT4 *) &i4RetMepPrimaryVid);
                    if ((((UINT4) i4RetPrimaryVid ==
                          ECFM_ISID_TO_ISID_INTERNAL (u4Isid))
                         || ((UINT4) i4RetMepPrimaryVid
                             == ECFM_ISID_TO_ISID_INTERNAL (u4Isid))) &&
                        (pu1MaName == NULL ||
                         ECFM_STRCMP (au1StrMaName, pu1MaName) == 0))
                    {
                        b1EntryFound = ECFM_TRUE;
                        EcfmSetMepCapability (CliHandle,
                                              u4ContextId,
                                              u4MdIndex,
                                              u4MaIndex, u4MepId, u4FlagVal);
                        break;
                    }
                }
            }
        }
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepId, &u4NextMepId);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepId = u4NextMepId;
            if (u4ContextId != u4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
    if (b1EntryFound != ECFM_TRUE)
    {
        u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {
            CliPrintf (CliHandle,
                       "\r%% MEP capability cannot be configured at level %d, isid %u\r\n",
                       au1MdLevel[u1LevelCounter], u4Isid);
        }
    }
    return CLI_SUCCESS;
}

/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmSetMepCapability
 *                                                                          
 *     DESCRIPTION      : This function will enable/disable various 
 *                        MEP's capabilities.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4MdIndex   - Md Index
 *                        u4Mdndex    - Ma Index
 *                        u4MepIndex   - Mep Index
 *                        u4FlagVal   - values to be set 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
PRIVATE INT4
EcfmSetMepCapability (tCliHandle CliHandle, UINT4 u4ContextId,
                      UINT4 u4MdIndex, UINT4 u4MaIndex,
                      UINT4 u4MepId, UINT4 u4Flag)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4Capability = ECFM_INIT_VAL;
    INT4                i4SendDmOptFields = ECFM_INIT_VAL;
    INT4                i4RetVal = CLI_SUCCESS;

    /* Check whether to enable or disable the capabilities */
    if ((u4Flag & CLI_ECFM_DISABLE_CAP) == CLI_ECFM_DISABLE_CAP)

    {
        i4Capability = ECFM_DISABLE;
    }

    else

    {
        i4Capability = ECFM_ENABLE;
    }
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    nmhGetFsMIEcfmMepPrimaryVid (u4ContextId, u4MdIndex, u4MaIndex,
                                 u4MepId, &u4RetMepPrimaryVid);
    nmhGetFsMIEcfmMaPrimaryVlanId (u4ContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaPrimaryVid);
    nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetMdLevel);

    do
    {
        /* Test if AIS capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_AIS_CAP) == CLI_ECFM_SET_AIS_CAP)
        {
            if (nmhTestv2FsMIY1731MepAisCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)
                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% AIS capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% AIS capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%% AIS capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% AIS capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% AIS capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if Rdi capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_RDI_CAP) == CLI_ECFM_SET_RDI_CAP)
        {
            if (nmhTestv2FsMIY1731MepRdiCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% RDI capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% RDI capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%% RDI capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% RDI capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% RDI capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Now set the AIS capability */
        if ((u4Flag & CLI_ECFM_SET_AIS_CAP) == CLI_ECFM_SET_AIS_CAP)
        {
            if (nmhSetFsMIY1731MepAisCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Now set the RDI capability */
        if ((u4Flag & CLI_ECFM_SET_RDI_CAP) == CLI_ECFM_SET_RDI_CAP)
        {
            if (nmhSetFsMIY1731MepRdiCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    do
    {
        if (i4RetVal == CLI_FAILURE)
        {
            break;
        }

        /* Test if ping capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_PING_CAP) == CLI_ECFM_SET_PING_CAP)
        {
            if (nmhTestv2FsMIY1731MepLoopbackCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)
            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)
                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Ping capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Ping capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else
                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Ping capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Ping capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Ping capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if multicast LBM reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_MCAST_PING_RX_CAP) ==
            CLI_ECFM_SET_MCAST_PING_RX_CAP)

        {
            if (nmhTestv2FsMIY1731MepMulticastLbmRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Loopback reception capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Loopback reception capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Loopback reception capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Loopback reception capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Loopback reception capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if 1DM reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_1WAY_FD_RX_CAP) ==
            CLI_ECFM_SET_1WAY_FD_RX_CAP)

        {
            if (nmhTestv2FsMIY1731Mep1DmRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% 1-DM reception capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% 1-DM reception capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%% 1-DM reception capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% 1-DM reception capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%% 1-DM reception capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if test capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_TST_RX_CAP) == CLI_ECFM_SET_TST_RX_CAP)

        {
            if (nmhTestv2FsMIY1731MepTstCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Tst capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Tst capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%% Tst capability cannot be set for level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Tst capability cannot be set for level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Tst reception capability cannot be set for level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if multicast test reception capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_MCAST_TST_RX_CAP) ==
            CLI_ECFM_SET_MCAST_TST_RX_CAP)

        {
            if (nmhTestv2FsMIY1731MepMulticastTstRecvCapability
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4Capability) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%Multicast Tst capability cannot be set for \n level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%%Multicast Tst capability cannot be set for \n level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%%Multicast Tst capability cannot be set for \n level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Multicast Tst capability cannot be set for \n level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else

                    {
                        CliPrintf (CliHandle,
                                   "\r%%Multicast Tst reception capability cannot be set for \n level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Test if optional fields in DMR capability can be set or not */
        if ((u4Flag & CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP) ==
            CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP)

        {
            if (i4Capability == ECFM_ENABLE)

            {
                i4SendDmOptFields = ECFM_SNMP_TRUE;
            }

            else

            {
                i4SendDmOptFields = ECFM_SNMP_FALSE;
            }
            if (nmhTestv2FsMIY1731MepDmrOptionalFields
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SendDmOptFields) == SNMP_FAILURE)

            {
                i4RetVal = CLI_FAILURE;
                if (u4RetMepPrimaryVid != 0)

                {
                    if (u4RetMepPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                    {
                        CliPrintf (CliHandle,
                                   "\r%%Dmr optional fields capability cannot be set for \n level %d, vlan %d\r\n",
                                   i4RetMdLevel, u4RetMepPrimaryVid);
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%%Dmr optional fields capability cannot be set for \n level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (u4RetMepPrimaryVid));
                    }

                }
                else

                {
                    if ((i4RetMaPrimaryVid != 0)
                        && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                    {
                        CliPrintf (CliHandle,
                                   "\r%%Dmr optional fields capability cannot be set for \n level %d, vlan %d\r\n",
                                   i4RetMdLevel, i4RetMaPrimaryVid);
                    }
                    else if ((i4RetMaPrimaryVid != 0)
                             && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Dmr optional fields capability cannot be set for \n level %d, Isid %d\r\n",
                                   i4RetMdLevel,
                                   ECFM_ISID_INTERNAL_TO_ISID
                                   (i4RetMaPrimaryVid));

                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r%%Dmr optional fields capability cannot be set for \n level %d\r\n",
                                   i4RetMdLevel);
                    }
                }
                break;
            }
        }

        /* Now set the required parameters */
        if ((u4Flag & CLI_ECFM_SET_PING_CAP) == CLI_ECFM_SET_PING_CAP)

        {
            if (nmhSetFsMIY1731MepLoopbackCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if ((u4Flag & CLI_ECFM_SET_MCAST_PING_RX_CAP) ==
            CLI_ECFM_SET_MCAST_PING_RX_CAP)

        {
            if (nmhSetFsMIY1731MepMulticastLbmRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if ((u4Flag & CLI_ECFM_SET_1WAY_FD_RX_CAP) ==
            CLI_ECFM_SET_1WAY_FD_RX_CAP)

        {
            if (nmhSetFsMIY1731Mep1DmRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if ((u4Flag & CLI_ECFM_SET_TST_RX_CAP) == CLI_ECFM_SET_TST_RX_CAP)

        {
            if (nmhSetFsMIY1731MepTstCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if ((u4Flag & CLI_ECFM_SET_MCAST_TST_RX_CAP) ==
            CLI_ECFM_SET_MCAST_TST_RX_CAP)

        {
            if (nmhSetFsMIY1731MepMulticastTstRecvCapability
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4Capability) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if ((u4Flag & CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP) ==
            CLI_ECFM_SET_TX_OPT_FIELDS_DMR_CAP)

        {
            if (nmhSetFsMIY1731MepDmrOptionalFields
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SendDmOptFields) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetCcmMac
 *                                                                          
 *     DESCRIPTION      : This function sets destination Mac Address for 
 *                        Continuity check.     
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - Context ID 
 *                        pu1MacAddr - Mac Address to set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetCcmMac (tCliHandle CliHandle, UINT4 u4ContextId,
                  UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetVal = CLI_SUCCESS;
    tEcfmMacAddr        au1InMacAddr;
    ECFM_MEMSET (au1InMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);

    /*In case of unicast set the MepUnicastCcmMacAddress as user specified 
     *In case of Multicast reset the MepUnicastCcmMacAddress */
    if (u4Command == CLI_ECFM_SET_CCM_UNICAST_MAC)

    {
        StrToMac (pu1Arg1, au1InMacAddr);
    }

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check if Mac Address can be set */
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Set the unicast Mac Address  */
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    /* Set the Mac Address  */
    do

    {
        if (nmhTestv2FsMIY1731MepUnicastCcmMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, au1InMacAddr) == SNMP_FAILURE)

        {
            i4RetVal = CLI_FAILURE;
            break;
        }
        if (nmhSetFsMIY1731MepUnicastCcmMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
             au1InMacAddr) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            break;
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetVal;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmTstSignalHandler                            
 *                                                                           
 *    Description         : This routne is called whenever Ctrl C is pressed 
 *                          to stop the TST Transaction                       
 *                                                                           
 *    Input(s)            : None                                             
 *                                                                           
 *    Output(s)           : None                                             
 *                                                                           
 *    Returns            : None                                              
 *****************************************************************************/
PRIVATE VOID
EcfmTstSignalHandler (INT4 i4Signal)
{
    tEcfmLbLtMsg       *pMsg = NULL;
    UNUSED_PARAM (i4Signal);

    /* Register to handle CTRL C event */
    CliEcfmRegisterSignalHandler (ECFM_SIGINT, EcfmTstSignalHandler);
    if (ECFM_LBLT_CLI_EVENT_INFO (0) == NULL)

    {
        return;
    }
    if (ECFM_ALLOC_MEM_BLOCK_LBLT_MSGQ (pMsg) == NULL)

    {
        return;
    }
    ECFM_MEMSET (pMsg, ECFM_INIT_VAL, ECFM_LBLT_MSG_INFO_SIZE);
    pMsg->MsgType = (tEcfmMsgType) ECFM_TST_STOP_TRANSACTION;
    pMsg->u4ContextId = ECFM_LBLT_CLI_EVENT_INFO (0)->u4ContextId;
    pMsg->u4PortNum = ECFM_LBLT_CLI_EVENT_INFO (0)->u4PortNum;
    pMsg->uMsg.Mep.u4VidIsid = ECFM_LBLT_CLI_EVENT_INFO (0)->u4VidIsid;
    pMsg->uMsg.Mep.u1MdLevel = ECFM_LBLT_CLI_EVENT_INFO (0)->u1MdLevel;
    pMsg->uMsg.Mep.u1Direction = ECFM_LBLT_CLI_EVENT_INFO (0)->u1Direction;
    if (EcfmLbLtCfgQueMsg (pMsg) != ECFM_SUCCESS)

    {
        ECFM_FREE_MEM_BLOCK (ECFM_LBLT_MSGQ_POOL, (UINT1 *) pMsg);
        return;
    }

    /* Sync Stop LB/TST Transaction at STAND BY Node */
    EcfmRedSyncStopLbTstTran (ECFM_TST_STOP_TRANSACTION, pMsg);
    return;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmThSignalHandler                            
 *                                                                           
 *    Description         : This routne is called whenever Ctrl C is pressed 
 *                          to stop the TH Transaction                       
 *                                                                           
 *    Input(s)            : None                                             
 *                                                                           
 *    Output(s)           : None                                             
 *                                                                           
 *    Returns            : None                                              
 *****************************************************************************/
PRIVATE VOID
EcfmThSignalHandler (INT4 i4Signal)
{
    tEcfmLbLtMsg       *pMsg = NULL;
    UNUSED_PARAM (i4Signal);
    /* Register to handle CTRL C event */
    CliEcfmRegisterSignalHandler (ECFM_SIGINT, EcfmThSignalHandler);
    if (ECFM_LBLT_CLI_EVENT_INFO (0) == NULL)
    {
        return;
    }
    if (ECFM_ALLOC_MEM_BLOCK_LBLT_MSGQ (pMsg) == NULL)
    {
        return;
    }
    ECFM_MEMSET (pMsg, ECFM_INIT_VAL, ECFM_LBLT_MSG_INFO_SIZE);
    pMsg->MsgType = (tEcfmMsgType) ECFM_TH_STOP_TRANSACTION;
    pMsg->u4ContextId = ECFM_LBLT_CLI_EVENT_INFO (0)->u4ContextId;
    pMsg->u4PortNum = ECFM_LBLT_CLI_EVENT_INFO (0)->u4PortNum;
    pMsg->uMsg.Mep.u4VidIsid = ECFM_LBLT_CLI_EVENT_INFO (0)->u4VidIsid;
    pMsg->uMsg.Mep.u1MdLevel = ECFM_LBLT_CLI_EVENT_INFO (0)->u1MdLevel;
    pMsg->uMsg.Mep.u1Direction = ECFM_LBLT_CLI_EVENT_INFO (0)->u1Direction;
    if (EcfmLbLtCfgQueMsg (pMsg) != ECFM_SUCCESS)
    {
        ECFM_FREE_MEM_BLOCK (ECFM_LBLT_MSGQ_POOL, (UINT1 *) pMsg);
        return;
    }
    /* Sync Stop LB/TST Transaction at STAND BY Node */
    EcfmRedSyncStopLbTstTran (ECFM_TH_STOP_TRANSACTION, pMsg);
    return;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmLtSignalHandler                            
 *                                                                           
 *    Description         : This routne is called whenever Ctrl C is pressed 
 *                          to stop the LT Transaction                       
 *                                                                           
 *    Input(s)            : None                                             
 *                                                                           
 *    Output(s)           : None                                             
 *                                                                           
 *    Returns            : None                                              
 *****************************************************************************/
VOID
EcfmLtSignalHandler (INT4 i4Signal)
{
    tEcfmLbLtMsg       *pMsg = NULL;
    UNUSED_PARAM (i4Signal);

    /* Register to handle CTRL C event */
    CliEcfmRegisterSignalHandler (ECFM_SIGINT, EcfmLtSignalHandler);

    if (ECFM_LBLT_CLI_EVENT_INFO (0) == NULL)
    {
        return;
    }

    if (ECFM_ALLOC_MEM_BLOCK_LBLT_MSGQ (pMsg) == NULL)
    {
        return;
    }

    ECFM_MEMSET (pMsg, ECFM_INIT_VAL, ECFM_LBLT_MSG_INFO_SIZE);

    pMsg->MsgType = (tEcfmMsgType) ECFM_LT_STOP_TRANSACTION;
    pMsg->u4ContextId = ECFM_LBLT_CLI_EVENT_INFO (0)->u4ContextId;
    pMsg->u4PortNum = ECFM_LBLT_CLI_EVENT_INFO (0)->u4PortNum;
    pMsg->uMsg.Mep.u4VidIsid = ECFM_LBLT_CLI_EVENT_INFO (0)->u4VidIsid;
    pMsg->uMsg.Mep.u1MdLevel = ECFM_LBLT_CLI_EVENT_INFO (0)->u1MdLevel;
    pMsg->uMsg.Mep.u1Direction = ECFM_LBLT_CLI_EVENT_INFO (0)->u1Direction;
    pMsg->uMsg.Mep.u4MdIndex = ECFM_LBLT_CLI_EVENT_INFO (0)->u4MdIndex;
    pMsg->uMsg.Mep.u4MaIndex = ECFM_LBLT_CLI_EVENT_INFO (0)->u4MaIndex;
    pMsg->uMsg.Mep.u2MepId =
        (UINT2) (ECFM_LBLT_CLI_EVENT_INFO (0)->u4LocalMepId);

    if (EcfmLbLtCfgQueMsg (pMsg) != ECFM_SUCCESS)
    {
        ECFM_FREE_MEM_BLOCK (ECFM_LBLT_MSGQ_POOL, (UINT1 *) pMsg);
        return;
    }
    return;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmLbSignalHandler                            
 *                                                                           
 *    Description         : This routne is called whenever Ctrl C is pressed 
 *                          to stop the LB Transaction                       
 *                                                                           
 *    Input(s)            : None                                             
 *                                                                           
 *    Output(s)           : None                                             
 *                                                                           
 *    Returns            : None                                              
 *****************************************************************************/
VOID
EcfmLbSignalHandler (INT4 i4Signal)
{
    tEcfmLbLtMsg       *pMsg = NULL;
    UNUSED_PARAM (i4Signal);

    /* Register to handle CTRL C event */
    CliEcfmRegisterSignalHandler (ECFM_SIGINT, EcfmLbSignalHandler);

    if (ECFM_LBLT_CLI_EVENT_INFO (0) == NULL)
    {
        return;
    }

    if (ECFM_ALLOC_MEM_BLOCK_LBLT_MSGQ (pMsg) == NULL)
    {
        return;
    }

    ECFM_MEMSET (pMsg, ECFM_INIT_VAL, ECFM_LBLT_MSG_INFO_SIZE);

    pMsg->MsgType = (tEcfmMsgType) ECFM_LB_STOP_TRANSACTION;
    pMsg->u4ContextId = ECFM_LBLT_CLI_EVENT_INFO (0)->u4ContextId;
    pMsg->u4PortNum = ECFM_LBLT_CLI_EVENT_INFO (0)->u4PortNum;
    pMsg->uMsg.Mep.u4VidIsid = ECFM_LBLT_CLI_EVENT_INFO (0)->u4VidIsid;
    pMsg->uMsg.Mep.u1MdLevel = ECFM_LBLT_CLI_EVENT_INFO (0)->u1MdLevel;
    pMsg->uMsg.Mep.u1Direction = ECFM_LBLT_CLI_EVENT_INFO (0)->u1Direction;
    pMsg->uMsg.Mep.u4MdIndex = ECFM_LBLT_CLI_EVENT_INFO (0)->u4MdIndex;
    pMsg->uMsg.Mep.u4MaIndex = ECFM_LBLT_CLI_EVENT_INFO (0)->u4MaIndex;
    pMsg->uMsg.Mep.u2MepId =
        (UINT2) (ECFM_LBLT_CLI_EVENT_INFO (0)->u4LocalMepId);
    pMsg->uMsg.Mep.u1SelectorType =
        ECFM_LBLT_CLI_EVENT_INFO (0)->u1SelectorType;

    if (EcfmLbLtCfgQueMsg (pMsg) != ECFM_SUCCESS)
    {
        ECFM_FREE_MEM_BLOCK (ECFM_LBLT_MSGQ_POOL, (UINT1 *) pMsg);
        return;
    }

    /* Sync Stop LB/TST Transaction at STANDBY Node */
    EcfmRedSyncStopLbTstTran (ECFM_LB_STOP_TRANSACTION, pMsg);
    return;
}

/*****************************************************************************
 *                                                                           
 *    Function Name       : EcfmGetBit
 *                                                                           
 *    Description         : This routne is used to get thge first non zero
 *                          bit in the byte, it also turns the bit to off.
 *                                                                           
 *    Input(s)            : pu1Byte - byte from which bits needs to be checked                                     
 *                                                                           
 *    Output(s)           : None                                             
 *                                                                           
 *    Returns             : bit position
 *****************************************************************************/
PRIVATE UINT1
EcfmGetBit (UINT1 *pu1Byte)
{
    UINT1               u1Counter = 0;
    while (*pu1Byte != 0)

    {
        for (u1Counter = 0; u1Counter < ECFM_BITS_IN_ONE_BYTE; u1Counter++)

        {
            if (((*pu1Byte >> u1Counter) & 0x01) != 0)

            {
                *pu1Byte &= ~(0x01 << u1Counter);
                return u1Counter;
            }
        }
    }
    return 0;
}
/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFLSlmProActive
 *                                                                          
 *     DESCRIPTION      : This function is used to display the contents of the Synthentic 
 *                        Loss Measurement buffer for ProActive.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        pu1Arg1     - Md name
 *                        pu1Arg2     - Ma Name
 *                        u4SlmMepId  - Local Mep ID
 *                        u4SlmRMepId - Remote Mep ID
 *                        i4TestType  -  Single/Dual Ended
 *                        u4TestId    - Test Id
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 ******************************************************************************/
INT4
EcfmCliShowFLSlmProActive (tCliHandle CliHandle,UINT4 u4FsMIY1731ContextId,
                          UINT4 u4FsMIY1731MegIndex,UINT4 u4FsMIY1731MeIndex,
                          UINT4 u4FsMIY1731MepIdentifier, 
                          UINT4 u4FsMIY1731SlmRMepIdentifier,
                          INT4 i4FsMIY1731MepSlmProATestType,
                          UINT4 u4FsMIY1731MepSlmProATestId)
{
	UINT4 u4FarEndLoss=0;
	UINT4 u4FarEndFLR=0;
	UINT4 u4FarEndFLRMin=0;
	UINT4 u4FarEndFLRAvg=0;
	UINT4 u4FarEndFLRMax=0;
	UINT4 u4FarEndAvailableCount=0;
	UINT4 u4FarEndUnAvailableCount=0;
	UINT4 u4FarEndHLICount=0;
	UINT4 u4FarEndState=0;
	UINT4 u4FarEndCHLICount=0;
	UINT4 u4NearEndLoss=0;
	UINT4 u4NearEndFLR=0;
	UINT4 u4NearEndFLRMin=0;
	UINT4 u4NearEndFLRAvg=0;
	UINT4 u4NearEndFLRMax=0;
	UINT4 u4NearEndAvailableCount=0;
	UINT4 u4NearEndUnAvailableCount=0;
	UINT4 u4NearEndHLICount=0;
	UINT4 u4NearEndState=0;
	UINT4 u4NearEndCHLICount=0;
	INT4 i4DestType=0;
	INT4 i4RetStatus =0;


	i4RetStatus = nmhGetFsMIY1731MepSlmProADestType
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
		  	 u4FsMIY1731SlmRMepIdentifier ,
			 i4FsMIY1731MepSlmProATestType,
			 u4FsMIY1731MepSlmProATestId , &i4DestType);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndLoss
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex 
                         ,u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,
                         i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4FarEndLoss);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndFLR
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4FarEndFLR);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndFLRMin
                           (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                            u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                            u4FsMIY1731SlmRMepIdentifier ,
                            i4FsMIY1731MepSlmProATestType ,
                            u4FsMIY1731MepSlmProATestId , 
                            &u4FarEndFLRMin);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndFLRAvg
                         (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                          u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                          u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                           u4FsMIY1731MepSlmProATestId ,&u4FarEndFLRAvg);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndFLRMax
                          (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                           u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                           u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                           u4FsMIY1731MepSlmProATestId , &u4FarEndFLRMax);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndAvailableCount
                         (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                          u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                          u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                          u4FsMIY1731MepSlmProATestId , &u4FarEndAvailableCount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndUnAvailableCount
                         (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                          u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                          u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                          u4FsMIY1731MepSlmProATestId ,&u4FarEndUnAvailableCount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndHLICount
                       (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                        u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                        u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                        u4FsMIY1731MepSlmProATestId , &u4FarEndHLICount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndState
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , (INT4 *)&u4FarEndState);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProAFarEndCHLICount
                         (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                          u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                          u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                          u4FsMIY1731MepSlmProATestId , &u4FarEndCHLICount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}


	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndLoss
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4NearEndLoss);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndFLR
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4NearEndFLR);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndFLRMin
                       (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                        u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                        u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                        u4FsMIY1731MepSlmProATestId , &u4NearEndFLRMin);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndFLRAvg
                       (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                        u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                        u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                        u4FsMIY1731MepSlmProATestId ,&u4NearEndFLRAvg);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndFLRMax
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4NearEndFLRMax);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndAvailableCount
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4NearEndAvailableCount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}


	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndUnAvailableCount
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId ,&u4NearEndUnAvailableCount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndHLICount
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , (INT4 *)&u4NearEndHLICount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndState
                         (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                          u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                          u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                          u4FsMIY1731MepSlmProATestId , (INT4 *)&u4NearEndState);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	i4RetStatus = nmhGetFsMIY1731MepSlmProANearEndCHLICount
                        (u4FsMIY1731ContextId ,u4FsMIY1731MegIndex ,
                         u4FsMIY1731MeIndex ,u4FsMIY1731MepIdentifier ,
                         u4FsMIY1731SlmRMepIdentifier ,i4FsMIY1731MepSlmProATestType ,
                         u4FsMIY1731MepSlmProATestId , &u4NearEndCHLICount);

	if (i4RetStatus == SNMP_FAILURE)
	{
		return (CLI_FAILURE);
	}

	/* Display SLM ProActive */
	CliPrintf(CliHandle, "Synthetic Loss Measurement : ProActive \r\n");
	CliPrintf(CliHandle, "----------------------------------------\r\n");

	CliPrintf (CliHandle, "\r\nTest Id : %d \r\n",u4FsMIY1731MepSlmProATestId);

	if(i4FsMIY1731MepSlmProATestType == CLI_ECFM_LM_TYPE_SINGLE_ENDED )
		CliPrintf (CliHandle, "Test Type :  Single-Ended \r\n");
	else
		CliPrintf (CliHandle, "Test Type : Dual-Ended  \r\n");

	if(i4DestType == CLI_ECFM_LM_DEST_TYPE_POINT_TO_POINT)
		CliPrintf (CliHandle, "Dest Type :  Point-to-Point  \r\n");
	else
		CliPrintf (CliHandle, "Dest Type : Point-to-Multipoint  \r\n");

	CliPrintf (CliHandle, "\r\n");
	CliPrintf (CliHandle, "Far-End Results: \r\n");

	if(u4FarEndState == ECFM_TRUE)
	{
		CliPrintf (CliHandle, "Far-End State : Available  \r\n");
	}
	else
	{
		CliPrintf (CliHandle, "Far-End State : UnAvailable  \r\n",u4FarEndState);
	}

	CliPrintf (CliHandle, "Far-End UnAvailable Count : %d   \r\n",u4FarEndUnAvailableCount);
	CliPrintf (CliHandle, "Far-End Available Count : %d   \r\n",u4FarEndAvailableCount);
	CliPrintf (CliHandle, "Far-End FLR : %d   \r\n",u4FarEndFLR);
	CliPrintf (CliHandle, "Far-End FLR Minimum : %d   \r\n",u4FarEndFLRMin);
	CliPrintf (CliHandle, "Far-End FLR Average : %d   \r\n",u4FarEndFLRAvg);
	CliPrintf (CliHandle, "Far-End FLR Maximum : %d   \r\n",u4FarEndFLRMax);
	CliPrintf (CliHandle, "Far-End High Loss Interval Count(HLI) : %d   \r\n",u4FarEndHLICount);
	CliPrintf (CliHandle, "Far-End Consecutive High Loss Interval Count(CHLI) : %d   \r\n",u4FarEndCHLICount);

	CliPrintf (CliHandle, "\r\n");
	CliPrintf (CliHandle, "Near-End Results :  \r\n");

	if(u4NearEndState == ECFM_TRUE)
	{
		CliPrintf (CliHandle, "Near-End State : Available   \r\n");
	}
	else
	{
		CliPrintf (CliHandle, "Near-End State : UnAvailable   \r\n");
	}
	CliPrintf (CliHandle, "Near-End UnAvailable Count : %d   \r\n",u4NearEndUnAvailableCount);
	CliPrintf (CliHandle, "Near-End Available Count : %d   \r\n",u4NearEndAvailableCount);
	CliPrintf (CliHandle, "Near-End FLR : %d   \r\n",u4NearEndFLR);
	CliPrintf (CliHandle, "Near-End FLR Minimum : %d   \r\n",u4NearEndFLRMin);
	CliPrintf (CliHandle, "Near-End FLR Average : %d   \r\n",u4NearEndFLRAvg);
	CliPrintf (CliHandle, "Near-End FLR Maximum : %d   \r\n",u4NearEndFLRMax);
	CliPrintf (CliHandle, "Near-End High Loss Interval Count(HLI) : %d   \r\n",u4NearEndHLICount);
	CliPrintf (CliHandle, "Near-End Consecutive High Loss Interval Count(CHLI) : %d   \r\n",u4NearEndCHLICount);

	CliPrintf (CliHandle, "\r\n");

	return (CLI_SUCCESS);
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFLSlmProActiveBuffer
 *                                                                          
 *     DESCRIPTION      : This function is used to display the contents of the Synthentic 
 *                        Loss Measurement buffer for ProActive.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        pu1Arg1     - Md name
 *                        pu1Arg2     - Ma Name
 *                        u4SlmMepId  - Local Mep ID
 *                        u4SlmRMepId - Remote Mep ID
 *                        i4TestType  -  Single/Dual Ended
 *                        u4TestId    - Test Id
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                         
 ******************************************************************************/ 
INT4
EcfmCliShowFLSlmProActiveBuffer (tCliHandle CliHandle, UINT4 u4ContextId,
                                 UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                                 UINT4 u4SlmMepId,UINT4 u4SlmRMepId,
                                 INT4 i4TestType,UINT4 u4TestId)
{
	UINT4               u4FsMIY1731ContextId =0;
	UINT4               u4FsMIY1731MegIndex =0;
	UINT4               u4FsMIY1731MeIndex =0;
	UINT4               u4FsMIY1731MepIdentifier =0;
	UINT4               u4FsMIY1731SlmRMepIdentifier =0;
	UINT4               u4FsMIY1731MepSlmProATestId=0;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMaFormat = ECFM_INIT_VAL;
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	INT4                i4FsMIY1731MepSlmProATestType =0;
	INT4                i4RetStatus =0;
	BOOL1               b1Entry = ECFM_FALSE;
	tSNMP_OCTET_STRING_TYPE RetMaName;
	tSNMP_OCTET_STRING_TYPE RetMdName;

	ECFM_UNREGISTER_CLI_CC_LOCK ();
	ECFM_REGISTER_CLI_LBLT_LOCK ();

	/* Getting the first Entry */
	i4RetStatus = nmhGetFirstIndexFsMIY1731MepSlmProAStatsTable( &u4FsMIY1731ContextId,
                              &u4FsMIY1731MegIndex,&u4FsMIY1731MeIndex,&u4FsMIY1731MepIdentifier,
                              &u4FsMIY1731SlmRMepIdentifier,&i4FsMIY1731MepSlmProATestType,
                              &u4FsMIY1731MepSlmProATestId);

	ECFM_REGISTER_CLI_CC_LOCK ();
	ECFM_UNREGISTER_CLI_LBLT_LOCK ();

	if (i4RetStatus == SNMP_FAILURE)
	{
		CliPrintf (CliHandle,"\r\n Entry Not Found :  \r\n");
		return (CLI_FAILURE);
	}

	/* Search for OnDemand Stats table satisfying the input conditions */
	do
	{
		MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMdName.pu1_OctetList = au1RetMdName;
		RetMdName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMdName (u4ContextId, u4FsMIY1731MegIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4FsMIY1731MegIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMaName.pu1_OctetList = au1RetMaName;
		RetMaName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMaName (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex, &RetMaName);
		RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
		nmhGetFsMIEcfmMaFormat (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex,
				&i4RetMaFormat);
		EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

		/* Checking wheather user configured entry is present or not */
                /* Not comparing TestId */
		if((u4SlmRMepId != ECFM_INIT_VAL) && (u4TestId == ECFM_INIT_VAL))
		{
			if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
					(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
					(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
					(u4FsMIY1731SlmRMepIdentifier ==  u4SlmRMepId) &&
					(i4TestType == i4FsMIY1731MepSlmProATestType))

			{
				ECFM_UNREGISTER_CLI_CC_LOCK ();
				ECFM_REGISTER_CLI_LBLT_LOCK ();

				/*Entry is Present,Print the table */
				EcfmCliShowFLSlmProActive(CliHandle,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
						u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						i4FsMIY1731MepSlmProATestType,u4FsMIY1731MepSlmProATestId);

				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				b1Entry = ECFM_TRUE;
			}
		}
                 /* Not comparing RMepId */
		else if((u4SlmRMepId == ECFM_INIT_VAL) && (u4TestId!= ECFM_INIT_VAL))
		{
			if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
					(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
					(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
					(i4TestType == i4FsMIY1731MepSlmProATestType) &&
					(u4TestId == u4FsMIY1731MepSlmProATestId) )

			{
				ECFM_UNREGISTER_CLI_CC_LOCK ();
				ECFM_REGISTER_CLI_LBLT_LOCK ();

				/*Entry is Present,Print the table */
				EcfmCliShowFLSlmProActive(CliHandle,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
						u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						i4FsMIY1731MepSlmProATestType,u4FsMIY1731MepSlmProATestId);

				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				b1Entry = ECFM_TRUE;
			}
		}
                 /* Not comparing RMepId and TestId */
                else if((u4SlmRMepId == ECFM_INIT_VAL) && (u4TestId == ECFM_INIT_VAL))
                {
                        if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
                                        (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                                        (u4FsMIY1731MepIdentifier == u4SlmMepId) &&
                                        (i4TestType == i4FsMIY1731MepSlmProATestType))

                        {
                                ECFM_UNREGISTER_CLI_CC_LOCK ();
                                ECFM_REGISTER_CLI_LBLT_LOCK ();

                                /*Entry is Present,Print the table */
                                EcfmCliShowFLSlmProActive(CliHandle,u4FsMIY1731ContextId,
                                                u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
                                                u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
                                                i4FsMIY1731MepSlmProATestType,u4FsMIY1731MepSlmProATestId);

                                ECFM_REGISTER_CLI_CC_LOCK ();
                                ECFM_UNREGISTER_CLI_LBLT_LOCK ();

                                b1Entry = ECFM_TRUE;
                        }
                }
		else
		{
			if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
					(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
					(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
					(u4FsMIY1731SlmRMepIdentifier ==  u4SlmRMepId) &&
					(i4TestType == i4FsMIY1731MepSlmProATestType) &&
					(u4TestId == u4FsMIY1731MepSlmProATestId) )
			{
				ECFM_UNREGISTER_CLI_CC_LOCK ();
				ECFM_REGISTER_CLI_LBLT_LOCK ();

				/*Entry is Present,Print the table */
				EcfmCliShowFLSlmProActive(CliHandle,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
						u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						i4FsMIY1731MepSlmProATestType,u4FsMIY1731MepSlmProATestId);

				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				b1Entry = ECFM_TRUE;
			}
		}
		ECFM_UNREGISTER_CLI_CC_LOCK ();
		ECFM_REGISTER_CLI_LBLT_LOCK ();

		/* Move to Next entry */
		i4RetStatus =nmhGetNextIndexFsMIY1731MepSlmProAStatsTable( 
                                            u4FsMIY1731ContextId,&u4FsMIY1731ContextId,
                                            u4FsMIY1731MegIndex,&u4FsMIY1731MegIndex,
                                            u4FsMIY1731MeIndex,&u4FsMIY1731MeIndex,
                                            u4FsMIY1731MepIdentifier,&u4FsMIY1731MepIdentifier,
                                            u4FsMIY1731SlmRMepIdentifier,&u4FsMIY1731SlmRMepIdentifier,
                                            i4FsMIY1731MepSlmProATestType,&i4FsMIY1731MepSlmProATestType,
                                            u4FsMIY1731MepSlmProATestId,&u4FsMIY1731MepSlmProATestId);

		ECFM_REGISTER_CLI_CC_LOCK ();
		ECFM_UNREGISTER_CLI_LBLT_LOCK ();

	}
	while (i4RetStatus == SNMP_SUCCESS);

	if(b1Entry != ECFM_TRUE)
	{
		CliPrintf (CliHandle,"\r\n Entry Not Found :  \r\n");
	}

	return (CLI_SUCCESS);
}



/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFLSlmOnDemandBuffer
 *                                                                          
 *     DESCRIPTION      : This function is used to display the contents of the Synthentic 
 *                        Loss Measurement buffer for OnDemand.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        pu1Arg1  - Md name
 *                        pu1Arg2   - Ma Name
 *                        u4SlmMepId  - Local Mep ID
 *                        u4SlmRMepId    -Remote Mep ID
 *                        i4TestType -  Single/Dual Ended
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowFLSlmOnDemandBuffer (tCliHandle CliHandle, UINT4 u4ContextId,
		                UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                                UINT4 u4SlmMepId,UINT4 u4SlmRMepId,
                                INT4 i4TestType)
{
	UINT4               u4FsMIY1731ContextId =0;
	UINT4               u4FsMIY1731MegIndex =0;
	UINT4               u4FsMIY1731MeIndex =0;
	UINT4               u4FsMIY1731MepIdentifier =0;
	UINT4               u4FsMIY1731SlmRMepIdentifier =0;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMaFormat = ECFM_INIT_VAL;
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	INT4                i4FsMIY1731MepSlmOnDemandTestType =0;
	INT4                i4RetStatus =0;
	BOOL1               b1Entry = ECFM_FALSE;
	tSNMP_OCTET_STRING_TYPE RetMaName;
	tSNMP_OCTET_STRING_TYPE RetMdName;

	ECFM_UNREGISTER_CLI_CC_LOCK ();
	ECFM_REGISTER_CLI_LBLT_LOCK ();

	/* Getting the first Entry */
	i4RetStatus = nmhGetFirstIndexFsMIY1731MepSlmOnDemandStatsTable( &u4FsMIY1731ContextId,
			&u4FsMIY1731MegIndex,&u4FsMIY1731MeIndex,
			&u4FsMIY1731MepIdentifier,&u4FsMIY1731SlmRMepIdentifier,
			&i4FsMIY1731MepSlmOnDemandTestType);

	ECFM_REGISTER_CLI_CC_LOCK ();
	ECFM_UNREGISTER_CLI_LBLT_LOCK ();

	if (i4RetStatus == SNMP_FAILURE)
	{
		CliPrintf (CliHandle,"\r\n Entry Not Found \r\n");

		return (CLI_FAILURE);
	}

	/* Search for OnDemand Stats table satisfying the input conditions */
	do
	{
		MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMdName.pu1_OctetList = au1RetMdName;
		RetMdName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMdName (u4ContextId, u4FsMIY1731MegIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4FsMIY1731MegIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMaName.pu1_OctetList = au1RetMaName;
		RetMaName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMaName (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex, &RetMaName);
		RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
		nmhGetFsMIEcfmMaFormat (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex,
				&i4RetMaFormat);
		EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);


		/* Checking wheather user configured entry is present or not */

                /* Not comparing the RMep Id */
		if (u4SlmRMepId == ECFM_INIT_VAL)
		{

			if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
					(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
					(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
					(i4TestType == i4FsMIY1731MepSlmOnDemandTestType))

			{
				ECFM_UNREGISTER_CLI_CC_LOCK ();
				ECFM_REGISTER_CLI_LBLT_LOCK ();

				/*Entry is Present,Print the table */
				EcfmCliShowFLSlmOnDemand(CliHandle,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
						u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						i4FsMIY1731MepSlmOnDemandTestType);
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				b1Entry = ECFM_TRUE;
			}

		}
		else
		{
			if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
					(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
					(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
					(u4FsMIY1731SlmRMepIdentifier ==  u4SlmRMepId) &&
					(i4TestType == i4FsMIY1731MepSlmOnDemandTestType))

			{
				ECFM_UNREGISTER_CLI_CC_LOCK ();
				ECFM_REGISTER_CLI_LBLT_LOCK ();

				/*Entry is Present,Print the table */
				EcfmCliShowFLSlmOnDemand(CliHandle,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
						u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						i4FsMIY1731MepSlmOnDemandTestType);
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				b1Entry = ECFM_TRUE;
			}
		}

		ECFM_UNREGISTER_CLI_CC_LOCK ();
		ECFM_REGISTER_CLI_LBLT_LOCK ();

		/* Move to Next entry */
		i4RetStatus =nmhGetNextIndexFsMIY1731MepSlmOnDemandStatsTable( u4FsMIY1731ContextId,
				&u4FsMIY1731ContextId,u4FsMIY1731MegIndex,
				&u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,
				&u4FsMIY1731MeIndex,u4FsMIY1731MepIdentifier,
				&u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
				&u4FsMIY1731SlmRMepIdentifier,i4FsMIY1731MepSlmOnDemandTestType,
				&i4FsMIY1731MepSlmOnDemandTestType);

		ECFM_REGISTER_CLI_CC_LOCK ();
		ECFM_UNREGISTER_CLI_LBLT_LOCK ();
	}
	while (i4RetStatus == SNMP_SUCCESS);

	if(b1Entry != ECFM_TRUE)
	{

		CliPrintf (CliHandle,"\r\n Entry Not Found :  \r\n");

	}
	return (CLI_SUCCESS);
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFLSlmOnDemand
 *                                                                          
 *     DESCRIPTION      : This function is used to display the contents of the Synthentic 
 *                        Loss Measurement buffer for OnDemand.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdIndex   - Md Index
 *                        MaIndex     - Ma Index
 *                        u4SlmMepId  - Local Mep ID
 *                        u4SlmRMepId - Remote Mep ID
 *                        i4TestType -  Single/Dual Ended
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowFLSlmOnDemand(tCliHandle CliHandle,UINT4 u4ContextId,
                         UINT4 u4MdIndex,UINT4 MaIndex,
                         UINT4 u4SlmMepId,UINT4 u4SlmRMepId,
                         INT4 i4TestType)
{
        tEcfmLbLtSlmOnDemandInfo    *pSlmInfo = NULL;
        tEcfmLbLtMepInfo   *pMepNode = NULL;
	UINT4 u4TestId =0 ;
	UINT4 u4FarEndLoss =0;
	UINT4 u4NearEndLoss= 0;


	if (ECFM_LBLT_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
	{
		return SNMP_FAILURE;
	}
	/* Get MEP entry corresponding to MegIndex, MeIndex, MepId */
	pMepNode =
		EcfmLbLtUtilGetMepEntryFrmGlob (u4MdIndex,
				MaIndex,
				u4SlmMepId);

	/* Check whether MEP entry exists or Not */
	if (pMepNode == NULL)
	{
		ECFM_LBLT_TRC (ECFM_MGMT_TRC | ECFM_ALL_FAILURE_TRC,
				"\tSNMP:No MEP Entry exist for given indices\n");
		ECFM_LBLT_RELEASE_CONTEXT ();
		return SNMP_FAILURE;
	}


	ECFM_LBLT_RELEASE_CONTEXT ();

        /* Getting the SLM Config Info */
	pSlmInfo = &(pMepNode->SlmOnDemandInfo);


        if (pSlmInfo == NULL)
        {
                ECFM_LBLT_TRC (ECFM_MGMT_TRC | ECFM_ALL_FAILURE_TRC,
                                "\tSNMP:No SLM Ondemand Entry exist for given indices\n");
                return SNMP_FAILURE;
        }


	if(nmhGetFsMIY1731MepSlmOnDemandTestId(u4ContextId,u4MdIndex,
				MaIndex,u4SlmMepId,u4SlmRMepId,i4TestType,
				&u4TestId) == SNMP_FAILURE)

	{
		return (CLI_FAILURE);
	}

	if(nmhGetFsMIY1731MepSlmOnDemandFarEndLoss(u4ContextId,u4MdIndex,
				MaIndex,u4SlmMepId,u4SlmRMepId,i4TestType,
				&u4FarEndLoss) == SNMP_FAILURE)

	{
		return (CLI_FAILURE);
	}

	if(nmhGetFsMIY1731MepSlmOnDemandNearEndLoss(u4ContextId,u4MdIndex,
				MaIndex,u4SlmMepId,u4SlmRMepId,i4TestType,
				&u4NearEndLoss) == SNMP_FAILURE)

	{
		return (CLI_FAILURE);
	}


	/* Display SLM OnDemand */
	CliPrintf(CliHandle, "Synthetic Loss Measurement : OnDemand \r\n");
	CliPrintf(CliHandle, "----------------------------------------\r\n");

	CliPrintf (CliHandle, "\r\nTest Id : %d \r\n",u4TestId);


	if(i4TestType == CLI_ECFM_LM_TYPE_SINGLE_ENDED )
	{
		CliPrintf (CliHandle, "Test Type :  Single-Ended \r\n");
	}
	else
	{
		CliPrintf (CliHandle, "Test Type : Dual-Ended  \r\n");
	}

	CliPrintf (CliHandle, "Far-End Loss : %d \r\n",u4FarEndLoss);
	CliPrintf (CliHandle, "Near-End Loss : %d \r\n",u4NearEndLoss);
        CliPrintf (CliHandle, "Total Tx : %d \r\n",pSlmInfo->u4SlmTxFCl);
        CliPrintf (CliHandle, "Total Rx : %d \r\n",pSlmInfo->u4SlrRxFCl);
	CliPrintf (CliHandle, "\r\n");

	return (CLI_SUCCESS);
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliInitSlmProActiveLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will initiate the SLM loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        i4TestType - Single/Dual Ended
 *                        i4Priority - packet priority
 *                        i4Interval - interval between packets
 *                        i4DropEnable - Is packet eligible for drop.
 *                        pu1MdName - Md Name
 *                        i4SlmCalcInterval - Interval time for calculation
 *                        i4SlmThreshold - Threshold limit
 *                        i4SlmConsFlrCheckCount - Conseq FLR checkcount
 *                        i4SlmCHLICheckCount - CHLI check count
 *                        i4SlmTestId - Test Id
 *                        i4SlmLocalMepId - Local MepId
 *                        i4DestType - point to point/multipoint
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *
 ******************************************************************************/
INT4
EcfmCliInitSlmProActiveLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                                        UINT4 u4Command, UINT1 *pu1Arg1,UINT1 *pu1Arg2,UINT1 *pu1Arg3,
                                        UINT1 *pu1Arg4,INT4 i4TestType,INT4 i4Priority,INT4 i4Interval,
                                        INT4 i4DropEnable,UINT1 *pu1MdName, INT4 i4SlmCalcInterval,
                                        INT4 i4SlmThreshold,INT4 i4SlmConsFlrCheckCount, 
                                        INT4 i4SlmCHLICheckCount,INT4 i4SlmTestId,UINT1 *pu1Arg5,
                                        UINT4 u4SlmLocalMepId,INT4 i4SlmDestType)

{
	tEcfmMacAddr        RetMacAddr;
	tEcfmMacAddr        MacAddr;
	UINT4               u4MdIndex = ECFM_INIT_VAL;
	UINT4               u4MaIndex = ECFM_INIT_VAL;
	UINT4               u4MepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextMdIndex = ECFM_INIT_VAL;
	UINT4               u4NextMaIndex = ECFM_INIT_VAL;
	UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4CurrContextId = ECFM_INIT_VAL;
	UINT4               u4NextContextId = ECFM_INIT_VAL;
	INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetDir = ECFM_INIT_VAL;
	INT4                i4RetIfIndex = ECFM_INIT_VAL;
	INT4                i4VlanId = ECFM_INIT_VAL;
	INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetMdLevel = ECFM_INIT_VAL;
	INT4                i4MdLevel = ECFM_INIT_VAL;
	INT4                i4RetVal = SNMP_SUCCESS;
	INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
	BOOL1               b1Entry = ECFM_FALSE;
	BOOL1               b1IsDestMpId = ECFM_FALSE;
	BOOL1               b1SameContext = ECFM_TRUE;
	BOOL1               b1Err = ECFM_FALSE;
	BOOL1               b2Err = ECFM_FALSE;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	tSNMP_OCTET_STRING_TYPE RetMdName;


	ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

	RetMdName.pu1_OctetList = au1RetMdName;
	RetMdName.i4_Length = ECFM_INIT_VAL;

	u4CurrContextId = u4ContextId;

	/* Check for MEP entry for a particular context */
	if (nmhGetNextIndexFsMIEcfmMepTable
			(u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
			 &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}
	if (u4NextContextId != u4ContextId)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}

	/* Scan Mep Table */
	while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

	{
		ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		i4RetPrimaryVid = ECFM_INIT_VAL;
		i4RetMaPrimaryVid = ECFM_INIT_VAL;
		i4RetMdLevel = ECFM_INIT_VAL;
		i4RetDir = ECFM_INIT_VAL;
		i4RetIfIndex = ECFM_INIT_VAL;
		i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
		nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				(UINT4 *) &i4RetPrimaryVid);
		nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
				u4MaIndex, &i4RetMaPrimaryVid);
		nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
		nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				&i4RetMepRowStatus);
		nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier, &i4RetDir);
		nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
				u4MepIdentifier, &i4RetIfIndex);
		nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		/* Search for MEP satisfying particular condition for particular command */
		switch (u4Command)

		{
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VSI:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))
				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VSI:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			default:
				break;
		}

		/* Entry Found */
		if (b1Entry == ECFM_TRUE)
		{

			ECFM_UNREGISTER_CLI_CC_LOCK ();
			ECFM_REGISTER_CLI_LBLT_LOCK ();
			/* Start the Loss Measurement */
			if (EcfmConfigSLMProActiveParams
					(CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
					 u4MepIdentifier, b1IsDestMpId,pu1Arg3,pu1Arg4,
					 i4TestType,i4Priority,i4Interval,i4DropEnable, 
					 i4SlmCalcInterval,i4SlmThreshold,
					 i4SlmConsFlrCheckCount,i4SlmCHLICheckCount,
					 i4SlmTestId,pu1Arg5,u4SlmLocalMepId,
					 i4SlmDestType,&b1Err, &b2Err) == ECFM_FAILURE)
			{

				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();

				if (b2Err == ECFM_TRUE)
				{
					CLI_SET_ERR (CLI_ECFM_LM_IN_PROGRESS_ERR);
					return CLI_FAILURE;
				}
				/* Move to next entry */
				i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
						&u4NextContextId,
						u4MdIndex,
						&u4NextMdIndex,
						u4MaIndex,
						&u4NextMaIndex,
						u4MepIdentifier,
						&u4NextMepIdentifier);

				if (i4RetVal == SNMP_SUCCESS)

				{
					u4MdIndex = u4NextMdIndex;
					u4MaIndex = u4NextMaIndex;
					u4MepIdentifier = u4NextMepIdentifier;
				}
				else
				{
					if (b1Err != ECFM_TRUE)
					{
						CLI_SET_ERR (CLI_ECFM_LM_INITIATION_ERR);
					}
					return CLI_FAILURE;
				}

				if (u4ContextId != u4NextContextId)
				{
					CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
					return CLI_FAILURE;
				}
				b1Entry = ECFM_FALSE;
				b1IsDestMpId = ECFM_FALSE;
				b1Err = ECFM_FALSE;
				continue;
			}
			ECFM_REGISTER_CLI_CC_LOCK ();
			ECFM_UNREGISTER_CLI_LBLT_LOCK ();
			return CLI_SUCCESS;
		}
		/* Move to next entry */
		i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
				&u4NextContextId,
				u4MdIndex,
				&u4NextMdIndex,
				u4MaIndex,
				&u4NextMaIndex,
				u4MepIdentifier,
				&u4NextMepIdentifier);
		if (i4RetVal == SNMP_SUCCESS)

		{
			if (u4ContextId != u4NextContextId)

			{
				b1SameContext = ECFM_FALSE;
			}
			u4MdIndex = u4NextMdIndex;
			u4MaIndex = u4NextMaIndex;
			u4MepIdentifier = u4NextMepIdentifier;
		}
		b1Entry = ECFM_FALSE;
		b1IsDestMpId = ECFM_FALSE;
		b1Err = ECFM_FALSE;
	}
	CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
	return CLI_FAILURE;

}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliStopSlmProActiveLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will initiate the SLM loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        i4TestType - Single/Dual Ended
 *                        i4Priority - packet priority
 *                        i4Interval - interval between packets
 *                        i4SlmMessageCount - number of packets to send
 *                        i4DropEnable - Is packet eligible for drop.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 ******************************************************************************/
INT4
EcfmCliStopSlmProActiveLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                                        UINT4 u4Command,UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                                        UINT1 *pu1MdName, UINT1 *pu1Arg3,INT4 i4SlmTestId,
                                        UINT4 u4SlmLocalMepId)
{

	tEcfmMacAddr        RetMacAddr;
	tEcfmMacAddr        MacAddr;
	UINT4               u4MdIndex = ECFM_INIT_VAL;
	UINT4               u4MaIndex = ECFM_INIT_VAL;
	UINT4               u4MepIdentifier = ECFM_INIT_VAL;
	UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextMdIndex = ECFM_INIT_VAL;
	UINT4               u4NextMaIndex = ECFM_INIT_VAL;
	UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4ErrorCode = ECFM_INIT_VAL;
	UINT4               u4CurrContextId = ECFM_INIT_VAL;
	UINT4               u4NextContextId = ECFM_INIT_VAL;
	UINT4               u4SlmRMepId = ECFM_INIT_VAL;
	INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetDir = ECFM_INIT_VAL;
	INT4                i4RetIfIndex = ECFM_INIT_VAL;
	INT4                i4VlanId = ECFM_INIT_VAL;
	INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetMdLevel = ECFM_INIT_VAL;
	INT4                i4MdLevel = ECFM_INIT_VAL;
	INT4                i4RetVal = SNMP_SUCCESS;
	INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
	BOOL1               b1Entry = ECFM_FALSE;
	BOOL1               b1SameContext = ECFM_TRUE;
	BOOL1               b1IsDestMpId = ECFM_FALSE;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	INT4                i4RetStatus =0;
	tSNMP_OCTET_STRING_TYPE RetMdName;

	ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

	RetMdName.pu1_OctetList = au1RetMdName;
	RetMdName.i4_Length = ECFM_INIT_VAL;
	u4CurrContextId = u4ContextId;
	/* Check for MEP entry for a particular context */
	if (nmhGetNextIndexFsMIEcfmMepDbTable
			(u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
			 &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}
	if (u4NextContextId != u4ContextId)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}

	/* Scan Mep Table */
	while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

	{
		i4RetPrimaryVid = ECFM_INIT_VAL;
		i4RetMaPrimaryVid = ECFM_INIT_VAL;
		i4RetMdLevel = ECFM_INIT_VAL;
		i4RetDir = ECFM_INIT_VAL;
		i4RetIfIndex = ECFM_INIT_VAL;
		i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
		nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				(UINT4 *) &i4RetPrimaryVid);
		nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
				u4MaIndex, &i4RetMaPrimaryVid);
		nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
		nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				&i4RetMepRowStatus);
		nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier, &i4RetDir);
		nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
				u4MepIdentifier, &i4RetIfIndex);
		nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		/* Search for MEP satisfying particular condition for particular
		 *          * command */
		switch (u4Command)

		{

			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_VSI:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_VSI:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)) )

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VLAN:
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)) )

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_DOM:
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_DOM:
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MAC_LEV:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_PROACTIVE_MEP_MPID_LEV:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			default:
				break;
		}

		/* Entry Found */
		if (b1Entry == ECFM_TRUE)
		{
			if (b1IsDestMpId == ECFM_TRUE)
			{
				u4SlmRMepId = *(UINT4 *) (VOID *) pu1Arg3;
				if (u4SlmRMepId != u4RMepIdentifier)
				{
					CLI_SET_ERR (CLI_ECFM_DEST_MEPID_ERR);
					return ECFM_FAILURE;
				}
			}
			else
			{
				ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
				ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
				StrToMac (pu1Arg3, MacAddr);
				nmhGetFsMIEcfmRMepMacAddress (u4CurrContextId,
						u4MdIndex,u4MaIndex,
						u4MepIdentifier, u4RMepIdentifier,
						&RetMacAddr);
				if ((ECFM_MEMCMP (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) != 0))
				{
					CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
					return ECFM_FAILURE;
				}

				i4RetStatus =  EcfmCcUtilGetRMepIdFromMacAddr (u4ContextId,u4MdIndex,u4MaIndex, (UINT2)u4SlmLocalMepId,
						MacAddr, &u4SlmRMepId);

				if (i4RetStatus != ECFM_SUCCESS)
				{
					CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
					return ECFM_FAILURE;

				}
			}

			ECFM_UNREGISTER_CLI_CC_LOCK ();
			ECFM_REGISTER_CLI_LBLT_LOCK ();
			/* Stop the Loss Measurement */
			/* Test if the transaction can be stop  */
			if (nmhTestv2FsMIY1731MepSlmCfgProAStatus
					(&u4ErrorCode, u4CurrContextId, u4MdIndex, u4MaIndex,
					 u4SlmLocalMepId,u4SlmRMepId, i4SlmTestId,ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

			{
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();
				return CLI_FAILURE;
			}

			/* Then stop the transaction */
			if (nmhSetFsMIY1731MepSlmCfgProAStatus
					(u4CurrContextId, u4MdIndex, u4MaIndex, u4SlmLocalMepId,u4SlmRMepId,
					 i4SlmTestId,ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

			{
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();
				CLI_FATAL_ERROR (CliHandle);
				return CLI_FAILURE;
			}
			ECFM_REGISTER_CLI_CC_LOCK ();
			ECFM_UNREGISTER_CLI_LBLT_LOCK ();
			return CLI_SUCCESS;
		}

		/* Move to next entry */
		i4RetVal =
			nmhGetNextIndexFsMIEcfmMepDbTable (u4CurrContextId,
					&u4NextContextId,
					u4MdIndex, &u4NextMdIndex,
					u4MaIndex, &u4NextMaIndex,
					u4MepIdentifier,
					&u4NextMepIdentifier,
					u4RMepIdentifier,&u4NextRMepIdentifier);
		if (i4RetVal == SNMP_SUCCESS)

		{
			if (u4CurrContextId != u4NextContextId)

			{
				b1SameContext = ECFM_FALSE;
			}
			u4MdIndex = u4NextMdIndex;
			u4MaIndex = u4NextMaIndex;
			u4MepIdentifier = u4NextMepIdentifier;
			u4RMepIdentifier = u4NextRMepIdentifier;
		}
		b1Entry = ECFM_FALSE;
	}
	CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
	return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigSLMProActiveParams
 *                                                                               
 *     DESCRIPTION      : This function will initiate the SLM loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4MdIndex Md Index
 *                        u4MaIndex Ma Index
 *                        u4MepIdentifier Mep Id
 *                        b1IsDestMpId Is mep id configured
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        i4TestType - Single/Dual Ended
 *                        i4Priority - packet priority
 *                        i4Interval - interval between packets
 *                        i4DropEnable - Is packet eligible for drop.
 *                        i4SlmCalcInterval - Interval time for calculation
 *                        i4SlmThreshold - Threshold limit
 *                        i4SlmConsFlrCheckCount - Conseq FLR checkcount
 *                        i4SlmCHLICheckCount - CHLI check count
 *                        i4SlmTestId - Test Id
 *                        i4SlmLocalMepId -  local mep id
 *                        i4DestType   - point to point/multipoint
 *     OUTPUT           : pb1Err,pb2Err - Indicates an Error from Test routine
 *      
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
PRIVATE INT4
EcfmConfigSLMProActiveParams (tCliHandle CliHandle, UINT4 u4ContextId,UINT4 u4MdIndex, 
                              UINT4 u4MaIndex,UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                              UINT1 *pu1Arg1,UINT1 *pu1Arg2,INT4 i4TestType, INT4 i4Priority,
                              INT4 i4Interval,INT4 i4DropEnable,INT4 i4SlmCalcInterval,
                              INT4 i4SlmThreshold,INT4 i4SlmConsFlrCheckCount,
                              INT4 i4SlmCHLICheckCount,INT4 i4SlmTestId,UINT1 *pu1Arg3,
                              UINT4 u4SlmLocalMepId,INT4 i4SlmDestType,BOOL1 * pb1Err, 
                              BOOL1 * pb2Err)
{
	tEcfmMacAddr        DestMacAddr = { 0 };
	UINT4               u4ErrorCode = ECFM_INIT_VAL;
	INT4                i4LmStatus = -1;
	INT4                i4RetStatus = 0;
	INT4                i4RowStatus =0;
	UINT4                u4SlmRMepId =0;
	tSNMP_OCTET_STRING_TYPE DataTlv;
	tSNMP_OCTET_STRING_TYPE SlmTestName;

	ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

	DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
	DataTlv.i4_Length = 0;

	ECFM_MEMSET (&SlmTestName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

	SlmTestName.pu1_OctetList = ECFM_LBLT_PDU;
	SlmTestName.i4_Length = 0;


	if(b1IsDestMpId != ECFM_TRUE)
	{
		ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		StrToMac (pu1Arg1, DestMacAddr);

                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();

		i4RetStatus =  EcfmCcUtilGetRMepIdFromMacAddr (u4ContextId,u4MdIndex,u4MaIndex, (UINT2)u4SlmLocalMepId,
				DestMacAddr, &u4SlmRMepId);

                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();
	}
	else
	{
		/* Set MepId of the destination */
		u4SlmRMepId = *(UINT4 *) (VOID *) pu1Arg1;

	}

	i4RetStatus = nmhGetFsMIY1731MepSlmCfgProARowStatus(u4ContextId, u4MdIndex, u4MaIndex, 
			u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &i4RowStatus);

	/* If i4RetStatus is NULL means there is no Entry Present, so we need to create an Entry first */
	if(i4RetStatus == 0)

	{
		if ( nmhTestv2FsMIY1731MepSlmCfgProARowStatus(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, CREATE_AND_WAIT) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProARowStatus(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, CREATE_AND_WAIT) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}

	/*Checking the Transmission status of this SLM */
	if (nmhGetFsMIY1731MepSlmCfgProAStatus (u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &i4LmStatus) != SNMP_FAILURE)
	{
		if (i4LmStatus == ECFM_TX_STATUS_NOT_READY)
		{
			*pb2Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
	}

	if(i4RetStatus != 0)
	{
		if ( nmhTestv2FsMIY1731MepSlmCfgProARowStatus(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex,
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, NOT_IN_SERVICE) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProARowStatus(u4ContextId, u4MdIndex, u4MaIndex,
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, NOT_IN_SERVICE) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProATestType(&u4ErrorCode,u4ContextId, u4MdIndex, 
				u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4TestType) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProADestType(&u4ErrorCode,u4ContextId, u4MdIndex, 
				u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,i4SlmDestType ) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProAPriority(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4Priority) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProAInterval(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4Interval) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProACalcDeltaT(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmCalcInterval) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProAFLRThreshold(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmThreshold) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProAConseqFLRCheckCount(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmConsFlrCheckCount) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProACHLICheckCount(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmCHLICheckCount) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProADropEnable(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4DropEnable) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProAStatus(&u4ErrorCode,u4ContextId, u4MdIndex, 
				u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ECFM_TX_STATUS_START) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	/* Set MepId or Dest Mac Address depending on the input */
	if (b1IsDestMpId == ECFM_TRUE)

	{
		if (nmhTestv2FsMIY1731MepSlmCfgProADestIsMepId
				(&u4ErrorCode,u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,ECFM_SNMP_TRUE) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmCfgProADestIsMepId
				(u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,
				 ECFM_SNMP_TRUE) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
		if (nmhTestv2FsMIY1731MepSlmCfgProADestMepId
				(&u4ErrorCode,u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,u4SlmRMepId) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmCfgProADestMepId
				(u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,
				 u4SlmRMepId) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}
	else
	{
		if (nmhTestv2FsMIY1731MepSlmCfgProADestIsMepId
				(&u4ErrorCode,u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ECFM_SNMP_FALSE) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmCfgProADestIsMepId
				(u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,
				 ECFM_SNMP_FALSE) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		/* Set destination address */
		if (nmhTestv2FsMIY1731MepSlmCfgProADestMacAddress
				(&u4ErrorCode,u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, DestMacAddr) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmCfgProADestMacAddress
				(u4ContextId, u4MdIndex,
				 u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,
				 DestMacAddr) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

	}
	/* Frame Pattern */
	if( pu1Arg2 != NULL )
	{

		DataTlv.i4_Length = ECFM_STRLEN (pu1Arg2);
		DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
		ECFM_STRCPY (DataTlv.pu1_OctetList, pu1Arg2);

		if ( nmhTestv2FsMIY1731MepSlmCfgProATlvType(&u4ErrorCode,u4ContextId, u4MdIndex, 
					u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,ECFM_LBLT_SLM_WITH_DATA_TLV ) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhTestv2FsMIY1731MepSlmCfgProATlvFramePatternSize(&u4ErrorCode,u4ContextId, u4MdIndex, 
					u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, DataTlv.i4_Length) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhTestv2FsMIY1731MepSlmCfgProATlvFramePattern(&u4ErrorCode,u4ContextId, u4MdIndex, 
					u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &DataTlv) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProATlvType(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ECFM_LBLT_SLM_WITH_DATA_TLV ) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProATlvFramePatternSize(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, DataTlv.i4_Length) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProATlvFramePattern(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &DataTlv) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}
	else
	{
		if ( nmhTestv2FsMIY1731MepSlmCfgProATlvType(&u4ErrorCode,u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,ECFM_LBLT_SLM_WITHOUT_TLV) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProATlvType(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ECFM_LBLT_SLM_WITHOUT_TLV) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

	}

	/* Test name  */
	if( pu1Arg3 != NULL )
	{

		SlmTestName.i4_Length = ECFM_STRLEN (pu1Arg3);
		SlmTestName.pu1_OctetList = ECFM_LBLT_PDU;
		ECFM_STRCPY (SlmTestName.pu1_OctetList, pu1Arg3);

#ifdef PMON_WANTED
		/* Checking weather testname configured is present or not in  pmon */
		if ( nmhGetFsPmonEthCfmAssocRowStatus(&SlmTestName,&i4RetStatus) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			CliPrintf (CliHandle, " \r\n Test name configured is not present in PMON \r\n");
			return ECFM_FAILURE;
		}
#endif
		if ( nmhTestv2FsMIY1731MepSlmCfgProATestName(&u4ErrorCode,u4ContextId, u4MdIndex, 
					u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &SlmTestName) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if ( nmhSetFsMIY1731MepSlmCfgProATestName(u4ContextId, u4MdIndex, u4MaIndex, 
					u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, &SlmTestName) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

	}

	if ( nmhSetFsMIY1731MepSlmCfgProATestType(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4TestType) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProADestType(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId,i4SlmDestType ) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProAPriority(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4Priority) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProAInterval(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4Interval) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}


	if ( nmhSetFsMIY1731MepSlmCfgProACalcDeltaT(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmCalcInterval) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProAFLRThreshold(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmThreshold) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProAConseqFLRCheckCount(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmConsFlrCheckCount) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProACHLICheckCount(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4SlmCHLICheckCount) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProADropEnable(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, i4DropEnable) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhTestv2FsMIY1731MepSlmCfgProARowStatus(&u4ErrorCode,u4ContextId, u4MdIndex, 
				u4MaIndex, u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ACTIVE) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProARowStatus(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ACTIVE) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if ( nmhSetFsMIY1731MepSlmCfgProAStatus(u4ContextId, u4MdIndex, u4MaIndex, 
				u4SlmLocalMepId, u4SlmRMepId, i4SlmTestId, ECFM_TX_STATUS_START) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}
        UNUSED_PARAM(u4MepIdentifier);
	return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliInitSlmOnDemandLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will initiate the SLM loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        i4TestType - Single/Dual Ended
 *                        i4Priority - packet priority
 *                        i4Interval - interval between packets
 *                        i4SlmMessageCount - number of packets to send
 *                        i4DropEnable - Is packet eligible for drop.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *      
 ******************************************************************************/                                                                    
INT4
EcfmCliInitSlmOnDemandLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Command, UINT1 *pu1Arg1,UINT1 *pu1Arg2,UINT1 *pu1Arg3,
                            UINT1 *pu1Arg4,INT4 i4TestType,INT4 i4Priority,INT4 i4Interval,
                            INT4 i4SlmMessageCount,INT4 i4DropEnable,UINT1 *pu1MdName)

{
	tEcfmMacAddr        RetMacAddr;
	tEcfmMacAddr        MacAddr;
	UINT4               u4MdIndex = ECFM_INIT_VAL;
	UINT4               u4MaIndex = ECFM_INIT_VAL;
	UINT4               u4MepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextMdIndex = ECFM_INIT_VAL;
	UINT4               u4NextMaIndex = ECFM_INIT_VAL;
	UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4CurrContextId = ECFM_INIT_VAL;
	UINT4               u4NextContextId = ECFM_INIT_VAL;
	INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetDir = ECFM_INIT_VAL;
	INT4                i4RetIfIndex = ECFM_INIT_VAL;
	INT4                i4VlanId = ECFM_INIT_VAL;
	INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetMdLevel = ECFM_INIT_VAL;
	INT4                i4MdLevel = ECFM_INIT_VAL;
	INT4                i4RetVal = SNMP_SUCCESS;
	INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
	BOOL1               b1Entry = ECFM_FALSE;
	BOOL1               b1IsDestMpId = ECFM_FALSE;
	BOOL1               b1SameContext = ECFM_TRUE;
	BOOL1               b1Err = ECFM_FALSE;
	BOOL1               b2Err = ECFM_FALSE;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	tSNMP_OCTET_STRING_TYPE RetMdName;


	ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
	RetMdName.pu1_OctetList = au1RetMdName;
	RetMdName.i4_Length = ECFM_INIT_VAL;

	u4CurrContextId = u4ContextId;

	/* Check for MEP entry for a particular context */
	if (nmhGetNextIndexFsMIEcfmMepTable
			(u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
			 &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}
	if (u4NextContextId != u4ContextId)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}


	/* Scan Mep Table */
	while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

	{
		ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		i4RetPrimaryVid = ECFM_INIT_VAL;
		i4RetMaPrimaryVid = ECFM_INIT_VAL;
		i4RetMdLevel = ECFM_INIT_VAL;
		i4RetDir = ECFM_INIT_VAL;
		i4RetIfIndex = ECFM_INIT_VAL;
		i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
		nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				(UINT4 *) &i4RetPrimaryVid);
		nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
				u4MaIndex, &i4RetMaPrimaryVid);
		nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
		nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				&i4RetMepRowStatus);
		nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier, &i4RetDir);
		nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
				u4MepIdentifier, &i4RetIfIndex);
		nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);


		/* Search for MEP satisfying particular condition for particular command */
		switch (u4Command)

		{
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VSI:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))
				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VSI:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			default:
				break;
		}

		/* Entry Found */
		if (b1Entry == ECFM_TRUE)
		{
			ECFM_UNREGISTER_CLI_CC_LOCK ();
			ECFM_REGISTER_CLI_LBLT_LOCK ();

			/* Start the Loss Measurement */
			if (EcfmConfigSLMOnDemandParams
					(CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
					 u4MepIdentifier, b1IsDestMpId,pu1Arg3,pu1Arg4,
					 i4TestType,i4Priority,i4Interval,i4SlmMessageCount,
					 i4DropEnable, &b1Err, &b2Err) == ECFM_FAILURE)

			{
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();
				ECFM_REGISTER_CLI_CC_LOCK ();

				if (b2Err == ECFM_TRUE)
				{
					CLI_SET_ERR (CLI_ECFM_LM_IN_PROGRESS_ERR);
					return CLI_FAILURE;
				}
				/* Move to next entry */
				i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
						&u4NextContextId,
						u4MdIndex,
						&u4NextMdIndex,
						u4MaIndex,
						&u4NextMaIndex,
						u4MepIdentifier,
						&u4NextMepIdentifier);

				if (i4RetVal == SNMP_SUCCESS)

				{
					u4MdIndex = u4NextMdIndex;
					u4MaIndex = u4NextMaIndex;
					u4MepIdentifier = u4NextMepIdentifier;
				}
				else
				{
					if (b1Err != ECFM_TRUE)
					{
						CLI_SET_ERR (CLI_ECFM_LM_INITIATION_ERR);
					}
					return CLI_FAILURE;
				}

				if (u4ContextId != u4NextContextId)
				{
					CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);


					return CLI_FAILURE;
				}
				b1Entry = ECFM_FALSE;
				b1IsDestMpId = ECFM_FALSE;
				b1Err = ECFM_FALSE;
				continue;
			}

			ECFM_UNREGISTER_CLI_LBLT_LOCK ();
			ECFM_REGISTER_CLI_CC_LOCK ();

			return CLI_SUCCESS;
		}
		/* Move to next entry */
		i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
				&u4NextContextId,
				u4MdIndex,
				&u4NextMdIndex,
				u4MaIndex,
				&u4NextMaIndex,
				u4MepIdentifier,
				&u4NextMepIdentifier);
		if (i4RetVal == SNMP_SUCCESS)

		{
			if (u4ContextId != u4NextContextId)

			{
				b1SameContext = ECFM_FALSE;
			}
			u4MdIndex = u4NextMdIndex;
			u4MaIndex = u4NextMaIndex;
			u4MepIdentifier = u4NextMepIdentifier;
		}
		b1Entry = ECFM_FALSE;
		b1IsDestMpId = ECFM_FALSE;
		b1Err = ECFM_FALSE;
	}
	CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
	return CLI_FAILURE;

}


/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliDelFLSlmProActiveConfig
 *                                                                          
 *     DESCRIPTION      : This function is used to Delete the configuration of the Synthentic 
 *                        Loss Measurement for ProActive.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        pu1Arg1     - Md name
 *                        pu1Arg2     - Ma Name
 *                        u4SlmMepId  - Local Mep ID
 *                        u4SlmRMepId - Remote Mep ID
 *                        u4TestId    - Test Id
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *      
 ******************************************************************************/                                                                   
INT4
EcfmCliDelFLSlmProActiveConfig (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                     UINT4 u4SlmMepId,UINT4 u4SlmRMepId,UINT4 u4TestId)
{
	UINT4               u4FsMIY1731ContextId =0;
	UINT4               u4FsMIY1731MegIndex =0;
	UINT4               u4FsMIY1731MeIndex =0;
	UINT4               u4FsMIY1731MepIdentifier =0;
	UINT4               u4FsMIY1731SlmRMepIdentifier =0;
	UINT4               u4FsMIY1731MepSlmProATestId=0;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMaFormat = ECFM_INIT_VAL;
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	INT4                i4RetStatus =0;
	BOOL1               b1Entry = ECFM_FALSE;
	tSNMP_OCTET_STRING_TYPE RetMaName;
	tSNMP_OCTET_STRING_TYPE RetMdName;

            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();




	/* Getting the first Entry */
	i4RetStatus = nmhGetFirstIndexFsMIY1731MepSlmCfgProATable( &u4FsMIY1731ContextId,
                                            &u4FsMIY1731MegIndex,&u4FsMIY1731MeIndex,&u4FsMIY1731MepIdentifier,
                                            (UINT4 *)&u4FsMIY1731SlmRMepIdentifier,(INT4*)&u4FsMIY1731MepSlmProATestId);



    ECFM_REGISTER_CLI_CC_LOCK ();
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();




	if (i4RetStatus == SNMP_FAILURE)
	{
		CliPrintf (CliHandle,"\r\n Entry Not Found :  \r\n");
		return (CLI_FAILURE);
	}
	/* Search for OnDemand Stats table satisfying the input conditions */
	do
	{
		MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMdName.pu1_OctetList = au1RetMdName;
		RetMdName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMdName (u4ContextId, u4FsMIY1731MegIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4FsMIY1731MegIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
		ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,sizeof (tSNMP_OCTET_STRING_TYPE));
		RetMaName.pu1_OctetList = au1RetMaName;
		RetMaName.i4_Length = ECFM_INIT_VAL;
		nmhGetFsMIEcfmMaName (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex, &RetMaName);
		RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
		nmhGetFsMIEcfmMaFormat (u4ContextId, u4FsMIY1731MegIndex, u4FsMIY1731MeIndex,
				&i4RetMaFormat);
		EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

		/* Checking wheather user configured entry is present or not */
		if ((ECFM_STRCMP (au1StrMdName, pu1Arg1) == ECFM_INIT_VAL) &&
				(ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
				(u4FsMIY1731MepIdentifier == u4SlmMepId) &&
				(u4FsMIY1731SlmRMepIdentifier ==  u4SlmRMepId) &&
				(u4TestId == u4FsMIY1731MepSlmProATestId) )

		{




                ECFM_UNREGISTER_CLI_CC_LOCK ();
                ECFM_REGISTER_CLI_LBLT_LOCK ();



			/*Entry is Present,Delete the table */
			if ( nmhTestv2FsMIY1731MepSlmCfgProARowStatus(&u4ErrorCode,u4FsMIY1731ContextId,
						u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,u4FsMIY1731MepIdentifier,
						u4FsMIY1731SlmRMepIdentifier,u4FsMIY1731MepSlmProATestId,
						ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

			{
                        ECFM_REGISTER_CLI_CC_LOCK ();
                        ECFM_UNREGISTER_CLI_LBLT_LOCK ()
				CliPrintf (CliHandle,"\r\n Unable to delete the Table :  \r\n");
				return (CLI_FAILURE);
			}

			if ( nmhSetFsMIY1731MepSlmCfgProARowStatus(u4FsMIY1731ContextId,u4FsMIY1731MegIndex,
						u4FsMIY1731MeIndex,u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
						u4FsMIY1731MepSlmProATestId, ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)

			{
                        ECFM_REGISTER_CLI_CC_LOCK ();
                        ECFM_UNREGISTER_CLI_LBLT_LOCK ()
				CliPrintf (CliHandle,"\r\n Unable to delete the Table :  \r\n");
				return (CLI_FAILURE);
			}
                        ECFM_REGISTER_CLI_CC_LOCK ();
                        ECFM_UNREGISTER_CLI_LBLT_LOCK ()
			b1Entry = ECFM_TRUE;
			break;
		}
               ECFM_UNREGISTER_CLI_CC_LOCK ();
               ECFM_REGISTER_CLI_LBLT_LOCK ();



		/* Move to Next entry */
		i4RetStatus = nmhGetNextIndexFsMIY1731MepSlmCfgProATable( u4FsMIY1731ContextId,&u4FsMIY1731ContextId,
                                             u4FsMIY1731MegIndex,&u4FsMIY1731MegIndex,u4FsMIY1731MeIndex,&u4FsMIY1731MeIndex,
                                             u4FsMIY1731MepIdentifier,&u4FsMIY1731MepIdentifier,u4FsMIY1731SlmRMepIdentifier,
                                         (UINT4 *)&u4FsMIY1731SlmRMepIdentifier,u4FsMIY1731MepSlmProATestId, (INT4*)&u4FsMIY1731MepSlmProATestId);

                ECFM_REGISTER_CLI_CC_LOCK ();
               ECFM_UNREGISTER_CLI_LBLT_LOCK ();


	}
	while (i4RetStatus == SNMP_SUCCESS);

	if(b1Entry != ECFM_TRUE)
	{
		CliPrintf (CliHandle,"\r\n Entry Not Found :  \r\n");
	}

	return (CLI_SUCCESS);
}



/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliStopSlmOnDemandLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will Stop the loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliStopSlmOnDemandLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                                      UINT4 u4Command,UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                                      UINT1 *pu1MdName, UINT1 *pu1Arg3)
{

	tEcfmMacAddr        RetMacAddr;
	tEcfmMacAddr        MacAddr;
	UINT4               u4MdIndex = ECFM_INIT_VAL;
	UINT4               u4MaIndex = ECFM_INIT_VAL;
	UINT4               u4MepIdentifier = ECFM_INIT_VAL;
	UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4NextMdIndex = ECFM_INIT_VAL;
	UINT4               u4NextMaIndex = ECFM_INIT_VAL;
	UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
	UINT4               u4ErrorCode = ECFM_INIT_VAL;
	UINT4               u4CurrContextId = ECFM_INIT_VAL;
	UINT4               u4NextContextId = ECFM_INIT_VAL;
	UINT4               u4DestMpId = ECFM_INIT_VAL;
	INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetDir = ECFM_INIT_VAL;
	INT4                i4RetIfIndex = ECFM_INIT_VAL;
	INT4                i4VlanId = ECFM_INIT_VAL;
	INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
	INT4                i4RetMdLevel = ECFM_INIT_VAL;
	INT4                i4MdLevel = ECFM_INIT_VAL;
	INT4                i4RetVal = SNMP_SUCCESS;
	INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
	BOOL1               b1Entry = ECFM_FALSE;
	BOOL1               b1SameContext = ECFM_TRUE;
	BOOL1               b1IsDestMpId = ECFM_FALSE;
	UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
	INT4                i4RetMdFormat = ECFM_INIT_VAL;
	tSNMP_OCTET_STRING_TYPE RetMdName;

	ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

	RetMdName.pu1_OctetList = au1RetMdName;
	RetMdName.i4_Length = ECFM_INIT_VAL;
	u4CurrContextId = u4ContextId;
	/* Check for MEP entry for a particular context */
	if (nmhGetNextIndexFsMIEcfmMepDbTable
			(u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
			 &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}
	if (u4NextContextId != u4ContextId)

	{
		CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
		return CLI_FAILURE;
	}

	/* Scan Mep Table */
	while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

	{
		i4RetPrimaryVid = ECFM_INIT_VAL;
		i4RetMaPrimaryVid = ECFM_INIT_VAL;
		i4RetMdLevel = ECFM_INIT_VAL;
		i4RetDir = ECFM_INIT_VAL;
		i4RetIfIndex = ECFM_INIT_VAL;
		i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
		nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				(UINT4 *) &i4RetPrimaryVid);
		nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
				u4MaIndex, &i4RetMaPrimaryVid);
		nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
		nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier,
				&i4RetMepRowStatus);
		nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
				u4MaIndex, u4MepIdentifier, &i4RetDir);
		nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
				u4MepIdentifier, &i4RetIfIndex);
		nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
		RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
		nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
		EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

		/* Search for MEP satisfying particular condition for particular
		 *          * command */
		switch (u4Command)

		{

			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_VSI:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_VSI:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM_SER:
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)) )

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VLAN:
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV_VSI:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel) &&
						((i4RetPrimaryVid == i4VlanId) ||
						 (i4RetMaPrimaryVid == i4VlanId)) )

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_DOM:
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0))

				{
					b1Entry = ECFM_TRUE;
				}
				break;

			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_DOM:
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(ECFM_STRCMP (au1StrMdName, pu1MdName) == 0))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MAC_LEV:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel))

				{
					b1Entry = ECFM_TRUE;
				}
				break;
			case CLI_ECFM_SLM_ONDEMAND_MEP_MPID_LEV:
				i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
				if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
						(i4MdLevel == i4RetMdLevel))

				{
					b1Entry = ECFM_TRUE;
					b1IsDestMpId = ECFM_TRUE;
				}
				break;
			default:
				break;
		}

		/* Entry Found */
		if (b1Entry == ECFM_TRUE)

		{
			if (b1IsDestMpId == ECFM_TRUE)
			{
				u4DestMpId = *(UINT4 *) (VOID *) pu1Arg3;
				if (u4DestMpId != u4RMepIdentifier)
				{
					CLI_SET_ERR (CLI_ECFM_DEST_MEPID_ERR);
					return ECFM_FAILURE;
				}
			}
			else
			{
				ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
				ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
				StrToMac (pu1Arg3, MacAddr);
				nmhGetFsMIEcfmRMepMacAddress (u4CurrContextId,
						u4MdIndex,u4MaIndex,
						u4MepIdentifier, u4RMepIdentifier,
						&RetMacAddr);
				if ((ECFM_MEMCMP
							(RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) != 0))
				{
					CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
					return ECFM_FAILURE;
				}
			}

			ECFM_UNREGISTER_CLI_CC_LOCK ();
			ECFM_REGISTER_CLI_LBLT_LOCK ();

			/* Stop the Loss Measurement */
			/* Test if the transaction can be stop  */
			if (nmhTestv2FsMIY1731MepSlmOnDStatus
					(&u4ErrorCode, u4CurrContextId, u4MdIndex, u4MaIndex,
					 u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

			{
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();
				return CLI_FAILURE;
			}

			/* Then stop the transaction */
			if (nmhSetFsMIY1731MepSlmOnDStatus
					(u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
					 ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

			{
				ECFM_REGISTER_CLI_CC_LOCK ();
				ECFM_UNREGISTER_CLI_LBLT_LOCK ();
				CLI_FATAL_ERROR (CliHandle);
				return CLI_FAILURE;
			}
			ECFM_REGISTER_CLI_CC_LOCK ();
			ECFM_UNREGISTER_CLI_LBLT_LOCK ();
			return CLI_SUCCESS;
		}

		/* Move to next entry */
		i4RetVal =
			nmhGetNextIndexFsMIEcfmMepDbTable (u4CurrContextId,
					&u4NextContextId,
					u4MdIndex, &u4NextMdIndex,
					u4MaIndex, &u4NextMaIndex,
					u4MepIdentifier,
					&u4NextMepIdentifier,
					u4RMepIdentifier,&u4NextRMepIdentifier);
		if (i4RetVal == SNMP_SUCCESS)

		{
			if (u4CurrContextId != u4NextContextId)

			{
				b1SameContext = ECFM_FALSE;
			}
			u4MdIndex = u4NextMdIndex;
			u4MaIndex = u4NextMaIndex;
			u4MepIdentifier = u4NextMepIdentifier;
			u4RMepIdentifier = u4NextRMepIdentifier;
		}
		b1Entry = ECFM_FALSE;
	}
	CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
	return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigSLMOnDemandParams
 *                                                                               
 *     DESCRIPTION      : This function will initiate the SLM loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4MdIndex  - Md Index
 *                        u4MaIndex  - Ma Index
 *                        u4MepIdentifier - Mep Id
 *                        b1IsDestMpId  - Is MepId Configured
 *                        pu1Arg1,pu1Arg2
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        i4TestType - Single/Dual Ended
 *                        i4Priority - packet priority
 *                        i4Interval - interval between packets
 *                        i4SlmMessageCount - number of packets to send
 *                        i4DropEnable - Is packet eligible for drop.
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : pb1Err,pb2Err - Indicates an Error from Test routine               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *     
 ******************************************************************************/
PRIVATE INT4
EcfmConfigSLMOnDemandParams (tCliHandle CliHandle, UINT4 u4ContextId,UINT4 u4MdIndex, 
                             UINT4 u4MaIndex,UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                             UINT1 *pu1Arg1,UINT1 *pu1Arg2,INT4 i4TestType, INT4 i4Priority,
                             INT4 i4Interval,INT4 i4SlmMessageCount,INT4 i4DropEnable,
                             BOOL1 * pb1Err, BOOL1 * pb2Err)
{
	tEcfmMacAddr        DestMacAddr = { 0 };
	UINT4               u4ErrorCode = ECFM_INIT_VAL;
	UINT4               u4DestMpId = ECFM_INIT_VAL;
	INT4                i4LmStatus = -1;
	tSNMP_OCTET_STRING_TYPE DataTlv;

	ECFM_MEMSET (&DataTlv, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
	DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
	DataTlv.i4_Length = 0;

	/* Set MepId or Dest Mac Address depending on the input */
	if (b1IsDestMpId == ECFM_TRUE)

	{
		if (nmhGetFsMIY1731MepSlmOnDStatus (u4ContextId, u4MdIndex, u4MaIndex,
					u4MepIdentifier, &i4LmStatus) != SNMP_FAILURE)
		{
			if (i4LmStatus == ECFM_TX_STATUS_NOT_READY)
			{
				*pb2Err = ECFM_TRUE;
				return ECFM_FAILURE;
			}
		}

		if (nmhTestv2FsMIY1731MepSlmOnDDestIsMepId
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmOnDDestIsMepId
				(u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
				 ECFM_SNMP_TRUE) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
		/* Set MepId of the destination */
		u4DestMpId = *(UINT4 *) (VOID *) pu1Arg1;
		if (nmhTestv2FsMIY1731MepSlmOnDDestMepId
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, u4DestMpId) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmOnDDestMepId
				(u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
				 u4DestMpId) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}
	else
	{
		if (nmhGetFsMIY1731MepSlmOnDStatus (u4ContextId, u4MdIndex, u4MaIndex,
					u4MepIdentifier, &i4LmStatus) != SNMP_FAILURE)
		{
			if (i4LmStatus == ECFM_TX_STATUS_NOT_READY)
			{
				*pb2Err = ECFM_TRUE;
				return ECFM_FAILURE;
			}
		}


		ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
		StrToMac (pu1Arg1, DestMacAddr);
		if (nmhTestv2FsMIY1731MepSlmOnDDestIsMepId
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmOnDDestIsMepId
				(u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
				 ECFM_SNMP_FALSE) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		/* Set destination address */
		if (nmhTestv2FsMIY1731MepSlmOnDDestMacAddress
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, DestMacAddr) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}
		if (nmhSetFsMIY1731MepSlmOnDDestMacAddress
				(u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
				 DestMacAddr) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}


	if (nmhTestv2FsMIY1731MepSlmOnDTestType
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4TestType) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if (nmhTestv2FsMIY1731MepSlmOnDStatus
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if (nmhTestv2FsMIY1731MepSlmOnDPriority
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4Priority) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if (nmhTestv2FsMIY1731MepSlmOnDInterval
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4Interval) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	/* Frame Pattern */
	if( pu1Arg2 != NULL )
	{

		DataTlv.i4_Length = ECFM_STRLEN (pu1Arg2);
		DataTlv.pu1_OctetList = ECFM_LBLT_PDU;
		ECFM_STRCPY (DataTlv.pu1_OctetList, pu1Arg2);

		if (nmhTestv2FsMIY1731MepSlmOnDTlvType
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_LBLT_SLM_WITH_DATA_TLV) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}


		if (nmhTestv2FsMIY1731MepSlmOnDTlvFramePatternSize
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, DataTlv.i4_Length) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if (nmhTestv2FsMIY1731MepSlmOnDTlvFramePattern
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if (nmhSetFsMIY1731MepSlmOnDTlvType
				(u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_LBLT_SLM_WITH_DATA_TLV) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		if (nmhSetFsMIY1731MepSlmOnDTlvFramePatternSize
				(u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, DataTlv.i4_Length) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

		if (nmhSetFsMIY1731MepSlmOnDTlvFramePattern
				(u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, &DataTlv) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}
	}

	else
	{
		if (nmhTestv2FsMIY1731MepSlmOnDTlvType
				(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_LBLT_SLM_WITHOUT_TLV) == SNMP_FAILURE)

		{
			*pb1Err = ECFM_TRUE;
			return ECFM_FAILURE;
		}

		if (nmhSetFsMIY1731MepSlmOnDTlvType
				(u4ContextId, u4MdIndex, u4MaIndex,
				 u4MepIdentifier, ECFM_LBLT_SLM_WITHOUT_TLV) == SNMP_FAILURE)

		{
			return ECFM_FAILURE;
		}

	}
	if (nmhTestv2FsMIY1731MepSlmOnDMessagesCount
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4SlmMessageCount) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if (nmhTestv2FsMIY1731MepSlmOnDDropEnable
			(&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4DropEnable) == SNMP_FAILURE)

	{
		*pb1Err = ECFM_TRUE;
		return ECFM_FAILURE;
	}

	if (nmhSetFsMIY1731MepSlmOnDTestType
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4TestType) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if (nmhSetFsMIY1731MepSlmOnDPriority
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4Priority) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if (nmhSetFsMIY1731MepSlmOnDInterval
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4Interval) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}


	if (nmhSetFsMIY1731MepSlmOnDMessagesCount
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4SlmMessageCount) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}

	if (nmhSetFsMIY1731MepSlmOnDDropEnable
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, i4DropEnable) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}
	if (nmhSetFsMIY1731MepSlmOnDStatus
			(u4ContextId, u4MdIndex, u4MaIndex,
			 u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

	{
		return ECFM_FAILURE;
	}
        UNUSED_PARAM(CliHandle);
	return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowFLBuffer
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Loss buffer.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4IfIndex   - Interface Index
 *                        u4Command   - Command Identifier
 *                        u4LossType  - Measurement Type of Frame Loss
 *                        b1Brief     - Whether user wants brief info
 *                                      or detailed 
 *                        pu1PeerMacAddr - Mac Address of the MEP with which
 *                        Frame Loss is calculated
 *                        pu1Arg1    - 
 *                        pu1Arg2    - 
 *                        Level or Vlan of the MEP which has initiated
 *                        Frame Loss measurement
 *                        pu1Arg3  - Md/Ma Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowFLBuffer (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4IfIndex, UINT4 u4Command,
                     INT4 i4LossType, BOOL1 b1Brief,
                     UINT1 *pu1PeerMacAddr, UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                     UINT1 *pu1Arg3)
{
    tEcfmMacAddr        RetMacAddr = {
        0
    };
    tEcfmMacAddr        MacAddr = {
        0
    };
    UINT4               u4SavedContextId = ECFM_INIT_VAL;
    UINT4               u4SavedMdIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMaIndex = ECFM_INIT_VAL;
    UINT4               u4PrevMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PrevTransId = ECFM_INIT_VAL;
    UINT4               u4PrevSeqNumber = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4SeqNumber = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    INT1               *pi1IfName = NULL;
    INT4                i4RetPortNum = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetLossType = ECFM_INIT_VAL;
    INT4                i4RetLmBufferSize = ECFM_INIT_VAL;
    INT4                i4DisplayFLBuffSize = ECFM_FALSE;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;

    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;
    u4CurrentContextId = u4ContextId;

    while ((nmhGetNextIndexFsMIY1731FlTable
            (u4CurrentContextId, &u4NextContextId, u4PrevMdIndex,
             &u4MdIndex, u4PrevMaIndex, &u4MaIndex, u4PrevMepIdentifier,
             &u4MepIdentifier, u4PrevTransId, &u4TransId,
             u4PrevSeqNumber, &u4SeqNumber) == SNMP_SUCCESS)
           && (u4CurrentContextId == u4NextContextId)
           && (b1ShowAll == ECFM_TRUE))

    {
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);

        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = ECFM_INIT_VAL;

        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;

        /* Compare the entry indices with saved one for skipping the entries
         * already showed for a MEP */
        if ((u4SavedContextId == u4NextContextId) &&
            (u4SavedMdIndex == u4MdIndex) &&
            (u4SavedMaIndex == u4MaIndex) &&
            (u4SavedMepIdentifier == u4MepIdentifier))

        {
            u4PrevMdIndex = u4MdIndex;
            u4PrevMaIndex = u4MaIndex;
            u4PrevMepIdentifier = u4MepIdentifier;
            u4PrevTransId = u4TransId;
            u4PrevSeqNumber = u4SeqNumber;
            b1Entry = ECFM_FALSE;
            continue;
        }
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetPortNum = ECFM_INIT_VAL;
        u4MdLevel = ECFM_INIT_VAL;
        i4VlanId = ECFM_INIT_VAL;
        i4RetLossType = ECFM_INIT_VAL;
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetPortNum);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIY1731FlPeerMepMacAddress (u4CurrentContextId,
                                            u4MdIndex, u4MaIndex,
                                            u4MepIdentifier, u4TransId,
                                            u4SeqNumber, &RetMacAddr);
        nmhGetFsMIY1731FlStatsMeasurementType (u4CurrentContextId,
                                               u4MdIndex, u4MaIndex,
                                               u4MepIdentifier,
                                               u4TransId, &i4RetLossType);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (u4ContextId, u4MdIndex, u4MaIndex, &RetMaName);
        RetMaName.pu1_OctetList[RetMaName.i4_Length] = '\0';
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (pu1PeerMacAddr != NULL)

        {
            StrToMac ((UINT1 *) pu1PeerMacAddr, MacAddr);
        }

        /* Search for MEP satisfying the input conditions */
        switch (u4Command)

        {
            case CLI_ECFM_SHOW_FL_INTF:
                if ((i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0)
                      && (i4LossType == i4RetLossType)))
                    && ((pu1PeerMacAddr == NULL)
                        || ((pu1PeerMacAddr != NULL)
                            &&
                            ((ECFM_MEMCMP
                              (RetMacAddr, MacAddr,
                               ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_INTF_UNAWARE:
                if ((i4RetPortNum == (INT4) u4IfIndex) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_INTF_SER:
                if ((i4RetPortNum == (INT4) u4IfIndex) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg3) == ECFM_INIT_VAL) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_INTF_VSI:
            case CLI_ECFM_SHOW_FL_INTF_ISID:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg1);
                if ((i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL:
                if (((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_UNAWARE:
                if ((i4RetMaPrimaryVid == 0) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV_INTF:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_INTF:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV_INTF_UNAWARE:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_INTF_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL)
                    && (i4RetMaPrimaryVid == 0) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_INTF_SER:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_DOM_INTF_VSI:
            case CLI_ECFM_SHOW_FL_DOM_INTF_ISID:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV_INTF_VLAN:
            case CLI_ECFM_SHOW_FL_LEV_INTF_VSI:
            case CLI_ECFM_SHOW_FL_LEV_INTF_ISID:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    (i4RetPortNum == (INT4) u4IfIndex) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV_UNAWARE:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_UNAWARE:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_SER:
                if ((ECFM_STRCMP (au1StrMaName, pu1Arg3) == ECFM_INIT_VAL) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_VLAN:
            case CLI_ECFM_SHOW_FL_VSI:
            case CLI_ECFM_SHOW_FL_ISID:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg1);
                if (((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_LEV_VLAN:
            case CLI_ECFM_SHOW_FL_LEV_VSI:
            case CLI_ECFM_SHOW_FL_LEV_ISID:
                u4MdLevel = *((UINT4 *) (VOID *) pu1Arg1);
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_SER:
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    (ECFM_STRCMP (au1StrMaName, pu1Arg2) == ECFM_INIT_VAL) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_FL_DOM_VLAN:
            case CLI_ECFM_SHOW_FL_DOM_VSI:
            case CLI_ECFM_SHOW_FL_DOM_ISID:
                i4VlanId = *((INT4 *) (VOID *) pu1Arg2);
                if ((ECFM_STRCMP (au1StrMdName, pu1Arg3) == ECFM_INIT_VAL) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4LossType == 0) ||
                     ((i4LossType != 0) &&
                      (i4LossType == i4RetLossType))) &&
                    ((pu1PeerMacAddr == NULL) ||
                     ((pu1PeerMacAddr != NULL) &&
                      ((ECFM_MEMCMP
                        (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) == 0)))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* If the entry is found */
        if (b1Entry == ECFM_TRUE)

        {
            u4SavedContextId = u4CurrentContextId;
            u4SavedMdIndex = u4MdIndex;
            u4SavedMaIndex = u4MaIndex;
            u4SavedMepIdentifier = u4MepIdentifier;
            if (nmhGetFsMIY1731FrameLossBufferSize
                (u4CurrentContextId, &i4RetLmBufferSize) != SNMP_FAILURE)

            {
                if (i4DisplayFLBuffSize == ECFM_FALSE)
                {
                    CliPrintf (CliHandle,
                               "\r\n FL Buffer maximum size configured : %d \r\n",
                               i4RetLmBufferSize);
                    i4DisplayFLBuffSize = ECFM_TRUE;
                }
            }
            CfaCliGetIfName (i4RetPortNum, pi1IfName);
            CliPrintf (CliHandle, "\r\nInterface : %s ", pi1IfName);
            CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepIdentifier);
            CliPrintf (CliHandle, "\r\nLevel     : %d", i4RetMdLevel);
            if (i4RetPrimaryVid != 0)
            {
#ifdef VSI_WANTED
                if (EcfmUtilCfaIsVsiId (i4RetPrimaryVid) == ECFM_SUCCESS)
                {
                    CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetPrimaryVid);
                }
                else if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#else
					if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
#endif
                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                               i4RetPrimaryVid);
                }
                else
                {

                    CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                }
            }
            else

            {
#ifdef VSI_WANTED
                if (EcfmUtilCfaIsVsiId (i4RetMaPrimaryVid) == ECFM_SUCCESS)
                {
                    CliPrintf (CliHandle, "\r\nVSI-ID    : %d \r", i4RetMaPrimaryVid);
                }
                else if ((i4RetMaPrimaryVid != 0)
                    && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#else
					if ((i4RetMaPrimaryVid != 0)
							&& (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))
#endif

                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                               i4RetMaPrimaryVid);
                }

                else

                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                }
            }
            if (i4RetPrimaryVid != 0)
            {
                if (i4RetPrimaryVid > ECFM_INTERNAL_ISID_MIN)
                {
                    CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                }
            }
            else
            {
                if ((i4RetMaPrimaryVid != 0)
                    && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                {
                    CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                }
            }
            if (b1Brief != ECFM_TRUE)

            {
                EcfmDisplayFLEntriesBrief (CliHandle,
                                           u4CurrentContextId,
                                           u4MdIndex, u4MaIndex,
                                           u4MepIdentifier);
            }

            else

            {
                EcfmDisplayFLEntriesDetail (CliHandle,
                                            u4CurrentContextId,
                                            u4MdIndex, u4MaIndex,
                                            u4MepIdentifier);
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to Next entry */
        u4PrevMdIndex = u4MdIndex;
        u4PrevMaIndex = u4MaIndex;
        u4PrevMepIdentifier = u4MepIdentifier;
        u4PrevTransId = u4TransId;
        u4PrevSeqNumber = u4SeqNumber;
        b1Entry = ECFM_FALSE;
        if (u4PagingStatus == CLI_FAILURE)

        {

            /* User pressed 'q' at more prompt, no more print required, 
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayFLEntriesBrief
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Loss buffer in brief.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - context Identifier
 *                        u4MdId      - MdIndex
 *                        u4MaId      - MaIndex
 *                        u4MepId     - MepId
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                          
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayFLEntriesBrief (tCliHandle CliHandle, UINT4 u4ConId,
                           UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId)
{
    time_t              ltime;
    tEcfmMacAddr        RetMacAddr;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SeqNumber = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextSeqNumber = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    INT4                i4RetMeasurementType = ECFM_INIT_VAL;
    UINT4               u4RetMeasurementTime = ECFM_INIT_VAL;
    UINT4               u4RetLossAvg = ECFM_INIT_VAL;
    UINT4               u4RetLossMin = ECFM_INIT_VAL;
    UINT4               u4RetLossMax = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_FAILURE;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1Date[ECFM_ARRAY_SIZE_64] = { 0 };
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1PrintStats = ECFM_FALSE;
    UINT4               u4FlStatsFarEndLossTotal = ECFM_INIT_VAL;
    UINT4               u4FlStatsNearEndLossTotal = ECFM_INIT_VAL;
    tEcfmCcFrmLossBuff *pFlBufferNode = NULL;
    u4MdIndex = u4MdId;
    u4MaIndex = u4MaId;
    u4MepIdentifier = u4MepId;
    u4ContextId = u4ConId;

    /* Scan Frame loss table */
    i4RetVal =
        nmhGetNextIndexFsMIY1731FlTable (u4ContextId, &u4NextContextId,
                                         u4MdIndex, &u4NextMdIndex,
                                         u4MaIndex, &u4NextMaIndex,
                                         u4MepIdentifier,
                                         &u4NextMepIdentifier, 0,
                                         &u4TransId, 0, &u4SeqNumber);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Entry should be for this particular MEP */
        if ((u4ContextId != u4NextContextId) &&
            (u4MdIndex != u4NextMdIndex) &&
            (u4MaIndex != u4NextMaIndex) &&
            (u4MepIdentifier != u4NextMepIdentifier))

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        if (b1Header == ECFM_TRUE)

        {
            nmhGetFsMIEcfmMepMacAddress (u4ConId, u4MdId, u4MaId,
                                         u4MepId, &RetMacAddr);
            PrintMacAddress (RetMacAddr, au1String);
            au1String[ECFM_INDEX_SEVENTEEN] = '\0';
            nmhGetFsMIY1731FlStatsMeasurementType (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId,
                                                   &i4RetMeasurementType);
            if (i4RetMeasurementType == CLI_ECFM_LM_TYPE_SINGLE_ENDED)

            {
                CliPrintf (CliHandle,
                           "\r\n--- %s single-ended frame loss statistics ---\r\n",
                           au1String);
            }

            else

            {
                CliPrintf (CliHandle,
                           "\r\n--- %s dual-ended frame loss statistics ---\r\n",
                           au1String);
            }
            b1Header = ECFM_FALSE;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731FlTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier,
                                             u4TransId, &u4NextTransId,
                                             u4SeqNumber, &u4NextSeqNumber);
        if ((u4ContextId == u4NextContextId)
            && (u4MdIndex == u4NextMdIndex)
            && (u4MaIndex == u4NextMaIndex)
            && (u4MepIdentifier == u4NextMepIdentifier))

        {
            if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

            {
                b1PrintStats = ECFM_TRUE;
            }
        }

        else

        {
            b1SameContext = ECFM_FALSE;
            b1PrintStats = ECFM_TRUE;
        }
        if (b1PrintStats == ECFM_TRUE)
        {
            nmhGetFsMIY1731FlMeasurementTimeStamp (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   u4TransId,
                                                   u4SeqNumber,
                                                   &u4RetMeasurementTime);
            ECFM_MEMSET (au1Date, ECFM_INIT_VAL, sizeof (au1Date));
            /* ctime() function converts the time value pointed to by time to local time
             * in the form of a character string. The string result that is produced by
             * ctime() contains exactly 26 characters and has the format
             * "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n". Because of this new line character,
             * mep Id and defect type are coming in the next line. To avoid this
             * subtracting the string length by 1.*/
            ltime = (INT4) u4RetMeasurementTime;
            MEMCPY (au1Date, ctime (&ltime),
                    (STRLEN (ctime (&ltime)) - ECFM_VAL_1));
            CliPrintf (CliHandle, "timestamp = %s,", au1Date);

            if (ECFM_CC_SELECT_CONTEXT (u4ConId) != ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "Unable to select the context\r\n");
                return;
            }

            /* Get Frame Loss Transmit statistics entry corresponding to 
             * MdIndex, MaIndex, MepId, FlTransId.
             */
            pFlBufferNode =
                EcfmSnmpLwGetFrmLossTransEntry (u4MdId, u4MaId,
                                                u4MepId, u4TransId);

            /* Check if Frame Loss Transmit statistics entry exists */
            if (pFlBufferNode == NULL)
            {
                ECFM_CC_RELEASE_CONTEXT ();
                return;
            }

            /* Get the Frame Loss statistics for Near and Far end Loss 
             * for the total transactions.
             */
            EcfmSnmpLwGetLmTransactionStats (pFlBufferNode, NULL, NULL, NULL,
                                             NULL, NULL, NULL, NULL,
                                             &u4FlStatsFarEndLossTotal,
                                             &u4FlStatsNearEndLossTotal);
            ECFM_CC_RELEASE_CONTEXT ();

            /* Get the Near end Loss Value */
            u4RetLossAvg = ECFM_INIT_VAL;
            u4RetLossMax = ECFM_INIT_VAL;
            u4RetLossMin = ECFM_INIT_VAL;
            nmhGetFsMIY1731FlStatsNearEndLossMax (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4RetLossMax);
            nmhGetFsMIY1731FlStatsNearEndLossAverage (u4ConId, u4MdId,
                                                      u4MaId, u4MepId,
                                                      u4TransId, &u4RetLossAvg);
            nmhGetFsMIY1731FlStatsNearEndLossMin (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4RetLossMin);
            CliPrintf (CliHandle,
                       "near-end loss max/avg/min = %u/%u/%u,\r\n",
                       u4RetLossMax, u4RetLossAvg, u4RetLossMin);
            CliPrintf (CliHandle, "Total near-end loss is %u,\r\n",
                       u4FlStatsNearEndLossTotal);

            /* Get the Max Loss end Loss Value */
            u4RetLossAvg = ECFM_INIT_VAL;
            u4RetLossMax = ECFM_INIT_VAL;
            u4RetLossMin = ECFM_INIT_VAL;
            nmhGetFsMIY1731FlStatsFarEndLossMax (u4ConId, u4MdId,
                                                 u4MaId, u4MepId,
                                                 u4TransId, &u4RetLossMax);
            nmhGetFsMIY1731FlStatsFarEndLossAverage (u4ConId, u4MdId,
                                                     u4MaId, u4MepId,
                                                     u4TransId, &u4RetLossAvg);
            nmhGetFsMIY1731FlStatsFarEndLossMin (u4ConId, u4MdId,
                                                 u4MaId, u4MepId,
                                                 u4TransId, &u4RetLossMin);
            CliPrintf (CliHandle,
                       "far-end loss max/avg/min = %u/%u/%u\r\n",
                       u4RetLossMax, u4RetLossAvg, u4RetLossMin);
            CliPrintf (CliHandle, "Total far-end loss is %u,\r\n",
                       u4FlStatsFarEndLossTotal);

            b1Header = ECFM_TRUE;
            b1PrintStats = ECFM_FALSE;
        }
        u4TransId = u4NextTransId;
        u4SeqNumber = u4NextSeqNumber;
        b1PrintStats = ECFM_FALSE;
    }
    return;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDisplayFLEntriesDetail
 *                                                                          
 *     DESCRIPTION      : This function will display the contents for the Frame
 *                        Loss buffer in detail.          
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - context Identifier
 *                        u4MdId      - MdIndex
 *                        u4MaId      - MaIndex
 *                        u4MepId     - MepId
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                          
 *                                                                          
 ******************************************************************************/
PRIVATE VOID
EcfmDisplayFLEntriesDetail (tCliHandle CliHandle, UINT4 u4ConId,
                            UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId)
{
    time_t              ltime;
    tEcfmMacAddr        RetMacAddr;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4SeqNumber = ECFM_INIT_VAL;
    UINT4               u4TransId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextSeqNumber = ECFM_INIT_VAL;
    UINT4               u4NextTransId = ECFM_INIT_VAL;
    UINT4               u4LmSent = ECFM_INIT_VAL;
    UINT4               u4LmRcvd = ECFM_INIT_VAL;
    UINT4               u4RetMeasurementTime = ECFM_INIT_VAL;
    UINT4               u4RetLossVal = ECFM_INIT_VAL;
    UINT4               u4RetLossAvg = ECFM_INIT_VAL;
    UINT4               u4RetLossMax = ECFM_INIT_VAL;
    UINT4               u4RetLossMin = ECFM_INIT_VAL;
    INT4                i4RetMeasurementType = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_FAILURE;
    INT4                i4RetTime = ECFM_INIT_VAL;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    UINT1               au1Date[ECFM_ARRAY_SIZE_64] = { 0 };
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1PrintStats = ECFM_FALSE;
    u4MdIndex = u4MdId;
    u4MaIndex = u4MaId;
    u4MepIdentifier = u4MepId;
    u4ContextId = u4ConId;

    /* Scan FL Table */
    i4RetVal =
        nmhGetNextIndexFsMIY1731FlTable (u4ContextId, &u4NextContextId,
                                         u4MdIndex, &u4NextMdIndex,
                                         u4MaIndex, &u4NextMaIndex,
                                         u4MepIdentifier,
                                         &u4NextMepIdentifier, 0,
                                         &u4TransId, 0, &u4SeqNumber);
    if (i4RetVal == SNMP_SUCCESS)

    {

        /* Entry is for this particular MEP */
        if ((u4ContextId != u4NextContextId) &&
            (u4MdIndex != u4NextMdIndex) &&
            (u4MaIndex != u4NextMaIndex) &&
            (u4MepIdentifier != u4NextMepIdentifier))

        {
            b1SameContext = ECFM_FALSE;
        }
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        if (b1Header == ECFM_TRUE)

        {
            CliPrintf (CliHandle, "\r\n%-20s%-15s%-15s%-24s\r\n",
                       "peer mac-address", "near-end loss",
                       "far-end loss", "measurement time taken");
            CliPrintf (CliHandle, "%-20s%-15s%-15s%-24s\r\n",
                       "-----------------", "-------------",
                       "------------", "----------------------");
            b1Header = ECFM_FALSE;
        }

        /* Get Peer Mac Address */
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        nmhGetFsMIY1731FlPeerMepMacAddress (u4ContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            u4TransId, u4SeqNumber,
                                            &RetMacAddr);
        PrintMacAddress (RetMacAddr, au1String);
        CliPrintf (CliHandle, "%-20s", au1String);

        /* Get the Near-end loss Value */
        u4RetLossVal = ECFM_INIT_VAL;
        nmhGetFsMIY1731FlNearEndLoss (u4ContextId, u4MdIndex, u4MaIndex,
                                      u4MepIdentifier, u4TransId,
                                      u4SeqNumber, &u4RetLossVal);
        CliPrintf (CliHandle, "%-15u", u4RetLossVal);

        /* Get the Far-end loss Value */
        u4RetLossVal = ECFM_INIT_VAL;
        nmhGetFsMIY1731FlFarEndLoss (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, u4TransId,
                                     u4SeqNumber, &u4RetLossVal);
        CliPrintf (CliHandle, "%-15u", u4RetLossVal);

        /* Get the measurement time taken */
        i4RetTime = ECFM_INIT_VAL;
        nmhGetFsMIY1731FlMeasurementTime (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepIdentifier,
                                          u4TransId, u4SeqNumber, &i4RetTime);
        CliPrintf (CliHandle, "%d", i4RetTime);
        CliPrintf (CliHandle, "ms");
        CliPrintf (CliHandle, "\r\n");

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIY1731FlTable (u4ContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier,
                                             u4TransId, &u4NextTransId,
                                             u4SeqNumber, &u4NextSeqNumber);
        if ((u4ContextId == u4NextContextId)
            && (u4MdIndex == u4NextMdIndex)
            && (u4MaIndex == u4NextMaIndex)
            && (u4MepIdentifier == u4NextMepIdentifier))

        {
            if ((u4TransId != u4NextTransId) || (i4RetVal == SNMP_FAILURE))

            {
                b1PrintStats = ECFM_TRUE;
            }
        }

        else

        {
            b1SameContext = ECFM_FALSE;
            b1PrintStats = ECFM_TRUE;
        }
        if (b1PrintStats == ECFM_TRUE)

        {
            nmhGetFsMIEcfmMepMacAddress (u4ConId, u4MdId, u4MaId,
                                         u4MepId, &RetMacAddr);
            PrintMacAddress (RetMacAddr, au1String);
            au1String[ECFM_INDEX_SEVENTEEN] = '\0';
            nmhGetFsMIY1731FlStatsMeasurementType (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId,
                                                   &i4RetMeasurementType);
            if (i4RetMeasurementType == CLI_ECFM_LM_TYPE_SINGLE_ENDED)

            {
                CliPrintf (CliHandle,
                           "\r\n--- %s single-ended frame loss statistics ---\r\n",
                           au1String);
            }

            else

            {
                CliPrintf (CliHandle,
                           "\r\n--- %s dual-ended frame loss statistics ---\r\n",
                           au1String);
            }
            nmhGetFsMIY1731FlMeasurementTimeStamp (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId,
                                                   u4SeqNumber,
                                                   &u4RetMeasurementTime);
            ECFM_MEMSET (au1Date, ECFM_INIT_VAL, sizeof (au1Date));
            /* ctime() function converts the time value pointed to by time to local time
             * in the form of a character string. The string result that is produced by
             * ctime() contains exactly 26 characters and has the format
             * "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n". Because of this new line character,
             * mep Id and defect type are coming in the next line. To avoid this
             * subtracting the string length by 1.*/
            ltime = (INT4) u4RetMeasurementTime;
            MEMCPY (au1Date, ctime (&ltime),
                    (STRLEN (ctime (&ltime)) - ECFM_VAL_1));

            CliPrintf (CliHandle, "timestamp = %s,", au1Date);
            if (i4RetMeasurementType == CLI_ECFM_LM_TYPE_SINGLE_ENDED)

            {
                u4LmSent = ECFM_INIT_VAL;
                nmhGetFsMIY1731FlStatsMessagesOut (u4ConId, u4MdId,
                                                   u4MaId, u4MepId,
                                                   u4TransId, &u4LmSent);
                CliPrintf (CliHandle, " packets sent = %d,", u4LmSent);
            }
            u4LmRcvd = ECFM_INIT_VAL;
            nmhGetFsMIY1731FlStatsMessagesIn (u4ConId, u4MdId, u4MaId,
                                              u4MepId, u4TransId, &u4LmRcvd);
            CliPrintf (CliHandle, " packets received = %d,\r\n", u4LmRcvd);

            /* Get the Near end Loss Value */
            u4RetLossAvg = ECFM_INIT_VAL;
            u4RetLossMax = ECFM_INIT_VAL;
            u4RetLossMin = ECFM_INIT_VAL;
            nmhGetFsMIY1731FlStatsNearEndLossMax (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4RetLossMax);
            nmhGetFsMIY1731FlStatsNearEndLossAverage (u4ConId, u4MdId,
                                                      u4MaId, u4MepId,
                                                      u4TransId, &u4RetLossAvg);
            nmhGetFsMIY1731FlStatsNearEndLossMin (u4ConId, u4MdId,
                                                  u4MaId, u4MepId,
                                                  u4TransId, &u4RetLossMin);
            CliPrintf (CliHandle,
                       "near-end loss max/avg/min = %u/%u/%u,\r\n",
                       u4RetLossMax, u4RetLossAvg, u4RetLossMin);

            /* Get the Far end Loss Value */
            u4RetLossAvg = ECFM_INIT_VAL;
            u4RetLossMax = ECFM_INIT_VAL;
            u4RetLossMin = ECFM_INIT_VAL;
            nmhGetFsMIY1731FlStatsFarEndLossMax (u4ConId, u4MdId,
                                                 u4MaId, u4MepId,
                                                 u4TransId, &u4RetLossMax);
            nmhGetFsMIY1731FlStatsFarEndLossAverage (u4ConId, u4MdId,
                                                     u4MaId, u4MepId,
                                                     u4TransId, &u4RetLossAvg);
            nmhGetFsMIY1731FlStatsFarEndLossMin (u4ConId, u4MdId,
                                                 u4MaId, u4MepId,
                                                 u4TransId, &u4RetLossMin);
            CliPrintf (CliHandle,
                       "far-end loss max/avg/min = %u/%u/%u\r\n",
                       u4RetLossMax, u4RetLossAvg, u4RetLossMin);
            b1Header = ECFM_TRUE;
            b1PrintStats = ECFM_FALSE;
        }
        u4TransId = u4NextTransId;
        u4SeqNumber = u4NextSeqNumber;
        b1PrintStats = ECFM_FALSE;
    }
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliClearFLBuffer
 *                                                                          
 *     DESCRIPTION      : This function will clear the contents of 
 *                        Frame Loss buffer.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliClearFLBuffer (tCliHandle CliHandle, UINT4 u4ContextId)
{
    UINT4               u4ErrCode = ECFM_INIT_VAL;

    /* Test if Frame loss buffer can be cleared or not */
    if (nmhTestv2FsMIY1731FrameLossBufferClear
        (&u4ErrCode, u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then clear it */
    if (nmhSetFsMIY1731FrameLossBufferClear
        (u4ContextId, ECFM_SNMP_TRUE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetFLBufferSize                               
 *                                                                          
 *     DESCRIPTION      : This function will set/reset the size of the 
 *                        Frame Loss Buffer.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command ID 
 *                        pu1Arg1     - Value to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetFLBufferSize (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4Size = ECFM_INIT_VAL;

    /* Setting the Frame Loss Buffer size according to the input command */
    if (u4Command == CLI_ECFM_SET_FL_BUFFER_SIZE)

    {
        i4Size = *(INT4 *) (VOID *) pu1Arg1;
    }

    else

    {
        i4Size = ECFM_FL_BUFFER_DEF_SIZE;
    }

    /* First Test if the size can be set or not */
    if (nmhTestv2FsMIY1731FrameLossBufferSize
        (&u4ErrorCode, u4ContextId, i4Size) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Then Set the size */
    if (nmhSetFsMIY1731FrameLossBufferSize (u4ContextId, i4Size) ==
        SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetClntLayerLevel
 *                                                                          
 *     DESCRIPTION      : This function sets the Client Layer MEP's Md Level.
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command Type 
 *                        pu1Arg1     - Value to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetClntLayerLevel (tCliHandle CliHandle, UINT4 u4ContextId,
                          UINT4 u4Command, UINT1 *pu1Arg1)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4ClntLevel = ECFM_INIT_VAL;
    BOOL1               b1LevelTestFailed = FALSE;

    /* Get MdIndex from config prompt */
    u4MdIndex = CLI_GET_MDINDEX ();

    if (u4Command == CLI_ECFM_SET_CLNT_LAYER_LEVEL)
    {
        i4ClntLevel = *(INT4 *) (VOID *) pu1Arg1;
    }
    else
    {
        i4ClntLevel = ECFM_MD_LEVEL_NOT_CONFIGURE;
    }

    do
    {
        /* Test if Client Level can be set or not */
        if (nmhTestv2FsMIY1731MegClientMEGLevel
            (&u4ErrorCode, u4ContextId, u4MdIndex, i4ClntLevel) == SNMP_FAILURE)
        {
            b1LevelTestFailed = TRUE;
            break;
        }

        /* Then set the value */
        if (nmhSetFsMIY1731MegClientMEGLevel
            (u4ContextId, u4MdIndex, i4ClntLevel) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            break;
        }
    }
    while (0);

    if (nmhTestv2FsMIY1731MegRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MegRowStatus
        (u4ContextId, u4MdIndex, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (b1LevelTestFailed == TRUE)
    {
        return CLI_FAILURE;
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetClntMacAddr
 *                                                                          
 *     DESCRIPTION      : This function sets Client Mac Address for AIS and
 *                        LCK messages.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command Type
 *                        pu1Arg1, pu1Arg2, pu1Arg3, pu1Arg4 - 
 *                        Input arguments acc. to the command
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetClntMacAddr (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4Command, UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    tEcfmMacAddr        AisMacAddr = {
        0
    };
    tEcfmMacAddr        LckMacAddr = {
        0
    };
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetVal = CLI_SUCCESS;
    BOOL1               b1IsLckMCast = ECFM_FALSE;
    BOOL1               b1IsAisMCast = ECFM_FALSE;
    BOOL1               b1IsAis = ECFM_FALSE;
    BOOL1               b1IsLck = ECFM_FALSE;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    switch (u4Command)

    {
        case CLI_ECFM_SET_AIS_CLNT_MAC:

            /* For AIS */
            b1IsAis = ECFM_TRUE;
            if (pu1Arg1 != NULL)

            {
                b1IsAisMCast = ECFM_FALSE;
                StrToMac (pu1Arg1, AisMacAddr);
            }

            else

            {
                b1IsAisMCast = ECFM_TRUE;
            }
            break;
        case CLI_ECFM_SET_LCK_CLNT_MAC:

            /* For LCK */
            b1IsLck = ECFM_TRUE;
            if (pu1Arg1 != NULL)

            {
                b1IsLckMCast = ECFM_FALSE;
                StrToMac (pu1Arg1, LckMacAddr);
            }

            else

            {
                b1IsLckMCast = ECFM_TRUE;
            }
            break;
        case CLI_ECFM_SET_AIS_LCK_CLNT_MAC:

            /* For AIS */
            b1IsAis = ECFM_TRUE;
            if (pu1Arg1 != NULL)

            {
                b1IsAisMCast = ECFM_FALSE;
                StrToMac (pu1Arg1, AisMacAddr);
            }

            else

            {
                b1IsAisMCast = ECFM_TRUE;
            }

            /* For LCK */
            b1IsLck = ECFM_TRUE;
            if (pu1Arg2 != NULL)

            {
                b1IsLckMCast = ECFM_FALSE;
                StrToMac (pu1Arg2, LckMacAddr);
            }

            else

            {
                b1IsLckMCast = ECFM_TRUE;
            }
            break;
        default:
            break;
    }

    do

    {

        /* If user wants to set client mac Address for Ais */
        if (b1IsAis == ECFM_TRUE)

        {
            if (b1IsAisMCast == ECFM_TRUE)

            {

                /* Test if AIS Multicast Address can be set or Not */
                if (nmhTestv2FsMIY1731MepAisDestIsMulticast
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, ECFM_SNMP_TRUE) == SNMP_FAILURE)

                {
                    break;
                }

                /* Then set for Multicast Mac Address */
                if (nmhSetFsMIY1731MepAisDestIsMulticast
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     ECFM_SNMP_TRUE) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }
            }

            else

            {

                /* Test if AIS Unicast Mac Address can be set or Not */
                if (nmhTestv2FsMIY1731MepAisClientMacAddress
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, AisMacAddr) == SNMP_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }

                /* Then set the Mac Address */
                if (nmhSetFsMIY1731MepAisClientMacAddress
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     AisMacAddr) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }

                /* Test if AIS Unicast Address can be set or Not */
                if (nmhTestv2FsMIY1731MepAisDestIsMulticast
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, ECFM_SNMP_FALSE) == SNMP_FAILURE)

                {
                    break;
                }

                /* Then set for Unicast Address */
                if (nmhSetFsMIY1731MepAisDestIsMulticast
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     ECFM_SNMP_FALSE) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }
            }
        }

        /* If user wants to set client mac Address for Lck */
        if (b1IsLck == ECFM_TRUE)

        {
            if (b1IsLckMCast == ECFM_TRUE)

            {

                /* Test if Lck Multicast Address can be set or Not */
                if (nmhTestv2FsMIY1731MepLckDestIsMulticast
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, ECFM_SNMP_TRUE) == SNMP_FAILURE)

                {
                    break;
                }

                /* Then set for Multicast Mac Address */
                if (nmhSetFsMIY1731MepLckDestIsMulticast
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     ECFM_SNMP_TRUE) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }
            }

            else

            {

                /* Test if Lck Unicast Mac Address can be set or Not */
                if (nmhTestv2FsMIY1731MepLckClientMacAddress
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, LckMacAddr) == SNMP_FAILURE)

                {
                    i4RetVal = CLI_FAILURE;
                    break;
                }

                /* Then set the Mac Address */
                if (nmhSetFsMIY1731MepLckClientMacAddress
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     LckMacAddr) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }

                /* Test if Lck Unicast Address can be set or Not */
                if (nmhTestv2FsMIY1731MepLckDestIsMulticast
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIndex, ECFM_SNMP_FALSE) == SNMP_FAILURE)

                {
                    break;
                }

                /* Then set for Unicast Address */
                if (nmhSetFsMIY1731MepLckDestIsMulticast
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                     ECFM_SNMP_FALSE) == SNMP_FAILURE)

                {
                    CLI_FATAL_ERROR (CliHandle);
                    break;
                }
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetVal;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetFLThreshold
 *                                                                          
 *     DESCRIPTION      : This function sets the Near-End and Far-End Loss
 *                        threshold value.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        pu1NearEndThreshold - Threshold for Near-end frame
 *                        loss
 *                        pu1FarEndThreshold  - Threshold for Far-end frame
 *                        loss
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetFLThreshold (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT1 *pu1NearEndThreshold, UINT1 *pu1FarEndThreshold)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4NearEndThreshold = ECFM_INIT_VAL;
    UINT4               u4FarEndThreshold = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    do

    {

        /* If user wants to set threshold for near-end */
        if (pu1NearEndThreshold != NULL)

        {
            u4NearEndThreshold = *((UINT4 *) (VOID *) pu1NearEndThreshold);

            /* Test if value can be set or not */
            if (nmhTestv2FsMIY1731MepNearEndFrameLossThreshold
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4NearEndThreshold) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }

            /* Then set the value */
            if (nmhSetFsMIY1731MepNearEndFrameLossThreshold
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4NearEndThreshold) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* If user wants to set threshold for far-end */
        if (pu1FarEndThreshold != NULL)

        {
            u4FarEndThreshold = *((UINT4 *) (VOID *) pu1FarEndThreshold);

            /* Test if value can be set or Not */
            if (nmhTestv2FsMIY1731MepFarEndFrameLossThreshold
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4FarEndThreshold) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }

            /* Then set the value */
            if (nmhSetFsMIY1731MepFarEndFrameLossThreshold
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4FarEndThreshold) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetOutOfServiceParams
 *                                                                          
 *     DESCRIPTION      : This function sets the MEP to perform out-of-service
 *                        and its related parameters or in-service operations.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Command   - Command Type
 *                        u4Flag       - Lck interval to be set
 *                        pu1LckPeriod - Lck period to be set
 *                        pu1LckDelay - Lck delay to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetOutOfServiceParams (tCliHandle CliHandle,
                              UINT4 u4ContextId, UINT4 u4Command,
                              UINT4 u4Flag, UINT1 *pu1LckPeriod,
                              UINT1 *pu1LckDelay)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4LckInterval = ECFM_INIT_VAL;
    UINT4               u4LckPeriod = ECFM_INIT_VAL;
    UINT4               u4LckDelay = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4EnableLck = ECFM_INIT_VAL;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* If user wants to enable out-of-service operations */
    if (u4Command == CLI_ECFM_SET_OUT_OF_SERVICE)

    {
        i4EnableLck = ECFM_SNMP_TRUE;
    }

    /* If user wants to disable out-of-service operations */
    else if (u4Command == CLI_ECFM_RESET_OUT_OF_SERVICE)

    {
        i4EnableLck = ECFM_SNMP_FALSE;
    }
    if (i4EnableLck != 0)

    {

        /* Test if status can be set or not */
        if (nmhTestv2FsMIY1731MepOutOfService
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, i4EnableLck) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then set the status */
        if (nmhSetFsMIY1731MepOutOfService
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
             i4EnableLck) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* Now if user wants to set interval, period or delay value */
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    do

    {
        if ((u4Flag & CLI_ECFM_SET_AIS_LCK_INT_1MIN) ==
            CLI_ECFM_SET_AIS_LCK_INT_1MIN)

        {
            u4LckInterval = ECFM_CC_AIS_LCK_INTERVAL_1_MIN;
        }

        else if ((u4Flag & CLI_ECFM_SET_AIS_LCK_INT_1SEC) ==
                 CLI_ECFM_SET_AIS_LCK_INT_1SEC)

        {
            u4LckInterval = ECFM_CC_AIS_LCK_INTERVAL_1_SEC;
        }

        if (pu1LckDelay != NULL)

        {
            u4LckDelay = *(UINT4 *) (VOID *) pu1LckDelay;
        }

        /* Test if interval, period and delay can be set or not */
        if (u4LckInterval != 0)

        {
            if (nmhTestv2FsMIY1731MepLckInterval
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4LckInterval) == SNMP_FAILURE)

            {
                break;
            }
        }

        if (pu1LckPeriod != NULL)
        {
            u4LckPeriod = *(UINT4 *) (VOID *) pu1LckPeriod;
            if (nmhTestv2FsMIY1731MepLckPeriod
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4LckPeriod) == SNMP_FAILURE)

            {
                break;
            }
        }
        if (u4LckDelay != 0)

        {
            if (nmhTestv2FsMIY1731MepLckDelay
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIndex, u4LckDelay) == SNMP_FAILURE)

            {
                break;
            }
        }

        /* After test, set the interval, period and delay */
        if (u4LckInterval != 0)

        {
            if (nmhSetFsMIY1731MepLckInterval
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4LckInterval) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        if (pu1LckPeriod != NULL)
        {
            u4LckPeriod = *(UINT4 *) (VOID *) pu1LckPeriod;
            if (nmhSetFsMIY1731MepLckPeriod
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4LckPeriod) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        if (u4LckDelay != 0)

        {
            if (nmhSetFsMIY1731MepLckDelay
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 u4LckDelay) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetVlanParams 
 *                                                                          
 *     DESCRIPTION      : This function will set vlan parameters
 *                        (drop-eligibility, vlan -priority).          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4Type - Type of command
 *                        u4Sts -  Drop-eligibility(enable/disable)
 *                        pu1Arg1 -  
 *                        pu1Arg2 - 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliSetVlanParams (tCliHandle CliHandle, UINT4 u4CurrContextId,
                      UINT4 u4Type, UINT4 u4Sts, UINT1 *pu1Arg1, UINT1 *pu1Arg2)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4Level = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4Priority = -1;
    INT4                i4RetMdRowStatus = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetStatus = CLI_SUCCESS;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    u4ContextId = u4CurrContextId;
    i4RetVal =
        nmhGetNextIndexFsMIY1731MegTable (u4ContextId, &u4NextContextId,
                                          0, &u4MdIndex);

    /* If the Domain name not configured, throw an error */
    if (i4RetVal == SNMP_SUCCESS)
    {
        if (u4ContextId != u4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }

    /* Scan MEG table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        i4Priority = -1;
        u4Level = 0;
        i4RetMdLevel = 0;
        nmhGetFsMIY1731MegRowStatus (u4ContextId, u4MdIndex, &i4RetMdRowStatus);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (u4ContextId, u4MdIndex, &i4RetMdLevel);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        switch (u4Type)

        {
            case CLI_ECFM_VLAN_PARAM_PRIORITY_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                i4Priority = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_VLAN_PARAM_PRIORITY_LEV:
                if (pu1Arg1 == NULL)
                {
                    u4Level = 7;
                }
                else
                {
                    u4Level = *(UINT4 *) (VOID *) pu1Arg1;
                }

                i4Priority = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) i4RetMdLevel == u4Level))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_VLAN_PARAM_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_VLAN_PARAM_LEVEL:
                u4Level = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) i4RetMdLevel == u4Level))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_VLAN_PARAM_PRIORITY:
                if (i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE)

                {
                    b1Entry = ECFM_TRUE;
                }
                i4Priority = *(INT4 *) (VOID *) pu1Arg1;
                break;
            case CLI_ECFM_VLAN_PARAM:
                if (i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            /* Check if MEG row status can be set */
            if (nmhTestv2FsMIY1731MegRowStatus
                (&u4ErrorCode, u4ContextId, u4MdIndex,
                 ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }
            if (nmhSetFsMIY1731MegRowStatus
                (u4ContextId, u4MdIndex,
                 ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }

            do

            {

                /* Test if vlan priority and drop eligibility can be set or not */
                if (i4Priority != -1)

                {
                    if (nmhTestv2FsMIY1731MegVlanPriority
                        (&u4ErrorCode, u4ContextId, u4MdIndex,
                         i4Priority) == SNMP_FAILURE)

                    {
                        i4RetStatus = CLI_FAILURE;
                        break;
                    }
                }

                if (u4Sts != 0)
                {
                    if (nmhTestv2FsMIY1731MegDropEnable
                        (&u4ErrorCode, u4ContextId, u4MdIndex,
                         u4Sts) == SNMP_FAILURE)

                    {
                        i4RetStatus = CLI_FAILURE;
                        break;
                    }
                }

                if (i4Priority != -1)
                {
                    if (nmhSetFsMIY1731MegVlanPriority
                        (u4ContextId, u4MdIndex, i4Priority) == SNMP_FAILURE)

                    {
                        CLI_FATAL_ERROR (CliHandle);
                        break;
                    }
                }

                if (u4Sts != 0)
                {
                    if (nmhSetFsMIY1731MegDropEnable
                        (u4ContextId, u4MdIndex, u4Sts) == SNMP_FAILURE)

                    {
                        CLI_FATAL_ERROR (CliHandle);
                        break;
                    }
                }
            }
            while (0);

            /* Check if MEG row status can be set */
            if (nmhTestv2FsMIY1731MegRowStatus
                (&u4ErrorCode, u4ContextId, u4MdIndex,
                 ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }
            if (nmhSetFsMIY1731MegRowStatus
                (u4ContextId, u4MdIndex,
                 ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }

            return i4RetStatus;
        }

        /* Move to next MEG */
        i4RetVal =
            nmhGetNextIndexFsMIY1731MegTable (u4ContextId,
                                              &u4NextContextId,
                                              u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            b1Entry = ECFM_FALSE;
        }
    }

    CLI_SET_ERR (CLI_ECFM_VLAN_PARAM_DOM_CONF_ERR);
    return CLI_FAILURE;
}

/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetDropEligibility
 *     
 *     DESCRIPTION      : This function will enables/disables the drop
 *                        eligibilty of various ECFM PDUs.     
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        i4SetValue  - DE to set or reset
 *                        u4Flag      - Value acc. to  the user's input
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetDropEligibility (tCliHandle CliHandle, UINT4 u4ContextId,
                           INT4 i4SetValue, UINT4 u4Flag)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4SetDropEligibility = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;
    INT4                i4RowStatus = ECFM_INIT_VAL;

    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;

    /* Check whether to set or reset the DE */
    if (i4SetValue == ECFM_ENABLE)

    {
        i4SetDropEligibility = ECFM_SNMP_TRUE;
    }

    else

    {
        i4SetDropEligibility = ECFM_SNMP_FALSE;
    }
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }

    do

    {

        /* Test if DE of CCM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
            CLI_ECFM_SET_VLAN_PARAMS_CCM)

        {
            if (nmhTestv2FsMIY1731MepCcmDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of AIS PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AIS) ==
            CLI_ECFM_SET_VLAN_PARAMS_AIS)

        {
            if (nmhTestv2FsMIY1731MepAisDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of LCK PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LCK) ==
            CLI_ECFM_SET_VLAN_PARAMS_LCK)

        {
            if (nmhTestv2FsMIY1731MepLckDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Then set the DE of CCM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
            CLI_ECFM_SET_VLAN_PARAMS_CCM)

        {
            if (nmhSetFsMIY1731MepCcmDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of AIS PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AIS) ==
            CLI_ECFM_SET_VLAN_PARAMS_AIS)

        {
            if (nmhSetFsMIY1731MepAisDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of LCK PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LCK) ==
            CLI_ECFM_SET_VLAN_PARAMS_LCK)

        {
            if (nmhSetFsMIY1731MepLckDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (i4RetStatus == CLI_FAILURE)

    {
        return CLI_FAILURE;
    }

    /* Setting DE of LMM PDU */
    if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LMM) == CLI_ECFM_SET_VLAN_PARAMS_LMM)

    {

        /* Test if DE of LMM PDU can be set or not */
        if (nmhTestv2FsMIY1731MepTransmitLmmDropEnable
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
             i4SetDropEligibility) == SNMP_FAILURE)

        {
            return CLI_FAILURE;
        }

        /* Then set the DE of LMM PDU */
        if (nmhSetFsMIY1731MepTransmitLmmDropEnable
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
             i4SetDropEligibility) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* Test if DE of LMM - Availability PDU can be set or not */
    if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AVLBLTY) ==
        CLI_ECFM_SET_VLAN_PARAMS_AVLBLTY)

    {
        do
        {
            if (nmhGetFsMIY1731MepAvailabilityRowStatus (u4ContextId,
                                                         u4MdIndex,
                                                         u4MaIndex,
                                                         u4MepId,
                                                         &i4RowStatus) !=
                SNMP_SUCCESS)
            {
                /*Test and Create Availability Measurement Table */
                if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepId, ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_SUCCESS)
                {
                    if (nmhSetFsMIY1731MepAvailabilityRowStatus
                        (u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepId,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                    {
                        break;
                    }
                }
            }
            /* If created already, change status to Not in Service to configure */
            else if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
                     (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                      u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_SUCCESS)
            {
                if (nmhSetFsMIY1731MepAvailabilityRowStatus
                    (u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
                {
                    break;
                }

            }
            /* If Availability is on-going */
            else
            {
                break;
            }
            if (nmhTestv2FsMIY1731MepAvailabilityDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                break;
            }

            if (nmhSetFsMIY1731MepAvailabilityDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
        while (0);
    }

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    do

    {

        /* Test if DE of LBM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LBM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LBM)

        {
            if (nmhTestv2FsMIY1731MepTransmitLbmDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of LTM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LTM)

        {
            if (nmhTestv2FsMIY1731MepTransmitLtmDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of TST PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_TST) ==
            CLI_ECFM_SET_VLAN_PARAMS_TST)

        {
            if (nmhTestv2FsMIY1731MepTransmitTstDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of 1DM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_1DM) ==
            CLI_ECFM_SET_VLAN_PARAMS_1DM)

        {
            if (nmhTestv2FsMIY1731MepTransmit1DmDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Test if DE of DMM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_DMM) ==
            CLI_ECFM_SET_VLAN_PARAMS_DMM)

        {
            if (nmhTestv2FsMIY1731MepTransmitDmmDropEnable
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4SetDropEligibility) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        /* Then set the DE of LBM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LBM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LBM)

        {
            if (nmhSetFsMIY1731MepTransmitLbmDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of LTM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LTM)

        {
            if (nmhSetFsMIY1731MepTransmitLtmDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of TST PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_TST) ==
            CLI_ECFM_SET_VLAN_PARAMS_TST)

        {
            if (nmhSetFsMIY1731MepTransmitTstDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of 1DM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_1DM) ==
            CLI_ECFM_SET_VLAN_PARAMS_1DM)

        {
            if (nmhSetFsMIY1731MepTransmit1DmDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }

        /* Then set the DE of DMM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_DMM) ==
            CLI_ECFM_SET_VLAN_PARAMS_DMM)

        {
            if (nmhSetFsMIY1731MepTransmitDmmDropEnable
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4SetDropEligibility) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    return i4RetStatus;
}

/******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSetVlanPriority
 *     
 *     DESCRIPTION      : This function will Test and Set the vlan priority 
 *                        variables used for both 802.1ag and Y.1731 
 *                        irrespective of mode the port is operating.
 *                        The TEST/SET is done for both the CC-LTM and CC,
 *                        LTM objects also.
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context ID 
 *                        u4Flag      - Value acc. to  the user's input
 *                        pu1Arg1, pu1Arg2, pu1Arg3, pu1Arg4, pu1Arg5, pu1Arg6,
 *                        pu1Arg7, pu1Arg8, pu1Arg9, pu1Arg10, pu1Arg11 
 *                        - Priority value acc. to the input                        
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSetVlanPriority (tCliHandle CliHandle, UINT4 u4ContextId,
                        UINT4 u4Flag, UINT1 *pu1Arg1,
                        UINT1 *pu1Arg2, UINT1 *pu1Arg3,
                        UINT1 *pu1Arg4, UINT1 *pu1Arg5,
                        UINT1 *pu1Arg6, UINT1 *pu1Arg7,
                        UINT1 *pu1Arg8, UINT1 *pu1Arg9,
                        UINT1 *pu1Arg10, UINT1 *pu1Arg11)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepId = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4VlanPriority = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;
    INT4                i4Y1731PortOperStatus = ECFM_DISABLE;
    INT4                i4TempVlanPriority = ECFM_INIT_VAL;
    BOOL1               b1Global = ECFM_FALSE;
    INT4                i4MepIfIndex = ECFM_INIT_VAL;
    INT4                i4RowStatus = ECFM_INIT_VAL;
    tEcfmCcMepInfo     *pMepNode = NULL;
    /* Getting the MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepId = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    pMepNode = EcfmCcUtilGetMepEntryFrmGlob (u4MdIndex, u4MaIndex, u4MepId);
    if (pMepNode == NULL)
    {
        CliPrintf (CliHandle, "\r%% SNMP: No MEP exists for the indices\n");
        return CLI_FAILURE;
    }

    if (pMepNode->pEcfmMplsParams == NULL)
    {
        if (nmhGetFsMIEcfmMepIfIndex (u4ContextId, u4MdIndex, u4MaIndex,
                                      u4MepId, &i4MepIfIndex) != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle, " Unable to retrieve the IfIndex "
                       "associated with the MEP-ID %u \r\n", u4MepId);
            return CLI_FAILURE;
        }

        if (nmhGetFsMIY1731PortOperStatus (i4MepIfIndex, &i4Y1731PortOperStatus)
            != SNMP_SUCCESS)
        {
            CliPrintf (CliHandle,
                       " Unable to retrieve the Port Operational Mode "
                       "for the IfIndex %d \r\n", i4MepIfIndex);
            return CLI_FAILURE;
        }
    }
    else
    {
        i4Y1731PortOperStatus = ECFM_ENABLE;
    }
    if (((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
         CLI_ECFM_SET_VLAN_PARAMS_CCM) &&
        ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
         CLI_ECFM_SET_VLAN_PARAMS_LTM))
    {
        if (pu1Arg2 != NULL)
        {
            i4VlanPriority = *(INT4 *) (VOID *) pu1Arg2;
        }
        if (pu1Arg4 != NULL)
        {
            i4TempVlanPriority = *(INT4 *) (VOID *) pu1Arg4;
        }

        /* When ECFM module is operating in 1ag mode, setting 
         * CCM/LTM Priority will result in setting both CCM and LTM
         * Priority. So, value configured in CCM and LTM priority
         * should not be different.
         */
        if ((i4Y1731PortOperStatus == ECFM_DISABLE) &&
            (i4VlanPriority != i4TempVlanPriority))
        {
            CliPrintf (CliHandle,
                       "\r%% Vlan Priority in CCM and LTM should be same "
                       "in IEEE 802.1ag mode\n");
            return CLI_FAILURE;
        }
    }

    /* Setting Vlan priority of all the PDUs */
    if (u4Flag == CLI_ECFM_SET_VLAN_PARAMS_ALL)
    {
        if (pu1Arg1 != NULL)
        {
            i4VlanPriority = *(INT4 *) (VOID *) pu1Arg1;
            b1Global = ECFM_TRUE;
        }
    }

    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    do
    {
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
            CLI_ECFM_SET_VLAN_PARAMS_CCM)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg2 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg2;
                }
            }

            if (nmhTestv2FsMIY1731MepCcmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)

            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        if (((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
             CLI_ECFM_SET_VLAN_PARAMS_CCM) ||
            ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
             CLI_ECFM_SET_VLAN_PARAMS_LTM))
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg2 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg2;
                }
                else if (pu1Arg4 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg4;
                }
            }

            if (nmhTestv2FsMIEcfmMepCcmLtmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of LCK PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LCK) ==
            CLI_ECFM_SET_VLAN_PARAMS_LCK)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg10;
            }

            if (nmhTestv2FsMIY1731MepLckPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of AIS PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AIS) ==
            CLI_ECFM_SET_VLAN_PARAMS_AIS)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg9 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg9;
                }
            }
            if (nmhTestv2FsMIY1731MepAisPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
            CLI_ECFM_SET_VLAN_PARAMS_CCM)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg2 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg2;
                }
            }

            if (nmhSetFsMIY1731MepCcmPriority
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }

        if (((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_CCM) ==
             CLI_ECFM_SET_VLAN_PARAMS_CCM) ||
            ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
             CLI_ECFM_SET_VLAN_PARAMS_LTM))
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg2 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg2;
                }
                else if (pu1Arg4 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg4;
                }
            }

            if (nmhSetFsMIEcfmMepCcmLtmPriority
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Then set the Vlan priority of AIS PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AIS) ==
            CLI_ECFM_SET_VLAN_PARAMS_AIS)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg9 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg9;
                }
            }

            if (nmhSetFsMIY1731MepAisPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        /* Then set the Vlan priority of LCK PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LCK) ==
            CLI_ECFM_SET_VLAN_PARAMS_LCK)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg10;
            }

            if (nmhSetFsMIY1731MepLckPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);

    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (i4RetStatus == CLI_FAILURE)
    {
        return CLI_FAILURE;
    }
    /* Setting Vlan priority of LMM PDU */
    if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LMM) == CLI_ECFM_SET_VLAN_PARAMS_LMM)
    {
        if (b1Global != ECFM_TRUE)
        {
            if (pu1Arg7 != NULL)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg7;
            }
            else
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
        /* Test if Vlan priority of LMM PDU can be set or not */
        if (nmhTestv2FsMIY1731MepTransmitLmmPriority
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
             i4VlanPriority) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Then set the Vlan priority of LMM PDU */
        if (nmhSetFsMIY1731MepTransmitLmmPriority
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
             i4VlanPriority) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* Setting Vlan priority of LMM PDU for Availability Measurement  */
    if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_AVLBLTY) ==
        CLI_ECFM_SET_VLAN_PARAMS_AVLBLTY)
    {
        if (b1Global != ECFM_TRUE)
        {
            if (pu1Arg11)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg11;
            }
            else
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }

        }

        do
        {
            if (nmhGetFsMIY1731MepAvailabilityRowStatus (u4ContextId,
                                                         u4MdIndex,
                                                         u4MaIndex,
                                                         u4MepId,
                                                         &i4RowStatus) !=
                SNMP_SUCCESS)
            {
                /*Test and Create Availability Measurement Table */
                if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepId, ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_SUCCESS)
                {
                    if (nmhSetFsMIY1731MepAvailabilityRowStatus
                        (u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepId,
                         ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                    {
                        break;
                    }
                }
            }
            /* If created already, change status to Not in Service to configure */
            else if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
                     (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                      u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_SUCCESS)
            {
                if (nmhSetFsMIY1731MepAvailabilityRowStatus
                    (u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepId, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
                {
                    break;
                }

            }
            /* If Availability is on-going */
            else
            {
                break;
            }

            /* Test if Vlan priority of LMM PDU can be set or not */
            if (nmhTestv2FsMIY1731MepAvailabilityPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                break;
            }

            /* Then set the Vlan priority of LMM PDU */
            if (nmhSetFsMIY1731MepAvailabilityPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
        while (0);
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();

    ECFM_REGISTER_CLI_LBLT_LOCK ();
    do
    {
        /* Test if Vlan priority of LBM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LBM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LBM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg3;
            }

            if (nmhTestv2FsMIY1731MepTransmitLbmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of LTM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LTM)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg4 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg4;
                }
            }
            /* When ECFM module is operating in Y1731 mode,
             * individual objects are available to set CCM and LTM priority. */
            if (nmhTestv2FsMIY1731MepTransmitLtmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of 1-DM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_1DM) ==
            CLI_ECFM_SET_VLAN_PARAMS_1DM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg5;
            }
            if (nmhTestv2FsMIY1731MepTransmit1DmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of DMM PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_DMM) ==
            CLI_ECFM_SET_VLAN_PARAMS_DMM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg6;
            }
            if (nmhTestv2FsMIY1731MepTransmitDmmPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Test if Vlan priority of TST PDU can be set or not */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_TST) ==
            CLI_ECFM_SET_VLAN_PARAMS_TST)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg8;
            }
            if (nmhTestv2FsMIY1731MepTransmitTstPriority
                (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepId, i4VlanPriority) == SNMP_FAILURE)
            {
                i4RetStatus = CLI_FAILURE;
                break;
            }
        }
        /* Then set the Vlan priority of LBM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LBM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LBM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg3;
            }
            if (nmhSetFsMIY1731MepTransmitLbmPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        /* Then set the Vlan priority of LTM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_LTM) ==
            CLI_ECFM_SET_VLAN_PARAMS_LTM)
        {
            if (b1Global != ECFM_TRUE)
            {
                if (pu1Arg4 != NULL)
                {
                    i4VlanPriority = *(INT4 *) (VOID *) pu1Arg4;
                }
            }
            /* When ECFM module is operating in Y1731 mode,
             * individual objects are available to set CCM and LTM priority. */
            if (nmhSetFsMIY1731MepTransmitLtmPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        /* Then set the Vlan priority of 1-DM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_1DM) ==
            CLI_ECFM_SET_VLAN_PARAMS_1DM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg5;
            }
            if (nmhSetFsMIY1731MepTransmit1DmPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        /* Then set the Vlan priority of DMM PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_DMM) ==
            CLI_ECFM_SET_VLAN_PARAMS_DMM)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg6;
            }
            if (nmhSetFsMIY1731MepTransmitDmmPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
        /* Then set the Vlan priority of TST PDU */
        if ((u4Flag & CLI_ECFM_SET_VLAN_PARAMS_TST) ==
            CLI_ECFM_SET_VLAN_PARAMS_TST)
        {
            if (b1Global != ECFM_TRUE)
            {
                i4VlanPriority = *(INT4 *) (VOID *) pu1Arg8;
            }
            if (nmhSetFsMIY1731MepTransmitTstPriority
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepId,
                 i4VlanPriority) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                break;
            }
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    return i4RetStatus;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmGetNumOfRMeps
 *                                                                          
 *     DESCRIPTION      : This function will find the remote Meps for a MEP.
 *                                                                          
 *     INPUT            : u4ContextId - context Identifier
 *                        u4MdId - MdIndex
 *                        u4MaId - MaIndex
 *                        u4MepId - MepId
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : Number of Remote Meps 
 *                                                                          
 ******************************************************************************/
PRIVATE INT2
EcfmGetNumOfRMeps (UINT4 u4ContextId, UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT2                u2TotalRMeps = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                           (UINT4 *) &i4NextContextId,
                                           0, &u4MdIndex, 0, &u4MaIndex,
                                           0, &u4MepIdentifier, 0,
                                           &u4RMepIdentifier) == SNMP_FAILURE)

    {
        return CLI_SUCCESS;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return CLI_SUCCESS;
    }
    ECFM_MEMSET (MacAddr, ECFM_DEF_MAC_ADDR, ECFM_MAC_ADDR_LENGTH);

    /* Scan Remote Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext))

    {
        if ((u4MdIndex == u4MdId) && (u4MaIndex == u4MaId)
            && (u4MepIdentifier == u4MepId))

        {
            nmhGetFsMIEcfmMepDbMacAddress (i4CurrentContextId,
                                           u4MdIndex, u4MaIndex,
                                           u4MepIdentifier,
                                           u4RMepIdentifier, &RetMacAddr);
            u2TotalRMeps = u2TotalRMeps + 1;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                               (UINT4 *)
                                               &i4NextContextId,
                                               u4MdIndex,
                                               &u4NextMdIndex,
                                               u4MaIndex,
                                               &u4NextMaIndex,
                                               u4MepIdentifier,
                                               &u4NextMepIdentifier,
                                               u4RMepIdentifier,
                                               &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (i4CurrentContextId != i4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
    }
    return u2TotalRMeps;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliInitLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will initiate the loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4, pu1Arg5, pu1Arg6
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        u4IfIndex - Interface Index on which initiating MEP exist
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliInitLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Command, INT4 i4Dir,
                            UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                            UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                            UINT1 *pu1Arg5, UINT1 *pu1Arg6, UINT4 u4IfIndex,
                            UINT1 *pu1MdName)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4LmmInterval = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsDestMpId = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;
    BOOL1               b2Err = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    /* Validate LMM Interval value */
    if (*(pu1Arg5) != 0)

    {
        i4LmmInterval = *(INT4 *) (VOID *) pu1Arg5;

    }
    else
    {
        i4LmmInterval = ECFM_CC_LMM_INTERVAL_100_Ms;
    }
    u4CurrContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_FL_MEP_MPID_DOM_ISID:
            case CLI_ECFM_FL_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MPID_DOM_VSI:
            case CLI_ECFM_FL_MEP_MPID_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))
                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_FL_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FL_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MPID_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MPID_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MPID_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MAC_DOM_ISID:
            case CLI_ECFM_FL_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MAC_DOM_VSI:
            case CLI_ECFM_FL_MEP_MAC_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_FL_MEP_MAC_LEV_ISID:
            case CLI_ECFM_FL_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MAC_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MAC_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MAC_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {
            /* Start the Loss Measurement */
            if (EcfmConfigLMParams
                (CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, b1IsDestMpId, pu1Arg3, pu1Arg4,
                 pu1Arg6, i4LmmInterval, &b1Err, &b2Err) == ECFM_FAILURE)

            {
                if (b2Err == ECFM_TRUE)
                {
                    CLI_SET_ERR (CLI_ECFM_LM_IN_PROGRESS_ERR);
                    return CLI_FAILURE;
                }
                if ((u4IfIndex != 0) && (i4Dir != 0))
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_LM_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                                            &u4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_LM_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }

                if (u4ContextId != u4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                b1IsDestMpId = ECFM_FALSE;
                b1Err = ECFM_FALSE;
                continue;
            }
            return CLI_SUCCESS;
        }
        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
        b1IsDestMpId = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliStopLossMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will stop the loss calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        u4IfIndex - Interface on which initiating MEP exist
 *                        pu1MdName - Md Name
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliStopLossMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Command, INT4 i4Dir,
                            UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT4 u4IfIndex,
                            UINT1 *pu1MdName, UINT1 *pu1Arg3)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4DestMpId = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1IsDestMpId = ECFM_FALSE;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;
    u4CurrContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable
        (u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4RetIfIndex);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {

            case CLI_ECFM_FL_MEP_MAC_DOM_ISID:
            case CLI_ECFM_FL_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MAC_DOM_VSI:
            case CLI_ECFM_FL_MEP_MAC_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MPID_DOM_ISID:
            case CLI_ECFM_FL_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_FL_MEP_MPID_DOM_VSI:
            case CLI_ECFM_FL_MEP_MPID_DOM_SER:
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_FL_MEP_MAC_LEV_ISID:
            case CLI_ECFM_FL_MEP_MAC_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MAC_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_FL_MEP_MPID_LEV_ISID:
            case CLI_ECFM_FL_MEP_MPID_LEV_VLAN:
            case CLI_ECFM_FL_MEP_MPID_LEV_VSI:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MAC_DOM:
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            case CLI_ECFM_FL_MEP_MPID_DOM:
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MAC_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_FL_MEP_MPID_LEV:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && ((i4Dir == 0)
                        || ((i4Dir != 0)
                            && (i4Dir ==
                                i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {
            if (b1IsDestMpId == ECFM_TRUE)
            {
                u4DestMpId = *(UINT4 *) (VOID *) pu1Arg3;
                if (u4DestMpId != u4RMepIdentifier)
                {
                    CLI_SET_ERR (CLI_ECFM_DEST_MEPID_ERR);
                    return ECFM_FAILURE;
                }
            }
            else
            {
                ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
                StrToMac (pu1Arg3, MacAddr);
                nmhGetFsMIEcfmRMepMacAddress (u4CurrContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, u4RMepIdentifier,
                                              &RetMacAddr);
                if ((ECFM_MEMCMP
                     (RetMacAddr, MacAddr, ECFM_MAC_ADDR_LENGTH) != 0))
                {
                    CLI_SET_ERR (CLI_ECFM_DEST_MAC_ERR);
                    return ECFM_FAILURE;
                }
            }

            /* Stop the Loss Measurement */
            /* Test if the transaction can be stop  */
            if (nmhTestv2FsMIY1731MepTransmitLmmStatus
                (&u4ErrorCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }

            /* Then stop the transaction */
            if (nmhSetFsMIY1731MepTransmitLmmStatus
                (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepDbTable (u4CurrContextId,
                                               &u4NextContextId,
                                               u4MdIndex, &u4NextMdIndex,
                                               u4MaIndex, &u4NextMaIndex,
                                               u4MepIdentifier,
                                               &u4NextMepIdentifier,
                                               u4RMepIdentifier,
                                               &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigLMParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for
 *                        Loss Measurement.
 *                                                                          
 *     INPUT            : CliHandle       - CliContext ID
 *                        u4MdIndex       - MdIndex                     
 *                        u4MaIndex       - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        b1IsDestMpId    - Destination MepId or Mac Address
 *                        i4LmInterval    - LMM Interval to set  
 *                        pu1Arg1         -
 *                        pu1Arg2         -
 *                        pu1Arg3         - Arguments acc. to the command
 *                                                                        
 *     OUTPUT           : pb1Err - Indicates an Error from Test routine
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigLMParams (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4MdIndex, UINT4 u4MaIndex,
                    UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                    UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT1 *pu1Arg3,
                    INT4 i4LmInterval, BOOL1 * pb1Err, BOOL1 * pb2Err)
{
    tEcfmMacAddr        DestMacAddr = { 0 };
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4DestMpId = ECFM_INIT_VAL;
    INT4                i4LmMsgs = ECFM_INIT_VAL;
    INT4                i4LmDeadline = ECFM_INIT_VAL;
    INT4                i4LmStatus = -1;

    /* Set MepId or Dest Mac Address depending on the input */
    if (b1IsDestMpId == ECFM_TRUE)

    {
        if (nmhGetFsMIY1731MepTransmitLmmStatus
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             &i4LmStatus) != SNMP_FAILURE)
        {
            if (i4LmStatus == ECFM_TX_STATUS_NOT_READY)
            {
                *pb2Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
        }

        if (nmhTestv2FsMIY1731MepTransmitLmmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLmmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set MepId of the destination */
        u4DestMpId = *(UINT4 *) (VOID *) pu1Arg1;
        if (nmhTestv2FsMIY1731MepTransmitLmmDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLmmDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {
        ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        StrToMac (pu1Arg1, DestMacAddr);
        if (nmhTestv2FsMIY1731MepTransmitLmmDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLmmDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set destination address */
        if (nmhTestv2FsMIY1731MepTransmitLmmDestMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, DestMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitLmmDestMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             DestMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Test Number of Observations required for loss mesurement 
     * before setting */
    if (pu1Arg2 != NULL)

    {
        i4LmMsgs = *(INT4 *) (VOID *) pu1Arg2;
    }

    else

    {
        i4LmMsgs = 0;
    }
    if (nmhTestv2FsMIY1731MepTransmitLmmMessages
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4LmMsgs) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Interval before setting */
    if (nmhTestv2FsMIY1731MepTransmitLmmInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4LmInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test DeadLine Time before setting */
    if (pu1Arg3 != NULL)

    {
        i4LmDeadline = *(INT4 *) (VOID *) pu1Arg3;
    }

    else

    {
        i4LmDeadline = 0;
    }

    /* Test Deadline before setting */
    if (nmhTestv2FsMIY1731MepTransmitLmmDeadline
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4LmDeadline) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Initiate Loss Measurement */
    if (nmhTestv2FsMIY1731MepTransmitLmmStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLmmMessages
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4LmMsgs) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLmmInterval
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4LmInterval) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLmmDeadline
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4LmDeadline) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitLmmStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    CliPrintf (CliHandle, " ");
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitTst
 * 
 *     DESCRIPTION      : This function will initiate TST message for the mep at
 *                        the provided domain and vlan to the destination mp.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Type of command
 *                        u4MpId - Destination MpId
 *                        pu1Arg1 - MdName/MdLevel of the MEP initiating LBM
 *                                  depending upon the type of command
 *                        u4VlanId - VlanId of the MEP initiating LBM
 *                        i4IfIndex - Interface of the MEP initiating LBM
 *                        i4MepDir  - Direction of the MEP initiating LBM
 *                        LbRequest - Variable of structure TstRequest contains
 *                        various values to be set for TST transmission.
 *                        u4CmdType - Start/Stop Test Transmission
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitTst (tCliHandle CliHandle, UINT4 u4ContextId,
                UINT4 u4Type, UINT1 *pu1Arg1, UINT4 u4VlanId,
                INT4 i4IfIndex, INT4 i4MepDir,
                tEcfmLbLtTransRequest TstRequest, UINT4 u4CmdType)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4RetMepPortNum = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_INIT_VAL;
    u4CurrentContextId = u4ContextId;

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get Required values corresponding to MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetMepPortNum);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        switch (u4Type)

        {
            case CLI_ECFM_TST_DOM_ISID:
            case CLI_ECFM_TST_DOM_VLAN:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((u4RetMepPrimaryVid == u4VlanId)
                        || (u4RetMaPrimaryVid == u4VlanId))
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4RetMepPortNum == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TST_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0)
                    && ((i4IfIndex == 0)
                        || ((i4IfIndex != 0)
                            && (i4RetMepPortNum == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TST_DOM_SER:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0)
                      && (i4RetMepPortNum == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TST_LEV_ISID:
            case CLI_ECFM_TST_LEV_VLAN:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0)
                      && (i4RetMepPortNum == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TST_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     ((i4IfIndex != 0)
                      && (i4RetMepPortNum == i4IfIndex)))
                    && ((i4MepDir == 0)
                        || ((i4MepDir != 0)
                            && (i4RetMepDirection == i4MepDir))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Required MEP found */
        if (b1Entry == ECFM_TRUE)

        {
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            UINT4               u4SavedTstOut = ECFM_INIT_VAL;
            UINT4               u4TstOut = ECFM_INIT_VAL;
            INT4                i4VlanIdIsid = ECFM_INIT_VAL;
            INT4                i4MaVlanId = ECFM_INIT_VAL;
            INT4                i4MepVlanId = ECFM_INIT_VAL;
            INT4                i4Direction = ECFM_INIT_VAL;
            INT4                i4TstPatternType = ECFM_INIT_VAL;
            INT4                i4CliRetVal = CLI_FAILURE;
            tEcfmMacAddr        RetMepMacAddr = {
                0
            };
            tEcfmMacAddr        RetTargetMacAddr = {
                0
            };
            tEcfmMacAddr        MCastMacAddr = {
                0
            };
            UINT1               au1SrcMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];
            UINT1               au1DestMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];
            ECFM_MEMSET (RetMepMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (RetTargetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (MCastMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (au1SrcMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (au1DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            /* Saving the foll. values for display */
            nmhGetFsMIY1731MepTstOut (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      &u4SavedTstOut);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);
            nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier,
                                        &i4Direction);
            nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         (UINT4 *) &i4MepVlanId);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId,
                                           u4MdIndex, u4MaIndex, &i4MaVlanId);
            if (i4MepVlanId == 0)

            {
                i4VlanIdIsid = i4MaVlanId;
            }

            else

            {
                i4VlanIdIsid = i4MepVlanId;
            }
            nmhGetFsMIEcfmMepMacAddress (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         &RetMepMacAddr);
            nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      &i4RetMepPortNum);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            if (u4CmdType == CLI_ECFM_TEST_STOP)

            {
                UINT4               u4ErrorCode = ECFM_INIT_VAL;

                /* Transmit status */
                if (nmhTestv2FsMIY1731MepTransmitTstStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

                {
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return ECFM_FAILURE;
                }

                /* Set the status */
                if (nmhSetFsMIY1731MepTransmitTstStatus
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

                {
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return ECFM_FAILURE;
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                CliPrintf (CliHandle, " \r\n");
                return ECFM_SUCCESS;
            }

            /* Global pointer for receiving evnts from LB initiator and receiver
             */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);

            do

            {
                if (pCliEvent == NULL)

                {
                    break;
                }
                pCliEvent->u4ContextId = u4ContextId;
                pCliEvent->u4PortNum = (UINT2) i4RetMepPortNum;
                pCliEvent->u4VidIsid = i4VlanIdIsid;
                pCliEvent->u1MdLevel = (UINT1) i4RetMdLevel;
                pCliEvent->u1Direction = (UINT1) (i4Direction);
                if (EcfmConfigureCliSession
                    (u4CurrentContextId, u4MdIndex, u4MaIndex,
                     (UINT2) u4MepIdentifier, CliHandle,
                     ECFM_CLI_SESSION_TST) == ECFM_FAILURE)

                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);
            if (i4CliRetVal != CLI_SUCCESS)

            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Check if tst cli session was created succesfully */
            /* Configure MEP values for tst transmission */
            if (EcfmConfigTstParams
                (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier,
                 (tEcfmLbLtTransRequest *) & TstRequest,
                 &b1Err) != ECFM_SUCCESS)

            {
                if ((i4IfIndex != 0) && (i4MepDir != 0))
                {
                    if (b1Err != ECFM_TRUE)

                    {
                        CLI_SET_ERR (CLI_ECFM_TST_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();

                /* Move to next entry */
                i4RetVal =
                    nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                     &u4NextContextId,
                                                     u4MdIndex, &u4NextMdIndex,
                                                     u4MaIndex, &u4NextMaIndex,
                                                     u4MepIdentifier,
                                                     &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_TST_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                if (u4CurrentContextId != u4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                continue;
            }
            if (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE)

            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT,
                              ECFM_CONTROL_PLANE_TRC,
                              "ECFM: CLI task should not enter Test display loop"
                              " instead finish transaction and exit .\n");
                return CLI_SUCCESS;
            }
            /* Display of the initiation */
            nmhGetFsMIY1731MepTransmitTstDestMacAddress
                (u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, &RetTargetMacAddr);
            PrintMacAddress (RetTargetMacAddr, au1DestMacAddr);
            PrintMacAddress (RetMepMacAddr, au1SrcMacAddr);
            au1SrcMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
            au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
            if (TstRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

            {
                if (TstRequest.b1LbVariableBytes != ECFM_TRUE)

                {
                    mmi_printf
                        ("\rTST to %d from %s with %d(%d) bytes of data. \r\n",
                         TstRequest.u4TargetMepId, au1SrcMacAddr,
                         TstRequest.u4LbPatternSize, TstRequest.u4LbPduSize);
                }

                else

                {
                    mmi_printf
                        ("\rTST to %d from %s with varying bytes of data. \r\n",
                         TstRequest.u4TargetMepId, au1SrcMacAddr);
                }
            }

            else if (TstRequest.u1LbDestType == ECFM_TX_DEST_TYPE_UNICAST)

            {
                if (TstRequest.b1LbVariableBytes != ECFM_TRUE)

                {
                    mmi_printf
                        ("\rTST to %s from %s with %d(%d) bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr,
                         TstRequest.u4LbPatternSize, TstRequest.u4LbPduSize);
                }

                else

                {
                    mmi_printf
                        ("\rTST to %s from %s with varying bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr);
                }
            }

            else

            {
                ECFM_GEN_MULTICAST_CLASS1_ADDR (MCastMacAddr,
                                                (UINT1) i4RetMdLevel);
                PrintMacAddress (MCastMacAddr, au1DestMacAddr);
                au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
                if (TstRequest.b1LbVariableBytes != ECFM_TRUE)

                {
                    mmi_printf
                        ("\rTST to %s from %s with %d(%d) bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr,
                         TstRequest.u4LbPatternSize, TstRequest.u4LbPduSize);
                }

                else

                {
                    mmi_printf
                        ("\rTST to %s from %s with varying bytes of data. \r\n",
                         au1DestMacAddr, au1SrcMacAddr);
                }
            }

            /* release LBLT task so that tst can begin */
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();

            do

            {

                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
                 * till the time Tst has got expired */
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();
                switch (ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events)

                {
                    case CLI_EV_ECFM_TST_TRANS_SEND:
                        nmhGetFsMIY1731MepTransmitTstDestMacAddress
                            (u4CurrentContextId, u4MdIndex, u4MaIndex,
                             u4MepIdentifier, &RetTargetMacAddr);
                        PrintMacAddress (RetTargetMacAddr, au1DestMacAddr);
                        au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';
                        mmi_printf ("\r%d bytes to %s: seq_no=%d\r\n",
                                    ECFM_LBLT_CLI_EVENT_INFO
                                    (CliHandle)->Msg.u4Msg1,
                                    au1DestMacAddr,
                                    ECFM_LBLT_CLI_EVENT_INFO
                                    (CliHandle)->Msg.u4Msg2);
                        break;
                    case CLI_EV_ECFM_TST_TRANS_ERROR:
                        mmi_printf
                            ("\rfailure in transaction!! transaction abort!!\r\n");
                        ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events =
                            CLI_EV_ECFM_TST_TRANS_STOP;
                        break;
                    case CLI_EV_ECFM_TST_TRANS_STOP:
                        break;
                    default:
                        mmi_printf
                            ("\runknown event received!! transaction abort!!\r\n");
                        ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events =
                            CLI_EV_ECFM_TST_TRANS_STOP;
                        break;
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (ECFM_LBLT_CLI_EVENT_INFO (CliHandle)->u1Events !=
                   CLI_EV_ECFM_TST_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;
            nmhGetFsMIY1731MepTstOut (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier, &u4TstOut);
            nmhGetFsMIY1731MepTransmitTstPatternType
                (u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, &i4TstPatternType);
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            if (TstRequest.u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

            {
                mmi_printf ("\r--- %d test statistics --- \r\n",
                            TstRequest.u4TargetMepId);
            }

            else

            {
                mmi_printf ("\r--- %s test statistics --- \r\n",
                            au1DestMacAddr);
            }
            mmi_printf ("packets sent = %d ", u4TstOut - u4SavedTstOut);
            if (i4TstPatternType == ECFM_LBLT_TEST_TLV_NULL_SIGNAL_WITHOUT_CRC)

            {
                mmi_printf (" with null signal without crc32 pattern \r\n");
            }

            else if (i4TstPatternType ==
                     ECFM_LBLT_TEST_TLV_NULL_SIGNAL_WITH_CRC)

            {
                mmi_printf (" with null signal with crc32 pattern \r\n");
            }

            else if (i4TstPatternType == ECFM_LBLT_TEST_TLV_PRBS_WITHOUT_CRC)

            {
                mmi_printf (" with prbs signal without crc32 pattern \r\n");
            }

            else

            {
                mmi_printf (" with prbs signal with crc32 pattern \r\n");
            }
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)

        {

            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CliPrintf (CliHandle, " ");
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliXmitTh
 * 
 *     DESCRIPTION      : This function will initiate TST message for the mep at
 *                        the provided domain and vlan to the destination mp.
 * 
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Type of command
 *                        u4MpId - Destination MpId
 *                        pu1Arg1 - MdName/MdLevel of the MEP initiating LBM
 *                                  depending upon the type of command
 *                        u4VlanId - VlanId of the MEP initiating LBM
 *                        i4IfIndex - Interface of the MEP initiating LBM
 *                        i4MepDir  - Direction of the MEP initiating LBM
 *                        LbRequest - Variable of structure TstRequest contains
 *                        various values to be set for TST transmission.
 *                        u4CmdType - Start/Stop Test Transmission
 *    
 *     OUTPUT           : None
 *    
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *    
 ******************************************************************************/
INT4
EcfmCliXmitTh (tCliHandle CliHandle, UINT4 u4ContextId,
               UINT4 u4Type, UINT1 *pu1Arg1, UINT4 u4VlanId,
               INT4 i4IfIndex, INT4 i4MepDir,
               tEcfmLbLtThTransRequest ThRequest, UINT4 u4CmdType)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMepPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4ThType = ECFM_INIT_VAL;
    UINT4               u4PktSize = ECFM_INIT_VAL;
    UINT4               u4VerifiedBps = ECFM_INIT_VAL;
    FLT4                f4VerifiedMBps = ECFM_INIT_VAL;
    UINT4               u4ThPps = ECFM_INIT_VAL;
    UINT4               u4DestMepId = ECFM_INIT_VAL;
    FLT4                f4THMbps = 0.0;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4RetMepPortNum = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1              *pu1MdName = NULL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_INIT_VAL;
    UINT1               au1THMbps[ECFM_ARRAY_SIZE_32] = { 0 };
    UINT1               u1EventId = ECFM_INIT_VAL;

    u4CurrentContextId = u4ContextId;

    ECFM_MEMSET (au1THMbps, ECFM_INIT_VAL, sizeof (au1THMbps));
    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex,
         0, &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        /* Reset return values for the next MEP */
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        u4RetMepPrimaryVid = ECFM_INIT_VAL;
        u4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_INIT_VAL;

        /* Get Required values corresponding to MEP entry */
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     &u4RetMepPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                  u4MaIndex, u4MepIdentifier, &i4RetMepPortNum);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        switch (u4Type)
        {
            case CLI_ECFM_TH_DOM_ISID:
            case CLI_ECFM_TH_DOM_VLAN:
            case CLI_ECFM_TH_DOM_VSI:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     (i4RetMepPortNum == i4IfIndex)) &&
                    ((i4MepDir == 0) || (i4RetMepDirection == i4MepDir)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TH_DOM:
                pu1MdName = (UINT1 *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (STRCMP (au1StrMdName, pu1MdName) == 0) &&
                    ((i4IfIndex == 0) ||
                     (i4RetMepPortNum == i4IfIndex)) &&
                    ((i4MepDir == 0) || (i4RetMepDirection == i4MepDir)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TH_LEV_ISID:
            case CLI_ECFM_TH_DOM_SER:
            case CLI_ECFM_TH_LEV_VLAN:
            case CLI_ECFM_TH_LEV_VSI:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((u4RetMepPrimaryVid == u4VlanId) ||
                     (u4RetMaPrimaryVid == u4VlanId)) &&
                    ((i4IfIndex == 0) ||
                     (i4RetMepPortNum == i4IfIndex)) &&
                    ((i4MepDir == 0) || (i4RetMepDirection == i4MepDir)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_TH_LEV:
                u4MdLevel = *(UINT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    ((i4IfIndex == 0) ||
                     (i4RetMepPortNum == i4IfIndex)) &&
                    ((i4MepDir == 0) || (i4RetMepDirection == i4MepDir)))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }
        /* Required MEP found */
        if (b1Entry == ECFM_TRUE)
        {
            tEcfmLbLtCliEvInfo *pCliEvent = NULL;
            INT4                i4VlanIdIsid = ECFM_INIT_VAL;
            INT4                i4MaVlanId = ECFM_INIT_VAL;
            INT4                i4MepVlanId = ECFM_INIT_VAL;
            INT4                i4Direction = ECFM_INIT_VAL;
            INT4                i4TstPatternType = ECFM_INIT_VAL;
            INT4                i4CliRetVal = CLI_FAILURE;
            tEcfmMacAddr        RetMepMacAddr = { 0 };
            tEcfmMacAddr        RetTargetMacAddr = { 0 };
            tEcfmMacAddr        MCastMacAddr = { 0 };
            UINT1               au1SrcMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];
            UINT1               au1DestMacAddr[ECFM_CLI_MAX_MAC_STRING_SIZE];

            ECFM_MEMSET (RetMepMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (RetTargetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (MCastMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (au1SrcMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
            ECFM_MEMSET (au1DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);

            nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);
            nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                        u4MaIndex, u4MepIdentifier,
                                        &i4Direction);
            nmhGetFsMIEcfmMepPrimaryVid (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         (UINT4 *) &i4MepVlanId);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrentContextId,
                                           u4MdIndex, u4MaIndex, &i4MaVlanId);
            if (i4MepVlanId == 0)
            {
                i4VlanIdIsid = i4MaVlanId;
            }
            else
            {
                i4VlanIdIsid = i4MepVlanId;
            }
            nmhGetFsMIEcfmMepMacAddress (u4CurrentContextId, u4MdIndex,
                                         u4MaIndex, u4MepIdentifier,
                                         &RetMepMacAddr);
            nmhGetFsMIEcfmMepIfIndex (u4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      &i4RetMepPortNum);
            ECFM_UNREGISTER_CLI_CC_LOCK ();
            ECFM_REGISTER_CLI_LBLT_LOCK ();
            /* Global pointer for receiving evnts from TH initiator and receiver
             */
            pCliEvent = EcfmInitLbLtCliEventInfo (CliHandle);
            do
            {
                if (pCliEvent == NULL)
                {
                    break;
                }
                pCliEvent->u4ContextId = u4ContextId;
                pCliEvent->u4PortNum = (UINT2) i4RetMepPortNum;
                pCliEvent->u4VidIsid = i4VlanIdIsid;
                pCliEvent->u1MdLevel = (UINT1) i4RetMdLevel;
                pCliEvent->u1Direction = (UINT1) (i4Direction);
                if (EcfmConfigureCliSession (u4CurrentContextId,
                                             u4MdIndex,
                                             u4MaIndex,
                                             (UINT2) u4MepIdentifier,
                                             CliHandle,
                                             ECFM_CLI_SESSION_TH) ==
                    ECFM_FAILURE)
                {
                    break;
                }
                i4CliRetVal = CLI_SUCCESS;
            }
            while (0);
            /* Check if TH cli session was created succesfully */
            if (i4CliRetVal != CLI_SUCCESS)
            {
                CLI_SET_ERR (CLI_ECFM_MEP_NOT_READY_TO_TRANSMIT_ERR);
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                return CLI_FAILURE;
            }

            /* Configure MEP values for th transmission */
            if (EcfmConfigThParams
                (CliHandle, u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier,
                 (tEcfmLbLtThTransRequest *) & ThRequest, &b1Err,
                 u4CmdType) != ECFM_SUCCESS)
            {
                if ((i4IfIndex != 0) && (i4MepDir != 0))
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_TH_INITIATION_ERR);
                    }
                    EcfmDeInitLbLtCliEventInfo (CliHandle);
                    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                    ECFM_REGISTER_CLI_CC_LOCK ();
                    return CLI_FAILURE;
                }
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                            &u4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)
                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_TH_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                if (u4CurrentContextId != u4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                b1Err = ECFM_FALSE;
                continue;
            }

            if ((u4CmdType == CLI_ECFM_TH_STOP) ||
                (ECFM_NODE_STATUS () != ECFM_NODE_ACTIVE))
            {
                EcfmDeInitLbLtCliEventInfo (CliHandle);
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
                ECFM_REGISTER_CLI_CC_LOCK ();
                ECFM_GLB_TRC (ECFM_INVALID_CONTEXT,
                              ECFM_CONTROL_PLANE_TRC,
                              "ECFM: CLI task should not enter Th display loop"
                              " instead finish transaction and exit .\n");
                return CLI_SUCCESS;
            }
            CliPrintf (CliHandle, "\r\n");
            /* release LBLT task so that th can begin */
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            do
            {
                /* CLI lock (ECFM_LBLT_CLI_SYNC_LOCK) is taken to block the  CLI shell 
                 * till the time Th has got expired */
                ECFM_TAKE_SEMAPHORE (pCliEvent->SyncSemId);
                ECFM_REGISTER_CLI_LBLT_LOCK ();

                while (pCliEvent->u1Events != 0)
                {
                    u1EventId = EcfmGetBit (&(pCliEvent->u1Events));
                    switch (u1EventId)
                    {
                        case CLI_EV_ECFM_TH_BURST_COMPLETE:
                            f4THMbps = (pCliEvent->Msg.u4Msg1) /
                                ECFM_LBLT_TH_MBPS_CONV_FACTOR;
                            SPRINTF ((CHR1 *) au1THMbps, "%f", f4THMbps);
                            mmi_printf
                                ("\r%-7d/%7s, packet size %-4d bytes\r\n",
                                 pCliEvent->Msg.u4Msg1, au1THMbps,
                                 pCliEvent->Msg.u4Msg2);
                            break;
                        case CLI_EV_ECFM_TH_TRANS_ERROR:
                            mmi_printf
                                ("\r\n failure in transaction!! transaction abort!!\r\n");
                            pCliEvent->u1Events = 0;
                            u1EventId = CLI_EV_ECFM_TH_TRANS_STOP;
                            break;
                        case CLI_EV_ECFM_TH_TRANS_STOP:
                            break;
                        default:
                            mmi_printf
                                ("\r\n unknown event received!! transaction abort!!\r\n");
                            pCliEvent->u1Events = 0;
                            u1EventId = CLI_EV_ECFM_TH_TRANS_STOP;
                            break;
                    }
                }
                ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            }
            while (u1EventId != CLI_EV_ECFM_TH_TRANS_STOP);
            ECFM_REGISTER_CLI_LBLT_LOCK ();

            EcfmDeInitLbLtCliEventInfo (CliHandle);
            pCliEvent = NULL;

            nmhGetFsMIY1731MepTransmitThDestMepId (u4CurrentContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   &u4DestMepId);
            nmhGetFsMIY1731MepTransmitThType (u4CurrentContextId,
                                              u4MdIndex, u4MaIndex,
                                              u4MepIdentifier, &i4ThType);

            nmhGetFsMIY1731MepTransmitThTestPatternType
                (u4CurrentContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, &i4TstPatternType);

            if (ThRequest.u1DestIsMepId == ECFM_TRUE)
            {
                if (i4ThType == CLI_ECFM_TH_TYPE_1TH)
                {
                    mmi_printf
                        ("\r\n--- %d one-way throughput statistics ---",
                         u4DestMepId);
                }
                else
                {
                    mmi_printf
                        ("\r\n--- %d two-way throughput statistics ---",
                         u4DestMepId);
                }
            }
            else
            {
                nmhGetFsMIY1731MepTransmitThDestMacAddress
                    (u4CurrentContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, &RetTargetMacAddr);
                PrintMacAddress (RetTargetMacAddr, au1DestMacAddr);
                au1DestMacAddr[ECFM_INDEX_SEVENTEEN] = '\0';

                if (i4ThType == CLI_ECFM_TH_TYPE_1TH)
                {
                    mmi_printf
                        ("\r\n--- %s one-way throughput statistics ---",
                         au1DestMacAddr);
                }
                else
                {
                    mmi_printf
                        ("\r\n--- %s two-way throughput statistics ---",
                         au1DestMacAddr);
                }
            }

            nmhGetFsMIY1731MepThVerifiedFrameSize (u4CurrentContextId,
                                                   u4MdIndex,
                                                   u4MaIndex,
                                                   u4MepIdentifier, &u4PktSize);
            nmhGetFsMIY1731MepThVerifiedBps (u4CurrentContextId,
                                             u4MdIndex, u4MaIndex,
                                             u4MepIdentifier, &u4VerifiedBps);

            ECFM_MEMSET (au1THMbps, ECFM_INIT_VAL, sizeof (au1THMbps));
            f4VerifiedMBps = u4VerifiedBps / ECFM_LBLT_TH_MBPS_CONV_FACTOR;
            SPRINTF ((CHR1 *) au1THMbps, "%f", f4VerifiedMBps);
            if (u4VerifiedBps > 0)
            {
                mmi_printf
                    ("\r\nfinal throughput %d bps / %s mbps, packet size %d bytes \r\n",
                     u4VerifiedBps, au1THMbps, u4PktSize);
            }
            else
            {
                mmi_printf
                    ("\r\nfinal throughput %d bps / %s mbps\r\n",
                     u4VerifiedBps, au1THMbps);
            }
            nmhGetFsMIY1731MepTransmitThPps (u4CurrentContextId,
                                             u4MdIndex,
                                             u4MaIndex,
                                             u4MepIdentifier, &u4ThPps);
            mmi_printf ("\rtransmission rate = %d pps \r\n", u4ThPps);

            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return CLI_SUCCESS;
        }
        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        if (u4CurrentContextId != u4NextContextId)
        {
            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }
        b1Entry = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CliPrintf (CliHandle, " ");
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigThParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB structures required 
 *                        for TH transmission.
 *                                                                          
 *     INPUT            : u4MdIndex    - MdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        pThRequest - Various fields to set
 *                        u4CmdType   - Start/Stop Test Transaction
 *                                                                        
 *     OUTPUT           : None
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigThParams (tCliHandle CliHandle, UINT4 u4ContextId,
                    UINT4 u4MdIndex, UINT4 u4MaIndex,
                    UINT4 u4MepIdentifier,
                    tEcfmLbLtThTransRequest * pThRequest,
                    BOOL1 * pb1Err, UINT4 u4CmdType)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    if (u4CmdType == CLI_ECFM_TH_STOP)
    {
        /* Transmit status */
        if (nmhTestv2FsMIY1731MepTransmitThStatus (&u4ErrorCode,
                                                   u4ContextId,
                                                   u4MdIndex,
                                                   u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_TX_STATUS_STOP)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        /* Set the status */
        if (nmhSetFsMIY1731MepTransmitThStatus (u4ContextId,
                                                u4MdIndex,
                                                u4MaIndex,
                                                u4MepIdentifier,
                                                ECFM_TX_STATUS_STOP) ==
            SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        CliPrintf (CliHandle, " \r\n");
        return ECFM_SUCCESS;
    }

    /* Set Destination type depending on the input */
    if (pThRequest->u1DestIsMepId == ECFM_TRUE)
    {
        /* MepId as a target */
        if (nmhTestv2FsMIY1731MepTransmitThDestIsMepId (&u4ErrorCode,
                                                        u4ContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        u4MepIdentifier,
                                                        ECFM_SNMP_TRUE)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitThDestIsMepId (u4ContextId,
                                                     u4MdIndex,
                                                     u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_SNMP_TRUE) ==
            SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepTransmitThDestMepId (&u4ErrorCode,
                                                      u4ContextId,
                                                      u4MdIndex,
                                                      u4MaIndex,
                                                      u4MepIdentifier,
                                                      pThRequest->
                                                      u4TargetMepId) ==
            SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitThDestMepId (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   pThRequest->
                                                   u4TargetMepId) ==
            SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }
    else
    {
        if (nmhTestv2FsMIY1731MepTransmitThDestIsMepId (&u4ErrorCode,
                                                        u4ContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        u4MepIdentifier,
                                                        ECFM_SNMP_FALSE)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitThDestIsMepId (u4ContextId,
                                                     u4MdIndex,
                                                     u4MaIndex,
                                                     u4MepIdentifier,
                                                     ECFM_SNMP_FALSE) ==
            SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }

        if (nmhTestv2FsMIY1731MepTransmitThDestMacAddress (&u4ErrorCode,
                                                           u4ContextId,
                                                           u4MdIndex,
                                                           u4MaIndex,
                                                           u4MepIdentifier,
                                                           pThRequest->
                                                           TargetMacAddr)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitThDestMacAddress (u4ContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        u4MepIdentifier,
                                                        pThRequest->
                                                        TargetMacAddr)
            == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }

    if (pThRequest->u1ThBurstType == ECFM_LBLT_TH_BURST_TYPE_DL)
    {
        /* Test Th Burst Deadline */
        if (nmhTestv2FsMIY1731MepTransmitThBurstDeadline (&u4ErrorCode,
                                                          u4ContextId,
                                                          u4MdIndex,
                                                          u4MaIndex,
                                                          u4MepIdentifier,
                                                          pThRequest->
                                                          u4ThBurstDeadline)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        /* Set Th Burst Deadline */
        if (nmhSetFsMIY1731MepTransmitThBurstDeadline (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       pThRequest->
                                                       u4ThBurstDeadline)
            == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }
    else
    {
        /* Test Number of Th Burst Messages */
        if (nmhTestv2FsMIY1731MepTransmitThBurstMessages (&u4ErrorCode,
                                                          u4ContextId,
                                                          u4MdIndex,
                                                          u4MaIndex,
                                                          u4MepIdentifier,
                                                          pThRequest->
                                                          u4ThBurstMessages)
            == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        /* Set number of Th Burst Messages */
        if (nmhSetFsMIY1731MepTransmitThBurstMessages (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       pThRequest->
                                                       u4ThBurstMessages)
            == SNMP_FAILURE)
        {
            return ECFM_FAILURE;
        }
    }

    /* Test Deadline */
    if (nmhTestv2FsMIY1731MepTransmitThDeadline (&u4ErrorCode,
                                                 u4ContextId,
                                                 u4MdIndex,
                                                 u4MaIndex,
                                                 u4MepIdentifier,
                                                 pThRequest->
                                                 u4ThDeadline) == SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    /* Test Pattern type */
    if (nmhTestv2FsMIY1731MepTransmitThTestPatternType (&u4ErrorCode,
                                                        u4ContextId,
                                                        u4MdIndex,
                                                        u4MaIndex,
                                                        u4MepIdentifier,
                                                        pThRequest->
                                                        u1TstPatternType)
        == SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    /* Test Pkt size */
    if (nmhTestv2FsMIY1731MepTransmitThFrameSize (&u4ErrorCode,
                                                  u4ContextId,
                                                  u4MdIndex,
                                                  u4MaIndex,
                                                  u4MepIdentifier,
                                                  pThRequest->
                                                  u4ThFrameSize) ==
        SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    /* Test Pps */
    if (nmhTestv2FsMIY1731MepTransmitThPps (&u4ErrorCode,
                                            u4ContextId,
                                            u4MdIndex,
                                            u4MaIndex,
                                            u4MepIdentifier,
                                            pThRequest->u4ThPps) ==
        SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test ThType */
    if (nmhTestv2FsMIY1731MepTransmitThType (&u4ErrorCode,
                                             u4ContextId,
                                             u4MdIndex,
                                             u4MaIndex,
                                             u4MepIdentifier,
                                             pThRequest->u1ThType) ==
        SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Number of Th Messages */
    if (nmhTestv2FsMIY1731MepTransmitThMessages (&u4ErrorCode,
                                                 u4ContextId,
                                                 u4MdIndex,
                                                 u4MaIndex,
                                                 u4MepIdentifier,
                                                 pThRequest->
                                                 u4ThMessages) == SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Th Burst Type */
    if (nmhTestv2FsMIY1731MepTransmitThBurstType (&u4ErrorCode,
                                                  u4ContextId,
                                                  u4MdIndex,
                                                  u4MaIndex,
                                                  u4MepIdentifier,
                                                  pThRequest->
                                                  u1ThBurstType) ==
        SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Set Th Pattern Type */

    if (nmhSetFsMIY1731MepTransmitThTestPatternType (u4ContextId,
                                                     u4MdIndex,
                                                     u4MaIndex,
                                                     u4MepIdentifier,
                                                     pThRequest->
                                                     u1TstPatternType)
        == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set Th InitPktSize */
    if (nmhSetFsMIY1731MepTransmitThFrameSize (u4ContextId,
                                               u4MdIndex,
                                               u4MaIndex,
                                               u4MepIdentifier,
                                               pThRequest->
                                               u4ThFrameSize) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set Th Pps */
    if (nmhSetFsMIY1731MepTransmitThPps (u4ContextId,
                                         u4MdIndex,
                                         u4MaIndex,
                                         u4MepIdentifier,
                                         pThRequest->u4ThPps) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set ThType */
    if (nmhSetFsMIY1731MepTransmitThType (u4ContextId,
                                          u4MdIndex,
                                          u4MaIndex,
                                          u4MepIdentifier,
                                          pThRequest->u1ThType) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set number of Th Messages */
    if (nmhSetFsMIY1731MepTransmitThMessages (u4ContextId,
                                              u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              pThRequest->
                                              u4ThMessages) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }
    /* Set Th Deadline */
    if (nmhSetFsMIY1731MepTransmitThDeadline (u4ContextId,
                                              u4MdIndex,
                                              u4MaIndex,
                                              u4MepIdentifier,
                                              pThRequest->
                                              u4ThDeadline) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepTransmitThBurstType (u4ContextId,
                                               u4MdIndex,
                                               u4MaIndex,
                                               u4MepIdentifier,
                                               pThRequest->
                                               u1ThBurstType) == SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    /* Set the Transmit status */
    if (nmhTestv2FsMIY1731MepTransmitThStatus (&u4ErrorCode,
                                               u4ContextId,
                                               u4MdIndex,
                                               u4MaIndex,
                                               u4MepIdentifier,
                                               ECFM_TX_STATUS_START) ==
        SNMP_FAILURE)
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    /* Set the status */
    if (nmhSetFsMIY1731MepTransmitThStatus (u4ContextId,
                                            u4MdIndex,
                                            u4MaIndex,
                                            u4MepIdentifier,
                                            ECFM_TX_STATUS_START) ==
        SNMP_FAILURE)
    {
        return ECFM_FAILURE;
    }

    CliPrintf (CliHandle, "");
    return ECFM_SUCCESS;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigTstParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB structures required 
 *                        for TST transmission.
 *                                                                          
 *     INPUT            : u4MdIndex    - MdIndex                     
 *                        u4MaIndex    - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        pTstRequest - Various fields to set
 *                                                                        
 *     OUTPUT           : None
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigTstParams (tCliHandle CliHandle, UINT4 u4ContextId,
                     UINT4 u4MdIndex, UINT4 u4MaIndex,
                     UINT4 u4MepIdentifier,
                     tEcfmLbLtTransRequest * pTstRequest, BOOL1 * pb1Err)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4VaryingBytes = ECFM_SNMP_FALSE;

    /* Set Destination type depending on the input */
    if (pTstRequest->u1LbDestType == ECFM_TX_DEST_TYPE_MEPID)

    {

        /* MepId as a target */
        if (nmhTestv2FsMIY1731MepTransmitTstDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_MEPID) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitTstDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_MEPID) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhTestv2FsMIY1731MepTransmitTstDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pTstRequest->u4TargetMepId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitTstDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pTstRequest->u4TargetMepId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Unicast Mac Address as a target */
    else if (pTstRequest->u1LbDestType == ECFM_TX_DEST_TYPE_UNICAST)

    {
        if (nmhTestv2FsMIY1731MepTransmitTstDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_UNICAST) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitTstDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_UNICAST) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
        if (nmhTestv2FsMIY1731MepTransmitTstDestMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, pTstRequest->LbTargetMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitTstDestMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             pTstRequest->LbTargetMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Multicast Mac Address as a target */
    else

    {
        if (nmhTestv2FsMIY1731MepTransmitTstDestType
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_TX_DEST_TYPE_MULTICAST) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepTransmitTstDestType
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_TX_DEST_TYPE_MULTICAST) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Test Pattern type */
    if (nmhTestv2FsMIY1731MepTransmitTstPatternType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u4LbTstPatternType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Pattern size */
    if (nmhTestv2FsMIY1731MepTransmitTstPatternSize
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u4LbPatternSize) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Interval Type */
    if (nmhTestv2FsMIY1731MepTransmitTstIntervalType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u1LbIntervalType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Interval */
    if (nmhTestv2FsMIY1731MepTransmitTstInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u2LbInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test variable bytes */
    if (pTstRequest->b1LbVariableBytes == ECFM_TRUE)

    {
        i4VaryingBytes = ECFM_SNMP_TRUE;
    }

    else

    {
        i4VaryingBytes = ECFM_SNMP_FALSE;
    }
    if (nmhTestv2FsMIY1731MepTransmitTstVariableBytes
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4VaryingBytes) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Number of TSTs */
    if (nmhTestv2FsMIY1731MepTransmitTstMessages
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u4LbMessages) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test Deadline */
    if (nmhTestv2FsMIY1731MepTransmitTstDeadline
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, pTstRequest->u4LbDeadline) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitTstPatternType
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u4LbTstPatternType) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitTstPatternSize
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u4LbPatternSize) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitTstIntervalType
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u1LbIntervalType) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    if (nmhSetFsMIY1731MepTransmitTstInterval
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u2LbInterval) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* variable bytes */
    if (nmhSetFsMIY1731MepTransmitTstVariableBytes
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         i4VaryingBytes) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Set number of TSTs */
    if (nmhSetFsMIY1731MepTransmitTstMessages
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u4LbMessages) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Set Deadline */
    if (nmhSetFsMIY1731MepTransmitTstDeadline
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         pTstRequest->u4LbDeadline) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }

    /* Set the Transmit status */
    if (nmhTestv2FsMIY1731MepTransmitTstStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Set the status */
    if (nmhSetFsMIY1731MepTransmitTstStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    CliPrintf (CliHandle, "");
    return ECFM_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliSet1DMTransInterval
 *                                                                          
 *     DESCRIPTION      : This function sets the 1DM Transaction interval.
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id 
 *                        i41DmTransInterval - Value to be set
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliSet1DMTransInterval (tCliHandle CliHandle, UINT4 u4ContextId,
                            INT4 i41DmTransInterval)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;
    INT4                i4SetValue = ECFM_INIT_VAL;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (i41DmTransInterval < ECFM_NUM_OF_TICKS_IN_A_MSEC)

        i4SetValue = i41DmTransInterval;
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    do

    {

        /* Test if value can be set or not */
        if (nmhTestv2FsMIY1731Mep1DmTransInterval
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, i4SetValue) == SNMP_FAILURE)

        {
            i4RetStatus = CLI_FAILURE;
            break;
        }

        /* Then set the value */
        if (nmhSetFsMIY1731Mep1DmTransInterval
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
             i4SetValue) == SNMP_FAILURE)

        {
            CLI_FATAL_ERROR (CliHandle);
            break;
        }
    }
    while (0);
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();
    if (nmhTestv2FsMIY1731MepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIY1731MepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)

    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliConfigureFaultAlarmTime
 *                                                                          
 *     DESCRIPTION      : This function sets Fault Alarm Time snf Fault Reset 
 *                        Time 
 *                        Fault Alarm Time - The time that defects must be present before 
 *                        a Fault Alarm is issued
 *                        Fault Reset Time - The time that defects must be absent before 
 *                        re-enabling a Fault Alarm 
 *                                                                          
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id 
 *                        i4Alarmtime - Value to be set
 *                        u4Command   - Set Alarm/Reset time
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliConfigureFaultAlarmTime (tCliHandle CliHandle, UINT4 u4ContextId,
                                INT4 i4AlarmTime, UINT4 u4Command)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetStatus = CLI_SUCCESS;
    INT4                i4SetValue = ECFM_INIT_VAL;

    /* Get MEP's indices */
    u4MdIndex = gaEcfmMepPromptInfo[CliHandle].u4MdIndex;
    u4MaIndex = gaEcfmMepPromptInfo[CliHandle].u4MaIndex;
    u4MepIndex = gaEcfmMepPromptInfo[CliHandle].u4MepIndex;
    i4SetValue = i4AlarmTime;
    /* Test whether MEP row status cab be Not-In-Service or not */
    if (nmhTestv2FsMIEcfmMepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    /* Set MEP row status as Not-In-Service */
    if (nmhSetFsMIEcfmMepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }

    if (u4Command == CLI_ECFM_FNG_SET_ALARMTIME)
    {
        /* Test whether fault alarm time value can be set or not */
        if (nmhTestv2FsMIEcfmMepFngAlarmTime
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, i4SetValue) == SNMP_FAILURE)
        {
            i4RetStatus = CLI_FAILURE;
        }
        else
        {
            /* Then set the value */
            if (nmhSetFsMIEcfmMepFngAlarmTime
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 i4SetValue) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
            }
        }
    }
    else if (u4Command == CLI_ECFM_FNG_SET_RESETTIME)
    {
        /* Test whether fault reset time value can be set or not */
        if (nmhTestv2FsMIEcfmMepFngResetTime
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIndex, i4SetValue) == SNMP_FAILURE)
        {
            i4RetStatus = CLI_FAILURE;
        }
        else
        {
            /* Then set the value */
            if (nmhSetFsMIEcfmMepFngResetTime
                (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
                 i4SetValue) == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
            }
        }
    }

    /* Test whether MEP row status cab be Active or not */
    if (nmhTestv2FsMIEcfmMepRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    /* Set MEP row status as active */
    if (nmhSetFsMIEcfmMepRowStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIndex,
         ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    return i4RetStatus;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmInitLbLtCliEventInfo
 *                                                                          
 *     DESCRIPTION      : This function allocates the memory for LBLT's CLI 
 *                        event info for a cli session.
 *                                                                          
 *     INPUT            : CliHandle - CLI handle
 *
 *     OUTPUT           : None               
 *
 *     RETURNS          : Pointer to the allocated LBLT's CLI event info.
 *****************************************************************************/
PRIVATE tEcfmLbLtCliEvInfo *
EcfmInitLbLtCliEventInfo (tCliHandle CliHandle)
{
    tEcfmLbLtCliEvInfo *pCliEvent = NULL;
    CHR1                ac1SynSemName[ECFM_ARRAY_SIZE_32] = {
        0
    };

    pCliEvent = &(gaEcfmLbLtCliEventInfo[CliHandle]);
    ECFM_MEMSET (pCliEvent, 0x00, sizeof (tEcfmLbLtCliEvInfo));
    SPRINTF (ac1SynSemName, "LT%d", CliHandle);
    if (ECFM_CREATE_SEMAPHORE
        ((UINT1 *) ac1SynSemName,
         &(gaEcfmLbLtCliEventInfo[CliHandle].SyncSemId)) == OSIX_FAILURE)

    {
        printf("\n EcfmInitLbLtCliEventInfo : SEM creation failed !\n");
        pCliEvent = NULL;
        return NULL;
    }
    /* Disable __more__ option */
    CliDisableMore (CliHandle);
    ECFM_LBLT_CLI_EVENT_INFO (CliHandle) = pCliEvent;
    return pCliEvent;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmDeInitLbLtCliEventInfo
 *                                                                          
 *     DESCRIPTION      : This function de-allocates the memory allocated for
 *                        LBLT's CLI event info for a cli session.
 *                                                                          
 *     INPUT            : CliHandle - CLI handle
 *
 *     OUTPUT           : None               
 *
 *     RETURNS          : None
 *****************************************************************************/
PRIVATE VOID
EcfmDeInitLbLtCliEventInfo (tCliHandle CliHandle)
{
    tEcfmLbLtCliEvInfo *pCliEvent = NULL;
    pCliEvent = ECFM_LBLT_CLI_EVENT_INFO (CliHandle);
    if (pCliEvent == NULL)

    {
        return;
    }
    ECFM_DELETE_SEMAPHORE (pCliEvent->SyncSemId);
    /* Enable __more__ option */
    CliEnableMore (CliHandle);
    ECFM_LBLT_CLI_EVENT_INFO (CliHandle) = NULL;
    return;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigIsidMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database config 
 *                        mode. New Mep will be created when that mep is not 
 *                        present at that level and vlan in the database 
 *                                                                           
 *     INPUT            : u1MdLevel   - level at which it needs to be created
 *                        Direction   - up/down                              
 *                        u4MepId     - MepIdentifier                        
 *                        u4Isid      - Isid                           
 *                        i1MepActiveStatus - its active status after        
 *                        creation
 *                        u4PortNum - Port Number
 *
 *     OUTPUT           : None                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigIsidMep (tCliHandle CliHandle, UINT4 u4Type,
                      UINT1 u1MdLevel, INT1 i1MepDirection,
                      UINT4 u4ContextId, UINT4 u4Isid,
                      UINT4 u4MepIdentifier, INT1 i1MepActiveStatus,
                      UINT4 u4PortNum, UINT1 *pu1MaName)
{
    UINT1               au1Cmd[MAX_PROMPT_LEN];
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVlanIdIsid = ECFM_INIT_VAL;
    INT4                i4IfIndex = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepStatus = ECFM_SNMP_FALSE;
    BOOL1               b1UnAwareMep = ECFM_FALSE;
    UINT4               u4IsidIntr = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    tSNMP_OCTET_STRING_TYPE RetMaName;

    u4IsidIntr = ECFM_ISID_TO_ISID_INTERNAL (u4Isid);

    UNUSED_PARAM (u4ContextId);

    if (nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex) ==
        SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ISID_ERR);
        return CLI_FAILURE;
    }

    /* in this case always ISID aware only */

    /* Scan Ma table for this Md level */
    while (i4RetVal == SNMP_SUCCESS)
    {
        u4RetMdLevel = ECFM_INIT_VAL;
        u4RetPrimaryVlanIdIsid = ECFM_INIT_VAL;
        ECFM_MEMSET (gaEcfmMepPromptInfo, ECFM_INIT_VAL, sizeof
                     (tEcfmMepPromptInfo));
        ECFM_MEMSET (au1Cmd, ECFM_INIT_VAL, MAX_PROMPT_LEN);

        nmhGetDot1agCfmMdMdLevel (u4MdIndex, (INT4 *) &u4RetMdLevel);

        /* Check if this entry is having this Md Level */
        if ((UINT1) u4RetMdLevel == u1MdLevel)
        {
            nmhGetIeee8021CfmMaCompPrimarySelectorOrNone
                (ECFM_CC_CURR_CONTEXT_ID (), u4MdIndex, u4MaIndex,
                 &u4RetPrimaryVlanIdIsid);
            if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                return ECFM_FAILURE;
            }

            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;

            nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);

            if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                return ECFM_FAILURE;
            }

            /* Check if this is the required Ma entry */
            /* u4RetPrimaryVlanIdIsid value contains the internal ISID */
            if ((u4RetPrimaryVlanIdIsid == u4IsidIntr) &&
                (pu1MaName == NULL ||
                 ECFM_STRCMP (RetMaName.pu1_OctetList, pu1MaName) == 0))
            {
                /* Create row by checking its row status */
                if (nmhTestv2FsMIEcfmExtMepRowStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                {
                    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
                    {
                        CliPrintf (CliHandle,
                                   "\r%% Invalid Virtual Switch.\r\n ");
                        return ECFM_FAILURE;
                    }

                    /* Check if MEP is already configured and user wants to change
                     * its status */
                    if ((EcfmSameMepExists
                         (CliHandle, u4MdIndex, u4MaIndex,
                          u4MepIdentifier, u4PortNum, u1MdLevel,
                          u4IsidIntr, i1MepDirection,
                          u4RetPrimaryVlanIdIsid,
                          &i4RetMepStatus) == ECFM_TRUE)
                        && (i1MepActiveStatus == ECFM_SNMP_TRUE)
                        && (i1MepActiveStatus != i4RetMepStatus))
                    {
                        nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       ECFM_ROW_STATUS_NOT_IN_SERVICE);
                        nmhSetFsMIEcfmExtMepActive (u4ContextId,
                                                    u4MdIndex,
                                                    u4MaIndex,
                                                    u4MepIdentifier,
                                                    i1MepActiveStatus);
                        nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       ECFM_ROW_STATUS_ACTIVE);
                        if (ECFM_CC_SELECT_CONTEXT (u4ContextId) !=
                            ECFM_SUCCESS)
                        {
                            CliPrintf (CliHandle,
                                       "\r%% Invalid Virtual Switch.\r\n ");
                            return ECFM_FAILURE;
                        }

                    }
                    /* MEP already exists and user does not want to change its
                     * status */
                    /* Y.1731 : ENTER MEP Config Mode */
                    if ((u4Type !=
                         CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_CONF_LEV)
                        && (u4Type != CLI_ECFM_DOWN_PBB_MEP_CTRL_CONF_LEV))
                    {
                        SPRINTF ((CHR1 *) au1Cmd, "%s", CLI_MEP_MODE);
                        if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)
                        {
                            CLI_SET_ERR (CLI_ECFM_MEP_CHMOD_ERR);
                            return CLI_FAILURE;
                        }
                        gaEcfmMepPromptInfo[CliHandle].u4MdIndex = u4MdIndex;
                        gaEcfmMepPromptInfo[CliHandle].u4MaIndex = u4MaIndex;
                        gaEcfmMepPromptInfo[CliHandle].u4MepIndex =
                            u4MepIdentifier;
                    }
                    return CLI_SUCCESS;
                }
                /* MEP can be created with this MA */
                if (nmhSetFsMIEcfmExtMepRowStatus
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
                {
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }
                if (ECFM_GET_IFINDEX_FROM_LOCAL_PORT (u4ContextId, u4PortNum,
                                                      (UINT4 *) &i4IfIndex) ==
                    ECFM_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    return CLI_FAILURE;
                }

                /* Set MEPs other values */
                if (nmhTestv2FsMIEcfmExtMepIfIndex
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, i4IfIndex) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    return CLI_FAILURE;
                }

                if (nmhSetFsMIEcfmExtMepIfIndex
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     i4IfIndex) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }

                if (nmhTestv2FsMIEcfmExtMepDirection
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, i1MepDirection) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    return CLI_FAILURE;
                }

                if (nmhSetFsMIEcfmExtMepDirection
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     i1MepDirection) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }

                /* Test only if it is vlan aware mep to be configured */
                if (b1UnAwareMep != ECFM_TRUE)
                {
                    if (nmhTestv2FsMIEcfmExtMepPrimaryVidOrIsid
                        (&u4ErrorCode, u4ContextId, u4MdIndex,
                         u4MaIndex, u4MepIdentifier,
                         u4IsidIntr) == SNMP_FAILURE)
                    {
                        nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       ECFM_ROW_STATUS_DESTROY);
                        return CLI_FAILURE;
                    }
                    if (nmhSetFsMIEcfmExtMepPrimaryVidOrIsid
                        (u4ContextId, u4MdIndex, u4MaIndex,
                         u4MepIdentifier, u4Isid) == SNMP_FAILURE)
                    {
                        nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                       u4MdIndex,
                                                       u4MaIndex,
                                                       u4MepIdentifier,
                                                       ECFM_ROW_STATUS_DESTROY);
                        CLI_FATAL_ERROR (CliHandle);
                        return CLI_FAILURE;
                    }
                }

                if (nmhTestv2FsMIEcfmExtMepActive
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, i1MepActiveStatus) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    return CLI_FAILURE;
                }

                if (nmhSetFsMIEcfmExtMepActive
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     i1MepActiveStatus) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }

                /* Change its row status to Active */
                if (nmhTestv2FsMIEcfmExtMepRowStatus
                    (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
                     u4MepIdentifier, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
                {
                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    return CLI_FAILURE;
                }

                if (nmhSetFsMIEcfmExtMepRowStatus
                    (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                     ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
                {

                    nmhSetFsMIEcfmExtMepRowStatus (u4ContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY);
                    CLI_FATAL_ERROR (CliHandle);
                    return CLI_FAILURE;
                }
                if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
                {
                    CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                    return ECFM_FAILURE;
                }

                if ((u4Type != CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_CONF_LEV)
                    && (u4Type != CLI_ECFM_DOWN_PBB_MEP_CTRL_CONF_LEV))
                {
                    /* Y.1731 : ENTER MEP Config Mode */
                    SPRINTF ((CHR1 *) au1Cmd, "%s", CLI_MEP_MODE);
                    if (CliChangePath ((CHR1 *) au1Cmd) == CLI_FAILURE)
                    {
                        CLI_SET_ERR (CLI_ECFM_MEP_CHMOD_ERR);
                        return CLI_FAILURE;
                    }
                    gaEcfmMepPromptInfo[CliHandle].u4MdIndex = u4MdIndex;
                    gaEcfmMepPromptInfo[CliHandle].u4MaIndex = u4MaIndex;
                    gaEcfmMepPromptInfo[CliHandle].u4MepIndex = u4MepIdentifier;
                }
                return CLI_SUCCESS;
            }
        }
        /* move to next Ma */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_MEP_CONFIG_MA_EXIST_ISID_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteOrDisableIsidMep                 
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database         
 *                        Delete or disable the configured Mep, if present. 
 *
 *     INPUT            : u1MdLevel  -  MdLevel 
 *                        u4Type     -   Type of the command(Disable or delete)
 *                        *pu4Isid -   pointer to IsId
 *                        u4MepIdentifier  - MepIdentifier                       
 *                        u4PortNum - Port Number
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliDeleteOrDisableIsidMep (tCliHandle CliHandle, UINT4 u4Type,
                               UINT4 u4ContextId, UINT4 u4MdLevel,
                               UINT4 *pu4Isid,
                               UINT4 u4MepIdentifier, UINT4 u4PortNum)
{
    INT4                i4IfIndex = ECFM_INIT_VAL;
    INT4                i4Level = ECFM_INIT_VAL;
    INT4                i4ServiceSelectType = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    INT4                i4Dir = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4RetMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMepIndex = ECFM_INIT_VAL;
    BOOL1               b1Delete = ECFM_FALSE;

    /* Check if there is any MEP */
    if (nmhGetFirstIndexIeee8021CfmStackTable
        (&i4IfIndex, &i4ServiceSelectType, &u4Isid, &i4Level,
         &i4Dir) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    switch (u4Type)
    {
        case CLI_ECFM_UP_DOM_ISID_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_LEV_ISID_MEP_CTRL_NOCONF:
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_TRUE;
            break;

        case CLI_ECFM_DOWN_LEV_ISID_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_ISID_MEP_CTRL_NOCONF:
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_TRUE;
            break;

        case CLI_ECFM_UP_LEV_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_UP_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF:
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_FALSE;
            break;

        case CLI_ECFM_DOWN_LEV_ISID_ACTIVE_MEP_CTRL_NOCONF:
        case CLI_ECFM_DOWN_DOM_ISID_ACTIVE_MEP_CTRL_NOCONF:
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_FALSE;
            break;

        case CLI_ECFM_UP_ACTIVE_PBB_MEP_CTRL_NOCONF_LEV:
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_FALSE;
            break;

        case CLI_ECFM_UP_PBB_MEP_CTRL_NOCONF_LEV:
            i4Dir = ECFM_MP_DIR_UP;
            b1Delete = ECFM_TRUE;
            break;

        case CLI_ECFM_DOWN_ACTIVE_PBB_MEP_CTRL_NOCONF_LEV:
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_FALSE;
            break;

        case CLI_ECFM_DOWN_PBB_MEP_CTRL_NOCONF_LEV:
            i4Dir = ECFM_MP_DIR_DOWN;
            b1Delete = ECFM_TRUE;
            break;
    }

    u4Isid = (UINT4) (*pu4Isid);
    i4ServiceSelectType = ECFM_SERVICE_SELECTION_ISID;

    if (nmhValidateIndexInstanceIeee8021CfmStackTable
        (u4PortNum, i4ServiceSelectType, u4Isid, u4MdLevel,
         i4Dir) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    nmhGetIeee8021CfmStackMdIndex (u4PortNum, i4ServiceSelectType, u4Isid,
                                   u4MdLevel, i4Dir, &u4RetMdIndex);
    nmhGetIeee8021CfmStackMaIndex (u4PortNum, i4ServiceSelectType, u4Isid,
                                   u4MdLevel, i4Dir, &u4RetMaIndex);
    nmhGetIeee8021CfmStackMepId (u4PortNum, i4ServiceSelectType, u4Isid,
                                 u4MdLevel, i4Dir, &u4RetMepIndex);
    /* Check if it MEP */
    if ((u4RetMdIndex == 0) || (u4RetMaIndex == 0) || (u4RetMepIndex == 0))
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    /* Required MEP */
    if (u4RetMepIndex != u4MepIdentifier)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    /* Disable or Delete MEP */
    if (b1Delete != ECFM_TRUE)
    {
        /* Deactivate MEP by setting MEP's row status to
         * not_in_service */
        if (nmhTestv2FsMIEcfmExtMepRowStatus
            (&u4ErrorCode, u4ContextId, u4RetMdIndex, u4RetMdIndex,
             u4RetMepIndex, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepRowStatus
            (u4ContextId, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        /* Test whether MEP can be de-activated */
        if (nmhTestv2FsMIEcfmExtMepActive
            (&u4ErrorCode, u4ContextId, u4RetMdIndex, u4RetMaIndex,
             u4RetMepIndex, ECFM_SNMP_FALSE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepActive
            (u4ContextId, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        /* Set MEP's row status to active */
        if (nmhTestv2FsMIEcfmExtMepRowStatus
            (&u4ErrorCode, u4ContextId, u4RetMdIndex, u4RetMaIndex,
             u4RetMepIndex, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMepRowStatus
            (u4ContextId, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        return CLI_SUCCESS;
    }
    /*Delete row by checking its row status */
    if (nmhTestv2FsMIEcfmExtMepRowStatus
        (&u4ErrorCode, u4ContextId, u4RetMdIndex, u4RetMaIndex,
         u4RetMepIndex, ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmExtMepRowStatus
        (u4ContextId, u4RetMdIndex, u4RetMaIndex, u4RetMepIndex,
         ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }

    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliCreateIsidMAssociation                          
 *                                                                          
 *     DESCRIPTION      : This function will create a new maintenance        
 *                        association in a maintenace domain config
 *                                                                           
 *     INPUT            : Pu1MaName   - Pointer to Ma Name                   
 *                        u4Isid  - Isid which needs to associated 
 *                        with this Ma.  
 *                        i4MhfCriteria - Value indicating if MHF can be created 
 *                        for this MA       
 *                        pu1Icc - Pointer to the ICC code
 *                        pu1Umc - Pointer to the UMC code                        
 *                        
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliCreateIsidMAssociation (tCliHandle CliHandle, UINT1 *pu1MaName,
                               UINT4 u4Isid, INT4 i4MhfCriteria,
                               INT4 i4SenderIdPermission,
                               UINT1 *pu1Icc, UINT1 *pu1Umc,
                               UINT4 u4MaNameType, UINT4 u4ContextId)
{
    tSNMP_OCTET_STRING_TYPE MaName;
    tSNMP_OCTET_STRING_TYPE IccCode;
    tSNMP_OCTET_STRING_TYPE UmcCode;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaUnusedIndex = ECFM_INIT_VAL;
    UINT4               u4SavedMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetVlanId = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_FAILURE;
    UINT1               au1RetMaName[ECFM_MA_NAME_MAX_LEN + 1];

    /* Get this value from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    /* Check for the existence of the already created Association */
    i4RetVal = nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex);
    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_MAX_LEN);
        MaName.pu1_OctetList = au1RetMaName;
        MaName.i4_Length = ECFM_INIT_VAL;

        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &MaName);
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetVlanId);
        nmhGetDot1agCfmMaNetFormat (u4MdIndex, u4MaIndex, &i4RetMaFormat);

        if ((u4MdIndex == u4PromptMdIndex) &&
            (((pu1MaName != NULL) &&
              (ECFM_STRCMP (MaName.pu1_OctetList, pu1MaName) == 0)) ||
             ((i4RetMaFormat == CLI_ECFM_MA_NAME_TYPE_PRIMARY_VID) &&
              (u4RetVlanId == u4Isid))))
        {
            if (u4RetVlanId != u4Isid)
            {
                CLI_SET_ERR (CLI_ECFM_MA_EXIST_VLANID_ERR);
                return CLI_FAILURE;
            }
            /* Set Mhf criteria and/or SenderId permission */
            if ((i4MhfCriteria == 0) && (i4SenderIdPermission == 0))
            {
                CLI_SET_ERR (CLI_ECFM_MA_EXIST_ERR);
                return CLI_FAILURE;
            }
            if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode,
                                                 u4ContextId,
                                                 u4PromptMdIndex,
                                                 u4MaIndex,
                                                 ECFM_SERVICE_SELECTION_ISID,
                                                 u4Isid,
                                                 ECFM_ROW_STATUS_NOT_IN_SERVICE)
                == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                              u4PromptMdIndex,
                                              u4MaIndex,
                                              ECFM_SERVICE_SELECTION_ISID,
                                              u4Isid,
                                              ECFM_ROW_STATUS_NOT_IN_SERVICE)
                == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
            if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
                return ECFM_FAILURE;
            }

            u4SavedMaIndex = u4MaIndex;
            break;
        }
        i4RetVal = nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    if (u4SavedMaIndex == 0)
    {
        /* Create MA */
        /* Get Unused index */
        if (nmhGetDot1agCfmMdMaNextIndex
            (u4PromptMdIndex, &u4MaUnusedIndex) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_OWERFLOW_ERR);
            return CLI_FAILURE;
        }
        /* Check whether Association can be created */
        if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode,
                                             u4ContextId,
                                             u4PromptMdIndex,
                                             u4MaUnusedIndex,
                                             ECFM_SERVICE_SELECTION_ISID,
                                             u4Isid,
                                             ECFM_ROW_STATUS_CREATE_AND_WAIT) ==
            SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        /* Create Maintenance Association */
        if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          ECFM_SERVICE_SELECTION_ISID,
                                          u4Isid,
                                          ECFM_ROW_STATUS_CREATE_AND_WAIT)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        /* Set MA Name Format */
        if (nmhTestv2FsMIEcfmExtMaFormat (&u4ErrCode,
                                          u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          ECFM_SERVICE_SELECTION_ISID,
                                          u4Isid, u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          ECFM_SERVICE_SELECTION_ISID,
                                          u4Isid, ECFM_ROW_STATUS_DESTROY);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaFormat (u4ContextId, u4PromptMdIndex,
                                       u4MaUnusedIndex,
                                       ECFM_SERVICE_SELECTION_ISID,
                                       u4Isid, u4MaNameType) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                          u4PromptMdIndex,
                                          u4MaUnusedIndex,
                                          ECFM_SERVICE_SELECTION_ISID,
                                          u4Isid, ECFM_ROW_STATUS_DESTROY);
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        /* Set the MA Name */
        if (pu1MaName != NULL)
        {
            if (u4MaNameType == CLI_ECFM_MA_NAME_TYPE_PRIMARY_VID)
            {
                UINT2               u2Vid = ECFM_INIT_VAL;
                UINT1               u1NameLsb = ECFM_INIT_VAL;
                UINT1               u1NameMsb = ECFM_INIT_VAL;
                UINT1               u1Temp = ECFM_INIT_VAL;
                UINT1              *pu1TempMaName = NULL;
                pu1TempMaName = pu1MaName;
                ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL,
                             ECFM_MA_NAME_ARRAY_SIZE);
                MaName.pu1_OctetList = au1RetMaName;
                MaName.i4_Length = ECFM_INIT_VAL;
                for (u1Temp = 0; u1Temp < ECFM_STRLEN (pu1TempMaName);
                     u1Temp = u1Temp + 1)
                {
                    if (ECFM_IS_NUMBERIC (pu1TempMaName[u1Temp]) != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_MA_NAME_FORMAT_ERR);
                        nmhSetDot1agCfmMaNetRowStatus (u4PromptMdIndex,
                                                       u4MaUnusedIndex,
                                                       ECFM_ROW_STATUS_DESTROY);
                        return CLI_FAILURE;
                    }
                }
                u2Vid = (UINT2) ATOI (pu1MaName);
                u1NameLsb = (UINT1) u2Vid & ECFM_MASK_WITH_VAL_255;
                MaName.pu1_OctetList[ECFM_INDEX_ONE] = u1NameLsb;
                u1NameMsb = u2Vid >> ECFM_SHIFT_8BITS;
                MaName.pu1_OctetList[ECFM_INDEX_ZERO] = u1NameMsb;
                MaName.i4_Length = ECFM_VAL_2;
            }
            else
            {
                ECFM_MEMSET (&MaName, ECFM_INIT_VAL,
                             sizeof (tSNMP_OCTET_STRING_TYPE));
                MaName.pu1_OctetList = pu1MaName;
                MaName.i4_Length = ECFM_STRLEN (pu1MaName);
            }

            if (nmhTestv2FsMIEcfmExtMaName (&u4ErrCode, u4ContextId,
                                            u4PromptMdIndex,
                                            u4MaUnusedIndex,
                                            ECFM_SERVICE_SELECTION_ISID,
                                            u4Isid, &MaName) == SNMP_FAILURE)
            {
                nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                              u4PromptMdIndex,
                                              u4MaUnusedIndex,
                                              ECFM_SERVICE_SELECTION_ISID,
                                              u4Isid, ECFM_ROW_STATUS_DESTROY);
                return CLI_FAILURE;
            }
            if (nmhSetFsMIEcfmExtMaName (u4ContextId,
                                         u4PromptMdIndex,
                                         u4MaUnusedIndex,
                                         ECFM_SERVICE_SELECTION_ISID,
                                         u4Isid, &MaName) == SNMP_FAILURE)
            {

                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
        }
/*
        if (nmhTestv2FsMIEcfmExtMaPrimarySelectorType (&u4ErrCode,
                                     u4ContextId,
                                   u4PromptMdIndex,
                                   u4MaUnusedIndex,
                                    ECFM_SERVICE_SELECTION_ISID,
                                   u4Isid,
                                   ECFM_SERVICE_SELECTION_ISID) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                        u4PromptMdIndex, 
                                        u4MaUnusedIndex,
                                        ECFM_SERVICE_SELECTION_ISID,
                                        u4Isid,
                                        ECFM_ROW_STATUS_DESTROY);            
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaPrimarySelectorType (u4ContextId,
                                u4PromptMdIndex, 
                                u4MaUnusedIndex,
                                ECFM_SERVICE_SELECTION_ISID,
                                u4Isid,
                                ECFM_SERVICE_SELECTION_ISID) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                    u4PromptMdIndex, 
                    u4MaUnusedIndex,
                    ECFM_SERVICE_SELECTION_ISID,
                    u4Isid,
                    ECFM_ROW_STATUS_DESTROY);            
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMaPrimarySelectorOrNone (&u4ErrCode,
                                     u4ContextId,
                                   u4PromptMdIndex,
                                   u4MaUnusedIndex,
                                    ECFM_SERVICE_SELECTION_ISID,
                                   u4Isid,
                                   u4Isid) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                        u4PromptMdIndex, 
                                        u4MaUnusedIndex,
                                        ECFM_SERVICE_SELECTION_ISID,
                                        u4Isid,
                                        ECFM_ROW_STATUS_DESTROY);            
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaPrimarySelectorOrNone (u4ContextId,
                                u4PromptMdIndex, 
                                u4MaUnusedIndex,
                                ECFM_SERVICE_SELECTION_ISID,
                                u4Isid,
                                u4Isid) == SNMP_FAILURE)
        {
            nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                    u4PromptMdIndex, 
                    u4MaUnusedIndex,
                    ECFM_SERVICE_SELECTION_ISID,
                    u4Isid,
                    ECFM_ROW_STATUS_DESTROY);            
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }*/

        u4SavedMaIndex = u4MaUnusedIndex;
    }
    /* Set Mhf criteria */
    if (i4MhfCriteria != -1)
    {
        if (nmhTestv2FsMIEcfmExtMaMhfCreation (&u4ErrCode,
                                               u4ContextId,
                                               u4PromptMdIndex,
                                               u4SavedMaIndex,
                                               ECFM_SERVICE_SELECTION_ISID,
                                               u4Isid,
                                               i4MhfCriteria) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_MHF_CRITERIA_CONF_ERR);
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMaMhfCreation (u4ContextId,
                                            u4PromptMdIndex,
                                            u4SavedMaIndex,
                                            ECFM_SERVICE_SELECTION_ISID,
                                            u4Isid,
                                            i4MhfCriteria) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }
    /* Set sender id permission */
    if (i4SenderIdPermission != -1)
    {
        if (nmhTestv2FsMIEcfmExtMaIdPermission (&u4ErrCode, u4ContextId,
                                                u4PromptMdIndex,
                                                u4SavedMaIndex,
                                                ECFM_SERVICE_SELECTION_ISID,
                                                u4Isid,
                                                i4SenderIdPermission) ==
            SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_SENDER_ID_CONF_ERR);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIEcfmExtMaIdPermission (u4ContextId, u4PromptMdIndex,
                                             u4SavedMaIndex,
                                             ECFM_SERVICE_SELECTION_ISID,
                                             u4Isid,
                                             i4SenderIdPermission)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    /* Now make this row status to active */
    if (nmhTestv2FsMIEcfmExtMaRowStatus (&u4ErrCode, u4ContextId,
                                         u4PromptMdIndex,
                                         u4SavedMaIndex,
                                         ECFM_SERVICE_SELECTION_ISID,
                                         u4Isid,
                                         ECFM_ROW_STATUS_ACTIVE) ==
        SNMP_FAILURE)
    {
        nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                      u4PromptMdIndex,
                                      u4SavedMaIndex,
                                      ECFM_SERVICE_SELECTION_ISID,
                                      u4Isid, ECFM_ROW_STATUS_DESTROY);
        return CLI_FAILURE;
    }
    if (nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                      u4PromptMdIndex,
                                      u4SavedMaIndex,
                                      ECFM_SERVICE_SELECTION_ISID,
                                      u4Isid,
                                      ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
    {
        nmhSetFsMIEcfmExtMaRowStatus (u4ContextId,
                                      u4PromptMdIndex,
                                      u4SavedMaIndex,
                                      ECFM_SERVICE_SELECTION_ISID,
                                      u4Isid, ECFM_ROW_STATUS_DESTROY);
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }

    /* Y.1731 : Setting ICC and UMC code */
    if ((pu1Icc != NULL) && (pu1Umc != NULL))
    {
        /* Make the row status to not-in-service */
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        ECFM_MEMSET (&IccCode, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        IccCode.pu1_OctetList = pu1Icc;
        IccCode.i4_Length = ECFM_STRLEN (pu1Icc);
        if (nmhTestv2FsMIY1731MeMegIdIcc (&u4ErrCode, u4ContextId,
                                          u4PromptMdIndex,
                                          u4SavedMaIndex,
                                          &IccCode) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_ICC_CONF_ERR);
            return CLI_FAILURE;
        }
        ECFM_MEMSET (&UmcCode, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
        UmcCode.pu1_OctetList = pu1Umc;
        UmcCode.i4_Length = ECFM_STRLEN (pu1Umc);
        if (nmhTestv2FsMIY1731MeMegIdUmc (&u4ErrCode, u4ContextId,
                                          u4PromptMdIndex,
                                          u4SavedMaIndex,
                                          &UmcCode) == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_UMC_CONF_ERR);
            return CLI_FAILURE;
        }

        if (nmhSetFsMIY1731MeMegIdIcc
            (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             &IccCode) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeMegIdUmc
            (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             &UmcCode) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        /* Make the row status to Active */
        if (nmhTestv2FsMIY1731MeRowStatus
            (&u4ErrCode, u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }
        if (nmhSetFsMIY1731MeRowStatus
            (u4ContextId, u4PromptMdIndex, u4SavedMaIndex,
             ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliConfigIsidMip                           
 *                                                                          
 *     DESCRIPTION      : This function will create/activate Mip. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        i4MdLevel  - MdLevel                     
 *                        i4Isid  - Isid
 *                        u4PortNum - port number
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliConfigIsidMip (tCliHandle CliHandle, UINT4 u4Type,
                      UINT4 u4ContextId, INT4 i4MdLevel,
                      INT4 i4Isid, UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4RetMipstatus = ECFM_INIT_VAL;
    INT4                i4SelectorType = ECFM_SERVICE_SELECTION_ISID;
    UINT4               u4IfIndex = ECFM_INIT_VAL;

    /* Get interface index from local port */
    if (ECFM_GET_IFINDEX_FROM_LOCAL_PORT (u4ContextId,
                                          u4PortNum,
                                          &u4IfIndex) == ECFM_FAILURE)
    {
        return CLI_FAILURE;
    }
    u4PortNum = u4IfIndex;

    /* Check if Mip exists */
    if (nmhGetFsMIEcfmExtMipRowStatus (u4PortNum,
                                       i4MdLevel,
                                       i4SelectorType,
                                       i4Isid, &i4RetRowStatus) != SNMP_FAILURE)
    {
        /*MIP creation and active scenario */
        /* User wants to create MIP but MIP already exists */
        if ((u4Type == CLI_ECFM_CONFIG_MIP_LEV_ISID) ||
            (u4Type == CLI_ECFM_CONFIG_MIP_DOM_ISID))
        {
            CLI_SET_ERR (CLI_ECFM_MIP_CONFIG_EXIST_ERR);
            return CLI_FAILURE;
        }

        /* Check if it is already active */
        nmhGetFsMIEcfmExtMipActive (u4PortNum,
                                    i4MdLevel, i4SelectorType,
                                    i4Isid, &i4RetMipstatus);

        if (i4RetMipstatus == ECFM_SNMP_TRUE)
        {
            /* Already active */
            CLI_SET_ERR (CLI_ECFM_MIP_CONFIG_EXIST_ERR);
            return CLI_FAILURE;
        }

        /* If MIP exists is disabled and user wants to make it Active */
        if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                              u4PortNum,
                                              i4MdLevel, i4SelectorType,
                                              i4Isid,
                                              ECFM_ROW_STATUS_NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum, i4MdLevel,
                                           i4SelectorType, i4Isid,
                                           ECFM_ROW_STATUS_NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMipActive (&u4ErrorCode,
                                           u4PortNum, i4MdLevel,
                                           i4SelectorType, i4Isid,
                                           ECFM_SNMP_TRUE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipActive (u4PortNum,
                                        i4MdLevel, i4SelectorType,
                                        i4Isid, ECFM_SNMP_TRUE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                              u4PortNum, i4MdLevel,
                                              i4SelectorType, i4Isid,
                                              ECFM_ROW_STATUS_ACTIVE) ==
            SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum, i4MdLevel,
                                           i4SelectorType, i4Isid,
                                           ECFM_ROW_STATUS_ACTIVE) ==
            SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }
        /* MIP is enabled/active now */
        return CLI_SUCCESS;
    }
    /* User wants to create MIP */
    if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                          u4PortNum, i4MdLevel,
                                          i4SelectorType, i4Isid,
                                          ECFM_ROW_STATUS_CREATE_AND_GO)
        == SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum, i4MdLevel,
                                       i4SelectorType, i4Isid,
                                       ECFM_ROW_STATUS_CREATE_AND_GO)
        == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }

    /* MIP is created */
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliDeleteIsidMip                           
 *                                                                          
 *     DESCRIPTION      : This function will delete/deactivate Mip. 
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type - Command type 
 *                          u4ContextId - Context Id
 *                        i4MdLevel  - MdLevel                     
 *                        i4Isid  - Isid
 *                        u4PortNum - Port Number
 *                                                                          
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliDeleteIsidMip (tCliHandle CliHandle, UINT4 u4Type,
                      UINT4 u4ContextId, INT4 i4MdLevel,
                      INT4 i4Isid, UINT4 u4PortNum)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    INT4                i4RetRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4SelectorType = ECFM_SERVICE_SELECTION_ISID;
    INT4                i4IsActive = ECFM_INIT_VAL;
    UINT4               u4IfIndex = ECFM_INIT_VAL;

    /* Get interface index from local port */
    if (ECFM_GET_IFINDEX_FROM_LOCAL_PORT (u4ContextId,
                                          u4PortNum,
                                          &u4IfIndex) == ECFM_FAILURE)
    {
        return CLI_FAILURE;
    }
    u4PortNum = u4IfIndex;
    /* If there any Mip exists */
    if (nmhGetFsMIEcfmExtMipRowStatus (u4PortNum,
                                       i4MdLevel, i4SelectorType,
                                       i4Isid, &i4RetRowStatus) != SNMP_SUCCESS)
    {
        CLI_SET_ERR (CLI_ECFM_MIP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    i4IsActive =
        ((u4Type == CLI_ECFM_DELETE_MIP_LEV_ISID)
         || (u4Type ==
             CLI_ECFM_DELETE_MIP_DOM_ISID)) ? ECFM_SNMP_TRUE : ECFM_SNMP_FALSE;

    /* If Mip exists and user wants to make it de-active */
    if (i4IsActive == ECFM_SNMP_FALSE)
    {
        if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                              u4PortNum, i4MdLevel,
                                              i4SelectorType, i4Isid,
                                              ECFM_ROW_STATUS_NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum,
                                           i4MdLevel, i4SelectorType,
                                           i4Isid,
                                           ECFM_ROW_STATUS_NOT_IN_SERVICE)
            == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMipActive (&u4ErrorCode,
                                           u4PortNum, i4MdLevel,
                                           i4SelectorType, i4Isid,
                                           ECFM_SNMP_FALSE) == SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipActive (u4PortNum,
                                        i4MdLevel, i4SelectorType,
                                        i4Isid,
                                        ECFM_SNMP_FALSE) == SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                              u4PortNum, i4MdLevel,
                                              i4SelectorType, i4Isid,
                                              ECFM_ROW_STATUS_ACTIVE) ==
            SNMP_FAILURE)
        {
            return CLI_FAILURE;
        }

        if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum,
                                           i4MdLevel, i4SelectorType,
                                           i4Isid,
                                           ECFM_ROW_STATUS_ACTIVE) ==
            SNMP_FAILURE)
        {
            CLI_FATAL_ERROR (CliHandle);
            return CLI_FAILURE;
        }

        return CLI_SUCCESS;
    }

    /* If Mip exists and user wants to delete it */
    if (nmhTestv2FsMIEcfmExtMipRowStatus (&u4ErrorCode,
                                          u4PortNum, i4MdLevel,
                                          i4SelectorType, i4Isid,
                                          ECFM_ROW_STATUS_DESTROY) ==
        SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }

    if (nmhSetFsMIEcfmExtMipRowStatus (u4PortNum,
                                       i4MdLevel, i4SelectorType,
                                       i4Isid,
                                       ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
    {
        CLI_FATAL_ERROR (CliHandle);
        return CLI_FAILURE;
    }
    if (ECFM_CC_SELECT_CONTEXT (u4ContextId) != ECFM_SUCCESS)
    {
        CliPrintf (CliHandle, "\r%% Invalid Virtual Switch.\r\n ");
        return ECFM_FAILURE;
    }

    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigPbbMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database config 
 *                        mode. New Mep will be created when that mep is not 
 *                        present at that level and vlan in the database 
 *                                                                           
 *     INPUT            : u1MdLevel   - level at which it needs to be created
 *                        Direction   - up/down                              
 *                        u4MepId     - MepIdentifier                        
 *                        i1MepActiveStatus - its active status after        
 *                        creation
 *                        u4PortNum - Port Number
 *
 *     OUTPUT           : None                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigPbbMep (tCliHandle CliHandle, UINT4 u4Type,
                     UINT1 u1MdLevel, INT1 i1MepDirection,
                     UINT4 u4ContextId, UINT4 u4MepIdentifier,
                     INT1 i1MepActiveStatus, UINT4 u4PortNum)
{
    tEcfmCcPortInfo    *pPortInfo = NULL;
    UINT1              *pIfFwdPortList = NULL;
    UINT4               u4Isid;
    UINT2               u2ByteInd = ECFM_INIT_VAL;
    UINT2               u2BitIndex = ECFM_INIT_VAL;
    UINT2               u2Port = ECFM_INIT_VAL;
    UINT1               u1PortFlag = ECFM_INIT_VAL;
    UINT1               u1ValidPortFlag = OSIX_FALSE;

    pIfFwdPortList = UtilPlstAllocLocalPortList (sizeof (tLocalPortListExt));

    if (pIfFwdPortList == NULL)
    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC | ECFM_CONTROL_PLANE_TRC,
                     "EcfmCliConfigPbbMep: Error in allocating memory "
                     "for pIfFwdPortList\r\n");
        return ECFM_FAILURE;
    }
    CLI_MEMSET (pIfFwdPortList, 0, sizeof (tLocalPortListExt));

    UNUSED_PARAM (u4PortNum);

    u4Isid = CLI_GET_ISID ();

    if (EcfmPbbGetMemberPortsForIsid
        (u4ContextId, u4Isid, pIfFwdPortList) != ECFM_SUCCESS)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        UtilPlstReleaseLocalPortList (pIfFwdPortList);
        return CLI_FAILURE;
    }

    for (u2ByteInd = ECFM_INIT_VAL; u2ByteInd < ECFM_PORT_LIST_SIZE;
         u2ByteInd++)
    {
        if (pIfFwdPortList[u2ByteInd] == 0)
        {
            continue;
        }
        u1PortFlag = pIfFwdPortList[u2ByteInd];
        for (u2BitIndex = 0;
             ((u2BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex) != 0));
             u2BitIndex++)
        {
            u2Port =
                (UINT2) ((u2ByteInd * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex));
            /*Reset the port info */
            pPortInfo = NULL;
            /*Get the port info */
            pPortInfo = ECFM_CC_GET_PORT_INFO (u2Port);
            if (pPortInfo != NULL)
            {

                if (EcfmCliConfigIsidMep
                    (CliHandle, u4Type, u1MdLevel, i1MepDirection,
                     u4ContextId, u4Isid, u4MepIdentifier,
                     i1MepActiveStatus, u2Port, NULL) == CLI_FAILURE)
                {
                    UtilPlstReleaseLocalPortList (pIfFwdPortList);
                    return CLI_FAILURE;
                }
                u1ValidPortFlag = OSIX_TRUE;
            }
        }
    }
    UtilPlstReleaseLocalPortList (pIfFwdPortList);
    if (u1ValidPortFlag == OSIX_FALSE)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteOrDisablePbbMep                 
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mep database         
 *                        Delete or disable the configured Mep, if present. 
 *
 *     INPUT            : u1MdLevel  -  MdLevel 
 *                        u4Type     -   Type of the command(Disable or delete)
 *                        u4MepIdentifier  - MepIdentifier                       
 *                        u4PortNum - Port Number
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliDeleteOrDisablePbbMep (tCliHandle CliHandle, UINT4 u4Type,
                              UINT4 u4MdLevel,
                              UINT4 u4MepIdentifier, UINT4 u4PortNum)
{
    tEcfmCcPortInfo    *pPortInfo = NULL;
    UINT1              *pIfFwdPortList = NULL;
    UINT4               u4Isid;
    UINT2               u2ByteInd = ECFM_INIT_VAL;
    UINT2               u2BitIndex = ECFM_INIT_VAL;
    UINT2               u2Port = ECFM_INIT_VAL;
    UINT1               u1PortFlag = ECFM_INIT_VAL;
    UINT1               u1ValidPortFlag = OSIX_FALSE;
    UINT4               u4ContextId;

    pIfFwdPortList = UtilPlstAllocLocalPortList (sizeof (tLocalPortListExt));

    if (pIfFwdPortList == NULL)
    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC | ECFM_CONTROL_PLANE_TRC,
                     "EcfmCliDeleteOrDisablePbbMep: Error in allocating memory "
                     "for pIfFwdPortList\r\n");
        return ECFM_FAILURE;
    }
    CLI_MEMSET (pIfFwdPortList, 0, sizeof (tLocalPortListExt));

    UNUSED_PARAM (u4PortNum);

    u4Isid = CLI_GET_ISID ();
    u4ContextId = ECFM_CC_CURR_CONTEXT_ID ();

    if (EcfmPbbGetMemberPortsForIsid
        (u4ContextId, u4Isid, pIfFwdPortList) != ECFM_SUCCESS)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        UtilPlstReleaseLocalPortList (pIfFwdPortList);
        return CLI_FAILURE;
    }

    for (u2ByteInd = ECFM_INIT_VAL; u2ByteInd < ECFM_PORT_LIST_SIZE;
         u2ByteInd++)
    {
        if (pIfFwdPortList[u2ByteInd] == 0)
        {
            continue;
        }
        u1PortFlag = pIfFwdPortList[u2ByteInd];
        for (u2BitIndex = 0;
             ((u2BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex) != 0));
             u2BitIndex++)
        {
            u2Port =
                (UINT2) ((u2ByteInd * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex));
            /*Reset the port info */
            pPortInfo = NULL;
            /*Get the port info */
            pPortInfo = ECFM_CC_GET_PORT_INFO (u2Port);
            if (pPortInfo != NULL)
            {
                if (EcfmCliDeleteOrDisableIsidMep
                    (CliHandle, u4Type, u4ContextId, u4MdLevel,
                     &u4Isid, u4MepIdentifier, u2Port) == CLI_FAILURE)
                {
                    UtilPlstReleaseLocalPortList (pIfFwdPortList);
                    return CLI_FAILURE;
                }
                u1ValidPortFlag = OSIX_TRUE;
            }
        }
    }
    UtilPlstReleaseLocalPortList (pIfFwdPortList);
    if (u1ValidPortFlag == OSIX_FALSE)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;

}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigPbbMip                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mip database config 
 *                        mode. New Mip will be created when that mip is not 
 *                        present at that level and vlan in the database 
 *                                                                           
 *     INPUT            : u1MdLevel   - level at which it needs to be created
 *                        i1MipActiveStatus - its active status after        
 *                        creation
 *                        u4PortNum - Port Number
 *
 *     OUTPUT           : None                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigPbbMip (tCliHandle CliHandle, UINT4 u4Type,
                     UINT4 u4ContextId, UINT1 u1MdLevel, UINT4 u4PortNum)
{
    tEcfmCcPortInfo    *pPortInfo = NULL;
    UINT1              *pIfFwdPortList = NULL;
    UINT4               u4Isid;
    UINT2               u2ByteInd = ECFM_INIT_VAL;
    UINT2               u2BitIndex = ECFM_INIT_VAL;
    UINT2               u2Port = ECFM_INIT_VAL;
    UINT1               u1PortFlag = ECFM_INIT_VAL;
    UINT1               u1ValidPortFlag = OSIX_FALSE;

    UNUSED_PARAM (u4PortNum);

    u4Isid = CLI_GET_ISID ();
    pIfFwdPortList = UtilPlstAllocLocalPortList (sizeof (tLocalPortListExt));

    if (pIfFwdPortList == NULL)
    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC | ECFM_CONTROL_PLANE_TRC,
                     "EcfmCliConfigPbbMip: Error in allocating memory "
                     "for pIfFwdPortList\r\n");
        return ECFM_FAILURE;
    }

    CLI_MEMSET (pIfFwdPortList, 0, sizeof (tLocalPortListExt));

    if (EcfmPbbGetMemberPortsForIsid
        (u4ContextId, u4Isid, pIfFwdPortList) != ECFM_SUCCESS)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_MIP_CONFIG_ERR);
        return CLI_FAILURE;
    }

    for (u2ByteInd = ECFM_INIT_VAL; u2ByteInd < ECFM_PORT_LIST_SIZE;
         u2ByteInd++)
    {
        if (pIfFwdPortList[u2ByteInd] == 0)
        {
            continue;
        }
        u1PortFlag = pIfFwdPortList[u2ByteInd];
        for (u2BitIndex = 0;
             ((u2BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex) != 0));
             u2BitIndex++)
        {
            u2Port =
                (UINT2) ((u2ByteInd * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex));
            /*Reset the port info */
            pPortInfo = NULL;
            /*Get the port info */
            pPortInfo = ECFM_CC_GET_PORT_INFO (u2Port);
            if (pPortInfo != NULL)
            {
                if (EcfmCliConfigIsidMip (CliHandle, u4Type,
                                          u4ContextId, u1MdLevel,
                                          u4Isid, u2Port) == CLI_FAILURE)
                {
                    UtilPlstReleaseLocalPortList (pIfFwdPortList);
                    return CLI_FAILURE;
                }
                u1ValidPortFlag = OSIX_TRUE;
            }
        }
    }
    UtilPlstReleaseLocalPortList (pIfFwdPortList);
    if (u1ValidPortFlag == OSIX_FALSE)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_MIP_CONFIG_ERR);
        UtilPlstReleaseLocalPortList (pIfFwdPortList);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteOrDisablePbbMip                 
 *                                                                           
 *     DESCRIPTION      : This function will enter into Mip database         
 *                        Delete or disable the configured Mip, if present. 
 *
 *     INPUT            : u1MdLevel  -  MdLevel 
 *                        u4Type     -   Type of the command(Disable or delete)
 *                        u4PortNum - Port Number
 *                                                                           
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliDeleteOrDisablePbbMip (tCliHandle CliHandle, UINT4 u4Type,
                              UINT4 u4MdLevel, UINT4 u4PortNum)
{
    tEcfmCcPortInfo    *pPortInfo = NULL;
    UINT1              *pIfFwdPortList = NULL;
    UINT4               u4Isid;
    UINT2               u2ByteInd = ECFM_INIT_VAL;
    UINT2               u2BitIndex = ECFM_INIT_VAL;
    UINT2               u2Port = ECFM_INIT_VAL;
    UINT1               u1PortFlag = ECFM_INIT_VAL;
    UINT1               u1ValidPortFlag = OSIX_FALSE;
    UINT4               u4ContextId;

    pIfFwdPortList = UtilPlstAllocLocalPortList (sizeof (tLocalPortListExt));

    if (pIfFwdPortList == NULL)
    {
        ECFM_CC_TRC (ECFM_ALL_FAILURE_TRC | ECFM_CONTROL_PLANE_TRC,
                     "EcfmCliDeleteOrDisablePbbMip: Error in allocating memory "
                     "for pIfFwdPortList\r\n");
        return ECFM_FAILURE;
    }
    CLI_MEMSET (pIfFwdPortList, 0, sizeof (tLocalPortListExt));

    UNUSED_PARAM (u4PortNum);

    u4Isid = CLI_GET_ISID ();
    u4ContextId = ECFM_CC_CURR_CONTEXT_ID ();

    if (EcfmPbbGetMemberPortsForIsid
        (u4ContextId, u4Isid, pIfFwdPortList) != ECFM_SUCCESS)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        UtilPlstReleaseLocalPortList (pIfFwdPortList);
        return CLI_FAILURE;
    }

    for (u2ByteInd = ECFM_INIT_VAL; u2ByteInd < ECFM_PORT_LIST_SIZE;
         u2ByteInd++)
    {
        if (pIfFwdPortList[u2ByteInd] == 0)
        {
            continue;
        }
        u1PortFlag = pIfFwdPortList[u2ByteInd];
        for (u2BitIndex = 0;
             ((u2BitIndex < BITS_PER_BYTE)
              && (EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex) != 0));
             u2BitIndex++)
        {
            u2Port =
                (UINT2) ((u2ByteInd * BITS_PER_BYTE) +
                         EcfmUtilQueryBitListTable (u1PortFlag, u2BitIndex));
            /*Reset the port info */
            pPortInfo = NULL;
            /*Get the port info */
            pPortInfo = ECFM_CC_GET_PORT_INFO (u2Port);
            if (pPortInfo != NULL)
            {
                if (EcfmCliDeleteIsidMip
                    (CliHandle, u4Type, u4ContextId, u4MdLevel,
                     u4Isid, u2Port) == CLI_FAILURE)
                {
                    UtilPlstReleaseLocalPortList (pIfFwdPortList);
                    return CLI_FAILURE;
                }
                u1ValidPortFlag = OSIX_TRUE;
            }
        }
    }
    UtilPlstReleaseLocalPortList (pIfFwdPortList);
    if (u1ValidPortFlag == OSIX_FALSE)
    {
        CLI_SET_ERR (CLI_ECFM_ISID_PORT_CONFIG_ERR);
        return CLI_FAILURE;
    }
    return CLI_SUCCESS;

}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliConfigIsidRemoteMep                                   
 *                                                                           
 *     DESCRIPTION      : This function will enter into MaMepList database config 
 *                        mode. New Static remote Mep will be associated with an
 *                        MA, if any MEP with same MEP Id does not exists.
 *                                                                           
 *     INPUT            : u4MepId     - MepIdentifier
 *                        u4Isid    - IsId
 *
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                            
 *                                                                           
 ******************************************************************************/
INT4
EcfmCliConfigIsidRemoteMep (tCliHandle CliHandle,
                            UINT4 u4MepIdentifier, UINT4 u4Isid,
                            UINT1 *pu1MaName)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4RetPrimaryVlanId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetRowStatus = ECFM_INIT_VAL;
    UINT4               u4IsidIntr = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    tSNMP_OCTET_STRING_TYPE RetMaName;
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    u4IsidIntr = ECFM_ISID_TO_ISID_INTERNAL (u4Isid);

    if (nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex) ==
        SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return CLI_FAILURE;
    }
    /* Get MdIndex from config prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    /* Scan Ma table for VlanId */
    while (i4RetVal == SNMP_SUCCESS)
    {
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetPrimaryVlanId);
        nmhGetDot1agCfmMaNetRowStatus (u4MdIndex, u4MaIndex, &i4RetRowStatus);
        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);

        /* Check if this is the required Ma entry */
        if ((u4PromptMdIndex == u4MdIndex) &&
            (i4RetRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
            (u4RetPrimaryVlanId == u4IsidIntr) &&
            (pu1MaName == NULL ||
             ECFM_STRCMP (RetMaName.pu1_OctetList, pu1MaName) == 0))
        {
            /* Required MA Entry found */
            /* Check if MepList entry creation is possible */
            if (nmhTestv2Dot1agCfmMaMepListRowStatus
                (&u4ErrorCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_ROW_STATUS_CREATE_AND_GO) == SNMP_FAILURE)
            {
                return CLI_FAILURE;
            }
            /* Create MepList Entry */
            if (nmhSetDot1agCfmMaMepListRowStatus (u4MdIndex,
                                                   u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_CREATE_AND_GO)
                == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
            /* Mep List entry creation successful */
            return CLI_SUCCESS;
        }
        /* move to next MA */
        i4RetVal =
            nmhGetNextIndexDot1agCfmMaNetTable (u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    /* No such MA entry exists */
    CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_VLAN_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmCliDeleteIsidRemoteMep                        
 *                                                                           
 *     DESCRIPTION      : This function deletes remote MEP   
 *                                                                           
 *     INPUT            : u4MepIdentifier - u4MepIdentifier of Remote MEP
 *                        u4Isid -        Isid       
 *                        
 *                                                                          
 *     OUTPUT           : CliHandle - Contains error messages                
 *                                                                           
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                         
 ******************************************************************************/
INT4
EcfmCliDeleteIsidRemoteMep (tCliHandle CliHandle,
                            UINT4 u4MepIdentifier, UINT4 u4Isid,
                            UINT1 *pu1MaName)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4ErrCode = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4PromptMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    UINT4               u4IsidIntr = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    u4IsidIntr = ECFM_ISID_TO_ISID_INTERNAL (u4Isid);

    /*Get first index */
    i4RetVal = nmhGetFirstIndexDot1agCfmMaNetTable (&u4MdIndex, &u4MaIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_RMEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    /*Get Md Index out of prompt */
    u4PromptMdIndex = CLI_GET_MDINDEX ();

    while (i4RetVal == SNMP_SUCCESS)
    {
        /* Get u4MaIndex's name */
        nmhGetIeee8021CfmMaCompPrimarySelectorOrNone (ECFM_CC_CURR_CONTEXT_ID
                                                      (), u4MdIndex, u4MaIndex,
                                                      &u4RetMaPrimaryVid);

        nmhGetDot1agCfmMaNetName (u4MdIndex, u4MaIndex, &RetMaName);
        /* Check if this is the required association */
        if ((u4RetMaPrimaryVid == u4IsidIntr) &&
            (u4MdIndex == u4PromptMdIndex) &&
            (pu1MaName == NULL ||
             ECFM_STRCMP (RetMaName.pu1_OctetList, pu1MaName) == 0))
        {
            /*That particular entry found */
            /* Now make this row status to DESTROY */
            if (nmhTestv2Dot1agCfmMaMepListRowStatus
                (&u4ErrCode, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_ROW_STATUS_DESTROY) == SNMP_FAILURE)
            {
                CLI_SET_ERR (CLI_ECFM_RMEP_NOT_PRESENT_ERR);
                return CLI_FAILURE;
            }
            if (nmhSetDot1agCfmMaMepListRowStatus (u4MdIndex, u4MaIndex,
                                                   u4MepIdentifier,
                                                   ECFM_ROW_STATUS_DESTROY)
                == SNMP_FAILURE)
            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
            /* Remote MEP deleted successfully */
            return CLI_SUCCESS;
        }
        /* Get next index */
        i4RetVal = nmhGetNextIndexDot1agCfmMaNetTable
            (u4MdIndex, &u4NextMdIndex, u4MaIndex, &u4NextMaIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    CLI_SET_ERR (CLI_ECFM_RMEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 *                                                                           
 *     FUNCTION NAME    : EcfmSearchMepIdInMA                        
 *                                                                           
 *     DESCRIPTION      : This function searches the MEPID in the MA provided by
 *                        the user, returns TRUE if entry found else FALSE.
 *                                                                           
 *     INPUT            : u4MdIndex - Md Index of the MA
 *                        u4MaIndex - Ma Index       
 *                        u4MepId   - MEPID of the MEP which is to be created
 *                                                                          
 *     OUTPUT           : None                
 *                                                                           
 *     RETURNS          : ECFM_TRUE/ECFM_FALSE                           
 *                                                                         
 ******************************************************************************/
PRIVATE INT4
EcfmSearchMepIdInMA (UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepId)
{
    INT4                i4RetVal = SNMP_FAILURE;
    UINT4               u4CurrMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4CurrMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4CurrMaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;

    i4RetVal = nmhGetNextIndexDot1agCfmMaMepListTable (0, &u4CurrMdIndex,
                                                       0, &u4CurrMaIndex,
                                                       0,
                                                       &u4CurrMaMepListIndex);
    /* MaTable not empty, now scan its each row */
    while (i4RetVal == SNMP_SUCCESS)
    {
        if ((u4CurrMdIndex == u4MdIndex) &&
            (u4CurrMaIndex == u4MaIndex) && (u4CurrMaMepListIndex == u4MepId))
        {
            /* Required MEPID found for a MA */
            return ECFM_TRUE;
        }

        i4RetVal = nmhGetNextIndexDot1agCfmMaMepListTable (u4CurrMdIndex,
                                                           &u4NextMdIndex,
                                                           u4CurrMaIndex,
                                                           &u4NextMaIndex,
                                                           u4CurrMaMepListIndex,
                                                           &u4NextMaMepListIndex);

        if (i4RetVal == SNMP_SUCCESS)
        {
            u4CurrMdIndex = u4NextMdIndex;
            u4CurrMaIndex = u4NextMaIndex;
            u4CurrMaMepListIndex = u4NextMaMepListIndex;
        }
    }
    return ECFM_FALSE;
}

INT4
EcfmCliSetXcheckIsidEnableStatus (tCliHandle CliHandle, UINT4 u4ContextId,
                                  UINT4 u4Type, UINT1 au1MdLevel[],
                                  UINT2 u2NoOfMdLevels, UINT1 *pu1ArgIsid,
                                  UINT1 *pu1MdName)
{
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4XchkStatus = ECFM_INIT_VAL;
    UINT4               u4Isid = ECFM_INIT_VAL;
    UINT4               u4ByteIndex = ECFM_INIT_VAL;
    UINT1               u1LevelCounter = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1LevelVlanList[ECFM_MD_LEVEL_MAX + 1];
    UINT1               u1LevelList = ECFM_INIT_VAL;
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE] = { 0 };
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMdName;

    ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    RetMdName.pu1_OctetList = au1RetMdName;
    RetMdName.i4_Length = ECFM_INIT_VAL;

    /* Allocating memory of ECFM_VLAN_LIST_SIZE = 512 */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        apu1LevelVlanList[u1LevelCounter] = UtilVlanAllocVlanListSize
            (sizeof (tVlanListExt));
        if (apu1LevelVlanList[u1LevelCounter] != NULL)
        {
            ECFM_MEMSET (apu1LevelVlanList[u1LevelCounter], ECFM_VAL_0,
                         sizeof (tVlanListExt));
        }
        else
        {
            /* Releasing allocated memory of LevelVlanList */
            for (u1LevelList = 0; u1LevelList < u1LevelCounter; u1LevelList++)
            {
                UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelList]);
            }
            CliPrintf (CliHandle, "\r%% Error in Allocating memory "
                       "for Vlan List Size\r\n");
            return CLI_FAILURE;
        }
    }
    u4Isid = *(UINT4 *) (VOID *) pu1ArgIsid;
    i4CurrentContextId = (INT4) (u4ContextId);
    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)
    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
        }
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        /* Releasing memory for Vlan List Size */
        for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
             u1LevelCounter++)
        {
            UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
        }
        CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if ((u4Type == CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) ||
        (u4Type == CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_DOM_VLAN_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_DOM_SER_XCHKING) ||
        (u4Type == CLI_ECFM_ENABLE_LEV_VLAN_XCHKING))
    {
        i4XchkStatus = ECFM_ENABLE;
    }
    else
    {
        i4XchkStatus = ECFM_DISABLE;
    }
    for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels; u1LevelCounter++)
    {
        ECFM_SET_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);
        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                       u4MaIndex, (INT4 *) &u4RetMaPrimaryVid);
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        nmhGetFsMIEcfmMdName (u4ContextId, u4MdIndex, &RetMdName);
        RetMdName.pu1_OctetList[RetMdName.i4_Length] = '\0';
        nmhGetFsMIEcfmMdFormat (u4ContextId, u4MdIndex, &i4RetMdFormat);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);
        if (i4RetMaRowStatus != ECFM_ROW_STATUS_ACTIVE)
        {
            if (nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                (UINT4 *) &i4NextContextId,
                                                u4MdIndex, &u4NextMdIndex,
                                                u4MaIndex,
                                                &u4NextMaIndex) == SNMP_SUCCESS)
            {
                i4RetVal = SNMP_SUCCESS;
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
                if (i4CurrentContextId != i4NextContextId)
                {
                    b1SameContext = ECFM_FALSE;
                }
                continue;
            }
            break;
        }
        for (u1LevelCounter = 0; u1LevelCounter < u2NoOfMdLevels;
             u1LevelCounter++)
        {
            if ((u4RetMdLevel == au1MdLevel[u1LevelCounter]) &&
                ((pu1MdName == NULL) ||
                 (STRCMP (au1StrMdName, pu1MdName) == 0)))
            {
                if ((u4Type != CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_DOM_UNAWARE_DISABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) &&
                    (u4Type != CLI_ECFM_LEV_UNAWARE_DISABLE_XCHKING))
                {
                    if (u4RetMaPrimaryVid == u4Isid)
                    {
                        ECFM_RESET_LIST_MEMBER
                            (apu1LevelVlanList
                             [au1MdLevel[u1LevelCounter]], u4RetMaPrimaryVid);
                        nmhSetFsMIEcfmMaCrosscheckStatus
                            (i4CurrentContextId, u4MdIndex,
                             u4MaIndex, i4XchkStatus);
                        break;
                    }
                    break;
                }
                else if (u4RetMaPrimaryVid == 0)
                {
                    ECFM_CLEAR_U1BIT (u1LevelList, au1MdLevel[u1LevelCounter]);
                    nmhSetFsMIEcfmMaCrosscheckStatus
                        (i4CurrentContextId, u4MdIndex, u4MaIndex,
                         i4XchkStatus);
                    break;
                }
            }
        }
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
        if (i4CurrentContextId != i4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
        }
    }
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        if ((u4Type == CLI_ECFM_DOM_UNAWARE_ENABLE_XCHKING) ||
            (u4Type == CLI_ECFM_DOM_UNAWARE_DISABLE_XCHKING) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_ENABLE_XCHKING) ||
            (u4Type == CLI_ECFM_LEV_UNAWARE_DISABLE_XCHKING))
        {
            UINT1               u1Level = ECFM_INIT_VAL;
            u1Level = EcfmGetBit (&u1LevelList);
            if (u1Level != 0)
            {
                CliPrintf (CliHandle,
                           "\r%% Crosscheck status cannot be configured at level %d\r\n",
                           u1Level);
            }
            else
            {
                break;
            }
        }
        else
        {
            for (u4ByteIndex = 0; u4ByteIndex < ECFM_VLAN_LIST_SIZE;
                 u4ByteIndex++)
            {
                if (apu1LevelVlanList[u1LevelCounter][u4ByteIndex] != 0)
                {
                    CliPrintf (CliHandle,
                               "\r%% Crosscheck status cannot be configured at level %d, vlan %d\r\n",
                               u1LevelCounter, u4Isid);
                    break;
                }
            }
        }
    }
    /* Releasing memory for Vlan List Size */
    for (u1LevelCounter = 0; u1LevelCounter < ECFM_MD_LEVEL_MAX + 1;
         u1LevelCounter++)
    {
        UtilVlanReleaseVlanListSize (apu1LevelVlanList[u1LevelCounter]);
    }
    return CLI_SUCCESS;
}

/***************************************************************************
 *                                                                         *
 *     Function Name : EcfmCliGetLevelVlanIsidInfo                      *
 *                                                                         *
 *     Description   : This function provides the level corresponding to   *
 *                     domain namei, vlan corresponding to service name    *
 *                     and validate MEPs MA for the creation and deletion. *
 *                                                                         *
 *     Input(s)      : CliHandle    - CLI Context                          *
 *                     u4ContextId  - Context Id                           *  
 *                     pu1MdName    - MD Name                              *  
 *                     pu1MaName    - MA Name                              *
 *                     u4PortNum    - Port Number                          *
 *                     b1Direction  - Direction                            *
 *                     b1Action     - Creation/Deletion                    *
 *                                                                         *
 *     Output(s)     : pu4MdLevel   - Level                                *
 *                     pu4VlanIsid  - VLAN or ISID                         *
 *                     pb1IsUnaware - Aware or Unaware                     *
 *                                                                         *
 *     Returns       : CLI_SUCCESS/CLI_FAILURE                             *
 *                                                                         *
 ***************************************************************************/
INT4
EcfmCliGetLevelVlanIsidInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT1 *pu1MdName, UINT1 *pu1MaName,
                             UINT4 *pu4MdLevel, UINT4 *pu4VlanIsid,
                             UINT4 u4CurrMdIndex, BOOL1 * pb1IsUnaware,
                             UINT4 u4PortNum, BOOL1 b1Direction, BOOL1 b1Action)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;
    tEcfmCcMepInfo     *pMepNode = NULL;

    /*Get first index */
    i4CurrentContextId = (INT4) (u4ContextId);
    if (pu1MdName != NULL)
    {
        i4RetVal = nmhGetNextIndexFsMIEcfmMdTable
            (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex);
        if ((u4ContextId != ECFM_INIT_VAL) &&
            (UINT4) (i4NextContextId) != u4ContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
        if (i4RetVal == SNMP_FAILURE)

        {
            CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
        {
            ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            RetMdName.pu1_OctetList = au1RetMdName;
            RetMdName.i4_Length = ECFM_INIT_VAL;

            nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
            nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex,
                                    &i4RetMdFormat);

            MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat,
                                         au1StrMdName);

            /* Check if this is the domain to delete */
            if (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)

            {
                nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                         (INT4 *) pu4MdLevel);
                u4CurrMdIndex = u4MdIndex;
                break;

            }
            /* Get next valid index */
            i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex);
            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (i4CurrentContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4MdIndex = u4NextMdIndex;
            }
        }
        if (pu4MdLevel == NULL)
        {
            CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
            CliPrintf (CliHandle, " ");
            return CLI_FAILURE;
        }
    }
    if (pu1MaName != NULL)
    {
        UINT4               u4MaIndex = ECFM_INIT_VAL;
        UINT4               u4NextMaIndex = ECFM_INIT_VAL;
        u4MdIndex = ECFM_INIT_VAL;
        u4NextMdIndex = ECFM_INIT_VAL;

        i4CurrentContextId = (INT4) (u4ContextId);
        i4NextContextId = ECFM_INIT_VAL;

        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable
            (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
             &u4MaIndex);

        if (i4RetVal == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        if ((u4ContextId != ECFM_INIT_VAL) &&
            (UINT4) (i4NextContextId) != u4ContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* MaTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext))

        {

            i4CurrentContextId = i4NextContextId;
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;
            nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            if (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)
            {
                if (u4CurrMdIndex != 0)
                {
                    if (u4CurrMdIndex == u4MdIndex)
                    {
                        nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId,
                                                       u4MdIndex, u4MaIndex,
                                                       (INT4 *) pu4VlanIsid);

                        ECFM_CC_SELECT_CONTEXT (u4ContextId);
                        /* Get MEP node from portInfo's MepInfoTree */
                        pMepNode = EcfmCcUtilGetMepEntryFrmPort ((UINT1) *pu4MdLevel, 
                                                                        *pu4VlanIsid, 
                                                              u4PortNum, b1Direction);
                        if (pMepNode != NULL)
                        {
                            if (ECFM_STRCMP (pMepNode->pMaInfo->au1Name,
                                             pu1MaName) != 0)
                            {
                                if (b1Action == ECFM_CREATE)
                                {
                                    CLI_SET_ERR (CLI_ECFM_MA_CONFIG_ERR);
                                }
                                else if (b1Action == ECFM_DELETE)
                                {
                                    CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
                                }
                                else
                                {
                                    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
                                }
                                ECFM_CC_RELEASE_CONTEXT ();
                                return CLI_FAILURE;
                            }
                        }
                        ECFM_CC_RELEASE_CONTEXT ();
                        if (*pu4VlanIsid == 0)
                        {
                            *pb1IsUnaware = ECFM_TRUE;
                        }
                        break;
                    }
                }
                else
                {
                    nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId,
                                                   u4MdIndex, u4MaIndex,
                                                   (INT4 *) pu4VlanIsid);
                    if (*pu4VlanIsid == 0)
                    {
                        *pb1IsUnaware = ECFM_TRUE;
                    }
                    break;
                }
            }
            else
            {
                *pu4VlanIsid = -1;
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (i4CurrentContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
            }
        }
        if ((INT4) *pu4VlanIsid == -1)
        {
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
    }
    ECFM_CC_SELECT_CONTEXT (u4ContextId);
    return CLI_SUCCESS;
}

/************************************************************************
 *  Function Name : EcfmCliGetMdMaSnmpIndex                             *
 *                                                                      *
 *  Description   : This function provides the MD and/or MA SNMP Index  *
 *                  when provided with Domain name and Level and/or     * 
 *                  Service Name. This utility is currently used for    *
 *                  MPLS-TP OAM purpose.                                *
 *                                                                      *
 *  Input(s)      : CliHandle    - CLI Context                          *
 *                  u4ContextId  - Context Id                           *
 *                  pu1MdName    - MD Name                              *  
 *                  u1MdLevel    - MD Level                             *
 *                  pu1MaName    - MA Name                              *
 *                                                                      *
 *  Output(s)     : pu4MdIndex - Pointer to MD Index                    *
 *                  pu4MaIndex - Pointer to MA Index                    *
 *                                                                      *
 *  Returns       : CLI_SUCCESS - If the associated MD/MA entry exsts   *
 *                  CLI_FAILURE - otherwise                             *
 *                                                                      *
 ************************************************************************/
INT4
EcfmCliGetMdMaSnmpIndex (tCliHandle CliHandle, UINT4 u4ContextId,
                         UINT1 *pu1MdName, UINT1 *pu1MdLevel,
                         UINT1 *pu1MaName, UINT4 *pu4MdIndex, UINT4 *pu4MaIndex)
{
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];

    *pu4MdIndex = ECFM_INIT_VAL;
    *pu4MaIndex = ECFM_INIT_VAL;
    u4NextContextId = ECFM_INIT_VAL;
    u4CurrContextId = u4ContextId;

    i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (u4CurrContextId,
                                               (UINT4 *) &u4NextContextId,
                                               u4CurrMdIndex, &u4NextMdIndex);

    if ((i4RetVal == SNMP_FAILURE) || (u4CurrContextId != u4NextContextId))
    {
        CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    u4CurrMdIndex = u4NextMdIndex;

    while (i4RetVal == SNMP_SUCCESS)
    {
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = ECFM_INIT_VAL;

        nmhGetFsMIEcfmMdName (u4CurrContextId, u4CurrMdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrContextId, u4CurrMdIndex, &i4RetMdFormat);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4CurrMdIndex,
                                 (INT4 *) &i4RetMdLevel);

        if (ECFM_STRCMP (au1StrMdName, pu1MdName) == 0)
        {
            if (pu1MdLevel != NULL)
            {
                if (i4RetMdLevel == (INT4) *pu1MdLevel)
                {
                    *pu4MdIndex = u4CurrMdIndex;
                    break;
                }
            }
        }
        /* Get next valid index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (u4CurrContextId,
                                                   (UINT4 *) &u4NextContextId,
                                                   u4CurrMdIndex,
                                                   &u4NextMdIndex);
        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (u4CurrContextId != u4NextContextId)
            {
                break;
            }
            u4CurrMdIndex = u4NextMdIndex;
        }
    }                            /* end of while */

    if (*pu4MdIndex == ECFM_INIT_VAL)
    {
        CliPrintf (CliHandle, " ");
        CLI_SET_ERR (CLI_ECFM_DOM_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    if (pu1MaName != NULL)
    {
        UINT4               u4CurrMaIndex = ECFM_INIT_VAL;
        UINT4               u4NextMaIndex = ECFM_INIT_VAL;

        u4CurrContextId = u4ContextId;
        u4NextContextId = ECFM_INIT_VAL;
        u4CurrMdIndex = *pu4MdIndex;
        u4NextMdIndex = ECFM_INIT_VAL;

        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable
            (u4CurrContextId, (UINT4 *) &u4NextContextId,
             u4CurrMdIndex, &u4NextMdIndex, u4CurrMaIndex, &u4NextMaIndex);

        if ((i4RetVal == SNMP_FAILURE) ||
            (u4CurrContextId != u4NextContextId) ||
            (u4CurrMdIndex != u4NextMdIndex))
        {
            CliPrintf (CliHandle, " ");
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }

        u4CurrMaIndex = u4NextMaIndex;

        /* MaTable not empty, now scan its each row */
        while (i4RetVal == SNMP_SUCCESS)
        {
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;
            nmhGetFsMIEcfmMaName (u4CurrContextId, u4CurrMdIndex, u4CurrMaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (u4CurrContextId, u4CurrMdIndex,
                                    u4CurrMaIndex, &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            if (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)
            {
                *pu4MaIndex = u4CurrMaIndex;
                break;
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (u4CurrContextId,
                                                       (UINT4 *)
                                                       &u4NextContextId,
                                                       u4CurrMdIndex,
                                                       &u4NextMdIndex,
                                                       u4CurrMaIndex,
                                                       &u4NextMaIndex);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)
            {
                if ((u4CurrContextId != u4NextContextId) ||
                    (u4CurrMdIndex != u4NextMdIndex))
                {
                    break;
                }

                u4CurrMaIndex = u4NextMaIndex;
            }
        }                        /* end of while */

        if (*pu4MaIndex == ECFM_INIT_VAL)
        {
            CliPrintf (CliHandle, " ");
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
    }

    ECFM_CC_SELECT_CONTEXT (u4ContextId);
    return CLI_SUCCESS;
}

/***************************************************************************
 *                                                                         *
 *     Function Name : EcfmCliGetNextVlanIsidInfo                             *
 *                                                                         *
 *     Description   : This function provides the level corresponding to   *
 *                     domain name and vlan corresponding to service name  *
 *                                                                         *
 *     Input(s)      :                                                     *
 *                                                                         *
 *     Output(s)     : NULL                                                *
 *                                                                         *
 *     Returns       : NONE                                                *
 *                                                                         *
 ***************************************************************************/
INT4
EcfmCliGetNextVlanIsidInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT1 *pu1MaName, UINT4 u4CurrVlanIsid,
                            UINT4 *pu4NextVlanIsid, BOOL1 * pb1IsUnaware)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4PrevVlanIsid = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;

    i4CurrentContextId = (INT4) (u4ContextId);
    if (pu1MaName != NULL)
    {
        UINT4               u4MaIndex = ECFM_INIT_VAL;
        UINT4               u4NextMaIndex = ECFM_INIT_VAL;
        u4MdIndex = ECFM_INIT_VAL;
        u4NextMdIndex = ECFM_INIT_VAL;

        i4CurrentContextId = (INT4) (u4ContextId);
        i4NextContextId = ECFM_INIT_VAL;

        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable
            (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
             &u4MaIndex);

        if (i4RetVal == SNMP_FAILURE)
        {
            CLI_SET_ERR (CLI_ECFM_MA_NOT_PRESENT_ERR);
            return CLI_FAILURE;
        }
        if ((u4ContextId != ECFM_INIT_VAL) &&
            (UINT4) (i4NextContextId) != u4ContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* MaTable not empty, now scan its each row */
        while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext))

        {

            i4CurrentContextId = i4NextContextId;
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;

            nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            if (ECFM_STRCMP (au1StrMaName, pu1MaName) == 0)
            {
                nmhGetFsMIEcfmMaPrimaryVlanId (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex,
                                               (INT4 *) pu4NextVlanIsid);
                if (u4CurrVlanIsid == u4PrevVlanIsid)
                {
                    if (*pu4NextVlanIsid == 0)
                    {
                        *pb1IsUnaware = ECFM_TRUE;
                    }
                    ECFM_CC_SELECT_CONTEXT (u4ContextId);
                    return CLI_SUCCESS;

                }
                u4PrevVlanIsid = *pu4NextVlanIsid;
            }

            /* Get next index */
            i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex);

            /* If valid index found */
            if (i4RetVal == SNMP_SUCCESS)

            {
                if (i4CurrentContextId != i4NextContextId)

                {
                    b1SameContext = ECFM_FALSE;
                }
                u4MdIndex = u4NextMdIndex;
                u4MaIndex = u4NextMaIndex;
            }
        }
    }
    else
    {
        UNUSED_PARAM (pu4NextVlanIsid);
    }
    ECFM_CC_SELECT_CONTEXT (u4ContextId);
    UNUSED_PARAM (CliHandle);
    return CLI_FAILURE;
}

/***************************************************************************
 *                                                                         *
 *     Function Name : EcfmCliShowDebug                                    *
 *                                                                         *
 *     Description   : This function prints the debug level                *
 *                                                                         *
 *     Input(s)      :                                                     *
                                                                           *
 *     Output(s)     : NULL                                                *
 *                                                                         *
 *     Returns       : NONE                                                *
                                                                           *
 ***************************************************************************/
VOID
EcfmCliShowDebug (tCliHandle CliHandle)
{
    INT4                i4DbgLevel = 0;
    UINT4               u4ContextId = ECFM_INIT_VAL;
    INT4                i4GblDbgLevel = ECFM_SNMP_FALSE;

    nmhGetFsMIEcfmTraceOption (u4ContextId, &i4DbgLevel);
    nmhGetFsMIEcfmGlobalTrace (&i4GblDbgLevel);

    if ((i4DbgLevel == 0) && (i4GblDbgLevel == ECFM_SNMP_FALSE))
    {
        return;
    }
    CliPrintf (CliHandle, "\rECFM: ");
    if (i4GblDbgLevel == ECFM_SNMP_TRUE)
    {
        CliPrintf (CliHandle, "\r\n   ECFM global debugging is on");
    }
    if ((i4DbgLevel & MGMT_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM management debugging is on");
    }
    if ((i4DbgLevel & ECFM_CRITICAL_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM Critical debugging is on");
    }
    if ((i4DbgLevel & INIT_SHUT_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM init and shutdown debugging is on");
    }
    if ((i4DbgLevel & OS_RESOURCE_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM resource debugging is on");
    }
    if ((i4DbgLevel & DUMP_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM packet flow debugging is on");
    }
    if ((i4DbgLevel & ALL_FAILURE_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM failure debugging is on");
    }
    if ((i4DbgLevel & BUFFER_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM buffer debugging is on");
    }
    if ((i4DbgLevel & CONTROL_PLANE_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM Control debugging is on");
    }
    if ((i4DbgLevel & ECFM_FN_ENTRY_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM function entry debugging is on");
    }
    if ((i4DbgLevel & ECFM_FN_EXIT_TRC) != 0)
    {
        CliPrintf (CliHandle, "\r\n   ECFM function exit debugging is on");
    }

    CliPrintf (CliHandle, "\r\n");
    return;
}

/*****************************************************************************
 *    FUNCTION NAME    : EcfmCliValidateMdNameFormatForMac
 *
 *    DESCRIPTION      : This function checks whether MD name is in Mac Address
 *                       Format or Not                 
 *
 *    INPUT            : pu1TestName - Name that needs to be validated
 *
 *    OUTPUT           : NONE
 *
 *    RETURNS          : ECFM_SUCCESS/ECFM_FAILURE
 *
 ****************************************************************************/

PRIVATE INT4
EcfmCliValidateMdNameFormatForMac (UINT1 *pu1TestName, INT4 i4TestLength)
{
    INT2                i2ColonCount = ECFM_INIT_VAL;
    INT2                i2CharCount = ECFM_INIT_VAL;
    INT2                i2MaxcharCount = ECFM_INIT_VAL;
    INT4                i4MdNameLen = i4TestLength;
    UINT4               u4UintVal = ECFM_INIT_VAL;
    UINT1              *pu1MdName = pu1TestName;

    /*  Validate Length Mac address + 2 Bytes */
    if ((i4MdNameLen < ECFM_MAC_ADD_STRING_AND_OCTET_MIN_LENGTH) ||
        (i4MdNameLen > ECFM_MAC_ADD_STRING_AND_OCTET_MAX_LENGTH))
    {
        return ECFM_FAILURE;
    }

    while (i4MdNameLen--)
    {
        if (*pu1MdName == ':')
        {
            if (i2CharCount < ECFM_INDEX_TWO)
            {
                return ECFM_FAILURE;
            }

            i2MaxcharCount = (i2MaxcharCount > i2CharCount) ?
                (i2MaxcharCount) : (i2CharCount);
            i2CharCount = 0;
            i2ColonCount++;
            pu1MdName++;
        }
        else if (ECFM_IS_HEX_DIGIT (*pu1MdName))
        {
            i2CharCount++;
            pu1MdName++;
        }
        else
        {
            return ECFM_FAILURE;
        }
    }

    if (((i2ColonCount == ECFM_INDEX_SIX) && (i2CharCount < 1)) ||
        ((i2ColonCount < ECFM_INDEX_SIX) || (i2ColonCount > ECFM_INDEX_SIX)) ||
        (i2CharCount > ECFM_INDEX_FIVE))
    {
        return ECFM_FAILURE;
    }

    SSCANF ((CHR1 *) (pu1TestName +
                      ECFM_MAC_ADD_STRING_AND_OCTET_MIN_LENGTH - 1), "%u",
            &u4UintVal);

    if (u4UintVal > ECFM_UINT2_MAX)
    {
        return ECFM_FAILURE;
    }

    return ECFM_SUCCESS;
}

/****************************************************************************
 *FUNCTION NAME    : MplsOamShowDomains
 *
 *DESCRIPTION      : This function will show the configured domain
 *                   information.
 *
 *INPUT            : CliHandle      - CliContext ID
 *                   u4ContextId    - Context Identifier
 *                   u4Type         - Command                                                     *                   pu1Arg         - Domain Name or Level
 *
 *OUTPUT           : None
 *
 *RETURNS          : CLI_SUCCESS/CLI_FAILURE
 ****************************************************************************/
INT4
MplsOamShowDomains (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                    UINT1 *pu1MdLevel)
{
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = 0;
    INT4                i4NextContextId = 0;
    INT4                i4RetMdRowStatus = 0;
    INT4                i4RetMepArchiveHoldTime = 0;
    UINT4               u4MdIndex = 0;
    UINT4               u4NextMdIndex = 0;
    UINT4               u4RetMdLevel = 0;
    UINT4               u4Count = 0;    /* No. of associations
                                         *  associated with a MD.
                                         */
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4MdLevel = 0;
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;

    i4CurrentContextId = (INT4) (u4ContextId);

    if (nmhGetNextIndexFsMIEcfmMdTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0,
         &u4MdIndex) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM_BRIEF) ||
        (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV_BRIEF))
    {
        CliPrintf (CliHandle, "\r\n%-10s%-10s%-10s%-20s\r\n",
                   "Index", "Level", "Services", "Archive(min)");
    }

    /* Its for required context, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))
    {
        i4RetMepArchiveHoldTime = ECFM_INIT_VAL;

        /* first check its row status */
        nmhGetFsMIEcfmMdRowStatus (i4CurrentContextId, u4MdIndex,
                                   &i4RetMdRowStatus);
        if (i4RetMdRowStatus == ECFM_ROW_STATUS_ACTIVE)
        {

            /* Get u4MdIndex's name level, no. of associations in this MD */
            nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                     (INT4 *) &u4RetMdLevel);

            u4Count = EcfmGetNoOfMasInMd (i4CurrentContextId, u4MdIndex);

            switch (u4Type)
            {
                case CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV_BRIEF:
                case CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV:
                    /* Compare MdLevel if passed through CLI */
                    if (pu1MdLevel != NULL)
                        MEMCPY (&u4MdLevel, pu1MdLevel, sizeof (UINT4));
                    if (u4RetMdLevel == u4MdLevel)
                    {
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                default:
                    break;
            }
            if ((pu1MdLevel == NULL) || (b1Entry == ECFM_TRUE))
            {
                if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM_BRIEF) ||
                    (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM_LEV_BRIEF))
                {
                    nmhGetFsMIEcfmMepArchiveHoldTime (i4CurrentContextId,
                                                      u4MdIndex,
                                                      &i4RetMepArchiveHoldTime);
                    CliPrintf (CliHandle, "%-10u", u4MdIndex);
                    CliPrintf (CliHandle, "%-10u", u4RetMdLevel);
                    CliPrintf (CliHandle, "%-10u", u4Count);
                    CliPrintf (CliHandle, "%-20u", i4RetMepArchiveHoldTime);
                    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                }
                else
                {
                    CliPrintf (CliHandle, "\r\nIndex : %u", u4MdIndex);
                    CliPrintf (CliHandle, "\r\nLevel : %u", u4RetMdLevel);
                    CliPrintf (CliHandle, "\r\nTotal Services : %u\r\n",
                               u4Count);

                    /* Crosscheck status to be added */
                    MplsOamShowXchkStatus (CliHandle, i4CurrentContextId,
                                           u4MdIndex, ECFM_TRUE);

                    /* Crosscheck parameters */
                    MplsOamShowXchkParams (CliHandle,
                                           CLI_Y1731_MPLSTPOAM_SHOW_DOM,
                                           i4CurrentContextId, u4MdIndex, 0,
                                           ECFM_TRUE);
                    u4PagingStatus = CliPrintf (CliHandle, "\r\n");
                }
            }
            if (b1Entry == ECFM_TRUE)    /* If the required entry found, break */
                b1Entry = ECFM_FALSE;
        }
        i4RetVal = nmhGetNextIndexFsMIEcfmMdTable (i4CurrentContextId,
                                                   (UINT4 *) &i4NextContextId,
                                                   u4MdIndex, &u4NextMdIndex);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1IsShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }
    CliPrintf (CliHandle, "\n");
    UNUSED_PARAM (u4PagingStatus);
    return CLI_SUCCESS;
}

/******************************************************************************
 *     FUNCTION NAME    : MplsOamCliShowServices
 *
 *     DESCRIPTION      : This function will show the configured associations.
 *
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId   - context Identifier
 *                        u4Type - Command
 *                        pu1MaName     - Service Name
 *                        pu1Arg        - Domain Name or Level
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ****************************************************************************/
INT4
MplsOamCliShowServices (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                        UINT1 *pu1MaName, UINT1 *pu1Arg)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMegIdCode;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4Count = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = 0;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4XchkSts = ECFM_INIT_VAL;
    INT4                i4CcRole = ECFM_INIT_VAL;
    INT4                i4RetCcInterval = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = 0;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMegIdCode[ECFM_CARRIER_CODE_ARRAY_SIZE];
    BOOL1               b1IsShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;

    i4CurrentContextId = (INT4) (u4ContextId);

    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    CliPrintf (CliHandle, "\r\n");

    if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_BRIEF) ||
        (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV_BRIEF))
    {
        CliPrintf (CliHandle,
                   "%-22s%-8s%-13s%-6s%-5s%-15s", "ServiceName", "Index",
                   "ServiceType", "Level", "MEPs", "CCM Interval");
        CliPrintf (CliHandle, "\r\n");
    }

    /* MaTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1IsShowAll))
    {
        i4RetMaRowStatus = ECFM_INIT_VAL;

        /* first check its row status */
        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        if (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE)

        {
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;

            i4RetMdLevel = ECFM_INIT_VAL;
            u4Count = ECFM_INIT_VAL;
            i4RetMaFormat = ECFM_INIT_VAL;

            if (ECFM_CC_SELECT_CONTEXT (i4CurrentContextId) != ECFM_SUCCESS)
            {
                return CLI_FAILURE;
            }
            /* Get MA entry corresponding to indices MdIndex, MaIndex */
            pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
            if (pMaNode == NULL)
            {
                ECFM_CC_RELEASE_CONTEXT ();
                return CLI_SUCCESS;
            }

            u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

            ECFM_MEMCPY (RetMaName.pu1_OctetList, pMaNode->au1Name,
                         pMaNode->u1NameLength);
            RetMaName.i4_Length = (INT4) pMaNode->u1NameLength;

            nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                     &i4RetMdLevel);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);
            nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex,
                                    &i4RetMdFormat);

            u4Count =
                EcfmGetNoOfMepsInMa (i4CurrentContextId, u4MdIndex, u4MaIndex);

            do
            {
                if ((pu1MaName != NULL) &&
                    (ECFM_STRCMP (RetMaName.pu1_OctetList, pu1MaName) != 0))
                {
                    break;
                }

                switch (u4Type)
                {
                    case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV_BRIEF:
                    case CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV:
                        if (pu1Arg != NULL)
                            MEMCPY (&i4MdLevel, pu1Arg, sizeof (INT4));

                        if (i4RetMdLevel == i4MdLevel)
                        {
                            b1Entry = ECFM_TRUE;
                        }
                        break;

                    default:
                        break;
                }

                /* If no Service name provided, show all the
                 * services or a given service.
                 */
                if (pu1Arg == NULL)
                {
                    b1Entry = ECFM_TRUE;
                }
                else if (b1Entry != ECFM_TRUE)
                {
                    /* If Service name is provided and is not found then
                     * donot display
                     */
                    break;
                }

                if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_BRIEF) ||
                    (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE_LEV_BRIEF))
                {

                    i4RetCcInterval = ECFM_INIT_VAL;
                    nmhGetFsMIEcfmMaCcmInterval (i4CurrentContextId, u4MdIndex,
                                                 u4MaIndex, &i4RetCcInterval);

                    MEMSET (au1StrMaName, ECFM_INIT_VAL,
                            ECFM_MA_NAME_ARRAY_SIZE);
                    EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                                 au1StrMaName);
                    CliPrintf (CliHandle, "%-22s", au1StrMaName);

                    CliPrintf (CliHandle, "%-8u", u4MaIndex);

                    /* Print the Selector Type/Service Type - PW/LSP */
                    if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                    {
                        CliPrintf (CliHandle, "%-13s", "LSP");
                    }
                    else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                    {
                        CliPrintf (CliHandle, "%-13s", "PW");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-13s", "-");
                    }

                    CliPrintf (CliHandle, "%-6u", i4RetMdLevel);
                    CliPrintf (CliHandle, "%-5u", u4Count);

                    switch (i4RetCcInterval)
                    {
                        case ECFM_CCM_INTERVAL_300Hz:
                            CliPrintf (CliHandle, "%-15s", "3.33 milliseconds");
                            break;
                        case ECFM_CCM_INTERVAL_10_Ms:
                            CliPrintf (CliHandle, "%-15s", "10 milliseconds");
                            break;
                        case ECFM_CCM_INTERVAL_100_Ms:
                            CliPrintf (CliHandle, "%-15s", "100 millseconds");
                            break;
                        case ECFM_CCM_INTERVAL_1_S:
                            CliPrintf (CliHandle, "%-15s", "1 second ");
                            break;
                        case ECFM_CCM_INTERVAL_10_S:
                            CliPrintf (CliHandle, "%-15s", "10 seconds ");
                            break;
                        case ECFM_CCM_INTERVAL_1_MIN:
                            CliPrintf (CliHandle, "%-15s", "1 minute ");
                            break;
                        case ECFM_CCM_INTERVAL_10_MIN:
                            CliPrintf (CliHandle, "%-15s", "10 minutes ");
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    CliPrintf (CliHandle,
                               "-------------------------------------------\r\n");
                    MEMSET (au1StrMaName, ECFM_INIT_VAL,
                            ECFM_MA_NAME_ARRAY_SIZE);
                    EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                                 au1StrMaName);
                    CliPrintf (CliHandle, "Service Name : %s\r\n",
                               au1StrMaName);

                    CliPrintf (CliHandle, "Index        : %u\r\n", u4MaIndex);

                    CliPrintf (CliHandle, "Level        : %u\r\n",
                               i4RetMdLevel);

                    if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                    {
                        CliPrintf (CliHandle, "ServiceType  : %s\r\n", "LSP");
                    }
                    else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                    {
                        CliPrintf (CliHandle, "ServiceType  : %s\r\n", "PW");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "ServiceType  : %s\r\n", "-");
                    }

                    i4CcRole = ECFM_INIT_VAL;

                    ECFM_MEMSET (au1RetMegIdCode, ECFM_INIT_VAL,
                                 ECFM_CARRIER_CODE_ARRAY_SIZE);
                    ECFM_MEMSET (&RetMegIdCode, ECFM_INIT_VAL,
                                 sizeof (tSNMP_OCTET_STRING_TYPE));

                    RetMegIdCode.pu1_OctetList = au1RetMegIdCode;
                    RetMegIdCode.i4_Length = 0;

                    nmhGetFsMIY1731MeCcmApplication (i4CurrentContextId,
                                                     u4MdIndex, u4MaIndex,
                                                     &i4CcRole);
                    nmhGetFsMIY1731MeMegIdIcc (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex, &RetMegIdCode);
                    switch (i4CcRole)
                    {
                        case ECFM_CC_ROLE_FM:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : fault management");
                            break;
                        case ECFM_CC_ROLE_PM:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : performance monitoring");
                            break;
                        case ECFM_CC_ROLE_PS:
                            CliPrintf (CliHandle,
                                       "\r\nCC Role    : protection switching");
                            break;
                        default:
                            break;
                    }

                    CliPrintf (CliHandle, "\r\nICC Code   : %s",
                               RetMegIdCode.pu1_OctetList);

                    ECFM_MEMSET (au1RetMegIdCode, ECFM_INIT_VAL,
                                 ECFM_CARRIER_CODE_ARRAY_SIZE);
                    ECFM_MEMSET (&RetMegIdCode, ECFM_INIT_VAL,
                                 sizeof (tSNMP_OCTET_STRING_TYPE));
                    RetMegIdCode.pu1_OctetList = au1RetMegIdCode;
                    RetMegIdCode.i4_Length = 0;

                    nmhGetFsMIY1731MeMegIdUmc (i4CurrentContextId, u4MdIndex,
                                               u4MaIndex, &RetMegIdCode);
                    CliPrintf (CliHandle, "\r\nUMC Code   : %s",
                               RetMegIdCode.pu1_OctetList);

                    /* VlanIds associated with Primary Vlan */
                    CliPrintf (CliHandle, "\r\nTotal MEPs : %-5u", u4Count);

                    /* crosscheck status */
                    nmhGetFsMIEcfmMaCrosscheckStatus (i4CurrentContextId,
                                                      u4MdIndex, u4MaIndex,
                                                      &i4XchkSts);
                    if (i4XchkSts == ECFM_ENABLE)
                    {
                        CliPrintf (CliHandle,
                                   "\nCrosscheck status : Enabled\r\n");
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\nCrosscheck status : Disabled\r\n");
                    }

                    /* Crosscheck parameters */
                    MplsOamShowXchkParams (CliHandle,
                                           CLI_Y1731_MPLSTPOAM_SHOW_SERVICE,
                                           i4CurrentContextId, u4MdIndex,
                                           u4MaIndex, ECFM_TRUE);
                }
                u4PagingStatus = CliPrintf (CliHandle, "\r\n");
            }
            while (0);

            b1Entry = ECFM_FALSE;
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);
        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1IsShowAll = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {

            /* User pressed 'q' at more prompt,
             * no more print required, exit */
            b1IsShowAll = ECFM_FALSE;
        }
    }
    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : MplsOamCliShowLocalMp
 *
 *     DESCRIPTION      : This function will display Mep
 *                        related information.
 *
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - ContextIdentifier
 *                        u4Type - Type of command
 *                        pu1MdName - Maintenace Domain of MIP
 *                        u4IfIndex - Interface Index where MIP is configured
 *                        u1Level - MD Level of MIP
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS
 *
 ****************************************************************************/
INT4
MplsOamCliShowLocalMp (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4Type, UINT1 *pu1MdLevel)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tSNMP_OCTET_STRING_TYPE MaName;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4MdIndex = 0;
    UINT4               u4MaIndex = 0;
    UINT4               u4MepIdentifier = 0;
    UINT4               u4CurrentContextId = 0;
    UINT4               u4NextContextId = 0;
    UINT4               u4NextMaIndex = 0;
    UINT4               u4NextMepIdentifier = 0;
    UINT4               u4NextMdIndex = 0;
    UINT4               u4MaServiceType = 0;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4MdLevel = SNMP_SUCCESS;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetMepDirection = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    UINT1               au1MaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1MepEntry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Header = ECFM_FALSE;

    MEMSET (au1MaName, 0, ECFM_MA_NAME_ARRAY_SIZE);

    u4CurrentContextId = u4ContextId;

    /* Check if Mep Table is having entry for the context u4ContextId */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    if (u4NextContextId != u4ContextId)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table for particular mep depending upon command type */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepDirection);
        nmhGetFsMIEcfmMepRowStatus (u4CurrentContextId, u4MdIndex, u4MaIndex,
                                    u4MepIdentifier, &i4RetMepRowStatus);

        switch (u4Type)
        {
            case CLI_Y1731_MPLSTPOAM_SHOW_MEP_AT_LEVEL:
                if (pu1MdLevel == 0)
                {
                    break;
                }
                MEMCPY (&i4MdLevel, pu1MdLevel, sizeof (INT4));
                if ((u4MepIdentifier != 0) && (i4RetMdLevel == i4MdLevel))
                {
                    b1MepEntry = ECFM_TRUE;
                }
                break;
            case CLI_Y1731_MPLSTPOAM_SHOW_MEP_ALL:
                if (u4MepIdentifier != 0)
                {
                    b1MepEntry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /*  If entry found */
        if (b1MepEntry == ECFM_TRUE)
        {
            INT4                i4RetMepActive = ECFM_INIT_VAL;
            INT4                i4MepCciEnabled = ECFM_INIT_VAL;
            UINT1               au1MaTempName[ECFM_MA_NAME_ARRAY_SIZE];

            /* If header needs to be printed */
            if (b1Header == ECFM_FALSE)
            {
                UINT4               u4Temp = ECFM_INIT_VAL;

                for (u4Temp = 0; u4Temp < ECFM_CLI_MAX_LINE_LENGTH; u4Temp++)
                {
                    CliPrintf (CliHandle, "-");
                }

                CliPrintf (CliHandle, "\n");
                CliPrintf (CliHandle, "%-6s%-13s%-16s%-6s%s", "MPID", "Level",
                           "ServiceType", "Type", "CC-Status");
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "%6s", " ");
                CliPrintf (CliHandle, "%-29s%-6s%s", "ServiceName", "Dir",
                           "MP-Status");
                CliPrintf (CliHandle, "\r\n");

                for (u4Temp = 0; u4Temp < ECFM_CLI_MAX_LINE_LENGTH; u4Temp++)
                {
                    CliPrintf (CliHandle, "-");
                }

                CliPrintf (CliHandle, "\n");
                b1Header = ECFM_TRUE;
            }

            ECFM_MEMSET (au1MaTempName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            MaName.pu1_OctetList = au1MaTempName;
            MaName.i4_Length = ECFM_INIT_VAL;

            if (ECFM_CC_SELECT_CONTEXT (u4CurrentContextId) != ECFM_SUCCESS)
            {
                return CLI_FAILURE;
            }

            /* Get MA entry corresponding to indices MdIndex, MaIndex */
            pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
            if (pMaNode == NULL)
            {
                ECFM_CC_RELEASE_CONTEXT ();
                return CLI_SUCCESS;
            }

            u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

            ECFM_MEMCPY (MaName.pu1_OctetList, pMaNode->au1Name,
                         pMaNode->u1NameLength);
            MaName.i4_Length = (INT4) pMaNode->u1NameLength;

            nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex,
                                    u4MaIndex, &i4RetMaFormat);
            nmhGetFsMIEcfmMepCciEnabled (u4ContextId,
                                         u4MdIndex,
                                         u4MaIndex,
                                         u4MepIdentifier, &i4MepCciEnabled);
            nmhGetFsMIEcfmMepActive (u4ContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     &i4RetMepActive);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&MaName, i4RetMaFormat, au1StrMaName);

            CliPrintf (CliHandle, "%-6u", u4MepIdentifier);

            /* Level */
            CliPrintf (CliHandle, "%-13u", i4RetMdLevel);

            /* Print the Selector Type/Service Type - PW/LSP */
            if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
            {
                CliPrintf (CliHandle, "%-16s", "LSP");
            }
            else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
            {
                CliPrintf (CliHandle, "%-16s", "PW");
            }
            else
            {
                CliPrintf (CliHandle, "%-16s", "-");
            }

            CliPrintf (CliHandle, "%-6s", "MEP");

            /* CCI Enabled Status */
            if (i4MepCciEnabled == ECFM_SNMP_TRUE)
            {
                CliPrintf (CliHandle, "%s", "Enabled");
            }
            else
            {
                CliPrintf (CliHandle, "%s", "Disabled");
            }

            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "%6s", " ");

            /* MA Name */
            CliPrintf (CliHandle, "%-29s", au1StrMaName);

            /* ENTITY DIRECTION */
            if (i4RetMepDirection == ECFM_MP_DIR_DOWN)
            {
                CliPrintf (CliHandle, "%-6s", "Down");
            }
            else
            {
                CliPrintf (CliHandle, "%-6s", "Up");
            }

            /* MEP status */
            if (i4RetMepActive == ECFM_SNMP_TRUE)
            {
                u4PagingStatus = CliPrintf (CliHandle, "%-s", "Active");
            }
            else
            {
                u4PagingStatus = CliPrintf (CliHandle, "%-s", "InActive");
            }

            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                             &u4NextContextId, u4MdIndex,
                                             &u4NextMdIndex, u4MaIndex,
                                             &u4NextMaIndex, u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }

        if (u4CurrentContextId != u4NextContextId)
        {
            /* Current context entry not found */
            b1SameContext = ECFM_FALSE;
        }

        b1MepEntry = ECFM_FALSE;

    }                            /* end of while */

    ECFM_CC_RELEASE_CONTEXT ();
    UNUSED_PARAM (u4PagingStatus);
    return CLI_SUCCESS;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : MplsOamCliShowLocalMepInfo
 *
 *     DESCRIPTION      : This function will display the informations regarding
 *                        the MEPs.
 *
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id
 *                        u4Type - Type of command
 *                        pu1Arg1 -
 *                        pu1Arg2 -
 *                        pu1Arg3 -
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
MplsOamCliShowLocalMepInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                            UINT4 u4Type, UINT1 u1MepId,
                            UINT1 u1MdLevel, UINT1 *pu1MaName)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tEcfmMacAddr        RetMacAddr;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    UINT4               u4CurrentContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = ECFM_INIT_VAL;
    INT4                i4MepDirection = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;

    u4CurrentContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrentContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        b1ShowAll = ECFM_FALSE;
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    if (u4NextContextId != u4ContextId)
    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll == ECFM_TRUE))
    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetMdLevel = ECFM_INIT_VAL;

        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;

        if (ECFM_CC_SELECT_CONTEXT (u4CurrentContextId) != ECFM_SUCCESS)
        {
            return CLI_FAILURE;
        }

        /* Get MA entry corresponding to indices MdIndex, MaIndex */
        pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
        if (pMaNode == NULL)
        {
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_SUCCESS;
        }

        u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

        nmhGetFsMIEcfmMaName (u4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);
        nmhGetFsMIEcfmMdName (u4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (u4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (u4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepDirection (u4CurrentContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4MepDirection);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Type)
        {
            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_SER:
                if ((u4MepIdentifier == u1MepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_LEV_SER:
                if ((u4MepIdentifier == u1MepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0)
                    && ((UINT4) (i4RetMdLevel) == u1MdLevel))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_MEP_MPID_ON_LEV:
                if ((u4MepIdentifier == u1MepId) &&
                    ((UINT4) (i4RetMdLevel) == u1MdLevel))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_MEP_MPID:
                if (u4MepIdentifier == u1MepId)

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            CliPrintf (CliHandle,
                       "\r\n-----------------------------------------------------------");

            if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
            {
                CliPrintf (CliHandle,
                           "\r\nMPID: %-4d MdLevel: %-13d ServiceType: "
                           "%-4s Dir: %s", u4MepIdentifier,
                           i4RetMdLevel, "LSP",
                           (i4MepDirection == ECFM_MP_DIR_UP) ? "Up" : "Down");
            }
            else
            {
                CliPrintf (CliHandle,
                           "\r\nMPID: %-4d MdLevel: %-13d ServiceType: "
                           "%-4s Dir: %s", u4MepIdentifier,
                           i4RetMdLevel, "PW",
                           (i4MepDirection == ECFM_MP_DIR_UP) ? "Up" : "Down");
            }
            CliPrintf (CliHandle,
                       "\r\n-----------------------------------------------------------\n");

            /* Routine called to display MEP Info */
            MplsOamDisplayMepInfo (CliHandle, u4CurrentContextId,
                                   u4MdIndex, u4MaIndex, u4MepIdentifier);
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrentContextId,
                                                    (UINT4 *)
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrentContextId != u4NextContextId)
            {
                b1ShowAll = ECFM_FALSE;
            }

            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            b1Entry = ECFM_FALSE;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt, no more print required,
             * exit */
            b1ShowAll = ECFM_FALSE;
        }
    }
    ECFM_CC_RELEASE_CONTEXT ();
    return CLI_SUCCESS;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : MplsOamDisplayMepInfo
 *
 *     DESCRIPTION      : This function will display the informations regarding
 *                        the MEPs.
 *
 *     INPUT            : CliHandle   - CliContext ID
 *                        u4ContextId - Context Id
 *                        u4MdIndex   - Md Index of the MEP
 *                        u4MaIndex   - Ma Index of the MEP
 *                        u4MepId     - MEPID of the MEP
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
PRIVATE VOID
MplsOamDisplayMepInfo (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u4MepId)
{
    tSNMP_OCTET_STRING_TYPE ErrorCcmRcvd;
    tSNMP_OCTET_STRING_TYPE XconCcmRcvd;
    INT4                i4RetValues = ECFM_INIT_VAL;
    INT4                i4RetConditionValues = ECFM_INIT_VAL;
    INT4                i4RetAisOffLoadStatus = ECFM_INIT_VAL;
    INT4                i4RetCcmOffLoadStatus = ECFM_INIT_VAL;
    INT4                i4RetPriority = ECFM_INIT_VAL;
    INT4                i4RetInterval = ECFM_INIT_VAL;
    INT4                i4RetDropEnable = ECFM_INIT_VAL;
    UINT4               u4RetPeriod = ECFM_INIT_VAL;
    UINT1               au1ErrorCcmRcvd[ECFM_MAX_CCM_PDU_SIZE];
    UINT1               au1XconCcmRcvd[ECFM_MAX_CCM_PDU_SIZE];
    UINT1               u1Index = ECFM_INIT_VAL;

    ECFM_MEMSET (au1ErrorCcmRcvd, ECFM_INIT_VAL, ECFM_MAX_CCM_PDU_SIZE);
    ECFM_MEMSET (au1XconCcmRcvd, ECFM_INIT_VAL, ECFM_MAX_CCM_PDU_SIZE);

    ECFM_MEMSET (&ErrorCcmRcvd, ECFM_INIT_VAL, sizeof
                 (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&XconCcmRcvd, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));

    ErrorCcmRcvd.pu1_OctetList = au1ErrorCcmRcvd;
    XconCcmRcvd.pu1_OctetList = au1XconCcmRcvd;
    ErrorCcmRcvd.i4_Length = 0;
    XconCcmRcvd.i4_Length = 0;

    nmhGetFsMIEcfmMepErrorCcmLastFailure (u4ContextId,
                                          u4MdIndex, u4MaIndex,
                                          u4MepId, &ErrorCcmRcvd);

    nmhGetFsMIEcfmMepXconCcmLastFailure (u4ContextId,
                                         u4MdIndex, u4MaIndex,
                                         u4MepId, &XconCcmRcvd);

    /*Status of MepCcmOffload */
    nmhGetFsMIEcfmMepCcmOffload (u4ContextId, u4MdIndex, u4MaIndex,
                                 u4MepId, (INT4 *) &i4RetCcmOffLoadStatus);

    nmhGetFsMIY1731MepAisOffload (u4ContextId, u4MdIndex, u4MaIndex,
                                  u4MepId, (INT4 *) &i4RetAisOffLoadStatus);

    CliPrintf (CliHandle, "\r\n%-37s", "CCM Off-Load Status");
    CliPrintf (CliHandle, "%-3s", ":");
    if (i4RetCcmOffLoadStatus == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }

    CliPrintf (CliHandle, "\r\n%-37s", "AIS Off-Load Status");
    CliPrintf (CliHandle, "%-3s", ":");
    if (i4RetAisOffLoadStatus == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }

    CliPrintf (CliHandle, "\r\n");

    /* RDI */
    CliPrintf (CliHandle, "\r\n\nRemote Defect Indication (RDI)\r\n");
    CliPrintf (CliHandle, "------------------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepRdiCapability (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }

    if (i4RetValues == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Period");
        CliPrintf (CliHandle, "%-3s", ":");
        i4RetValues = ECFM_INIT_VAL;
        nmhGetFsMIY1731MepRdiPeriod (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, (UINT4 *) &i4RetValues);
        CliPrintf (CliHandle, "%d seconds", i4RetValues);
    }

    ECFM_UNREGISTER_CLI_CC_LOCK ();
    ECFM_REGISTER_CLI_LBLT_LOCK ();

    CliPrintf (CliHandle, "\r\n\nLoopback (LB)\r\n");
    CliPrintf (CliHandle, "-------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepLoopbackCapability (u4ContextId, u4MdIndex,
                                          u4MaIndex, u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }
    ECFM_UNREGISTER_CLI_LBLT_LOCK ();
    ECFM_REGISTER_CLI_CC_LOCK ();

    /*AIS Details */
    CliPrintf (CliHandle, "\r\n\nAlarm Indication Signal (AIS)\r\n");
    CliPrintf (CliHandle, "-----------------------------");
    CliPrintf (CliHandle, "\r\n%-37s", "Capability");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepAisCapability (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &i4RetValues);
    if (i4RetValues == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "%-18s", "Enabled");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Disabled");
    }

    CliPrintf (CliHandle, "\r\n%-37s", "Condition");
    CliPrintf (CliHandle, "%-3s", ":");
    i4RetConditionValues = ECFM_INIT_VAL;
    nmhGetFsMIY1731MepAisCondition (u4ContextId, u4MdIndex, u4MaIndex,
                                    u4MepId, &i4RetConditionValues);
    if (i4RetConditionValues == ECFM_TRUE)
    {
        CliPrintf (CliHandle, "%-18s", "Exist");
    }
    else
    {
        CliPrintf (CliHandle, "%-18s", "Does not exist");
    }

    /* If Ais Capability is enabled then show the details */
    if (i4RetValues == ECFM_ENABLE)
    {
        nmhGetFsMIY1731MepAisInterval (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &i4RetInterval);
        nmhGetFsMIY1731MepAisPeriod (u4ContextId, u4MdIndex, u4MaIndex,
                                     u4MepId, &u4RetPeriod);
        nmhGetFsMIY1731MepAisPriority (u4ContextId, u4MdIndex,
                                       u4MaIndex, u4MepId, &i4RetPriority);
        nmhGetFsMIY1731MepAisDropEnable (u4ContextId, u4MdIndex,
                                         u4MaIndex, u4MepId, &i4RetDropEnable);
        CliPrintf (CliHandle, "\r\n%-37s", "Period");
        CliPrintf (CliHandle, "%-3s", ":");
        CliPrintf (CliHandle, "%d seconds", u4RetPeriod);

        CliPrintf (CliHandle, "\r\n%-37s", "Drop-Eligibility");
        CliPrintf (CliHandle, "%-3s", ":");

        if (i4RetDropEnable == 1)
        {
            CliPrintf (CliHandle, "%s", "Enabled");
        }
        else
        {
            CliPrintf (CliHandle, "%s", "Disabled");
        }

        CliPrintf (CliHandle, "\r\n%-37s", "Interval");
        CliPrintf (CliHandle, "%-3s", ":");

        if (i4RetInterval == ECFM_CC_AIS_LCK_INTERVAL_1_SEC)
        {
            CliPrintf (CliHandle, "%s", "1 seconds");
        }
        else
        {
            CliPrintf (CliHandle, "%s", "1 minute");
        }
    }

    CliPrintf (CliHandle, "\r\n\nError Or Cross Connect PDU Received \r\n");
    CliPrintf (CliHandle, "-----------------------------------");
    if (ErrorCcmRcvd.i4_Length != 0)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last Error CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":");
        for (u1Index = 1; u1Index <= ErrorCcmRcvd.i4_Length; u1Index++)
        {
            if (u1Index <= ECFM_MAX_CCM_PDU_SIZE)
            {
                CliPrintf (CliHandle, " %02x", au1ErrorCcmRcvd[u1Index - 1]);
                if ((u1Index != 0) && (!(u1Index % 13)))
                {
                    CliPrintf (CliHandle, "\n");
                    CliPrintf (CliHandle, "%-39s", " ");
                }
            }
        }
    }
    else
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last Error CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":  None");
    }
    if (XconCcmRcvd.i4_Length != 0)
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last XCON CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":");
        for (u1Index = 1; u1Index <= XconCcmRcvd.i4_Length; u1Index++)
        {
            if (u1Index <= ECFM_MAX_CCM_PDU_SIZE)
            {
                CliPrintf (CliHandle, " %02x", au1XconCcmRcvd[u1Index - 1]);
                if ((u1Index != 0) && (!(u1Index % 13)))
                {
                    CliPrintf (CliHandle, "\n");
                    CliPrintf (CliHandle, "%-39s", " ");
                }
            }
        }
    }
    else
    {
        CliPrintf (CliHandle, "\r\n%-37s", "Last XCON CCM PDU");
        CliPrintf (CliHandle, "%-2s", ":  None");
    }
    CliPrintf (CliHandle, "\r\n");
    return;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : MplsOamCliShowRMep
 *
 *     DESCRIPTION      : This function will display the contents for the remote
 *                        mep .
 *
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Type - Type of command
 *                        pu1Arg1 - MepId
 *                        pu1Arg2 - Level
 *                        pu1Arg3 - Service Name
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
MplsOamCliShowRMep (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4Type,
                    UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT1 *pu1MaName)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tEcfmCcMepInfo     *pMepNode = NULL;
    unEcfmMplsPathParams *pMplsPathParams = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4RetCcmSeqErrors = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = ECFM_INIT_VAL;
    UINT4               u4RMepId = ECFM_INIT_VAL;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4RetRMepRdi = ECFM_INIT_VAL;
    INT4                i4RetRMepState = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT4               u4MdLevel = ECFM_INIT_VAL;
    BOOL1               b1MdEntry = ECFM_FALSE;
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1RMepEntry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_TRUE;
    BOOL1               b1MplsService = ECFM_FALSE;

    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)
    {
        if ((u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV_SER) ||
            (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV) ||
            (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_SER) ||
            (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID))
        {
            CliPrintf (CliHandle, "\r\nProvided RMep doesn't exist\r\n");
        }
        else if (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_LEVEL)
        {
            CliPrintf (CliHandle, "\r\nProvided MD Level doesn't exist\r\n");
        }

        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    /* Scan Remote Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll))
    {
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;

        ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;

        i4RetMdLevel = ECFM_INIT_VAL;
        u4RetCcmSeqErrors = ECFM_INIT_VAL;
        i4RetRMepRdi = ECFM_INIT_VAL;
        i4RetRMepState = ECFM_INIT_VAL;

        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepCcmSequenceErrors (i4CurrentContextId, u4MdIndex,
                                            u4MaIndex, u4MepIdentifier,
                                            &u4RetCcmSeqErrors);
        nmhGetFsMIEcfmMepDbRMepState (i4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      u4RMepIdentifier, &i4RetRMepState);
        nmhGetFsMIEcfmMepDbRdi (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                u4MepIdentifier, u4RMepIdentifier,
                                &i4RetRMepRdi);
        nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (ECFM_CC_SELECT_CONTEXT (i4CurrentContextId) != ECFM_SUCCESS)
        {
            return CLI_FAILURE;
        }
        /* Get MA entry corresponding to indices MdIndex, MaIndex */
        pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
        if (pMaNode == NULL)
        {
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_SUCCESS;
        }

        u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

        switch (u4Type)
        {
            case CLI_MPLSTPOAM_SHOW_RMEP_LEVEL:
                if (pu1Arg2 == NULL)
                    break;

                MEMCPY (&u4MdLevel, pu1Arg2, sizeof (UINT4));

                if ((UINT4) (i4RetMdLevel) == u4MdLevel)
                {
                    b1MdEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_ALL:
                b1Entry = ECFM_TRUE;
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV_SER:
                MEMCPY (&u4RMepId, pu1Arg1, sizeof (UINT4));
                MEMCPY (&u4MdLevel, pu1Arg2, sizeof (UINT4));

                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1RMepEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }

                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV:
                MEMCPY (&u4RMepId, pu1Arg1, sizeof (UINT4));
                MEMCPY (&u4MdLevel, pu1Arg2, sizeof (UINT4));

                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel))
                {
                    b1RMepEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_SER:
                MEMCPY (&u4RMepId, pu1Arg1, sizeof (UINT4));

                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1RMepEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID:
                MEMCPY (&u4RMepId, pu1Arg1, sizeof (UINT4));

                if (u4RMepIdentifier == u4RMepId)
                {
                    b1RMepEntry = ECFM_TRUE;
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            if ((u4Type != CLI_MPLSTPOAM_SHOW_RMEP_LEVEL) &&
                (u4Type != CLI_MPLSTPOAM_SHOW_RMEP_ALL))
            {
                /* Domain/Level of remote mep */
                CliPrintf (CliHandle, "\r\nLevel                : %d",
                           i4RetMdLevel);

                if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                {
                    CliPrintf (CliHandle, "\r\nServiceType          : %s",
                               "LSP");
                    b1MplsService = ECFM_TRUE;
                }
                else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                {
                    CliPrintf (CliHandle, "\r\nServiceType          : %s",
                               "PW");
                    b1MplsService = ECFM_TRUE;
                }

                if (b1MplsService == TRUE)
                {
                    pMepNode = EcfmCcUtilGetMepEntryFrmGlob (u4MdIndex,
                                                             u4MaIndex,
                                                             u4MepIdentifier);
                    if (pMepNode != NULL)
                    {
                        pMplsPathParams =
                            &(pMepNode->pEcfmMplsParams->MplsPathParams);
                        if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                        {
                            CliPrintf (CliHandle, "\r\n   LSP Path Params   : "
                                       "Tnl: %u  Lsp-Num: %u  Src: %u  Dest: %u",
                                       pMplsPathParams->MplsLspParams.
                                       u4TunnelId,
                                       pMplsPathParams->MplsLspParams.
                                       u4TunnelInst,
                                       pMplsPathParams->MplsLspParams.u4SrcLer,
                                       pMplsPathParams->MplsLspParams.u4DstLer);
                        }
                        else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                        {
                            CliPrintf (CliHandle, "\r\n   PW Path Params    : "
                                       "VC-Id: %u", pMplsPathParams->u4PswId);
                        }
                    }
                }

                /* MEPID of mep */
                CliPrintf (CliHandle, "\r\nMPID                 : %u",
                           u4MepIdentifier);

                /* MEPID of remote mep */
                CliPrintf (CliHandle, "\r\nRMPID                : %u",
                           u4RMepIdentifier);

                switch (i4RetRMepState)
                {
                    case ECFM_RMEP_IDLE:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Idle");
                        break;
                    case ECFM_RMEP_START:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Start");
                        break;
                    case ECFM_RMEP_FAILED:
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP State     : Failed");
                        break;
                    case ECFM_RMEP_OK:
                        CliPrintf (CliHandle, "\r\nRemote MEP State     : Ok");
                        break;
                    default:
                        break;
                }

                if (i4RetRMepState == ECFM_RMEP_OK)
                {
                    /* RDI bit of Remote MEP */
                    if (i4RetRMepRdi == ECFM_SNMP_TRUE)
                    {
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP Rdi       : True");
                    }
                    else
                    {
                        CliPrintf (CliHandle,
                                   "\r\nRemote MEP Rdi       : False");
                    }
                }
            }
            else
            {
                if (b1Header == ECFM_TRUE)
                {
                    CliPrintf (CliHandle, "%-6s%-5s%-13s%-6s%-6s", "RMPID",
                               "MPID", "ServiceType", "Level", "Mep-Up");
                    CliPrintf (CliHandle, "\r\n");
                    b1Header = ECFM_FALSE;
                }

                /* MEPID of remote mep */
                CliPrintf (CliHandle, "%-6u", u4RMepIdentifier);

                /* MEPID of mep */
                CliPrintf (CliHandle, "%-5u", u4MepIdentifier);

                if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                {
                    CliPrintf (CliHandle, "%-13s", "LSP");
                }
                else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                {
                    CliPrintf (CliHandle, "%-13s", "PW");
                }

                /* DomainLevel of remote mep */
                CliPrintf (CliHandle, "%-6u", i4RetMdLevel);

                /* Status */
                if (i4RetRMepState == ECFM_RMEP_OK)
                {
                    CliPrintf (CliHandle, "%-6s", "Yes");
                }
                else
                {
                    CliPrintf (CliHandle, "%-6s", "No");
                }
            }
            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId,
                                                      u4MdIndex,
                                                      &u4NextMdIndex,
                                                      u4MaIndex,
                                                      &u4NextMaIndex,
                                                      u4MepIdentifier,
                                                      &u4NextMepIdentifier,
                                                      u4RMepIdentifier,
                                                      &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1ShowAll = ECFM_FALSE;
            }

            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt, no more print required,
             * exit */
            b1ShowAll = ECFM_FALSE;
        }

        b1Entry = ECFM_FALSE;
    }

    if ((u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV_SER) ||
        (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_LEV) ||
        (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID_SER) ||
        (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_CC_MPID))
    {
        if (b1RMepEntry == ECFM_FALSE)
        {
            CliPrintf (CliHandle, "\r\nProvided RMep doesn't exist\r\n");
        }
    }
    else if (u4Type == CLI_MPLSTPOAM_SHOW_RMEP_LEVEL)
    {
        if (b1MdEntry == ECFM_FALSE)
        {
            CliPrintf (CliHandle, "\r\nProvided MD Level doesn't exist\r\n");
        }
    }

    ECFM_CC_RELEASE_CONTEXT ();
    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : MplsOamCliShowErrors
 *
 *     DESCRIPTION      : This function will show all remote MEPs related
 *                        errors belonging to same domain or level or all
 *                        and for all remote MEPs if no input is specified
 *
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4Type - Type of command
 *                        pu1arg1 - Maintenance Domain or Level of MEP
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ****************************************************************************/
INT4
MplsOamCliShowErrors (tCliHandle CliHandle, UINT4 u4ContextId,
                      UINT4 u4Type, INT1 *pu1MdLevel)
{

    /* Input parameters */
    UINT4               u4MdLevel = ECFM_INIT_VAL;

    /* Variables to scan MEP table */
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    /* Various defects */
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMepPortNum = ECFM_INIT_VAL;
    INT4                i4RetPortOperStatus = ECFM_INIT_VAL;
    UINT2               u2Header = ECFM_INIT_VAL;
    UINT1               au1MdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1Defects[ECFM_NUM_OF_MEP_DEFECTS];
    UINT1               u1Defects = ECFM_INIT_VAL;
    UINT1               u1DftsVal = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tSNMP_OCTET_STRING_TYPE RetDefects;

    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        b1SameContext = ECFM_FALSE;
        return CLI_SUCCESS;
    }

    /* Scan Mep Table to show errors for MEP as well as remote MEPs */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {

        /* Initialise variable for the entry */
        u4RetMdLevel = ECFM_INIT_VAL;
        ECFM_MEMSET (au1MdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (au1Defects, ECFM_INIT_VAL, ECFM_NUM_OF_MEP_DEFECTS);
        ECFM_MEMSET (&RetDefects, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        RetDefects.pu1_OctetList = au1Defects;
        RetDefects.i4_Length = 0;

        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex,
                                 (INT4 *) &u4RetMdLevel);

        /* check if this entry is having Md Level */
        switch (u4Type)
        {
            case CLI_MPLSTPOAM_SHOW_ERR_LEV:
                MEMCPY (&u4MdLevel, pu1MdLevel, sizeof (UINT4));
                if (u4RetMdLevel == u4MdLevel)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_ERR_ALL:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        /* Show all the errors corresponding to MEP and its associated
         * remote MEPs */
        if (b1Entry == ECFM_TRUE)
        {
            i4RetMepPortNum = ECFM_INIT_VAL;
            i4RetPortOperStatus = ECFM_INIT_VAL;

            nmhGetFsMIY1731PortOperStatus (i4RetMepPortNum,
                                           &i4RetPortOperStatus);

            /* If Y1731 is Disabled */
            if (i4RetPortOperStatus == ECFM_DISABLE)
            {
                return CLI_FAILURE;
            }
            else
            {
                /* Display only Y1731 related errors */
                nmhGetFsMIY1731MepDefectConditions (i4CurrentContextId,
                                                    u4MdIndex, u4MaIndex,
                                                    u4MepIdentifier,
                                                    &RetDefects);

                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ZERO];
                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_RDI_ERRS) == CLI_ECFM_CC_RDI_ERRS)
                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_RDI_CCM_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_LOC_ERRS) == CLI_ECFM_CC_LOC_ERRS)
                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else

                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_LOC_DFCT_ENTRY, b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_PERIOD_ERRS) ==
                    CLI_ECFM_CC_UNEXP_PERIOD_ERRS)
                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_UNEXP_PERIOD_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_MEP_ERRS) ==
                    CLI_ECFM_CC_UNEXP_MEP_ERRS)
                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_UNEXP_MEP_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_MISMERGE_ERRS) ==
                    CLI_ECFM_CC_MISMERGE_ERRS)
                {
                    u2Header = u2Header + 1;
                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_MISMERGE_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_UNEXP_LEV_ERRS) ==
                    CLI_ECFM_CC_UNEXP_LEV_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_CC_LINK_FAIL_ERRS) ==
                    CLI_ECFM_CC_LINK_FAIL_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_LOCAL_LINK_FAIL_DFCT_ENTRY,
                                                 b1Header);
                }

                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_HW_FAIL_ERRS) ==
                    CLI_ECFM_HW_FAIL_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_INTERNAL_HW_FAIL_DFCT_ENTRY,
                                                 b1Header);
                }

                u1Defects = 0;
                u1DftsVal = 0;
                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_SW_FAIL_ERRS) ==
                    CLI_ECFM_SW_FAIL_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_INTERNAL_SW_FAIL_DFCT_ENTRY,
                                                 b1Header);
                }

                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_AIS_ERRS) == CLI_ECFM_AIS_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_AIS_CONDITION_ENTRY,
                                                 b1Header);
                }

                u1Defects = RetDefects.pu1_OctetList[ECFM_INDEX_ONE];
                u1DftsVal = u1Defects;

                if ((u1DftsVal & CLI_ECFM_LCK_ERRS) == CLI_ECFM_LCK_ERRS)
                {
                    u2Header = u2Header + 1;

                    if (u2Header == 1)
                    {
                        b1Header = ECFM_TRUE;
                    }
                    else
                    {
                        b1Header = ECFM_FALSE;
                    }

                    MplsOamShowRMepY1731Defects (CliHandle, i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier, u4RetMdLevel,
                                                 ECFM_LCK_CONDITION_ENTRY,
                                                 b1Header);
                }
            }                    /* end of else */
        }

        /* move to next MEP */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (i4CurrentContextId,
                                                    (UINT4 *)
                                                    &i4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;

            /* Reset variables for the next entry */
            b1Entry = ECFM_FALSE;
            b1Header = ECFM_FALSE;
            u2Header = ECFM_INIT_VAL;
        }

        if (i4CurrentContextId != i4NextContextId)
        {
            b1SameContext = ECFM_FALSE;
            b1Header = ECFM_FALSE;
            u2Header = ECFM_INIT_VAL;
        }
    }                            /* end of while */
    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : MplsOamShowRMepY1731Defects
 *
 *     DESCRIPTION      : This function will show all remote MEPs related
 *                        errors corresponding to particular MEP indices.
 *
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ContextId - Context Identifier
 *                        u4MdId - Md Index of MEP
 *                        u4MaId - Ma Index of MEP
 *                        u4MepId - MepId of MEP
 *                        u4MdLevel - MdLevel of MEP
 *                        i1Def - Particular defect to be shown
 *                        b1Header - Boolean flag to indicate if header is to
 *                                   be shown.
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : None
 *
 ****************************************************************************/
PRIVATE VOID
MplsOamShowRMepY1731Defects (tCliHandle CliHandle, UINT4 u4ContextId,
                             UINT4 u4MdId, UINT4 u4MaId, UINT4 u4MepId,
                             UINT4 u4MdLevel, INT1 i1Def, BOOL1 b1Header)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrRMepId = ECFM_INIT_VAL;
    UINT4               u4XconnRMepId = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RDIDefect = ECFM_INIT_VAL;
    INT4                i4RCcmDefect = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1RMepFound = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    UINT1              *apu1Y1731Reason[] = {
        (UINT1 *) "remote defect indication",
        (UINT1 *) "loss of continuity",
        (UINT1 *) "unexpected period",
        (UINT1 *) "unexpected MEP",
        (UINT1 *) "mismerge",
        (UINT1 *) "unexpected level",
        (UINT1 *) "locally link failure",
        (UINT1 *) "internal h/w failure",
        (UINT1 *) "internal s/w failure",
        (UINT1 *) "ais condition",
        (UINT1 *) "lck condition"
    };
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];

    if (b1Header == ECFM_TRUE)
    {
        CliPrintf (CliHandle, "\r\n%-10s%-10d", "MEP-ID : ", u4MepId);
        CliPrintf (CliHandle,
                   "\r\n%-8s%-12s%-13s%-10s%-35s\r\n",
                   "Level", "Service", "ServiceType", "RMEP-ID",
                   "Current defect type");
        CliPrintf (CliHandle, "%-8s%-12s%-13s%-10s%-35s\r\n", "-----",
                   "-------", "-----------", "-------", "-------------------");
    }

    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;

    nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdId, u4MaId, &RetMaName);
    nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdId, u4MaId, &i4RetMaFormat);

    MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

    if (ECFM_CC_SELECT_CONTEXT (i4CurrentContextId) != ECFM_SUCCESS)
    {
        return;
    }
    /* Get MA entry corresponding to indices MdIndex, MaIndex */
    pMaNode = EcfmSnmpLwGetMaEntry (u4MdId, u4MaId);
    if (pMaNode == NULL)
    {
        ECFM_CC_RELEASE_CONTEXT ();
        return;
    }

    u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

    /* Check if the error is software failure or hardware failure which
     * are not related to any remote MEP. */
    if ((i1Def == ECFM_INTERNAL_SW_FAIL_DFCT_ENTRY) ||
        (i1Def == ECFM_INTERNAL_HW_FAIL_DFCT_ENTRY) ||
        (i1Def == ECFM_AIS_CONDITION_ENTRY) ||
        (i1Def == ECFM_LCK_CONDITION_ENTRY))
    {
        CliPrintf (CliHandle, "%-8u", u4MdLevel);
        CliPrintf (CliHandle, "%-12s", au1StrMaName);
        if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)

        {
            CliPrintf (CliHandle, "%-13s", "LSP");
        }
        else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
        {
            CliPrintf (CliHandle, "%-13s", "PW");
        }
        else
        {
            CliPrintf (CliHandle, "%-13s", "-");
        }
        CliPrintf (CliHandle, "%-10s", "-");
        CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        CliPrintf (CliHandle, "\r\n");
        return;
    }

    /* Check if the error is Unexp Period, Unexp MEP, Unexp Level or Mismerge
     * which are related to a particular remote MEP. */
    if ((i1Def == ECFM_UNEXP_PERIOD_DFCT_ENTRY) ||
        (i1Def == ECFM_UNEXP_MEP_DFCT_ENTRY) ||
        (i1Def == ECFM_MISMERGE_DFCT_ENTRY) ||
        (i1Def == ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY))
    {
        CliPrintf (CliHandle, "%-8u", u4MdLevel);
        CliPrintf (CliHandle, "%-12s", au1StrMaName);
        if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)

        {
            CliPrintf (CliHandle, "%-13s", "LSP");
        }
        else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
        {
            CliPrintf (CliHandle, "%-13s", "PW");
        }
        else
        {
            CliPrintf (CliHandle, "%-13s", "-");
        }

        if ((i1Def == ECFM_UNEXP_MEG_LEVEL_DFCT_ENTRY) ||
            (i1Def == ECFM_MISMERGE_DFCT_ENTRY))
        {
            nmhGetFsMIEcfmXconnRMepId (u4ContextId, u4MdId, u4MaId,
                                       u4MepId, &u4XconnRMepId);
            CliPrintf (CliHandle, "%-10u", u4XconnRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        }
        else if ((i1Def == ECFM_UNEXP_PERIOD_DFCT_ENTRY) ||
                 (i1Def == ECFM_UNEXP_MEP_DFCT_ENTRY))
        {
            nmhGetFsMIEcfmErrorRMepId (u4ContextId, u4MdId, u4MaId,
                                       u4MepId, &u4ErrRMepId);
            CliPrintf (CliHandle, "%-10u", u4ErrRMepId);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        }

        CliPrintf (CliHandle, "\r\n");
        return;
    }
    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmRemoteMepDbExTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_RMEP_CONFIG_MA_ERR);
        return;
    }
    if ((UINT4) (i4NextContextId) != u4ContextId)

    {
        return;
    }
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {

        /* Check if remote MEP is remote to MEP with indices u4MdId, u4MaId,
         * u4MepId */
        if ((u4MdIndex == u4MdId) &&
            (u4MaIndex == u4MaId) && (u4MepIdentifier == u4MepId))

        {

            /* Y.1731 related defects */
            /* Check if remote MEP is cause of particular defect  */
            switch (i1Def)

            {
                case ECFM_RDI_CCM_DFCT_ENTRY:
                    nmhGetFsMIEcfmRMepRDIDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RDIDefect);
                    if (i4RDIDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                case ECFM_LOC_DFCT_ENTRY:
                    nmhGetFsMIEcfmRMepCcmDefect (i4CurrentContextId,
                                                 u4MdIndex, u4MaIndex,
                                                 u4MepIdentifier,
                                                 u4RMepIdentifier,
                                                 &i4RCcmDefect);
                    if (i4RCcmDefect == ECFM_SNMP_TRUE)

                    {
                        b1RMepFound = ECFM_TRUE;
                        b1Entry = ECFM_TRUE;
                    }
                    break;
                default:
                    break;
            }
        }

        /* Check if entry found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Show particular defect corresponding to remote MEP  */
            CliPrintf (CliHandle, "%-8u", u4MdLevel);
            CliPrintf (CliHandle, "%-12s", au1StrMaName);
            if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)

            {
                CliPrintf (CliHandle, "%-13s", "LSP");
            }
            else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
            {
                CliPrintf (CliHandle, "%-13s", "PW");
            }
            else
            {
                CliPrintf (CliHandle, "%-13s", "-");
            }

            CliPrintf (CliHandle, "%-10u", u4RMepIdentifier);
            CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
            CliPrintf (CliHandle, "\r\n");
        }

        /* move to next remote MEP */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmRemoteMepDbExTable (i4CurrentContextId,
                                                       (UINT4 *)
                                                       &i4NextContextId,
                                                       u4MdIndex,
                                                       &u4NextMdIndex,
                                                       u4MaIndex,
                                                       &u4NextMaIndex,
                                                       u4MepIdentifier,
                                                       &u4NextMepIdentifier,
                                                       u4RMepIdentifier,
                                                       &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }
        if (i4CurrentContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }

        /* Reset variables for the next entry */
        b1Entry = ECFM_FALSE;
        i4RDIDefect = ECFM_SNMP_FALSE;
        i4RCcmDefect = ECFM_SNMP_FALSE;
    }

    /* When there is no remote MEP with the defect */
    if (b1RMepFound != ECFM_TRUE)

    {
        CliPrintf (CliHandle, "%-8u", u4MdLevel);
        CliPrintf (CliHandle, "%-12s", au1StrMaName);
        if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)

        {
            CliPrintf (CliHandle, "%-5s", "LSP");
        }
        else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
        {
            CliPrintf (CliHandle, "%-5s", "PW");
        }
        else
        {
            CliPrintf (CliHandle, "%-5s", "-");
        }

        CliPrintf (CliHandle, "%-10s", "-");
        CliPrintf (CliHandle, "%-35s", apu1Y1731Reason[i1Def - 1]);
        CliPrintf (CliHandle, "\r\n");
    }
    return;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : MplsOamCliShowRMepInXChkList
 *
 *     DESCRIPTION      : This function will display the status of remote mep
 *                        mpid at a specified level or vlan.
 *
 *     INPUT            : CliHandle - CliContext ID
 *                        u4Type - Type of command
 *                        pu1Arg1 -
 *                        pu1Arg2 -
 *                        pu1Arg3 -
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 ******************************************************************************/
INT4
MplsOamCliShowRMepInXChkList (tCliHandle CliHandle, UINT4 u4ContextId,
                              UINT4 u4Type, UINT1 *pu1RMepId, UINT1 *pu1MdLevel,
                              UINT1 *pu1MaName)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4PagingStatus = CLI_SUCCESS;
    UINT4               u4MaServiceType = 0;
    UINT4               u4RMepId = 0;
    UINT4               u4MdLevel = 0;
    INT4                i4RetMdFormat = ECFM_INIT_VAL;
    INT4                i4RetRMepState = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaFormat = SNMP_SUCCESS;
    UINT1               au1RetMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMdName[ECFM_MD_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];
    BOOL1               b1ShowAll = ECFM_TRUE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1Header = ECFM_TRUE;

    i4CurrentContextId = (INT4) (u4ContextId);

    /*Check for remote MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepDbTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier, 0, &u4RMepIdentifier) == SNMP_FAILURE)
    {
        return CLI_SUCCESS;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return CLI_SUCCESS;
    }

    if (pu1RMepId != NULL)
    {
        MEMCPY (&u4RMepId, pu1RMepId, sizeof (UINT4));
    }
    if (pu1MdLevel != NULL)
    {
        MEMCPY (&u4MdLevel, pu1MdLevel, sizeof (UINT4));
    }
    /* Scan Remote Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1ShowAll))
    {

        /* Reset variables for each entry */
        ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);
        ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));
        ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                     sizeof (tSNMP_OCTET_STRING_TYPE));

        RetMaName.pu1_OctetList = au1RetMaName;
        RetMaName.i4_Length = 0;
        RetMdName.pu1_OctetList = au1RetMdName;
        RetMdName.i4_Length = 0;
        i4RetMdLevel = ECFM_INIT_VAL;

        /* Get the required variables */
        nmhGetFsMIEcfmMdName (i4CurrentContextId, u4MdIndex, &RetMdName);
        nmhGetFsMIEcfmMdFormat (i4CurrentContextId, u4MdIndex, &i4RetMdFormat);
        nmhGetFsMIEcfmMepDbRMepState (i4CurrentContextId, u4MdIndex,
                                      u4MaIndex, u4MepIdentifier,
                                      u4RMepIdentifier, &i4RetRMepState);
        nmhGetFsMIEcfmMdMdLevel (i4CurrentContextId, u4MdIndex, &i4RetMdLevel);

        MEMSET (au1StrMdName, ECFM_INIT_VAL, ECFM_MD_NAME_ARRAY_SIZE);
        EcfmUtilMdNameOctetStrToStr (&RetMdName, i4RetMdFormat, au1StrMdName);

        nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                              &RetMaName);
        nmhGetFsMIEcfmMaFormat (u4ContextId, u4MdIndex, u4MaIndex,
                                &i4RetMaFormat);

        MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
        EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, au1StrMaName);

        if (ECFM_CC_SELECT_CONTEXT (i4CurrentContextId) != ECFM_SUCCESS)
        {
            return CLI_FAILURE;
        }

        /* Get MA entry corresponding to indices MdIndex, MaIndex */
        pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
        if (pMaNode == NULL)
        {
            ECFM_CC_RELEASE_CONTEXT ();
            return CLI_SUCCESS;
        }

        u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

        /* Search for remote MEPs satisfying the conditions according to particular
         * command type */
        switch (u4Type)
        {
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_LEV:
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel))
                {
                    b1Entry = ECFM_TRUE;
                }

                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_LEV_SER:
                if ((u4RMepIdentifier == u4RMepId) &&
                    ((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_LEV_SER:
                if (((UINT4) (i4RetMdLevel) == u4MdLevel) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID_SER:
                if ((u4RMepIdentifier == u4RMepId) &&
                    (STRCMP (au1StrMaName, pu1MaName) == 0))
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_SER:
                if (STRCMP (au1StrMaName, pu1MaName) == 0)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_LEV:
                if ((UINT4) (i4RetMdLevel) == u4MdLevel)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK_MPID:
                if (u4RMepIdentifier == u4RMepId)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_MPLSTPOAM_SHOW_RMEP_XCHK:
                b1Entry = ECFM_TRUE;
                break;
            default:
                break;
        }

        if (b1Entry == ECFM_TRUE)
        {
            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\n%-6s%-5s%-6s%-13s%-s\r\n",
                           "RMPID", "MPID", "Level", "ServiceType", "Mep-Up");
                b1Header = ECFM_FALSE;
            }

            /* MEPID of mep */
            CliPrintf (CliHandle, "%-6u", u4RMepIdentifier);

            /* MEPID of remote mep */
            CliPrintf (CliHandle, "%-5u", u4MepIdentifier);

            /* Level of remote mep */
            CliPrintf (CliHandle, "%-6d", i4RetMdLevel);

            if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
            {
                CliPrintf (CliHandle, "%-13s", "LSP");
            }
            else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
            {
                CliPrintf (CliHandle, "%-13s", "PW");
            }
            else
            {
                CliPrintf (CliHandle, "%-13s", "-");
            }

            /* Status of remote MEP */
            if (i4RetRMepState == ECFM_RMEP_OK)
            {
                CliPrintf (CliHandle, "%-s", "Yes");
            }
            else
            {
                CliPrintf (CliHandle, "%-s", "No");
            }

            u4PagingStatus = CliPrintf (CliHandle, "\r\n");
        }

        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepDbTable (i4CurrentContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId,
                                                      u4MdIndex,
                                                      &u4NextMdIndex,
                                                      u4MaIndex,
                                                      &u4NextMaIndex,
                                                      u4MepIdentifier,
                                                      &u4NextMepIdentifier,
                                                      u4RMepIdentifier,
                                                      &u4NextRMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1ShowAll = ECFM_FALSE;
            }

            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
            u4RMepIdentifier = u4NextRMepIdentifier;
        }

        if (u4PagingStatus == CLI_FAILURE)
        {
            /* User pressed 'q' at more prompt, no more print required,
             * exit */
            b1ShowAll = ECFM_FALSE;
        }

        /* Reset for next entry */
        b1Entry = ECFM_FALSE;
    }

    return CLI_SUCCESS;
}

/****************************************************************************
 *
 *     FUNCTION NAME    : MplsOamShowXchkParams
 *
 *     DESCRIPTION      : This function will show the crosscheck list
 *                        information for a particualar MD or MA
 *
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4Type -  Command
 *                        u4ContextId - Context Identifier
 *                        u4MdId - MD Index
 *                        u4MaId - MA Index
 *                        b1Header - True, indicates that header to be printed.
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : None
 *
 ****************************************************************************/
PRIVATE VOID
MplsOamShowXchkParams (tCliHandle CliHandle, UINT4 u4Type, UINT4 u4ContextId,
                       UINT4 u4MdId, UINT4 u4MaId, BOOL1 b1Header)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    INT4                i4RetVal = ECFM_INIT_VAL;
    INT4                i4CurrContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4MepActive = ECFM_INIT_VAL;
    INT4                i4RMepState = ECFM_INIT_VAL;
    INT4                i4RetMepRowStatus = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = ECFM_INIT_VAL;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaMepListIndex = ECFM_INIT_VAL;
    UINT4               u4LocalMepId = ECFM_INIT_VAL;
    UINT4               u4NextMaMepListIndex = ECFM_INIT_VAL;
    BOOL1               b1SameContext = ECFM_TRUE;

    i4CurrContextId = (INT4) (u4ContextId);

    i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                      (UINT4 *)
                                                      &i4NextContextId, 0,
                                                      &u4MdIndex, 0,
                                                      &u4MaIndex, 0,
                                                      &u4MaMepListIndex);
    if (i4RetVal == SNMP_SUCCESS)
    {

        /* Check if it has entry for this particular context */
        if (i4CurrContextId != i4NextContextId)

        {
            b1SameContext = ECFM_FALSE;
        }
    }

    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))
    {
        if (((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE) &&
             (u4MdIndex == u4MdId) &&
             (u4MaIndex == u4MaId)) ||
            ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM) && (u4MdIndex == u4MdId)))
        {
            i4RetMepRowStatus = ECFM_INIT_VAL;
            i4MepActive = ECFM_INIT_VAL;
            u4LocalMepId = ECFM_INIT_VAL;

            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "Crosscheck:");
                CliPrintf (CliHandle,
                           "\r\n%-5s%-13s%-7s%s", "MPID",
                           "ServiceType", "Type", "Mep-Up");
                CliPrintf (CliHandle, "\r\n");
                b1Header = ECFM_FALSE;
            }

            /* If MEP is locally configured or not */
            if ((nmhGetFsMIEcfmMepRowStatus
                 (i4CurrContextId, u4MdIndex, u4MaIndex, u4MaMepListIndex,
                  &i4RetMepRowStatus) == SNMP_SUCCESS)
                && (i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE))
            {
                nmhGetFsMIEcfmMepActive (i4CurrContextId, u4MdIndex, u4MaIndex,
                                         u4MaMepListIndex, &i4MepActive);

                if (ECFM_CC_SELECT_CONTEXT (i4CurrContextId) != ECFM_SUCCESS)
                {
                    return;
                }

                /* Get MA entry corresponding to indices MdIndex, MaIndex */
                pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
                if (pMaNode == NULL)
                {
                    ECFM_CC_RELEASE_CONTEXT ();
                    return;
                }

                u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

                /* MepId */
                CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);

                if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                {
                    CliPrintf (CliHandle, "%-13s", "LSP");
                }
                else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                {
                    CliPrintf (CliHandle, "%-13s", "PW");
                }
                else
                {
                    CliPrintf (CliHandle, "%-13s", "-");
                }

                /* Type */
                CliPrintf (CliHandle, "%-7s", "Local");

                /* Status */
                if (i4MepActive == ECFM_SNMP_TRUE)
                {
                    CliPrintf (CliHandle, "%s", "Yes");
                }
                else
                {
                    CliPrintf (CliHandle, "%s", "No");
                }

                if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM) ||
                    (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE))
                {
                    CliPrintf (CliHandle, "\r\n");
                }
            }
            else
            {
                if (EcfmRemoteMep
                    (i4CurrContextId, u4MdIndex, u4MaIndex, u4MaMepListIndex,
                     &u4LocalMepId) == ECFM_TRUE)
                {

                    nmhGetFsMIEcfmMepDbRMepState (i4CurrContextId, u4MdIndex,
                                                  u4MaIndex, u4LocalMepId,
                                                  u4MaMepListIndex,
                                                  &i4RMepState);

                    if (ECFM_CC_SELECT_CONTEXT (i4CurrContextId) !=
                        ECFM_SUCCESS)
                    {
                        return;
                    }

                    /* Get MA entry corresponding to indices MdIndex, MaIndex */
                    pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
                    if (pMaNode == NULL)
                    {
                        ECFM_CC_RELEASE_CONTEXT ();
                        return;
                    }

                    u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

                    /* MepId */
                    CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);

                    if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                    {
                        CliPrintf (CliHandle, "%-13s", "LSP");
                    }
                    else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                    {
                        CliPrintf (CliHandle, "%-13s", "PW");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-13s", "-");
                    }

                    /* Type */
                    CliPrintf (CliHandle, "%-7s", "Remote");

                    /* Status */
                    if (i4RMepState == ECFM_RMEP_OK)
                    {
                        CliPrintf (CliHandle, "%s", "Yes");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%s", "No");
                    }

                    if ((u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM) ||
                        (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_SERVICE))
                    {
                        CliPrintf (CliHandle, "\r\n");
                    }
                }
                else
                {
                    /* Not configured */
                    /* MepId */
                    CliPrintf (CliHandle, "%-5u", u4MaMepListIndex);

                    if (ECFM_CC_SELECT_CONTEXT (i4CurrContextId) !=
                        ECFM_SUCCESS)
                    {
                        return;
                    }

                    /* Get MA entry corresponding to indices MdIndex, MaIndex */
                    pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
                    if (pMaNode == NULL)
                    {
                        ECFM_CC_RELEASE_CONTEXT ();
                        return;
                    }

                    u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

                    if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
                    {
                        CliPrintf (CliHandle, "%-13s", "LSP");
                    }
                    else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
                    {
                        CliPrintf (CliHandle, "%-13s", "PW");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "%-13s", "-");
                    }

                    /* Type */
                    CliPrintf (CliHandle, "%-7s", "Not configured");

                    /* Status */
                    CliPrintf (CliHandle, "%-7s", "No");
                    if (u4Type == CLI_Y1731_MPLSTPOAM_SHOW_DOM)
                    {
                        CliPrintf (CliHandle, "\r\n");
                    }
                    else
                    {
                        CliPrintf (CliHandle, "-\r\n");
                    }
                }
            }
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaMepListTable (i4CurrContextId,
                                                          (UINT4 *)
                                                          &i4NextContextId,
                                                          u4MdIndex,
                                                          &u4NextMdIndex,
                                                          u4MaIndex,
                                                          &u4NextMaIndex,
                                                          u4MaMepListIndex,
                                                          &u4NextMaMepListIndex);

        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MaMepListIndex = u4NextMaMepListIndex;

            /* Check for the same context */
            if (i4CurrContextId != i4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
            }
        }
    }
    ECFM_CC_RELEASE_CONTEXT ();
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : MplsOamCliShowGlobalInfo                           */
/*                                                                           */
/*     DESCRIPTION      : This function displays global information in ECFM  */
/*                                                                           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : None                                               */
/*                                                                           */
/*****************************************************************************/
INT4
MplsOamCliShowGlobalInfo (tCliHandle CliHandle, UINT4 u4ContextId)
{

    tSNMP_OCTET_STRING_TYPE Y1731TrapOption;
    INT4                i4OffLoadStatus = ECFM_INIT_VAL;
    INT4                i4SystemControl = ECFM_INIT_VAL;
    INT4                i4MepCrosscheckDelay = ECFM_INIT_VAL;
    UINT1               au1Y1731TrapOption[ECFM_ARRAY_SIZE_2] = { 0 };
    UINT1               u1CurY1731TrapOptionMsb = ECFM_INIT_VAL;
    UINT1               u1CurY1731TrapOptionLsb = ECFM_INIT_VAL;
    UINT1               u1TempChar = ECFM_INIT_VAL;    /* For displaying the traps */
    BOOL1               b1TrapEnabled = ECFM_FALSE;

    /* SystemControl */
    nmhGetFsMIEcfmSystemControl (u4ContextId, &i4SystemControl);

    /* Checking SystemControl value other than default value */
    if (i4SystemControl == ECFM_SHUTDOWN)
    {
        CliPrintf (CliHandle, "ECFM Status : Shutdown.\r\n");
        return CLI_SUCCESS;
    }

    /* Off-Load Status */
    nmhGetFsMIEcfmGlobalCcmOffload (u4ContextId, &i4OffLoadStatus);
    if (i4OffLoadStatus == ECFM_ENABLE)
    {
        CliPrintf (CliHandle, "\r\nCC OffLoad Status : Enabled\r\n");
    }
    else
    {
        CliPrintf (CliHandle, "\r\nCC OffLoad Status : Disabled\r\n");
    }

    CliPrintf (CliHandle, "\r\n");

    /*Mep Cross Check Delay */
    nmhGetFsMIEcfmCrosscheckDelay (u4ContextId, &i4MepCrosscheckDelay);
    CliPrintf (CliHandle, "Cross-Check Delay               : %u\r\n",
               i4MepCrosscheckDelay);

    /*Trap Option Y1731 */
    ECFM_MEMSET (&Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (au1Y1731TrapOption));
    Y1731TrapOption.pu1_OctetList = au1Y1731TrapOption;
    Y1731TrapOption.i4_Length = 0;

    if (nmhGetFsMIY1731TrapControl (u4ContextId, &Y1731TrapOption) ==
        SNMP_FAILURE)
    {
        return CLI_FAILURE;
    }
    CliPrintf (CliHandle, "\r\nEnabled Traps\r\n");
    CliPrintf (CliHandle, "-------------\r\n");

    u1CurY1731TrapOptionLsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionMsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ONE];

    /* Ais Condition */
    if (Y1731_CLI_AIS_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
        == ECFM_TRUE)
    {
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "ais condition");
    }

    /* Internal Software Failure */
    if (Y1731_CLI_INTERNAL_SW_FAILURE_TRAP_ENABLED
        (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "internal s/w failure");
    }

    /* Internal Hardware Failure */
    if (Y1731_CLI_INTERNAL_HW_FAILURE_TRAP_ENABLED
        (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "internal h/w failure");
    }

    /*Local Link Failure  */
    if (Y1731_CLI_LOCAL_LINK_FAILURE_TRAP_ENABLED
        (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "local-link failure");
    }

    /* Unexpected Meg Level */
    if (Y1731_CLI_UNEXPECTED_MEG_LEVEL_TRAP_ENABLED
        (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
            (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "unexpected meg level");
    }

    /* Mis Merge */
    if (Y1731_CLI_MIS_MERGE_TRAP_ENABLED (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
            (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "mismerge");
    }

    /* Unexpected Mep */
    if (Y1731_CLI_UNEXPECTED_MEP_TRAP_ENABLED (u1CurY1731TrapOptionLsb)
        == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
            (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "unexpected mep");
    }

    /*Unexpected Period  */
    if (Y1731_CLI_UNEXPECTED_PERIOD_TRAP_ENABLED
        (u1CurY1731TrapOptionLsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
            (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "unexpected period");
    }

    /* Loss of Continuity */
    if (Y1731_CLI_LOC_TRAP_ENABLED (u1CurY1731TrapOptionLsb) == ECFM_TRUE)
    {
        b1TrapEnabled = ECFM_TRUE;
        if (u1TempChar >= 1)

        {
            CliPrintf (CliHandle, ", ");
        }
        if ((u1TempChar == ECFM_VAL_4) || (u1TempChar == ECFM_VAL_8) ||
            (u1TempChar == ECFM_VAL_12) || (u1TempChar == ECFM_VAL_16))

        {
            CliPrintf (CliHandle, "\r\n");
        }
        u1TempChar = u1TempChar + ECFM_INCR_VAL;
        CliPrintf (CliHandle, "loss of continuity");
    }

    if (b1TrapEnabled == FALSE)
    {
        CliPrintf (CliHandle, "No Traps Enabled\r\n");
    }

    CliPrintf (CliHandle, "\r\n");
    return CLI_SUCCESS;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : MplsOamShowXchkStatus  
 *                                                                          
 *     DESCRIPTION      : This function will show crosscheck status of a
 *                        Maintenance Domain
 *                                                                          
 *     INPUT            : CliHandle  - CliContext ID
 *                        u4ContextId - Context Identifier                                                 
 *                        u4MdIndex -  MD identifier
 *                        b1Header - True, indicates that header to be printed.
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 ****************************************************************************/
PRIVATE VOID
MplsOamShowXchkStatus (tCliHandle CliHandle, UINT4 u4ContextId, UINT4 u4MdId,
                       BOOL1 b1Header)
{
    tEcfmCcMaInfo      *pMaNode = NULL;
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4MaServiceType = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMaRowStatus = ECFM_INIT_VAL;
    INT4                i4RetMaFormat = ECFM_INIT_VAL;
    INT4                i4CurrentContextId = ECFM_INIT_VAL;
    INT4                i4NextContextId = ECFM_INIT_VAL;
    INT4                i4XchkStatus = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    BOOL1               b1SameContext = ECFM_TRUE;

    i4CurrentContextId = (INT4) (u4ContextId);

    if (nmhGetNextIndexFsMIEcfmMaTable
        (i4CurrentContextId, (UINT4 *) &i4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex) == SNMP_FAILURE)
    {
        return;
    }

    if ((UINT4) (i4NextContextId) != u4ContextId)
    {
        return;
    }

    /* MaTable not empty, now scan its each row */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext))
    {
        i4RetMaRowStatus = ECFM_INIT_VAL;

        nmhGetFsMIEcfmMaRowStatus (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                   &i4RetMaRowStatus);
        if ((u4MdId == u4MdIndex)
            && (i4RetMaRowStatus == ECFM_ROW_STATUS_ACTIVE))
        {
            i4XchkStatus = ECFM_INIT_VAL;
            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;

            nmhGetFsMIEcfmMaCrosscheckStatus (i4CurrentContextId, u4MdIndex,
                                              u4MaIndex, &i4XchkStatus);
            nmhGetFsMIEcfmMaName (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                  &RetMaName);
            nmhGetFsMIEcfmMaFormat (i4CurrentContextId, u4MdIndex, u4MaIndex,
                                    &i4RetMaFormat);

            MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat,
                                         au1StrMaName);

            if (ECFM_CC_SELECT_CONTEXT (i4CurrentContextId) != ECFM_SUCCESS)
            {
                return;
            }

            /* Get MA entry corresponding to indices MdIndex, MaIndex */
            pMaNode = EcfmSnmpLwGetMaEntry (u4MdIndex, u4MaIndex);
            if (pMaNode == NULL)
            {
                ECFM_CC_RELEASE_CONTEXT ();
                return;
            }

            u4MaServiceType = (UINT4) pMaNode->u1SelectorType;

            if (b1Header == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\n");
                CliPrintf (CliHandle, "%-13s%-11s%-22s", "ServiceType",
                           "Crosscheck", "ServiceID");
                CliPrintf (CliHandle, "\r\n");

                b1Header = ECFM_FALSE;
            }

            if (u4MaServiceType == ECFM_SERVICE_SELECTION_LSP)
            {
                CliPrintf (CliHandle, "%-13s", "LSP");
            }
            else if (u4MaServiceType == ECFM_SERVICE_SELECTION_PW)
            {
                CliPrintf (CliHandle, "%-13s", "PW");
            }
            else
            {
                CliPrintf (CliHandle, "%-13s", "-");
            }

            if (i4XchkStatus == ECFM_ENABLE)
            {
                CliPrintf (CliHandle, "%-11s", "Enabled");
            }
            else
            {
                CliPrintf (CliHandle, "%-11s", "Disabled");
            }
            CliPrintf (CliHandle, "%-22s\r\n", au1StrMaName);
        }

        /* Get next index */
        i4RetVal = nmhGetNextIndexFsMIEcfmMaTable (i4CurrentContextId,
                                                   (UINT4 *)
                                                   &i4NextContextId,
                                                   u4MdIndex,
                                                   &u4NextMdIndex,
                                                   u4MaIndex, &u4NextMaIndex);
        /* If valid index found */
        if (i4RetVal == SNMP_SUCCESS)
        {
            if (i4CurrentContextId != i4NextContextId)
            {
                b1SameContext = ECFM_FALSE;
            }

            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
        }
    }
    ECFM_CC_RELEASE_CONTEXT ();
    return;
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmUtilGetMaName                                  */
/*                                                                           */
/*     DESCRIPTION      : This function returns the MA name for the given MD */
/*                        MA index                                           */
/*                                                                           */
/*     INPUT            :                                                    */
/*                        u4ContextId - Context Identifier                   */
/*                        u4MdIndex - Md Index                               */
/*                        u4MaIndex - Ma Index                               */
/*                        pau1MaName- MA Name to be returned                 */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : None                                               */
/*****************************************************************************/
PRIVATE VOID
EcfmUtilGetMaName (UINT4 u4CurrContextId, UINT4 u4MdIndex, UINT4 u4MaIndex,
                   UINT1 *pau1MaName)
{
    tSNMP_OCTET_STRING_TYPE RetMaName;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    INT4                i4RetMaFormat = ECFM_INIT_VAL;

    ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL, sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
    RetMaName.pu1_OctetList = au1RetMaName;
    RetMaName.i4_Length = 0;
    nmhGetFsMIEcfmMaName (u4CurrContextId, u4MdIndex, u4MaIndex, &RetMaName);
    nmhGetFsMIEcfmMaFormat (u4CurrContextId, u4MdIndex, u4MaIndex,
                            &i4RetMaFormat);
    EcfmUtilMaNameOctetStrToStr (&RetMaName, i4RetMaFormat, pau1MaName);
    return;
}
/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliEthBnShowAllInfo                            */
/*                                                                           */
/*     DESCRIPTION      : This function displays All EthBn information       */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
INT4
EcfmCliEthBnShowAllInfo (tCliHandle CliHandle, UINT4 u4IfIndex)
{
    INT4   i4RetVal = SNMP_FAILURE;
    UINT4  u4CurrIfIdx = 0;

    /*  The CC_LOCK  is taken from the calling CLI function . The below function needs to be executed in the CC_LOCK */
    i4RetVal = nmhGetFirstIndexFsMIY1731EthBnPortTable ((INT4 *)&u4IfIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        return (CLI_FAILURE);
    }
    do
    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();

        i4RetVal = EcfmCliEthBnInfo (CliHandle, u4IfIndex);

        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();

        if (i4RetVal == CLI_FAILURE)
        {
            return (CLI_FAILURE);
        }

        u4CurrIfIdx = u4IfIndex;
        i4RetVal = nmhGetNextIndexFsMIY1731EthBnPortTable  (u4CurrIfIdx,(INT4 *) &u4IfIndex);
    }
    while (i4RetVal == SNMP_SUCCESS);
    return (CLI_SUCCESS);
}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliEthBnInfo                                   */
/*                                                                           */
/*     DESCRIPTION      : This function displays EthBn information           */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
INT4
EcfmCliEthBnInfo (tCliHandle CliHandle, UINT4 u4IfIndex)
{
  INT4  i4EthBnPortStatus = 0;
  INT4  i4EthBnTrapStatus = 0;
  UINT4 u4EthBnPeerOui = 0;
  UINT4 u4EthBnNominalBw = 0;
  UINT4 u4EthBnCurrentBw = 0;
  UINT4 u4EthBnGnmTimePeriod = 0;
  UINT1 au1IfName[CFA_MAX_PORT_NAME_LENGTH];

  nmhGetFsMIY1731EthBnPortStatus (u4IfIndex, &i4EthBnPortStatus);
  nmhGetFsMIY1731EthBnTrapStatus (u4IfIndex, &i4EthBnTrapStatus);
  nmhGetFsMIY1731EthBnPeerOui (u4IfIndex, &u4EthBnPeerOui);
  nmhGetFsMIY1731EthBnNominalBw (u4IfIndex, &u4EthBnNominalBw);
  nmhGetFsMIY1731EthBnCurrentBw (u4IfIndex, &u4EthBnCurrentBw);
  nmhGetFsMIY1731EthBnGnmTimePeriod (u4IfIndex, &u4EthBnGnmTimePeriod);

  MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
  MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);

  if (CfaCliGetIfName ( u4IfIndex, (INT1 *) au1IfName) ==
          CLI_FAILURE)
  {
      return (CLI_FAILURE);
  }
  CliPrintf (CliHandle, "\r\nETH-BN related Info for %-7s\r\n", au1IfName);
  CliPrintf (CliHandle, "\r----------------------------- \r\n ");
  if (i4EthBnPortStatus == ECFM_SNMP_TRUE)
  {
      CliPrintf (CliHandle, "\r\n%-25s : %s", "ETH-BN Status", "Enabled");
  }
  else
  {
      CliPrintf (CliHandle, "\r\n%-25s : %s", "ETH-BN Status", "Disabled");
  }
  if (i4EthBnTrapStatus == ECFM_SNMP_TRUE)
  {
      CliPrintf (CliHandle, "\r\n%-25s : %s", "ETH-BN Trap Status", "Enabled");
  }
  else
  {
      CliPrintf (CliHandle, "\r\n%-25s : %s", "ETH-BN Trap Status", "Disabled");
  }
  CliPrintf (CliHandle, "\r\n%-25s : %d", "ETH-BN OUI", u4EthBnPeerOui);
  CliPrintf (CliHandle, "\r\n%-25s : %d", "ETH-BN Nominal bandwidth", u4EthBnNominalBw);
  CliPrintf (CliHandle, "\r\n%-25s : %d", "ETH-BN Current bandwidth", u4EthBnCurrentBw);
  CliPrintf (CliHandle, "\r\n%-25s: %d",  "ETH-BN TimePeriod(secs)", u4EthBnGnmTimePeriod);
  CliPrintf (CliHandle, "\r\n");

    return CLI_SUCCESS;

}
/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliEthBnShowAllStat                            */
/*                                                                           */
/*     DESCRIPTION      : This function displays EthBn statistics            */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/

INT4
EcfmCliEthBnShowAllStat (tCliHandle CliHandle, UINT4 u4IfIndex)
{
    INT4   i4RetVal = SNMP_FAILURE;
    UINT4  u4CurrIfIdx = 0;

    i4RetVal = nmhGetFirstIndexFsMIY1731EthBnPortTable ((INT4 *)&u4IfIndex);
    if (i4RetVal == SNMP_FAILURE)
    {
        return (CLI_FAILURE);
    }

    do
    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();

        i4RetVal = EcfmCliEthBnStat (CliHandle, u4IfIndex);
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();

        if (i4RetVal == CLI_FAILURE)
        {
            return (CLI_FAILURE);
        }
        u4CurrIfIdx = u4IfIndex;
        i4RetVal = nmhGetNextIndexFsMIY1731EthBnPortTable(u4CurrIfIdx, (INT4 *)&u4IfIndex);
    }
    while (i4RetVal == SNMP_SUCCESS);

    return (CLI_SUCCESS);

}
/*****************************************************************************/
/*     FUNCTION NAME    : EcfmCliEthBnStat                                   */
/*                                                                           */
/*     DESCRIPTION      : This function displays EthBn Statistics            */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
INT4
EcfmCliEthBnStat (tCliHandle CliHandle, UINT4 u4IfIndex)
{
  tEcfmLbLtEthBnInfo EcfmLbLtEthBnInfo;
  UINT4 u4EthBnRateChangeStats = 0;
  UINT4 u4EthBnRxCount = 0;
  UINT1 au1IfName[CFA_MAX_PORT_NAME_LENGTH];

  MEMSET (&EcfmLbLtEthBnInfo, 0, sizeof (tEcfmLbLtEthBnInfo));

  MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
  if (CfaCliGetIfName ( u4IfIndex, (INT1 *) au1IfName) ==
          CLI_FAILURE)
  {
      return (CLI_FAILURE);
  }
  nmhGetFsMIY1731EthBnRateChangeStats (u4IfIndex, &u4EthBnRateChangeStats);
  nmhGetFsMIY1731EthBnRxCount (u4IfIndex, &u4EthBnRxCount);
  CliPrintf (CliHandle, "\r\n EthBn related Info for %-8s\r\n", au1IfName);
  CliPrintf (CliHandle, "\r--------------------- \r\n ");
  CliPrintf (CliHandle, "\r\n%-25s : %d", "EthBn Rate change Statistics", u4EthBnRateChangeStats);
  CliPrintf (CliHandle, "\r\n%-25s : %d", "ETH-BN Rx Count", u4EthBnRxCount);
  CliPrintf (CliHandle, "\r\n");

  return CLI_SUCCESS;

}

/*****************************************************************************/
/*     FUNCTION NAME    : EcfmMpTpMepListPrint                               */
/*                                                                           */
/*     DESCRIPTION      : This function displays MPLS-TP OAM MEPs objects in */
/*                        ECFM for show running configuration for a          */
/*                        particular context                                 */
/*                                                                           */
/*     INPUT            : CliHandle - Handle to the cli context              */
/*                        u4ContextId - Context Identifier                   */
/*                        u4MdIndex - Md Index                               */
/*                        u4MaIndex - Ma Index                               */
/*                        u1Module  - Module Id                              */
/*                                                                           */
/*     OUTPUT           : None                                               */
/*                                                                           */
/*     RETURNS          : VOID                                               */
/*****************************************************************************/
PRIVATE INT4
EcfmMpTpMepListPrint (tCliHandle CliHandle, UINT4 u4CurrContextId,
                      UINT4 u4MdIndex, UINT4 u4MaIndex, UINT4 u1Module)
{
    tSNMP_OID_TYPE      RetServiceRowPtr;
    tServicePtr        *pBaseServicePtr = NULL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4RMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextRMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextSelectorOrNone = ECFM_INIT_VAL;
    UINT4               u4Length = ECFM_INIT_VAL;
    UINT4               u4PwIndex = ECFM_INIT_VAL;
    UINT4               u4PswId = ECFM_INIT_VAL;
    UINT1               au1StrMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1MepActiveState[ECFM_VAL_8];
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4MepActive = ECFM_FALSE;
    INT4                i4NextSelectorType = ECFM_INIT_VAL;

    ECFM_MEMSET (&RetServiceRowPtr, ECFM_INIT_VAL, sizeof (tSNMP_OID_TYPE));
    ECFM_MEMSET (au1StrMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);

    /* Allocate Memory for Service Ptr Structure */
    pBaseServicePtr = (tServicePtr *) MemAllocMemBlk
        (ECFM_MPLSTP_SERVICE_PTR_POOLID);

    if (pBaseServicePtr == NULL)
    {
        return CLI_FAILURE;
    }

    MEMSET (pBaseServicePtr, 0, sizeof (tServicePtr));

    RetServiceRowPtr.pu4_OidList = pBaseServicePtr->au4ServicePtr;
    RetServiceRowPtr.u4_Length = pBaseServicePtr->u4OidLength;

    EcfmUtilGetMaName (u4CurrContextId, u4MdIndex, u4MaIndex, au1StrMaName);

    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrContextId, &u4NextContextId, u4MdIndex, &u4NextMdIndex,
         u4MaIndex, &u4NextMaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)
    {
        /* Releasing memory for Base Service Pointer */
        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                            (UINT1 *) pBaseServicePtr);
        return CLI_SUCCESS;
    }
    if ((u4NextContextId != u4CurrContextId) || (u4NextMdIndex != u4MdIndex) ||
        (u4NextMaIndex != u4MaIndex))
    {
        /* Releasing memory for Base Service Pointer */
        MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                            (UINT1 *) pBaseServicePtr);
        return CLI_SUCCESS;
    }
    while (i4RetVal == SNMP_SUCCESS)
    {
        if (nmhGetNextIndexFsMIY1731MplstpExtRemoteMepTable (u4CurrContextId,
                                                             &u4NextContextId,
                                                             u4MdIndex,
                                                             &u4NextMdIndex,
                                                             u4MaIndex,
                                                             &u4NextMaIndex,
                                                             u4MepIdentifier,
                                                             &u4NextMepIdentifier,
                                                             0,
                                                             &u4RMepIdentifier)
            == SNMP_FAILURE)
        {
            /* Releasing memory for Base Service Pointer */
            MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                (UINT1 *) pBaseServicePtr);
            return CLI_SUCCESS;
        }
        if ((u4NextContextId != u4CurrContextId) || (u4NextMdIndex != u4MdIndex)
            || (u4NextMaIndex != u4MaIndex)
            || (u4NextMepIdentifier != u4MepIdentifier))

        {
            /* Releasing memory for Base Service Pointer */
            MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                (UINT1 *) pBaseServicePtr);
            return CLI_SUCCESS;
        }

        while (i4RetVal == SNMP_SUCCESS)
        {
            nmhGetFsMIEcfmMepActive (u4CurrContextId, u4MdIndex, u4MaIndex,
                                     u4MepIdentifier, &i4MepActive);
            if (i4MepActive == ECFM_SNMP_TRUE)
            {
                ECFM_STRCPY (au1MepActiveState, "active ");
            }
            if (nmhGetFsMIY1731MplstpExtRMepServicePointer (u4CurrContextId,
                                                            u4MdIndex,
                                                            u4MaIndex,
                                                            u4MepIdentifier,
                                                            u4RMepIdentifier,
                                                            &RetServiceRowPtr)
                == SNMP_FAILURE)
            {
                /* Releasing memory for Base Service Pointer */
                MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                    (UINT1 *) pBaseServicePtr);
                return CLI_FAILURE;
            }
            if (ECFM_CC_SELECT_CONTEXT (u4CurrContextId) != ECFM_SUCCESS)
            {
                /* Releasing memory for Base Service Pointer */
                MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                    (UINT1 *) pBaseServicePtr);
                return CLI_FAILURE;
            }
            u4Length = (RetServiceRowPtr.u4_Length) / sizeof (UINT4);
            nmhGetNextIndexFsMIEcfmExtMaTable (u4CurrContextId,
                                               &u4NextContextId,
                                               u4MdIndex,
                                               &u4NextMdIndex,
                                               u4MaIndex,
                                               &u4NextMdIndex,
                                               0,
                                               &i4NextSelectorType,
                                               0, &u4NextSelectorOrNone);
            if (i4NextSelectorType == ECFM_SERVICE_SELECTION_LSP)
            {
                CliPrintf (CliHandle, "\r  %s mep %u service %s %s"
                           "rmep %u lsp tunnel  %u lsp-num %u "
                           "source %u destination %u \r\n",
                           gau1ModuleName[u1Module], u4MepIdentifier,
                           au1StrMaName, au1MepActiveState, u4RMepIdentifier,
                           RetServiceRowPtr.pu4_OidList[u4Length - ECFM_VAL_4],
                           RetServiceRowPtr.pu4_OidList[u4Length - ECFM_VAL_3],
                           RetServiceRowPtr.pu4_OidList[u4Length - ECFM_VAL_2],
                           RetServiceRowPtr.pu4_OidList[u4Length - ECFM_VAL_1]);
            }
            else if (i4NextSelectorType == ECFM_SERVICE_SELECTION_PW)
            {
                u4PwIndex = RetServiceRowPtr.pu4_OidList[u4Length - ECFM_VAL_1];
                if (EcfmMplsGetPwId (u4PwIndex, &u4PswId) != ECFM_SUCCESS)
                {
                    /* Releasing memory for Base Service Pointer */
                    MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                                        (UINT1 *) pBaseServicePtr);
                    return CLI_FAILURE;
                }
                CliPrintf (CliHandle, "\r %s mep %d service %s %s rmep "
                           "%u pw %u \r\n", gau1ModuleName[u1Module],
                           u4MepIdentifier, au1StrMaName,
                           au1MepActiveState, u4RMepIdentifier, u4PswId);
            }

            i4RetVal =
                nmhGetNextIndexFsMIY1731MplstpExtRemoteMepTable
                (u4CurrContextId, &u4NextContextId, u4MdIndex, &u4NextMdIndex,
                 u4MaIndex, &u4NextMaIndex, u4MepIdentifier,
                 &u4NextMepIdentifier, u4RMepIdentifier, &u4NextRMepIdentifier);
            if ((u4NextContextId != u4CurrContextId)
                || (u4NextMdIndex != u4MdIndex) || (u4NextMaIndex != u4MaIndex)
                || (u4NextMepIdentifier != u4MepIdentifier))
            {
                i4RetVal = SNMP_FAILURE;
            }
            else
            {
                u4RMepIdentifier = u4NextRMepIdentifier;
            }
        }
        EcfmShowRunningConfigMepDetails (CliHandle, (UINT4) u4CurrContextId,
                                         u4MdIndex, u4MaIndex, u4MepIdentifier,
                                         u1Module);

        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                                    &u4NextContextId, u4MdIndex,
                                                    &u4NextMdIndex, u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if ((u4NextContextId != u4CurrContextId) ||
            (u4NextMdIndex != u4MdIndex) || (u4NextMaIndex != u4MaIndex))
        {
            i4RetVal = SNMP_FAILURE;
        }
        else
        {
            u4MepIdentifier = u4NextMepIdentifier;
        }
    }
    /* Releasing memory for Base Service Pointer */
    MemReleaseMemBlock (ECFM_MPLSTP_SERVICE_PTR_POOLID,
                        (UINT1 *) pBaseServicePtr);
    CliPrintf (CliHandle, "\n");
    return CLI_SUCCESS;
}

/**************** Availability Related CLI functions Starts*******************/

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliInitAvlbltyMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will initiate the availability calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, pu1Arg3,
 *                        pu1Arg4, pu1Arg5, pu1Arg6
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        u4IfIndex - Interface Index on which initiating MEP exist
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliInitAvlbltyMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4Command, INT4 i4Dir,
                               UINT1 *pu1Arg1, UINT1 *pu1Arg2,
                               UINT1 *pu1Arg3, UINT1 *pu1Arg4,
                               UINT1 *pu1Arg5, UINT1 *pu1Arg6,
                               UINT1 *pu1Arg7, UINT1 *pu1Arg8,
                               UINT1 *pu1Arg9, UINT1 *pu1Arg10,
                               INT4 i4Arg11, INT4 i4Arg13, UINT4 u4IfIndex)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4AvlbltyInterval = ECFM_INIT_VAL;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1IsDestMpId = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    BOOL1               b1Err = ECFM_FALSE;
    UINT4               au4AvlbltyIntValues[] =
        { 0, ECFM_CC_AVLBLTY_INTERVAL_VALUE_1, ECFM_CC_AVLBLTY_INTERVAL_VALUE_2,
        ECFM_CC_AVLBLTY_INTERVAL_VALUE_3, ECFM_CC_AVLBLTY_INTERVAL_VALUE_4,
        ECFM_CC_AVLBLTY_INTERVAL_VALUE_5, ECFM_CC_AVLBLTY_INTERVAL_VALUE_6,
        ECFM_CC_AVLBLTY_INTERVAL_VALUE_7
    };
    UINT2               u2Index = ECFM_INIT_VAL;
    BOOL1               b1ValidAvlbltyInterval = ECFM_FALSE;

    /* Validate Availability Interval value */
    if (pu1Arg5 != NULL)

    {
        i4AvlbltyInterval = *(INT4 *) (VOID *) pu1Arg5;

        for (u2Index = ECFM_MIN_AVLBLTY_INTERVALS;
             u2Index < ECFM_MAX_AVLBLTY_INTERVALS; u2Index++)
        {

            /* If Valid Availability Interval found */
            if (au4AvlbltyIntValues[u2Index] == (UINT4) i4AvlbltyInterval)

            {
                b1ValidAvlbltyInterval = ECFM_TRUE;
                i4AvlbltyInterval = u2Index;
                break;
            }
        }
        if (b1ValidAvlbltyInterval != ECFM_TRUE)

        {

            /* Not a valid value */
            CLI_SET_ERR (CLI_ECFM_INVALID_AVLBLTY_INTERVAL_ERR);
            return CLI_FAILURE;
        }
    }

    else

    {
        i4AvlbltyInterval = ECFM_CC_AVLBLTY_INTERVAL_100_Ms;
    }
    u4CurrContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4RetIfIndex);
        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_SER:
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_VLAN:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && (i4RetMaPrimaryVid == 0) && ((i4Dir == 0)
                                                    || ((i4Dir != 0)
                                                        && (i4Dir ==
                                                            i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                    b1IsDestMpId = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_SER:
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_VLAN:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4RetMaPrimaryVid == 0) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {
            /* Start the Availability Measurement */
            if (EcfmConfigAvailParams
                (CliHandle, u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, b1IsDestMpId, pu1Arg3, pu1Arg4,
                 i4AvlbltyInterval, pu1Arg6, pu1Arg7, pu1Arg8,
                 pu1Arg9, pu1Arg10, i4Arg11, i4Arg13, &b1Err) == ECFM_FAILURE)

            {
                if ((u4IfIndex != 0) && (i4Dir != 0))
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_AVLBLTY_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }
                /* Move to next entry */
                i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                                            &u4NextContextId,
                                                            u4MdIndex,
                                                            &u4NextMdIndex,
                                                            u4MaIndex,
                                                            &u4NextMaIndex,
                                                            u4MepIdentifier,
                                                            &u4NextMepIdentifier);
                if (i4RetVal == SNMP_SUCCESS)

                {
                    u4MdIndex = u4NextMdIndex;
                    u4MaIndex = u4NextMaIndex;
                    u4MepIdentifier = u4NextMepIdentifier;
                }
                else
                {
                    if (b1Err != ECFM_TRUE)
                    {
                        CLI_SET_ERR (CLI_ECFM_AVLBLTY_INITIATION_ERR);
                    }
                    return CLI_FAILURE;
                }

                if (u4ContextId != u4NextContextId)
                {
                    CLI_SET_ERR (CLI_ECFM_NO_MEP_FOR_TRANS_INITIATION_ERR);
                    return CLI_FAILURE;
                }
                b1Entry = ECFM_FALSE;
                b1IsDestMpId = ECFM_FALSE;
                b1Err = ECFM_FALSE;
                continue;
            }
            return CLI_SUCCESS;
        }
        /* Move to next entry */
        i4RetVal = nmhGetNextIndexFsMIEcfmMepTable (u4ContextId,
                                                    &u4NextContextId,
                                                    u4MdIndex,
                                                    &u4NextMdIndex,
                                                    u4MaIndex,
                                                    &u4NextMaIndex,
                                                    u4MepIdentifier,
                                                    &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4ContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
        b1IsDestMpId = ECFM_FALSE;
        b1Err = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliStopAvlbltyMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will stop the Availability calculations.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        u4IfIndex - Interface on which initiating MEP exist
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliStopAvlbltyMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4Command, INT4 i4Dir,
                               UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT4 u4IfIndex)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    u4CurrContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
        return CLI_FAILURE;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4RetIfIndex);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {

            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM_SER:
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV_VLAN:

            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_ISID:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_VLAN:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM_SER:
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV_VLAN:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_AVLBLTY_MEP_MAC_LEV:
            case CLI_ECFM_AVLBLTY_MEP_MAC_DOM:
            case CLI_ECFM_AVLBLTY_MEP_MPID_LEV:
            case CLI_ECFM_AVLBLTY_MEP_MPID_DOM:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && (i4RetMaPrimaryVid == 0) && ((i4Dir == 0)
                                                    || ((i4Dir != 0)
                                                        && (i4Dir ==
                                                            i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {

            /* Stop the Availability Measurement */
            /* Test if the transaction can be stopped  */
            if (nmhTestv2FsMIY1731MepAvailabilityStatus
                (&u4ErrorCode, u4CurrContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier, ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }

            /* Then stop the transaction */
            if (nmhSetFsMIY1731MepAvailabilityStatus
                (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 ECFM_TX_STATUS_STOP) == SNMP_FAILURE)

            {
                CLI_FATAL_ERROR (CliHandle);
                return CLI_FAILURE;
            }
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
    }
    CLI_SET_ERR (CLI_ECFM_MEP_NOT_PRESENT_ERR);
    return CLI_FAILURE;
}

/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmConfigAvailParams                                
 *                                                                          
 *     DESCRIPTION      : This function will set the MIB fields required for
 *                        Availability Measurement.
 *                                                                          
 *     INPUT            : CliHandle       - CliContext ID
 *                        u4MdIndex       - MdIndex                     
 *                        u4MaIndex       - MaIndex
 *                        u4MepIdentifier - MepIdentifier
 *                        b1IsDestMpId    - Destination MepId or Mac Address
 *                        i4AvailInterval - Availability Interval to set  
 *                        pu1Arg1         -
 *                        pu1Arg2         -
 *                        pu1Arg3         - Arguments acc. to the command
 *                                                                        
 *     OUTPUT           : pb1Err - Indicates an Error from Test routine
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/ECFM_FAILURE                           
 *                                                                          
 ******************************************************************************/
PRIVATE INT4
EcfmConfigAvailParams (tCliHandle CliHandle, UINT4 u4ContextId,
                       UINT4 u4MdIndex, UINT4 u4MaIndex,
                       UINT4 u4MepIdentifier, BOOL1 b1IsDestMpId,
                       UINT1 *pu1Arg1, UINT1 *pu1Arg2, INT4 i4AvailInterval,
                       UINT1 *pu1Arg4, UINT1 *pu1Arg5, UINT1 *pu1Arg6,
                       UINT1 *pu1Arg7, UINT1 *pu1Arg8, INT4 i4Arg9,
                       INT4 i4Arg10, BOOL1 * pb1Err)
{
    tSNMP_OCTET_STRING_TYPE LowerThreshold;
    tSNMP_OCTET_STRING_TYPE UpperThreshold;
    tEcfmMacAddr        DestMacAddr = { 0 };
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    UINT4               u4DestMpId = ECFM_INIT_VAL;
    UINT4               u4WindowSize = ECFM_INIT_VAL;
    UINT4               u4AvlbltyDeadline = ECFM_INIT_VAL;
    UINT4               u4AvlbltyAlgoType = ECFM_INIT_VAL;
    UINT4               u4AvlbltySchldInitTime = ECFM_INIT_VAL;
    UINT4               u4AvlbltySchldEndTime = ECFM_INIT_VAL;
    INT4                i4RowStatus = ECFM_INIT_VAL;
    UINT1               u1AvlbltyModestArea = ECFM_INIT_VAL;

    if (nmhGetFsMIY1731MepAvailabilityRowStatus (u4ContextId,
                                                 u4MdIndex,
                                                 u4MaIndex,
                                                 u4MepIdentifier,
                                                 &i4RowStatus) != SNMP_SUCCESS)
    {
        /*Test and Create Availability Measurement Table */
        if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_SUCCESS)
        {
            if (nmhSetFsMIY1731MepAvailabilityRowStatus
                (u4ContextId, u4MdIndex, u4MaIndex,
                 u4MepIdentifier,
                 ECFM_ROW_STATUS_CREATE_AND_WAIT) == SNMP_FAILURE)
            {
                *pb1Err = ECFM_TRUE;
                return ECFM_FAILURE;
            }
        }
    }
    /* If created already, change status to Not in Service to configure */
    else if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
             (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
              u4MepIdentifier, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_SUCCESS)
    {
        if (nmhSetFsMIY1731MepAvailabilityRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_ROW_STATUS_NOT_IN_SERVICE) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }
    /* If Availability is on-going */
    else
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Set MepId or Dest Mac Address depending on the input */
    if (b1IsDestMpId == ECFM_TRUE)

    {
        if (nmhTestv2FsMIY1731MepAvailabilityDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepAvailabilityDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set MepId of the destination */
        u4DestMpId = *(UINT4 *) (VOID *) pu1Arg1;
        if (nmhTestv2FsMIY1731MepAvailabilityDestMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4DestMpId) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepAvailabilityDestMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             u4DestMpId) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    else

    {
        ECFM_MEMSET (DestMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        StrToMac (pu1Arg1, DestMacAddr);
        if (nmhTestv2FsMIY1731MepAvailabilityDestIsMepId
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepAvailabilityDestIsMepId
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }

        /* Set destination address */
        if (nmhTestv2FsMIY1731MepAvailabilityDestMacAddress
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, DestMacAddr) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
        if (nmhSetFsMIY1731MepAvailabilityDestMacAddress
            (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
             DestMacAddr) == SNMP_FAILURE)

        {
            return ECFM_FAILURE;
        }
    }

    /* Test the Window Size to be configured  
     * before setting */
    if (pu1Arg2 != NULL)

    {
        u4WindowSize = *(UINT4 *) (VOID *) pu1Arg2;
        if (nmhTestv2FsMIY1731MepAvailabilityWindowSize
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4WindowSize) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityWindowSize
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4WindowSize) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
    }

    /* Test Interval before setting */
    if (nmhTestv2FsMIY1731MepAvailabilityInterval
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4AvailInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepAvailabilityInterval
        (u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, i4AvailInterval) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Test DeadLine Time before setting */
    if (pu1Arg4 != NULL)

    {
        u4AvlbltyDeadline = *(INT4 *) (VOID *) pu1Arg4;

        /* Test Deadline before setting */
        if (nmhTestv2FsMIY1731MepAvailabilityDeadline
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltyDeadline) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityDeadline
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltyDeadline) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set Lower Threshold */
    if (pu1Arg5 != NULL)
    {
        LowerThreshold.pu1_OctetList = pu1Arg5;
        LowerThreshold.i4_Length = ECFM_AVLBLTY_RATIO_LENGTH;

        /* Test Lower Threshold before setting */
        if (nmhTestv2FsMIY1731MepAvailabilityLowerThreshold
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &LowerThreshold) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityLowerThreshold
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &LowerThreshold) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set Upper Threshold */
    if (pu1Arg6 != NULL)
    {
        UpperThreshold.pu1_OctetList = pu1Arg6;
        UpperThreshold.i4_Length = ECFM_AVLBLTY_RATIO_LENGTH;

        /* Test Upper Threshold before setting */
        if (nmhTestv2FsMIY1731MepAvailabilityUpperThreshold
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &UpperThreshold) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityUpperThreshold
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, &UpperThreshold) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set Scheduled Down Init Time */
    if (pu1Arg7 != NULL)
    {
        u4AvlbltySchldInitTime = *(INT4 *) (VOID *) pu1Arg7;

        /* Test  Scheduled Down Init Time  before setting */
        if (nmhTestv2FsMIY1731MepAvailabilitySchldDownInitTime
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltySchldInitTime) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilitySchldDownInitTime
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltySchldInitTime) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set Scheduled Down End Time */
    if (pu1Arg8 != NULL)
    {
        u4AvlbltySchldEndTime = *(INT4 *) (VOID *) pu1Arg8;

        /* Test Scheduled Down End Time before setting */
        if (nmhTestv2FsMIY1731MepAvailabilitySchldDownEndTime
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltySchldEndTime) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilitySchldDownEndTime
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, u4AvlbltySchldEndTime) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set Modest Area ( Area Between upper and 
     * Lower threshold) Status */
    u1AvlbltyModestArea = (UINT1) i4Arg9;
    if (u1AvlbltyModestArea == CLI_TRUE)
    {
        /* Test Modest Area Status before setting */
        if (nmhTestv2FsMIY1731MepAvailabilityModestAreaIsAvailable
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityModestAreaIsAvailable
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_TRUE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }
    else
    {
        /* Test Modest Area Status before setting */
        if (nmhTestv2FsMIY1731MepAvailabilityModestAreaIsAvailable
            (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

        if (nmhSetFsMIY1731MepAvailabilityModestAreaIsAvailable
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_SNMP_FALSE) == SNMP_FAILURE)

        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }

    }

    /* Test and Set availability measurement algorithm */
    u4AvlbltyAlgoType = (UINT4) i4Arg10;

    /* Test availability measurement algorithm before setting */
    if (nmhTestv2FsMIY1731MepAvailabilityType
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4AvlbltyAlgoType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepAvailabilityType
        (u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, u4AvlbltyAlgoType) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /*MAke  Availability Measurement Table as Active */
    if (nmhTestv2FsMIY1731MepAvailabilityRowStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_ROW_STATUS_ACTIVE) == SNMP_SUCCESS)
    {
        if (nmhSetFsMIY1731MepAvailabilityRowStatus
            (u4ContextId, u4MdIndex, u4MaIndex,
             u4MepIdentifier, ECFM_ROW_STATUS_ACTIVE) == SNMP_FAILURE)
        {
            *pb1Err = ECFM_TRUE;
            return ECFM_FAILURE;
        }
    }
    else
    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    /* Initiate Availability Measurement */
    if (nmhTestv2FsMIY1731MepAvailabilityStatus
        (&u4ErrorCode, u4ContextId, u4MdIndex, u4MaIndex,
         u4MepIdentifier, ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        *pb1Err = ECFM_TRUE;
        return ECFM_FAILURE;
    }

    if (nmhSetFsMIY1731MepAvailabilityStatus
        (u4ContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
         ECFM_TX_STATUS_START) == SNMP_FAILURE)

    {
        return ECFM_FAILURE;
    }
    CliPrintf (CliHandle, " ");
    return ECFM_SUCCESS;

    return 0;
}

/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliShowLoopbackStatus
 *
 *     DESCRIPTION      : This function will show the Loopback Status.
 *
 *     INPUT            : CliHandle - CliContext ID
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE
 *
 *******************************************************************************/
INT4
EcfmCliShowLoopbackStatus (tCliHandle CliHandle, UINT4 u4ContextId)
{

#if defined (Y1564_WANTED) || (RFC2544_WANTED)
    tSNMP_OCTET_STRING_TYPE RetMaName;
    tSNMP_OCTET_STRING_TYPE RetMdName;
    UINT4               u4Y1731ContextId = ECFM_INIT_VAL;
    UINT4               u4Y1731MegIndex = ECFM_INIT_VAL;
    UINT4               u4Y1731MeIndex = ECFM_INIT_VAL;
    UINT4               u4Y1731MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextY1731ContextId = ECFM_INIT_VAL;
    UINT4               u4NextY1731MegIndex = ECFM_INIT_VAL;
    UINT4               u4NextY1731MeIndex = ECFM_INIT_VAL;
    UINT4               u4NextY1731MepIdentifier = ECFM_INIT_VAL;
    INT4                i4RetPriVlanId = ECFM_INIT_VAL;
    INT4                i4MepLoopbackStatus = ECFM_INIT_VAL;
    UINT1               au1RetMaName[ECFM_MA_NAME_ARRAY_SIZE];
    UINT1               au1RetMdName[ECFM_MA_NAME_ARRAY_SIZE];

    if (nmhGetNextIndexFsMIY1731MepTable (u4ContextId, &u4NextY1731ContextId,
                                          u4Y1731MegIndex, &u4NextY1731MegIndex,
                                          u4Y1731MeIndex, &u4NextY1731MeIndex,
                                          u4Y1731MepIdentifier,
                                          &u4NextY1731MepIdentifier)
        != SNMP_SUCCESS)
    {
        return CLI_SUCCESS;
    }

    do
    {

        if (u4ContextId != u4NextY1731ContextId)
        {
            return CLI_SUCCESS;
        }
        u4Y1731ContextId = u4NextY1731ContextId;
        u4Y1731MegIndex = u4NextY1731MegIndex;
        u4Y1731MeIndex = u4NextY1731MeIndex;
        u4Y1731MepIdentifier = u4NextY1731MepIdentifier;

        if (nmhGetFsMIY1731MepLoopbackStatus (u4Y1731ContextId, u4Y1731MegIndex,
                                              u4Y1731MeIndex,
                                              u4Y1731MepIdentifier,
                                              &i4MepLoopbackStatus) ==
            SNMP_SUCCESS)
        {

            ECFM_MEMSET (au1RetMaName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (au1RetMdName, ECFM_INIT_VAL, ECFM_MA_NAME_ARRAY_SIZE);
            ECFM_MEMSET (&RetMaName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));
            ECFM_MEMSET (&RetMdName, ECFM_INIT_VAL,
                         sizeof (tSNMP_OCTET_STRING_TYPE));

            RetMaName.pu1_OctetList = au1RetMaName;
            RetMaName.i4_Length = 0;
            RetMdName.pu1_OctetList = au1RetMdName;
            RetMdName.i4_Length = 0;
            nmhGetFsMIEcfmMaName (u4Y1731ContextId, u4Y1731MegIndex,
                                  u4Y1731MeIndex, &RetMaName);
            nmhGetFsMIEcfmMdName (u4Y1731ContextId, u4Y1731MegIndex,
                                  &RetMdName);
            nmhGetFsMIEcfmMaPrimaryVlanId (u4Y1731ContextId, u4Y1731MegIndex,
                                           u4Y1731MeIndex, &i4RetPriVlanId);

            CliPrintf (CliHandle, "\r\n");
            CliPrintf (CliHandle, "\r -------------------------------\r\n");
            CliPrintf (CliHandle, "\r Service Name          : %s\r\n", RetMaName.pu1_OctetList);
            CliPrintf (CliHandle, "\r Domain Name           : %s\r\n", RetMdName.pu1_OctetList);
#ifdef VSI_WANTED
            if (EcfmUtilCfaIsVsiId (i4RetPriVlanId) == ECFM_SUCCESS)
            {
                CliPrintf (CliHandle, "\r Vsi Id                : %d\r\n", i4RetPriVlanId);
            }
            else
#endif
            {
            CliPrintf (CliHandle, "\r Vlan Identifier       : %d\r\n", i4RetPriVlanId);
            }
            CliPrintf (CliHandle, "\r MEG Identifier        : %d\r\n", u4Y1731MegIndex);
            CliPrintf (CliHandle, "\r ME Identifier         : %d\r\n", u4Y1731MeIndex);
            CliPrintf (CliHandle, "\r MEP Identifier        : %d\r\n", u4Y1731MepIdentifier);
            if (i4MepLoopbackStatus == ECFM_SNMP_TRUE)
            {
                CliPrintf (CliHandle, "\r Loopback Status       : Enabled\r\n");
            }
            else
            {
                CliPrintf (CliHandle,
                           "\r Loopback Status       : Disabled\r\n");
            }
        }
    }
    while (nmhGetNextIndexFsMIY1731MepTable
           (u4Y1731ContextId, &u4NextY1731ContextId, u4Y1731MegIndex,
            &u4NextY1731MegIndex, u4Y1731MeIndex, &u4NextY1731MeIndex,
            u4Y1731MepIdentifier, &u4NextY1731MepIdentifier) == SNMP_SUCCESS);
#else
    UNUSED_PARAM (CliHandle);
    UNUSED_PARAM (u4ContextId);
#endif
    return CLI_SUCCESS;
}
/*******************************************************************************
 *
 *     FUNCTION NAME    : EcfmCliShowSummary
 *
 *     DESCRIPTION      : This function will show the summary of domains,
 *                         MEPS configured
 *
 *     INPUT            : CliHandle - CliContext ID
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : None
 *
 *******************************************************************************/
VOID
EcfmCliShowSummary (tCliHandle CliHandle)
{

    UINT4    u4DomCount = 0;
    UINT4    u4MepCount = 0;
    UINT4    u4ServCount = 0;

     ECFM_REGISTER_CLI_CC_LOCK ();
    if (RBTreeCount(ECFM_CC_MA_TABLE, &u4ServCount) == RB_FAILURE)
    {
        return ;
    }

    if (RBTreeCount(ECFM_CC_MD_TABLE, &u4DomCount) == RB_FAILURE)
    {
        return ;
    }

    if (RBTreeCount(ECFM_CC_MEP_TABLE, &u4MepCount) == RB_FAILURE)
    {
        return ;
    }
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    CliPrintf (CliHandle, "   %s : %u\r\n","Total number of Services   ", u4ServCount);
    CliPrintf (CliHandle, "   %s : %u\r\n","Total number of Domains    ", u4DomCount);
    CliPrintf (CliHandle, "   %s : %u\r\n","Total number of Local MEPS ", u4MepCount);
    return ;
}
/*******************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliShowAvlbltyMeasurement
 *                                                                               
 *     DESCRIPTION      : This function will show the Availability Percentage.          
 *                                                                          
 *     INPUT            : CliHandle - CliContext ID
 *                        u4ContextId - context Identifier,
 *                        u4Command - Type of command
 *                        i4Dir - Direction of initiating MEP
 *                        pu1Arg1, pu1Arg2, 
 *                        arguments can contain different pararmeters according
 *                        to particular command.
 *                        u4IfIndex - Interface on which initiating MEP exist
 *
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : CLI_SUCCESS/CLI_FAILURE                           
 *                                                                          
 ******************************************************************************/
INT4
EcfmCliShowAvlbltyMeasurement (tCliHandle CliHandle, UINT4 u4ContextId,
                               UINT4 u4Command, INT4 i4Dir,
                               UINT1 *pu1Arg1, UINT1 *pu1Arg2, UINT4 u4IfIndex)
{
    tEcfmMacAddr        RetMacAddr;
    tEcfmMacAddr        MacAddr;
    UINT4               u4MdIndex = ECFM_INIT_VAL;
    UINT4               u4MaIndex = ECFM_INIT_VAL;
    UINT4               u4MepIdentifier = ECFM_INIT_VAL;
    UINT4               u4NextMdIndex = ECFM_INIT_VAL;
    UINT4               u4NextMaIndex = ECFM_INIT_VAL;
    UINT4               u4NextMepIdentifier = ECFM_INIT_VAL;
    UINT4               u4CurrContextId = ECFM_INIT_VAL;
    UINT4               u4NextContextId = ECFM_INIT_VAL;
    UINT4               u4RMepId = ECFM_INIT_VAL;
    INT4                i4RetPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetDir = ECFM_INIT_VAL;
    INT4                i4RetIfIndex = ECFM_INIT_VAL;
    INT4                i4VlanId = ECFM_INIT_VAL;
    INT4                i4RetMaPrimaryVid = ECFM_INIT_VAL;
    INT4                i4RetMdLevel = ECFM_INIT_VAL;
    INT4                i4MdLevel = ECFM_INIT_VAL;
    INT4                i4RetVal = SNMP_SUCCESS;
    INT4                i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
    INT4                i4IsMepId = ECFM_INIT_VAL;
    INT1               *pi1IfName = NULL;
    UINT1               au1Percentage[ECFM_AVLBLTY_RATIO_LENGTH] = { 0 };
    UINT1               au1IfName[CFA_MAX_PORT_NAME_LENGTH];
    BOOL1               b1Entry = ECFM_FALSE;
    BOOL1               b1SameContext = ECFM_TRUE;
    tSNMP_OCTET_STRING_TYPE Percentage;
    tMacAddr            RMacAddr;
    UINT1               au1String[ECFM_CLI_MAX_MAC_STRING_SIZE];

    ECFM_MEMSET (RMacAddr, ECFM_INIT_VAL, MAC_ADDR_LEN);
    ECFM_MEMSET (au1String, ECFM_INIT_VAL, ECFM_CLI_MAX_MAC_STRING_SIZE);

    ECFM_MEMSET (&Percentage, 0, sizeof (tSNMP_OCTET_STRING_TYPE));
    Percentage.pu1_OctetList = au1Percentage;

    MEMSET (au1IfName, 0, CFA_MAX_PORT_NAME_LENGTH);
    pi1IfName = (INT1 *) au1IfName;

    u4CurrContextId = u4ContextId;

    /* Check for MEP entry for a particular context */
    if (nmhGetNextIndexFsMIEcfmMepTable
        (u4CurrContextId, &u4NextContextId, 0, &u4MdIndex, 0,
         &u4MaIndex, 0, &u4MepIdentifier) == SNMP_FAILURE)

    {
        return CLI_FAILURE;
    }
    if (u4NextContextId != u4ContextId)

    {
        return CLI_SUCCESS;
    }

    /* Scan Mep Table */
    while ((i4RetVal == SNMP_SUCCESS) && (b1SameContext == ECFM_TRUE))

    {
        ECFM_MEMSET (MacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        ECFM_MEMSET (RetMacAddr, ECFM_INIT_VAL, ECFM_MAC_ADDR_LENGTH);
        i4RetPrimaryVid = ECFM_INIT_VAL;
        i4RetMaPrimaryVid = ECFM_INIT_VAL;
        i4RetMdLevel = ECFM_INIT_VAL;
        i4RetDir = ECFM_INIT_VAL;
        i4RetIfIndex = ECFM_INIT_VAL;
        i4RetMepRowStatus = ECFM_ROW_STATUS_NOT_IN_SERVICE;
        nmhGetFsMIEcfmMepPrimaryVid (u4CurrContextId, u4MdIndex,
                                     u4MaIndex, u4MepIdentifier,
                                     (UINT4 *) &i4RetPrimaryVid);
        nmhGetFsMIEcfmMaPrimaryVlanId (u4CurrContextId, u4MdIndex,
                                       u4MaIndex, &i4RetMaPrimaryVid);
        nmhGetFsMIEcfmMdMdLevel (u4CurrContextId, u4MdIndex, &i4RetMdLevel);
        nmhGetFsMIEcfmMepRowStatus (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier,
                                    &i4RetMepRowStatus);
        nmhGetFsMIEcfmMepDirection (u4CurrContextId, u4MdIndex,
                                    u4MaIndex, u4MepIdentifier, &i4RetDir);
        nmhGetFsMIEcfmMepIfIndex (u4CurrContextId, u4MdIndex, u4MaIndex,
                                  u4MepIdentifier, &i4RetIfIndex);

        /* Search for MEP satisfying particular condition for particular
         * command */
        switch (u4Command)

        {

            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF_SER:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF_VLAN:

            case CLI_ECFM_SHOW_AVLBLTY_LEV_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_ISID:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_VLAN:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_SER:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_VLAN:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                i4VlanId = *(INT4 *) (VOID *) pu1Arg2;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel) &&
                    ((i4RetPrimaryVid == i4VlanId) ||
                     (i4RetMaPrimaryVid == i4VlanId)) &&
                    ((i4Dir == 0)
                     || ((i4Dir != 0) && (i4Dir == i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_AVLBLTY_LEV:
            case CLI_ECFM_SHOW_AVLBLTY_DOM:
            case CLI_ECFM_SHOW_AVLBLTY_LEV_INTF:
            case CLI_ECFM_SHOW_AVLBLTY_DOM_INTF:
                i4MdLevel = *(INT4 *) (VOID *) pu1Arg1;
                if ((i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE) &&
                    (i4MdLevel == i4RetMdLevel)
                    && (i4RetMaPrimaryVid == 0) && ((i4Dir == 0)
                                                    || ((i4Dir != 0)
                                                        && (i4Dir ==
                                                            i4RetDir)))
                    && ((u4IfIndex == 0)
                        || ((u4IfIndex != 0)
                            && (u4IfIndex == (UINT4) i4RetIfIndex))))

                {
                    b1Entry = ECFM_TRUE;
                }
                break;
            case CLI_ECFM_SHOW_AVLBLTY:
                if (i4RetMepRowStatus == ECFM_ROW_STATUS_ACTIVE)
                {
                    b1Entry = ECFM_TRUE;
                }
                break;

            default:
                break;
        }

        /* Entry Found */
        if (b1Entry == ECFM_TRUE)

        {
            /* Get Availability Percentage */

            if (nmhGetFsMIY1731MepAvailabilityPercentage
                (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 &Percentage) == SNMP_FAILURE)

            {
                return CLI_FAILURE;
            }

            if (nmhGetFsMIY1731MepAvailabilityDestIsMepId
                (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                 &i4IsMepId) != SNMP_FAILURE)
            {
                if (i4IsMepId == ECFM_TRUE)
                {
                    if (nmhGetFsMIY1731MepAvailabilityDestMepId
                        (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         &u4RMepId) == SNMP_FAILURE)
                    {
                        return CLI_FAILURE;
                    }
                }
                else
                {
                    if (nmhGetFsMIY1731MepAvailabilityDestMacAddress
                        (u4CurrContextId, u4MdIndex, u4MaIndex, u4MepIdentifier,
                         &RMacAddr) == SNMP_FAILURE)
                    {
                        return CLI_FAILURE;
                    }
                }
            }

            CfaCliGetIfName (i4RetIfIndex, pi1IfName);
            CliPrintf (CliHandle, "\r\nInterface : %s ", pi1IfName);
            CliPrintf (CliHandle, "\r\nMEP-ID    : %d", u4MepIdentifier);
            if (i4IsMepId == ECFM_TRUE)
            {
                CliPrintf (CliHandle, "\r\nRMEP-ID   : %d", u4RMepId);
            }
            else
            {
                CliPrintf (CliHandle, "\r\nRMEP MAC-Address: ");
                /* Mac address of the remote mep */
                PrintMacAddress (RMacAddr, au1String);
                CliPrintf (CliHandle, "%s", au1String);
            }

            CliPrintf (CliHandle, "\r\nLevel     : %d", i4RetMdLevel);
            if (i4RetPrimaryVid != 0)
            {
                if (i4RetPrimaryVid < ECFM_INTERNAL_ISID_MIN)
                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                               i4RetPrimaryVid);
                }
                else
                {

                    CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                }
            }
            else

            {
                if ((i4RetMaPrimaryVid != 0)
                    && (i4RetMaPrimaryVid < ECFM_INTERNAL_ISID_MIN))

                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : %d",
                               i4RetMaPrimaryVid);
                }

                else

                {
                    CliPrintf (CliHandle, "\r\nVLAN-ID   : -");
                }
            }
            if (i4RetPrimaryVid != 0)
            {
                if (i4RetPrimaryVid > ECFM_INTERNAL_ISID_MIN)
                {
                    CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                }
            }
            else
            {
                if ((i4RetMaPrimaryVid != 0)
                    && (i4RetMaPrimaryVid > ECFM_INTERNAL_ISID_MIN))
                {
                    CliPrintf (CliHandle, "\r\nISID      : %d \r\n",
                               ECFM_ISID_INTERNAL_TO_ISID (i4RetMaPrimaryVid));
                }
                else
                {
                    CliPrintf (CliHandle, "\r\nISID      : - \r\n");
                }
            }

            CliPrintf (CliHandle, "Availability Percentage : %s\r\n",
                       au1Percentage);
            return CLI_SUCCESS;
        }

        /* Move to next entry */
        i4RetVal =
            nmhGetNextIndexFsMIEcfmMepTable (u4CurrContextId,
                                             &u4NextContextId,
                                             u4MdIndex, &u4NextMdIndex,
                                             u4MaIndex, &u4NextMaIndex,
                                             u4MepIdentifier,
                                             &u4NextMepIdentifier);
        if (i4RetVal == SNMP_SUCCESS)

        {
            if (u4CurrContextId != u4NextContextId)

            {
                b1SameContext = ECFM_FALSE;
            }
            u4MdIndex = u4NextMdIndex;
            u4MaIndex = u4NextMaIndex;
            u4MepIdentifier = u4NextMepIdentifier;
        }
        b1Entry = ECFM_FALSE;
    }
    return CLI_SUCCESS;
}

/**************************** Availability Related CLI Functions Ends *********************/
#ifdef VSI_WANTED
/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliErrorDisplayVsi
 *
 *     DESCRIPTION      : This function will display the error message.
 *
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ErrCode     - Type of error
 *                        pu1VsiList   - Type of error
 *
 *     OUTPUT           : None
 *
 *     RETURNS          : None
 *
 *****************************************************************************/
VOID
EcfmCliErrorDisplayVsi (tCliHandle CliHandle, UINT4 u4ErrCode, UINT1 *pu1VsiList)
{
    if (CLI_GET_ERR (&u4ErrCode) == CLI_FAILURE)
    {
        return;
    }
    CliPrintf (CliHandle, "\r%% %s",
               gaEcfmCliErrString[CLI_ERR_OFFSET_ECFM (u4ErrCode)]);
    UtilVsiReleaseVsiListSize (pu1VsiList);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return;
}
#endif

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliErrorDisplay                               
 *                                                                          
 *     DESCRIPTION      : This function will display the error message. 
 *                                                                          
 *     INPUT            : CliHandle     - CliContext ID
 *                        u4ErrCode     - Type of error
 *                        pu1VlanList   - Type of error
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 *****************************************************************************/
VOID
EcfmCliErrorDisplay (tCliHandle CliHandle, UINT4 u4ErrCode, UINT1 *pu1VlanList)
{
    if (CLI_GET_ERR (&u4ErrCode) == CLI_FAILURE)
    {
        return;
    }
    CliPrintf (CliHandle, "\r%% %s",
               gaEcfmCliErrString[CLI_ERR_OFFSET_ECFM (u4ErrCode)]);
    UtilVlanReleaseVlanListSize (pu1VlanList);
    ECFM_UNREGISTER_CLI_CC_LOCK ();
    return;
}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliMepValidateLbmTarget                              
 *                                                                          
 *     DESCRIPTION      : This function will validate the Mac address. 
 *                                                                          
 *     INPUT            : CommandType   - Dest Type UMAC/MPID/MUMAC
 *                        u4ContextId   - Context Id
 *                        u4MdIndex     - Index in MD Table
 *                        u4MaIndex     - Index in MA Table
 *                        u4MepId       - Mep Indentifier
 *                        pu1MacAddr    - Destination Mac Address
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 *****************************************************************************/
BOOL1
EcfmCliMepValidateLbmTarget (tCliHandle CliHandle,
                             UINT1 u1DestType,
                             UINT4 u4ContextId,
                             UINT4 u4MdIndex,
                             UINT4 u4MaIndex, UINT4 u4MepId, UINT4 *pu4Target)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;

    if (pu4Target == NULL && u1DestType == ECFM_TX_DEST_TYPE_MEPID)
    {
        return ECFM_FALSE;
    }
    if (u1DestType == ECFM_TX_DEST_TYPE_MEPID)
    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        if (nmhTestv2FsMIY1731MepTransmitLbmDestMepId
            (&u4ErrorCode,
             u4ContextId,
             u4MdIndex, u4MaIndex, u4MepId, *pu4Target) == SNMP_SUCCESS)
        {
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return ECFM_TRUE;
        }
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    else
    {
        return ECFM_TRUE;
    }
    return ECFM_FALSE;

}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliMepValidateLtmTarget                              
 *                                                                          
 *     DESCRIPTION      : This function will validate the Mac address. 
 *                                                                          
 *     INPUT            : CommandType   - Dest Type UMAC/MPID/MUMAC
 *                        u4ContextId   - Context Id
 *                        u4MdIndex     - Index in MD Table
 *                        u4MaIndex     - Index in MA Table
 *                        u4MepId       - Mep Indentifier
 *                        pu1MacAddr    - Destination Mac Address
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : None                           
 *                                                                          
 *****************************************************************************/
BOOL1
EcfmCliMepValidateLtmTarget (tCliHandle CliHandle,
                             UINT1 u1DestType,
                             UINT4 u4ContextId,
                             UINT4 u4MdIndex,
                             UINT4 u4MaIndex, UINT4 u4MepId, UINT4 *pu4Target)
{
    UINT4               u4ErrorCode = ECFM_INIT_VAL;
    if (pu4Target == NULL)
    {
        return ECFM_FALSE;
    }

    if (u1DestType == ECFM_TX_DEST_TYPE_MEPID)
    {
        ECFM_UNREGISTER_CLI_CC_LOCK ();
        ECFM_REGISTER_CLI_LBLT_LOCK ();
        if (nmhTestv2FsMIY1731MepTransmitLtmTargetMepId
            (&u4ErrorCode,
             u4ContextId,
             u4MdIndex, u4MaIndex, u4MepId, *pu4Target) == SNMP_SUCCESS)
        {
            ECFM_UNREGISTER_CLI_LBLT_LOCK ();
            ECFM_REGISTER_CLI_CC_LOCK ();
            return ECFM_TRUE;
        }
        ECFM_UNREGISTER_CLI_LBLT_LOCK ();
        ECFM_REGISTER_CLI_CC_LOCK ();
    }
    else
    {
        return ECFM_TRUE;
    }
    return ECFM_FALSE;

}

/****************************************************************************
 * 
 *     FUNCTION NAME    : EcfmCliGetVlanIsidInfo                              
 *                                                                          
 *     DESCRIPTION      : This function will find the Matching Vlan Id 
 *                         or Isid for the given input
 *                                                                          
 *     INPUT            : u4ContextId   - Context Id
 *                        u4MdLevel     - MD Level
 *                        u2LocalPortId - Port Number
 *                        b1Direction   - Mep Direction
 *                        pu4VlanIsid   - VlanID or ISID
 *                                 
 *     OUTPUT           : None               
 *                                                                          
 *     RETURNS          : ECFM_SUCCESS/FAILURE                           
 *                                                                          
 *****************************************************************************/
INT4
EcfmCliGetVlanIsidInfo (UINT4 u4ContextId,
                        UINT4 u4MdLevel,
                        UINT2 u2LocalPortId,
                        BOOL1 b1Direction,
                        UINT2 u2MepIdentifier,
                        UINT1 *pu1MaName, UINT4 *pu4VlanIsid)
{
    tEcfmCcMepInfo     *pMepNode = NULL;
    UINT4               u4VlanIsid = ECFM_INIT_VAL;
    BOOL1               b1EntryFound = ECFM_FALSE;

    while (u4VlanIsid < ECFM_INTERNAL_ISID_MAX)
    {
        /* Get MEP node from portInfo's MepInfoTree */
        pMepNode = EcfmCcUtilGetMepEntryFrmPort
            ((UINT1) u4MdLevel, u4VlanIsid, u2LocalPortId, b1Direction);
        if (pMepNode != NULL)
        {
            if ((pMepNode->u2MepId == u2MepIdentifier) &&
                (pMepNode->pMaInfo != NULL) &&
                (pMepNode->u4ContextId == u4ContextId) &&
                (ECFM_STRCMP (pMepNode->pMaInfo->au1Name, pu1MaName) == 0))
            {
                b1EntryFound = ECFM_TRUE;
                *pu4VlanIsid = u4VlanIsid;
                break;
            }
        }
        u4VlanIsid++;
    }
    if (b1EntryFound == ECFM_TRUE)
    {
        return ECFM_SUCCESS;
    }
    return ECFM_FAILURE;
}

/******************************************************************************
 * Function Name      : EcfmShowTraps                                         *
 *                                                                            *
 * Description        : This function is called from the SNMPV3 Module        *
 *                      to display the ECFM traps configured.                 *
 *                                                                            *
 *                                                                            *
 * Input(s)           : u1Module  - Module Index                              *
 *                      CliHandle - Handle to the cli context                 *                                   
 *                                                                            *
 * Output(s)          : None                                                  *
 *                                                                            *
 * Return Value(s)    : Nothing                                               *
 *****************************************************************************/
PUBLIC VOID
EcfmShowTraps (tCliHandle CliHandle, UINT1 u1Module)
{
    UINT1               u1TrapOption = 0;
    UINT1               au1Y1731TrapOption[ECFM_INDEX_TWO] = { 0 };
    UINT1               u1CurY1731TrapOptionLsb = (UINT1) ECFM_INIT_VAL;
    UINT1               u1CurTrapOption = (UINT1) ECFM_INIT_VAL;
    UINT1               u1CurY1731TrapOptionMsb = (UINT1) ECFM_INIT_VAL;
    UINT1
         
         
         
         
         
         
         
        u1ModuleName[ECFM_MAX_SRC_MODULE][ECFM_SRC_MODULE_NAME_LEN] =
        { "ethernet cfm", "y1731-mplstp oam" };
    tSNMP_OCTET_STRING_TYPE EcfmTrapOption;
    tSNMP_OCTET_STRING_TYPE Y1731TrapOption;
    ECFM_MEMSET (&EcfmTrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (&Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (tSNMP_OCTET_STRING_TYPE));
    ECFM_MEMSET (au1Y1731TrapOption, ECFM_INIT_VAL,
                 sizeof (au1Y1731TrapOption));
    EcfmTrapOption.pu1_OctetList = &u1TrapOption;
    EcfmTrapOption.i4_Length = 1;
    Y1731TrapOption.pu1_OctetList = au1Y1731TrapOption;
    Y1731TrapOption.i4_Length = 1;
    nmhGetFsMIEcfmTrapControl (ECFM_DEFAULT_CONTEXT, &EcfmTrapOption);
    nmhGetFsMIY1731TrapControl (ECFM_DEFAULT_CONTEXT, &Y1731TrapOption);
    u1CurTrapOption = EcfmTrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionLsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ZERO];
    u1CurY1731TrapOptionMsb = Y1731TrapOption.pu1_OctetList[ECFM_INDEX_ONE];
    if (ECFM_CLI_ALL_CCM_TRAP_ENABLED
        (u1CurTrapOption, u1CurY1731TrapOptionMsb,
         u1CurY1731TrapOptionLsb) == ECFM_TRUE)
    {
        CliPrintf (CliHandle, "\n%s all", u1ModuleName[u1Module]);
    }
    else
    {
        if ((u1CurTrapOption != ECFM_INIT_VAL) ||
            (u1CurY1731TrapOptionMsb != ECFM_INIT_VAL) ||
            (u1CurY1731TrapOptionLsb != ECFM_INIT_VAL))
        {
            CliPrintf (CliHandle, "\n%s", u1ModuleName[u1Module]);
        }
        if ((ECFM_CLI_RDI_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
            || (Y1731_CLI_RDI_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionLsb)))
        {
            CliPrintf (CliHandle, " rdi-ccm,");
        }
        if (ECFM_CLI_REMOTE_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " mep-missing,");
        }
        if (ECFM_CLI_ERR_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " errored-ccm,");
        }
        if (ECFM_CLI_XCONN_CCM_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " cross-connect,");
        }
        if (Y1731_CLI_LOC_TRAP_ENABLED (u1CurY1731TrapOptionLsb) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " loss-of-continuity,");
        }
        if (Y1731_CLI_UNEXPECTED_PERIOD_TRAP_ENABLED
            (u1CurY1731TrapOptionLsb) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " unexpected-period,");
        }
        if (Y1731_CLI_UNEXPECTED_MEP_TRAP_ENABLED (u1CurY1731TrapOptionLsb)
            == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " unexpected-mep,");
        }
        if (Y1731_CLI_MIS_MERGE_TRAP_ENABLED (u1CurY1731TrapOptionMsb) ==
            ECFM_TRUE)
        {
            CliPrintf (CliHandle, " mis-merge,");
        }
        if (Y1731_CLI_UNEXPECTED_MEG_LEVEL_TRAP_ENABLED
            (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " unexpected-level,");
        }
        if (u1Module == ECFM_INIT_VAL)
        {
            if (ECFM_CLI_MAC_STATUS_TRAP_ENABLED (u1CurTrapOption) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " mac-status,");
            }
            if (Y1731_CLI_LOCAL_LINK_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " local-link-failure,");
            }
            if (Y1731_CLI_INTERNAL_HW_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " hardware-failure,");
            }
            if (Y1731_CLI_INTERNAL_SW_FAILURE_TRAP_ENABLED
                (u1CurY1731TrapOptionMsb) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " software-failure,");
            }
            if (Y1731_CLI_FRAME_LOSS_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
                ECFM_TRUE)
            {
                CliPrintf (CliHandle, " frame-loss,");
            }
            if (Y1731_CLI_FRAME_DELAY_TRAP_ENABLED (u1CurY1731TrapOptionLsb) ==
                ECFM_TRUE)
            {
                CliPrintf (CliHandle, " frame-delay,");
            }
            if (Y1731_CLI_TST_RCVD_WITH_ERROR_TRAP_ENABLED
                (u1CurY1731TrapOptionLsb) == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " bit-error,");
            }
            if (Y1731_CLI_LCK_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
                == ECFM_TRUE)
            {
                CliPrintf (CliHandle, " lck-condition,");
            }
        }
        if (Y1731_CLI_AIS_CONDITION_TRAP_ENABLED (u1CurY1731TrapOptionMsb)
            == ECFM_TRUE)
        {
            CliPrintf (CliHandle, " ais-condition");
        }
    }
}
#endif /*  */
